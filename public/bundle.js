/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(34);
	
	var _reactRedux = __webpack_require__(172);
	
	var _redux = __webpack_require__(179);
	
	var _reduxThunk = __webpack_require__(196);
	
	var _reduxThunk2 = _interopRequireDefault(_reduxThunk);
	
	var _App = __webpack_require__(197);
	
	var _App2 = _interopRequireDefault(_App);
	
	var _reducers = __webpack_require__(247);
	
	var _reducers2 = _interopRequireDefault(_reducers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var store = (0, _redux.createStore)(_reducers2.default, (0, _redux.applyMiddleware)(_reduxThunk2.default)); // import io from 'socket.io-client';
	//
	// let socket = io();
	//
	// socket.on('connection', s => {
	//   console.log('a user connected');
	//   s.on('disconnect', function(){
	//     console.log('user disconnected');
	//   });
	// });
	
	
	(0, _reactDom.render)(_react2.default.createElement(
	  _reactRedux.Provider,
	  { store: store },
	  _react2.default.createElement(_App2.default, null)
	), document.getElementById('app'));

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(2);

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var ReactChildren = __webpack_require__(5);
	var ReactComponent = __webpack_require__(17);
	var ReactPureComponent = __webpack_require__(20);
	var ReactClass = __webpack_require__(21);
	var ReactDOMFactories = __webpack_require__(26);
	var ReactElement = __webpack_require__(9);
	var ReactPropTypes = __webpack_require__(31);
	var ReactVersion = __webpack_require__(32);
	
	var onlyChild = __webpack_require__(33);
	var warning = __webpack_require__(11);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(27);
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var __spread = _assign;
	
	if (process.env.NODE_ENV !== 'production') {
	  var warned = false;
	  __spread = function __spread() {
	    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
	    warned = true;
	    return _assign.apply(null, arguments);
	  };
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	  PureComponent: ReactPureComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function createMixin(mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Deprecated hook for JSX spread, don't use this for anything.
	  __spread: __spread
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict';
	
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc'); // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(6);
	var ReactElement = __webpack_require__(9);
	
	var emptyFunction = __webpack_require__(12);
	var traverseAllChildren = __webpack_require__(14);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function fiveArgumentPooler(a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function standardReleaser(instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule reactProdInvariant
	 * 
	 */
	'use strict';
	
	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */
	
	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;
	
	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }
	
	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	  throw error;
	}
	
	module.exports = reactProdInvariant;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _assign = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(10);
	
	var warning = __webpack_require__(11);
	var canDefineProperty = __webpack_require__(13);
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	var specialPropKeyWarningShown, specialPropRefWarningShown;
	
	function hasValidRef(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}
	
	function hasValidKey(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}
	
	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function warnAboutAccessingKey() {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}
	
	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function warnAboutAccessingRef() {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}
	
	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	    var shadowChildren = Array.isArray(props.children) ? props.children.slice(0) : props.children;
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      Object.defineProperty(element, '_shadowChildren', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: shadowChildren
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._shadowChildren = shadowChildren;
	      element._source = source;
	    }
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }
	
	  return element;
	};
	
	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
	 */
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(
	      /* eslint-disable no-proto */
	      config.__proto__ == null || config.__proto__ === Object.prototype,
	      /* eslint-enable no-proto */
	      'React.createElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
	    }
	
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (key || ref) {
	      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
	        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	        if (key) {
	          defineKeyPropWarningGetter(props, displayName);
	        }
	        if (ref) {
	          defineRefPropWarningGetter(props, displayName);
	        }
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
	 */
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
	 */
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = _assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(
	      /* eslint-disable no-proto */
	      config.__proto__ == null || config.__proto__ === Object.prototype,
	      /* eslint-enable no-proto */
	      'React.cloneElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
	    }
	
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    // Remaining properties override existing props
	    var defaultProps;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * Verifies the object is a ReactElement.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	ReactElement.REACT_ELEMENT_TYPE = REACT_ELEMENT_TYPE;
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 10 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(12);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };
	
	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }
	
	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }
	
	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }
	
	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    Object.defineProperty({}, 'x', { get: function get() {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactCurrentOwner = __webpack_require__(10);
	var ReactElement = __webpack_require__(9);
	
	var getIteratorFn = __webpack_require__(15);
	var invariant = __webpack_require__(8);
	var KeyEscapeUtils = __webpack_require__(16);
	var warning = __webpack_require__(11);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && (typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 15 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * 
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 16 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule KeyEscapeUtils
	 * 
	 */
	
	'use strict';
	
	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });
	
	  return '$' + escapedString;
	}
	
	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
	
	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}
	
	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};
	
	module.exports = KeyEscapeUtils;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactNoopUpdateQueue = __webpack_require__(18);
	
	var canDefineProperty = __webpack_require__(13);
	var emptyObject = __webpack_require__(19);
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'setState');
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'forceUpdate');
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */
	
	'use strict';
	
	var warning = __webpack_require__(11);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    warnNoop(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    warnNoop(publicInstance, 'setState');
	  }
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPureComponent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var ReactComponent = __webpack_require__(17);
	var ReactNoopUpdateQueue = __webpack_require__(18);
	
	var emptyObject = __webpack_require__(19);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactPureComponent(props, context, updater) {
	  // Duplicated from ReactComponent.
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	function ComponentDummy() {}
	ComponentDummy.prototype = ReactComponent.prototype;
	ReactPureComponent.prototype = new ComponentDummy();
	ReactPureComponent.prototype.constructor = ReactPureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(ReactPureComponent.prototype, ReactComponent.prototype);
	ReactPureComponent.prototype.isPureReactComponent = true;
	
	module.exports = ReactPureComponent;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var ReactComponent = __webpack_require__(17);
	var ReactElement = __webpack_require__(9);
	var ReactPropTypeLocations = __webpack_require__(22);
	var ReactPropTypeLocationNames = __webpack_require__(24);
	var ReactNoopUpdateQueue = __webpack_require__(18);
	
	var emptyObject = __webpack_require__(19);
	var invariant = __webpack_require__(8);
	var keyMirror = __webpack_require__(23);
	var keyOf = __webpack_require__(25);
	var warning = __webpack_require__(11);
	
	var MIXINS_KEY = keyOf({ mixins: null });
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});
	
	var injectedMixins = [];
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or host components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function displayName(Constructor, _displayName) {
	    Constructor.displayName = _displayName;
	  },
	  mixins: function mixins(Constructor, _mixins) {
	    if (_mixins) {
	      for (var i = 0; i < _mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, _mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, _childContextTypes);
	  },
	  contextTypes: function contextTypes(Constructor, _contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = _assign({}, Constructor.contextTypes, _contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = _getDefaultProps;
	    }
	  },
	  propTypes: function propTypes(Constructor, _propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = _assign({}, Constructor.propTypes, _propTypes);
	  },
	  statics: function statics(Constructor, _statics) {
	    mixStaticSpecIntoComponent(Constructor, _statics);
	  },
	  autobind: function autobind() {} };
	
	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but only in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
	    }
	  }
	}
	
	function validateMethodOverride(isAlreadyDefined, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (isAlreadyDefined) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classes.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    if (process.env.NODE_ENV !== 'production') {
	      var typeofSpec = typeof spec === 'undefined' ? 'undefined' : _typeof(spec);
	      var isMixinValid = typeofSpec === 'object' && spec !== null;
	
	      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
	    }
	
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;
	
	  var proto = Constructor.prototype;
	  var autoBindPairs = proto.__reactAutoBindPairs;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    var isAlreadyDefined = proto.hasOwnProperty(name);
	    validateMethodOverride(isAlreadyDefined, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        autoBindPairs.push(name, property);
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;
	
	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && (typeof one === 'undefined' ? 'undefined' : _typeof(one)) === 'object' && (typeof two === 'undefined' ? 'undefined' : _typeof(two)) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  var pairs = component.__reactAutoBindPairs;
	  for (var i = 0; i < pairs.length; i += 2) {
	    var autoBindKey = pairs[i];
	    var method = pairs[i + 1];
	    component[autoBindKey] = bindAutoBindMethod(component, method);
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function replaceState(newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback, 'replaceState');
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted() {
	    return this.updater.isMounted(this);
	  }
	};
	
	var ReactClassComponent = function ReactClassComponent() {};
	_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function createClass(spec) {
	    var Constructor = function Constructor(props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (initialState === undefined && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;
	
	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function injectMixin(mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(23);
	
	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});
	
	module.exports = ReactPropTypeLocations;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function keyMirror(obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : void 0;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 25 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	
	var keyOf = function keyOf(oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};
	
	module.exports = keyOf;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(9);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @private
	 */
	var createDOMFactory = ReactElement.createFactory;
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(27);
	  createDOMFactory = ReactElementValidator.createFactory;
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = {
	  a: createDOMFactory('a'),
	  abbr: createDOMFactory('abbr'),
	  address: createDOMFactory('address'),
	  area: createDOMFactory('area'),
	  article: createDOMFactory('article'),
	  aside: createDOMFactory('aside'),
	  audio: createDOMFactory('audio'),
	  b: createDOMFactory('b'),
	  base: createDOMFactory('base'),
	  bdi: createDOMFactory('bdi'),
	  bdo: createDOMFactory('bdo'),
	  big: createDOMFactory('big'),
	  blockquote: createDOMFactory('blockquote'),
	  body: createDOMFactory('body'),
	  br: createDOMFactory('br'),
	  button: createDOMFactory('button'),
	  canvas: createDOMFactory('canvas'),
	  caption: createDOMFactory('caption'),
	  cite: createDOMFactory('cite'),
	  code: createDOMFactory('code'),
	  col: createDOMFactory('col'),
	  colgroup: createDOMFactory('colgroup'),
	  data: createDOMFactory('data'),
	  datalist: createDOMFactory('datalist'),
	  dd: createDOMFactory('dd'),
	  del: createDOMFactory('del'),
	  details: createDOMFactory('details'),
	  dfn: createDOMFactory('dfn'),
	  dialog: createDOMFactory('dialog'),
	  div: createDOMFactory('div'),
	  dl: createDOMFactory('dl'),
	  dt: createDOMFactory('dt'),
	  em: createDOMFactory('em'),
	  embed: createDOMFactory('embed'),
	  fieldset: createDOMFactory('fieldset'),
	  figcaption: createDOMFactory('figcaption'),
	  figure: createDOMFactory('figure'),
	  footer: createDOMFactory('footer'),
	  form: createDOMFactory('form'),
	  h1: createDOMFactory('h1'),
	  h2: createDOMFactory('h2'),
	  h3: createDOMFactory('h3'),
	  h4: createDOMFactory('h4'),
	  h5: createDOMFactory('h5'),
	  h6: createDOMFactory('h6'),
	  head: createDOMFactory('head'),
	  header: createDOMFactory('header'),
	  hgroup: createDOMFactory('hgroup'),
	  hr: createDOMFactory('hr'),
	  html: createDOMFactory('html'),
	  i: createDOMFactory('i'),
	  iframe: createDOMFactory('iframe'),
	  img: createDOMFactory('img'),
	  input: createDOMFactory('input'),
	  ins: createDOMFactory('ins'),
	  kbd: createDOMFactory('kbd'),
	  keygen: createDOMFactory('keygen'),
	  label: createDOMFactory('label'),
	  legend: createDOMFactory('legend'),
	  li: createDOMFactory('li'),
	  link: createDOMFactory('link'),
	  main: createDOMFactory('main'),
	  map: createDOMFactory('map'),
	  mark: createDOMFactory('mark'),
	  menu: createDOMFactory('menu'),
	  menuitem: createDOMFactory('menuitem'),
	  meta: createDOMFactory('meta'),
	  meter: createDOMFactory('meter'),
	  nav: createDOMFactory('nav'),
	  noscript: createDOMFactory('noscript'),
	  object: createDOMFactory('object'),
	  ol: createDOMFactory('ol'),
	  optgroup: createDOMFactory('optgroup'),
	  option: createDOMFactory('option'),
	  output: createDOMFactory('output'),
	  p: createDOMFactory('p'),
	  param: createDOMFactory('param'),
	  picture: createDOMFactory('picture'),
	  pre: createDOMFactory('pre'),
	  progress: createDOMFactory('progress'),
	  q: createDOMFactory('q'),
	  rp: createDOMFactory('rp'),
	  rt: createDOMFactory('rt'),
	  ruby: createDOMFactory('ruby'),
	  s: createDOMFactory('s'),
	  samp: createDOMFactory('samp'),
	  script: createDOMFactory('script'),
	  section: createDOMFactory('section'),
	  select: createDOMFactory('select'),
	  small: createDOMFactory('small'),
	  source: createDOMFactory('source'),
	  span: createDOMFactory('span'),
	  strong: createDOMFactory('strong'),
	  style: createDOMFactory('style'),
	  sub: createDOMFactory('sub'),
	  summary: createDOMFactory('summary'),
	  sup: createDOMFactory('sup'),
	  table: createDOMFactory('table'),
	  tbody: createDOMFactory('tbody'),
	  td: createDOMFactory('td'),
	  textarea: createDOMFactory('textarea'),
	  tfoot: createDOMFactory('tfoot'),
	  th: createDOMFactory('th'),
	  thead: createDOMFactory('thead'),
	  time: createDOMFactory('time'),
	  title: createDOMFactory('title'),
	  tr: createDOMFactory('tr'),
	  track: createDOMFactory('track'),
	  u: createDOMFactory('u'),
	  ul: createDOMFactory('ul'),
	  'var': createDOMFactory('var'),
	  video: createDOMFactory('video'),
	  wbr: createDOMFactory('wbr'),
	
	  // SVG
	  circle: createDOMFactory('circle'),
	  clipPath: createDOMFactory('clipPath'),
	  defs: createDOMFactory('defs'),
	  ellipse: createDOMFactory('ellipse'),
	  g: createDOMFactory('g'),
	  image: createDOMFactory('image'),
	  line: createDOMFactory('line'),
	  linearGradient: createDOMFactory('linearGradient'),
	  mask: createDOMFactory('mask'),
	  path: createDOMFactory('path'),
	  pattern: createDOMFactory('pattern'),
	  polygon: createDOMFactory('polygon'),
	  polyline: createDOMFactory('polyline'),
	  radialGradient: createDOMFactory('radialGradient'),
	  rect: createDOMFactory('rect'),
	  stop: createDOMFactory('stop'),
	  svg: createDOMFactory('svg'),
	  text: createDOMFactory('text'),
	  tspan: createDOMFactory('tspan')
	};
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var ReactCurrentOwner = __webpack_require__(10);
	var ReactComponentTreeHook = __webpack_require__(28);
	var ReactElement = __webpack_require__(9);
	var ReactPropTypeLocations = __webpack_require__(22);
	
	var checkReactTypeSpec = __webpack_require__(29);
	
	var canDefineProperty = __webpack_require__(13);
	var getIteratorFn = __webpack_require__(15);
	var warning = __webpack_require__(11);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	function getCurrentComponentErrorInfo(parentType) {
	  var info = getDeclarationErrorAddendum();
	
	  if (!info) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      info = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	  return info;
	}
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
	
	  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	  if (memoizer[currentComponentErrorInfo]) {
	    return;
	  }
	  memoizer[currentComponentErrorInfo] = true;
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwner = '';
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkReactTypeSpec(componentClass.propTypes, element.props, ReactPropTypeLocations.prop, name, element, null);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function createElement(type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    if (!validType) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
	    }
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function createFactory(type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function cloneElement(element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentTreeHook
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactCurrentOwner = __webpack_require__(10);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	function isNative(fn) {
	  // Based on isNative() from Lodash
	  var funcToString = Function.prototype.toString;
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var reIsNative = RegExp('^' + funcToString
	  // Take an example native function source for comparison
	  .call(hasOwnProperty)
	  // Strip regex characters so we can use it for regex
	  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  // Remove hasOwnProperty from the template to make it generic
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  try {
	    var source = funcToString.call(fn);
	    return reIsNative.test(source);
	  } catch (err) {
	    return false;
	  }
	}
	
	var canUseCollections =
	// Array.from
	typeof Array.from === 'function' &&
	// Map
	typeof Map === 'function' && isNative(Map) &&
	// Map.prototype.keys
	Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	// Set
	typeof Set === 'function' && isNative(Set) &&
	// Set.prototype.keys
	Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
	
	var itemMap;
	var rootIDSet;
	
	var itemByKey;
	var rootByKey;
	
	if (canUseCollections) {
	  itemMap = new Map();
	  rootIDSet = new Set();
	} else {
	  itemByKey = {};
	  rootByKey = {};
	}
	
	var unmountedIDs = [];
	
	// Use non-numeric keys to prevent V8 performance issues:
	// https://github.com/facebook/react/pull/7232
	function getKeyFromID(id) {
	  return '.' + id;
	}
	function getIDFromKey(key) {
	  return parseInt(key.substr(1), 10);
	}
	
	function get(id) {
	  if (canUseCollections) {
	    return itemMap.get(id);
	  } else {
	    var key = getKeyFromID(id);
	    return itemByKey[key];
	  }
	}
	
	function remove(id) {
	  if (canUseCollections) {
	    itemMap['delete'](id);
	  } else {
	    var key = getKeyFromID(id);
	    delete itemByKey[key];
	  }
	}
	
	function create(id, element, parentID) {
	  var item = {
	    element: element,
	    parentID: parentID,
	    text: null,
	    childIDs: [],
	    isMounted: false,
	    updateCount: 0
	  };
	
	  if (canUseCollections) {
	    itemMap.set(id, item);
	  } else {
	    var key = getKeyFromID(id);
	    itemByKey[key] = item;
	  }
	}
	
	function addRoot(id) {
	  if (canUseCollections) {
	    rootIDSet.add(id);
	  } else {
	    var key = getKeyFromID(id);
	    rootByKey[key] = true;
	  }
	}
	
	function removeRoot(id) {
	  if (canUseCollections) {
	    rootIDSet['delete'](id);
	  } else {
	    var key = getKeyFromID(id);
	    delete rootByKey[key];
	  }
	}
	
	function getRegisteredIDs() {
	  if (canUseCollections) {
	    return Array.from(itemMap.keys());
	  } else {
	    return Object.keys(itemByKey).map(getIDFromKey);
	  }
	}
	
	function getRootIDs() {
	  if (canUseCollections) {
	    return Array.from(rootIDSet.keys());
	  } else {
	    return Object.keys(rootByKey).map(getIDFromKey);
	  }
	}
	
	function purgeDeep(id) {
	  var item = get(id);
	  if (item) {
	    var childIDs = item.childIDs;
	
	    remove(id);
	    childIDs.forEach(purgeDeep);
	  }
	}
	
	function describeComponentFrame(name, source, ownerName) {
	  return '\n    in ' + name + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	}
	
	function _getDisplayName(element) {
	  if (element == null) {
	    return '#empty';
	  } else if (typeof element === 'string' || typeof element === 'number') {
	    return '#text';
	  } else if (typeof element.type === 'string') {
	    return element.type;
	  } else {
	    return element.type.displayName || element.type.name || 'Unknown';
	  }
	}
	
	function describeID(id) {
	  var name = ReactComponentTreeHook.getDisplayName(id);
	  var element = ReactComponentTreeHook.getElement(id);
	  var ownerID = ReactComponentTreeHook.getOwnerID(id);
	  var ownerName;
	  if (ownerID) {
	    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	  }
	  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	  return describeComponentFrame(name, element && element._source, ownerName);
	}
	
	var ReactComponentTreeHook = {
	  onSetChildren: function onSetChildren(id, nextChildIDs) {
	    var item = get(id);
	    item.childIDs = nextChildIDs;
	
	    for (var i = 0; i < nextChildIDs.length; i++) {
	      var nextChildID = nextChildIDs[i];
	      var nextChild = get(nextChildID);
	      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	      !(nextChild.childIDs != null || _typeof(nextChild.element) !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	      if (nextChild.parentID == null) {
	        nextChild.parentID = id;
	        // TODO: This shouldn't be necessary but mounting a new root during in
	        // componentWillMount currently causes not-yet-mounted components to
	        // be purged from our tree data so their parent ID is missing.
	      }
	      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	    }
	  },
	  onBeforeMountComponent: function onBeforeMountComponent(id, element, parentID) {
	    create(id, element, parentID);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(id, element) {
	    var item = get(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.element = element;
	  },
	  onMountComponent: function onMountComponent(id) {
	    var item = get(id);
	    item.isMounted = true;
	    var isRoot = item.parentID === 0;
	    if (isRoot) {
	      addRoot(id);
	    }
	  },
	  onUpdateComponent: function onUpdateComponent(id) {
	    var item = get(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.updateCount++;
	  },
	  onUnmountComponent: function onUnmountComponent(id) {
	    var item = get(id);
	    if (item) {
	      // We need to check if it exists.
	      // `item` might not exist if it is inside an error boundary, and a sibling
	      // error boundary child threw while mounting. Then this instance never
	      // got a chance to mount, but it still gets an unmounting event during
	      // the error boundary cleanup.
	      item.isMounted = false;
	      var isRoot = item.parentID === 0;
	      if (isRoot) {
	        removeRoot(id);
	      }
	    }
	    unmountedIDs.push(id);
	  },
	  purgeUnmountedComponents: function purgeUnmountedComponents() {
	    if (ReactComponentTreeHook._preventPurging) {
	      // Should only be used for testing.
	      return;
	    }
	
	    for (var i = 0; i < unmountedIDs.length; i++) {
	      var id = unmountedIDs[i];
	      purgeDeep(id);
	    }
	    unmountedIDs.length = 0;
	  },
	  isMounted: function isMounted(id) {
	    var item = get(id);
	    return item ? item.isMounted : false;
	  },
	  getCurrentStackAddendum: function getCurrentStackAddendum(topElement) {
	    var info = '';
	    if (topElement) {
	      var type = topElement.type;
	      var name = typeof type === 'function' ? type.displayName || type.name : type;
	      var owner = topElement._owner;
	      info += describeComponentFrame(name || 'Unknown', topElement._source, owner && owner.getName());
	    }
	
	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;
	
	    info += ReactComponentTreeHook.getStackAddendumByID(id);
	    return info;
	  },
	  getStackAddendumByID: function getStackAddendumByID(id) {
	    var info = '';
	    while (id) {
	      info += describeID(id);
	      id = ReactComponentTreeHook.getParentID(id);
	    }
	    return info;
	  },
	  getChildIDs: function getChildIDs(id) {
	    var item = get(id);
	    return item ? item.childIDs : [];
	  },
	  getDisplayName: function getDisplayName(id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element) {
	      return null;
	    }
	    return _getDisplayName(element);
	  },
	  getElement: function getElement(id) {
	    var item = get(id);
	    return item ? item.element : null;
	  },
	  getOwnerID: function getOwnerID(id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element || !element._owner) {
	      return null;
	    }
	    return element._owner._debugID;
	  },
	  getParentID: function getParentID(id) {
	    var item = get(id);
	    return item ? item.parentID : null;
	  },
	  getSource: function getSource(id) {
	    var item = get(id);
	    var element = item ? item.element : null;
	    var source = element != null ? element._source : null;
	    return source;
	  },
	  getText: function getText(id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (typeof element === 'string') {
	      return element;
	    } else if (typeof element === 'number') {
	      return '' + element;
	    } else {
	      return null;
	    }
	  },
	  getUpdateCount: function getUpdateCount(id) {
	    var item = get(id);
	    return item ? item.updateCount : 0;
	  },
	
	  getRegisteredIDs: getRegisteredIDs,
	
	  getRootIDs: getRootIDs
	};
	
	module.exports = ReactComponentTreeHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule checkReactTypeSpec
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactPropTypeLocationNames = __webpack_require__(24);
	var ReactPropTypesSecret = __webpack_require__(30);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(28);
	}
	
	var loggedTypeFailures = {};
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var componentStackInfo = '';
	
	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(28);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }
	
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}
	
	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 30 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypesSecret
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var ReactElement = __webpack_require__(9);
	var ReactPropTypeLocationNames = __webpack_require__(24);
	var ReactPropTypesSecret = __webpack_require__(30);
	
	var emptyFunction = __webpack_require__(12);
	var getIteratorFn = __webpack_require__(15);
	var warning = __webpack_require__(11);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	  symbol: createPrimitiveTypeChecker('symbol'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	/*eslint-disable no-self-compare*/
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	/*eslint-enable no-self-compare*/
	
	/**
	 * We use an Error-like object for backward compatibility as people may call
	 * PropTypes directly and inspect their output. However we don't use real
	 * Errors anymore. We don't inspect their stack anyway, and creating them
	 * is prohibitively expensive if they are created too often, such as what
	 * happens in oneOfType() for any type before the one that matched.
	 */
	function PropTypeError(message) {
	  this.message = message;
	  this.stack = '';
	}
	// Make `instanceof Error` still work for returned errors.
	PropTypeError.prototype = Error.prototype;
	
	function createChainableTypeChecker(validate) {
	  if (process.env.NODE_ENV !== 'production') {
	    var manualPropTypeCallCache = {};
	  }
	  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (process.env.NODE_ENV !== 'production') {
	      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
	        var cacheKey = componentName + ':' + propName;
	        if (!manualPropTypeCallCache[cacheKey]) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in the next major version. You may be ' + 'seeing this warning due to a third-party PropTypes library. ' + 'See https://fb.me/react-warning-dont-call-proptypes for details.', propFullName, componentName) : void 0;
	          manualPropTypeCallCache[cacheKey] = true;
	        }
	      }
	    }
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new PropTypeError('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName, secret) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	    }
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!ReactElement.isValidElement(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (is(propValue, expectedValues[i])) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	    }
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	function isSymbol(propType, propValue) {
	  // Native Symbol.
	  if (propType === 'symbol') {
	    return true;
	  }
	
	  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	  if (propValue['@@toStringTag'] === 'Symbol') {
	    return true;
	  }
	
	  // Fallback for non-spec compliant Symbols which are polyfilled.
	  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	    return true;
	  }
	
	  return false;
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  if (isSymbol(propType, propValue)) {
	    return 'symbol';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return ANONYMOUS;
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 32 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */
	
	'use strict';
	
	module.exports = '15.3.1';

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactElement = __webpack_require__(9);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(35);

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactDefaultInjection = __webpack_require__(39);
	var ReactMount = __webpack_require__(162);
	var ReactReconciler = __webpack_require__(59);
	var ReactUpdates = __webpack_require__(56);
	var ReactVersion = __webpack_require__(32);
	
	var findDOMNode = __webpack_require__(167);
	var getHostComponentFromComposite = __webpack_require__(168);
	var renderSubtreeIntoContainer = __webpack_require__(169);
	var warning = __webpack_require__(11);
	
	ReactDefaultInjection.inject();
	
	var ReactDOM = {
	  findDOMNode: findDOMNode,
	  render: ReactMount.render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    ComponentTree: {
	      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
	      getNodeFromInstance: function getNodeFromInstance(inst) {
	        // inst is an internal instance (but could be a composite)
	        if (inst._renderedComponent) {
	          inst = getHostComponentFromComposite(inst);
	        }
	        if (inst) {
	          return ReactDOMComponentTree.getNodeFromInstance(inst);
	        } else {
	          return null;
	        }
	      }
	    },
	    Mount: ReactMount,
	    Reconciler: ReactReconciler
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(49);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        // Firefox does not have the issue with devtools loaded over file://
	        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
	        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    var testFunc = function testFn() {};
	    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
	        break;
	      }
	    }
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactInstrumentation = __webpack_require__(62);
	  var ReactDOMUnknownPropertyHook = __webpack_require__(170);
	  var ReactDOMNullInputValuePropHook = __webpack_require__(171);
	
	  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
	}
	
	module.exports = ReactDOM;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponentTree
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var DOMProperty = __webpack_require__(37);
	var ReactDOMComponentFlags = __webpack_require__(38);
	
	var invariant = __webpack_require__(8);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var Flags = ReactDOMComponentFlags;
	
	var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
	
	/**
	 * Drill down (through composites and empty components) until we get a host or
	 * host text component.
	 *
	 * This is pretty polymorphic but unavoidable with the current structure we have
	 * for `_renderedChildren`.
	 */
	function getRenderedHostOrTextFromComponent(component) {
	  var rendered;
	  while (rendered = component._renderedComponent) {
	    component = rendered;
	  }
	  return component;
	}
	
	/**
	 * Populate `_hostNode` on the rendered host/text component with the given
	 * DOM node. The passed `inst` can be a composite.
	 */
	function precacheNode(inst, node) {
	  var hostInst = getRenderedHostOrTextFromComponent(inst);
	  hostInst._hostNode = node;
	  node[internalInstanceKey] = hostInst;
	}
	
	function uncacheNode(inst) {
	  var node = inst._hostNode;
	  if (node) {
	    delete node[internalInstanceKey];
	    inst._hostNode = null;
	  }
	}
	
	/**
	 * Populate `_hostNode` on each child of `inst`, assuming that the children
	 * match up with the DOM (element) children of `node`.
	 *
	 * We cache entire levels at once to avoid an n^2 problem where we access the
	 * children of a node sequentially and have to walk from the start to our target
	 * node every time.
	 *
	 * Since we update `_renderedChildren` and the actual DOM at (slightly)
	 * different times, we could race here and see a newer `_renderedChildren` than
	 * the DOM nodes we see. To avoid this, ReactMultiChild calls
	 * `prepareToManageChildren` before we change `_renderedChildren`, at which
	 * time the container's child nodes are always cached (until it unmounts).
	 */
	function precacheChildNodes(inst, node) {
	  if (inst._flags & Flags.hasCachedChildNodes) {
	    return;
	  }
	  var children = inst._renderedChildren;
	  var childNode = node.firstChild;
	  outer: for (var name in children) {
	    if (!children.hasOwnProperty(name)) {
	      continue;
	    }
	    var childInst = children[name];
	    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
	    if (childID === 0) {
	      // We're currently unmounting this child in ReactMultiChild; skip it.
	      continue;
	    }
	    // We assume the child nodes are in the same order as the child instances.
	    for (; childNode !== null; childNode = childNode.nextSibling) {
	      if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
	        precacheNode(childInst, childNode);
	        continue outer;
	      }
	    }
	    // We reached the end of the DOM children without finding an ID match.
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
	  }
	  inst._flags |= Flags.hasCachedChildNodes;
	}
	
	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }
	
	  // Walk up the tree until we find an ancestor whose instance we have cached.
	  var parents = [];
	  while (!node[internalInstanceKey]) {
	    parents.push(node);
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }
	
	  var closest;
	  var inst;
	  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
	    closest = inst;
	    if (parents.length) {
	      precacheChildNodes(inst, node);
	    }
	  }
	
	  return closest;
	}
	
	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode(node) {
	  var inst = getClosestInstanceFromNode(node);
	  if (inst != null && inst._hostNode === node) {
	    return inst;
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance(inst) {
	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  if (inst._hostNode) {
	    return inst._hostNode;
	  }
	
	  // Walk up the tree until we find an ancestor whose DOM node we have cached.
	  var parents = [];
	  while (!inst._hostNode) {
	    parents.push(inst);
	    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
	    inst = inst._hostParent;
	  }
	
	  // Now parents contains each ancestor that does *not* have a cached native
	  // node, and `inst` is the deepest ancestor that does.
	  for (; parents.length; inst = parents.pop()) {
	    precacheChildNodes(inst, inst._hostNode);
	  }
	
	  return inst._hostNode;
	}
	
	var ReactDOMComponentTree = {
	  getClosestInstanceFromNode: getClosestInstanceFromNode,
	  getInstanceFromNode: getInstanceFromNode,
	  getNodeFromInstance: getNodeFromInstance,
	  precacheChildNodes: precacheChildNodes,
	  precacheNode: precacheNode,
	  uncacheNode: uncacheNode
	};
	
	module.exports = ReactDOMComponentTree;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_PROPERTY: 0x1,
	  HAS_BOOLEAN_VALUE: 0x4,
	  HAS_NUMERIC_VALUE: 0x8,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function injectDOMPropertyConfig(domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	
	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	  ROOT_ATTRIBUTE_NAME: 'data-reactroot',
	
	  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
	  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function isCustomAttribute(attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 38 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponentFlags
	 */
	
	'use strict';
	
	var ReactDOMComponentFlags = {
	  hasCachedChildNodes: 1 << 0
	};
	
	module.exports = ReactDOMComponentFlags;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */
	
	'use strict';
	
	var BeforeInputEventPlugin = __webpack_require__(40);
	var ChangeEventPlugin = __webpack_require__(55);
	var DefaultEventPluginOrder = __webpack_require__(73);
	var EnterLeaveEventPlugin = __webpack_require__(74);
	var HTMLDOMPropertyConfig = __webpack_require__(79);
	var ReactComponentBrowserEnvironment = __webpack_require__(80);
	var ReactDOMComponent = __webpack_require__(94);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactDOMEmptyComponent = __webpack_require__(133);
	var ReactDOMTreeTraversal = __webpack_require__(134);
	var ReactDOMTextComponent = __webpack_require__(135);
	var ReactDefaultBatchingStrategy = __webpack_require__(136);
	var ReactEventListener = __webpack_require__(137);
	var ReactInjection = __webpack_require__(140);
	var ReactReconcileTransaction = __webpack_require__(141);
	var SVGDOMPropertyConfig = __webpack_require__(149);
	var SelectEventPlugin = __webpack_require__(150);
	var SimpleEventPlugin = __webpack_require__(151);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
	  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
	    return new ReactDOMEmptyComponent(instantiate);
	  });
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	}
	
	module.exports = {
	  inject: inject
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var EventConstants = __webpack_require__(41);
	var EventPropagators = __webpack_require__(42);
	var ExecutionEnvironment = __webpack_require__(49);
	var FallbackCompositionState = __webpack_require__(50);
	var SyntheticCompositionEvent = __webpack_require__(52);
	var SyntheticInputEvent = __webpack_require__(54);
	
	var keyOf = __webpack_require__(25);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return (typeof opera === 'undefined' ? 'undefined' : _typeof(opera)) === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if ((typeof detail === 'undefined' ? 'undefined' : _typeof(detail)) === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(23);
	
	var PropagationPhases = keyMirror({ bubbled: null, captured: null });
	
	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topAnimationEnd: null,
	  topAnimationIteration: null,
	  topAnimationStart: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topInvalid: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topTransitionEnd: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});
	
	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};
	
	module.exports = EventConstants;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(41);
	var EventPluginHub = __webpack_require__(43);
	var EventPluginUtils = __webpack_require__(45);
	
	var accumulateInto = __webpack_require__(47);
	var forEachAccumulated = __webpack_require__(48);
	var warning = __webpack_require__(11);
	
	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, upwards, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    var targetInst = event._targetInst;
	    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
	    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7);
	
	var EventPluginRegistry = __webpack_require__(44);
	var EventPluginUtils = __webpack_require__(45);
	var ReactErrorUtils = __webpack_require__(46);
	
	var accumulateInto = __webpack_require__(47);
	var forEachAccumulated = __webpack_require__(48);
	var invariant = __webpack_require__(8);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	var getDictionaryKey = function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	};
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {function} listener The callback to store.
	   */
	  putListener: function putListener(inst, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : _prodInvariant('94', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : void 0;
	
	    var key = getDictionaryKey(inst);
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[key] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(inst, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function getListener(inst, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    var key = getDictionaryKey(inst);
	    return bankForRegistrationName && bankForRegistrationName[key];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function deleteListener(inst, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(inst, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      var key = getDictionaryKey(inst);
	      delete bankForRegistrationName[key];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   */
	  deleteAllListeners: function deleteAllListeners(inst) {
	    var key = getDictionaryKey(inst);
	    for (var registrationName in listenerBank) {
	      if (!listenerBank.hasOwnProperty(registrationName)) {
	        continue;
	      }
	
	      if (!listenerBank[registrationName][key]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(inst, registrationName);
	      }
	
	      delete listenerBank[registrationName][key];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function enqueueEvents(events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function processEventQueue(simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function __purge() {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function __getListenerBank() {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	
	  if (process.env.NODE_ENV !== 'production') {
	    var lowerCasedName = registrationName.toLowerCase();
	    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
	
	    if (registrationName === 'onDoubleClick') {
	      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Mapping from lowercase registration names to the properly cased version,
	   * used to warn in the case of missing event handlers. Available
	   * only in __DEV__.
	   * @type {Object}
	   */
	  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function injectEventPluginOrder(InjectedEventPluginOrder) {
	    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function getPluginModuleForEvent(event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function _resetEventPlugins() {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
	      for (var lowerCasedName in possibleRegistrationNames) {
	        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
	          delete possibleRegistrationNames[lowerCasedName];
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var EventConstants = __webpack_require__(41);
	var ReactErrorUtils = __webpack_require__(46);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `ComponentTree`: [required] Module that can convert between React instances
	 *   and actual node references.
	 */
	var ComponentTree;
	var TreeTraversal;
	var injection = {
	  injectComponentTree: function injectComponentTree(Injected) {
	    ComponentTree = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	    }
	  },
	  injectTreeTraversal: function injectTreeTraversal(Injected) {
	    TreeTraversal = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
	    }
	  }
	};
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function validateEventDispatches(event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, simulated, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchInstances[i])) {
	        return dispatchInstances[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchInstances)) {
	      return dispatchInstances;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchInstances = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchInstance = event._dispatchInstances;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
	  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
	  var res = dispatchListener ? dispatchListener(event) : null;
	  event.currentTarget = null;
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getInstanceFromNode: function getInstanceFromNode(node) {
	    return ComponentTree.getInstanceFromNode(node);
	  },
	  getNodeFromInstance: function getNodeFromInstance(node) {
	    return ComponentTree.getNodeFromInstance(node);
	  },
	  isAncestor: function isAncestor(a, b) {
	    return TreeTraversal.isAncestor(a, b);
	  },
	  getLowestCommonAncestor: function getLowestCommonAncestor(a, b) {
	    return TreeTraversal.getLowestCommonAncestor(a, b);
	  },
	  getParentInstance: function getParentInstance(inst) {
	    return TreeTraversal.getParentInstance(inst);
	  },
	  traverseTwoPhase: function traverseTwoPhase(target, fn, arg) {
	    return TreeTraversal.traverseTwoPhase(target, fn, arg);
	  },
	  traverseEnterLeave: function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function rethrowCaughtError() {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
	
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }
	
	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 48 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 * 
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}
	
	module.exports = forEachAccumulated;

/***/ },
/* 49 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var PooledClass = __webpack_require__(6);
	
	var getTextContentAccessor = __webpack_require__(51);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	_assign(FallbackCompositionState.prototype, {
	  destructor: function destructor() {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function getText() {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function getData() {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(49);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(53);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var PooledClass = __webpack_require__(6);
	
	var emptyFunction = __webpack_require__(12);
	var warning = __webpack_require__(11);
	
	var didWarnForAddedNewProperty = false;
	var isProxySupported = typeof Proxy === 'function';
	
	var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function timeStamp(event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  if (process.env.NODE_ENV !== 'production') {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	  }
	
	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	  return this;
	}
	
	_assign(SyntheticEvent.prototype, {
	
	  preventDefault: function preventDefault() {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function stopPropagation() {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }
	
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function persist() {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function destructor() {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      if (process.env.NODE_ENV !== 'production') {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      } else {
	        this[propName] = null;
	      }
	    }
	    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
	      this[shouldBeReleasedProperties[i]] = null;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
	    }
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	if (process.env.NODE_ENV !== 'production') {
	  if (isProxySupported) {
	    /*eslint-disable no-func-assign */
	    SyntheticEvent = new Proxy(SyntheticEvent, {
	      construct: function construct(target, args) {
	        return this.apply(target, Object.create(target.prototype), args);
	      },
	      apply: function apply(constructor, that, args) {
	        return new Proxy(constructor.apply(that, args), {
	          set: function set(target, prop, value) {
	            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
	              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
	              didWarnForAddedNewProperty = true;
	            }
	            target[prop] = value;
	            return true;
	          }
	        });
	      }
	    });
	    /*eslint-enable no-func-assign */
	  }
	}
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var E = function E() {};
	  E.prototype = Super.prototype;
	  var prototype = new E();
	
	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	
	/**
	  * Helper to nullify syntheticEvent instance properties when destructing
	  *
	  * @param {object} SyntheticEvent
	  * @param {String} propName
	  * @return {object} defineProperty object
	  */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };
	
	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }
	
	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }
	
	  function warn(action, result) {
	    var warningCondition = false;
	    process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(53);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(41);
	var EventPluginHub = __webpack_require__(43);
	var EventPropagators = __webpack_require__(42);
	var ExecutionEnvironment = __webpack_require__(49);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactUpdates = __webpack_require__(56);
	var SyntheticEvent = __webpack_require__(53);
	
	var getEventTarget = __webpack_require__(70);
	var isEventSupported = __webpack_require__(71);
	var isTextInputElement = __webpack_require__(72);
	var keyOf = __webpack_require__(25);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementInst = null;
	}
	
	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return targetInst;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(target, targetInst);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.
	  // IE10+ fire input events to often, such when a placeholder
	  // changes or when an input with a placeholder is focused.
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 11);
	}
	
	/**
	 * (For IE <=11) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function get() {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function set(val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For IE <=11) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  if (activeElement.attachEvent) {
	    activeElement.attachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.addEventListener('propertychange', handlePropertyChange, false);
	  }
	}
	
	/**
	 * (For IE <=11) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	
	  if (activeElement.detachEvent) {
	    activeElement.detachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
	  }
	
	  activeElement = null;
	  activeElementInst = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For IE <=11) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetInstForInputEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return targetInst;
	  }
	}
	
	function handleEventsForInputEventIE(topLevelType, target, targetInst) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9-11, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetInstForInputEventIE(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementInst;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetInstForClickEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return targetInst;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    var getTargetInstFunc, handleEventFunc;
	    if (shouldUseChangeEvent(targetNode)) {
	      if (doesChangeEventBubble) {
	        getTargetInstFunc = getTargetInstForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }
	
	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst);
	      if (inst) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var CallbackQueue = __webpack_require__(57);
	var PooledClass = __webpack_require__(6);
	var ReactFeatureFlags = __webpack_require__(58);
	var ReactReconciler = __webpack_require__(59);
	var Transaction = __webpack_require__(69);
	
	var invariant = __webpack_require__(8);
	
	var dirtyComponents = [];
	var updateBatchNumber = 0;
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
	}
	
	var NESTED_UPDATES = {
	  initialize: function initialize() {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function close() {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function initialize() {
	    this.callbackQueue.reset();
	  },
	  close: function close() {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */true);
	}
	
	_assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function destructor() {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function perform(method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  // Any updates enqueued while reconciling must be performed after this entire
	  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
	  // C, B could update twice in a single batch if C's render enqueues an update
	  // to B (since B would have already updated, we should skip it, and the only
	  // way we can know to do so is by checking the batch counter).
	  updateBatchNumber++;
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    var markerName;
	    if (ReactFeatureFlags.logTopLevelRenders) {
	      var namedComponent = component;
	      // Duck type TopLevelWrapper. This is probably always true.
	      if (component._currentElement.props === component._renderedComponent._currentElement) {
	        namedComponent = component._renderedComponent;
	      }
	      markerName = 'React update: ' + namedComponent.getName();
	      console.time(markerName);
	    }
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
	
	    if (markerName) {
	      console.timeEnd(markerName);
	    }
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function flushBatchedUpdates() {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	  if (component._updateBatchNumber == null) {
	    component._updateBatchNumber = updateBatchNumber + 1;
	  }
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function injectReconcileTransaction(ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function injectBatchingStrategy(_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var PooledClass = __webpack_require__(6);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}
	
	_assign(CallbackQueue.prototype, {
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function enqueue(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function notifyAll() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },
	
	  checkpoint: function checkpoint() {
	    return this._callbacks ? this._callbacks.length : 0;
	  },
	
	  rollback: function rollback(len) {
	    if (this._callbacks) {
	      this._callbacks.length = len;
	      this._contexts.length = len;
	    }
	  },
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function reset() {
	    this._callbacks = null;
	    this._contexts = null;
	  },
	
	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function destructor() {
	    this.reset();
	  }
	
	});
	
	PooledClass.addPoolingTo(CallbackQueue);
	
	module.exports = CallbackQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 58 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactFeatureFlags
	 * 
	 */
	
	'use strict';
	
	var ReactFeatureFlags = {
	  // When true, call console.time() before and .timeEnd() after each top-level
	  // render (both initial renders and updates). Useful when looking at prod-mode
	  // timeline profiles in Chrome, for example.
	  logTopLevelRenders: false
	};
	
	module.exports = ReactFeatureFlags;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(60);
	var ReactInstrumentation = __webpack_require__(62);
	
	var warning = __webpack_require__(11);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} the containing host component instance
	   * @param {?object} info about the host container
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
	  ) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
	      }
	    }
	    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
	      }
	    }
	    return markup;
	  },
	
	  /**
	   * Returns a value that can be passed to
	   * ReactComponentEnvironment.replaceNodeWithMarkup.
	   */
	  getHostNode: function getHostNode(internalInstance) {
	    return internalInstance.getHostNode();
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent(internalInstance, safely) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
	      }
	    }
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent(safely);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function receiveComponent(internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
	      }
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(internalInstance, transaction, updateBatchNumber) {
	    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
	      // The component's enqueued batch number should always be the current
	      // batch or the following one.
	      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
	      return;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
	      }
	    }
	    internalInstance.performUpdateIfNecessary(transaction);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(61);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	
	  return (
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement.ref !== prevElement.ref ||
	    // If owner changes but we have an unchanged function ref, don't update refs
	    typeof nextElement.ref === 'string' && nextElement._owner !== prevElement._owner
	  );
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	
	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function isValidOwner(object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },
	
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function addComponentAsRefTo(component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function removeComponentAsRefFrom(component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
	    var ownerPublicInstance = owner.getPublicInstance();
	    // Check that `component`'s owner is still alive and that `component` is still the current ref
	    // because we do not want to detach the ref if another component stole it.
	    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstrumentation
	 */
	
	'use strict';
	
	var debugTool = null;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactDebugTool = __webpack_require__(63);
	  debugTool = ReactDebugTool;
	}
	
	module.exports = { debugTool: debugTool };
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDebugTool
	 */
	
	'use strict';
	
	var ReactInvalidSetStateWarningHook = __webpack_require__(64);
	var ReactHostOperationHistoryHook = __webpack_require__(65);
	var ReactComponentTreeHook = __webpack_require__(28);
	var ReactChildrenMutationWarningHook = __webpack_require__(66);
	var ExecutionEnvironment = __webpack_require__(49);
	
	var performanceNow = __webpack_require__(67);
	var warning = __webpack_require__(11);
	
	var hooks = [];
	var didHookThrowForEvent = {};
	
	function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
	  try {
	    fn.call(context, arg1, arg2, arg3, arg4, arg5);
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
	    didHookThrowForEvent[event] = true;
	  }
	}
	
	function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
	  for (var i = 0; i < hooks.length; i++) {
	    var hook = hooks[i];
	    var fn = hook[event];
	    if (fn) {
	      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
	    }
	  }
	}
	
	var _isProfiling = false;
	var flushHistory = [];
	var lifeCycleTimerStack = [];
	var currentFlushNesting = 0;
	var currentFlushMeasurements = null;
	var currentFlushStartTime = null;
	var currentTimerDebugID = null;
	var currentTimerStartTime = null;
	var currentTimerNestedFlushDuration = null;
	var currentTimerType = null;
	
	var lifeCycleTimerHasWarned = false;
	
	function clearHistory() {
	  ReactComponentTreeHook.purgeUnmountedComponents();
	  ReactHostOperationHistoryHook.clearHistory();
	}
	
	function getTreeSnapshot(registeredIDs) {
	  return registeredIDs.reduce(function (tree, id) {
	    var ownerID = ReactComponentTreeHook.getOwnerID(id);
	    var parentID = ReactComponentTreeHook.getParentID(id);
	    tree[id] = {
	      displayName: ReactComponentTreeHook.getDisplayName(id),
	      text: ReactComponentTreeHook.getText(id),
	      updateCount: ReactComponentTreeHook.getUpdateCount(id),
	      childIDs: ReactComponentTreeHook.getChildIDs(id),
	      // Text nodes don't have owners but this is close enough.
	      ownerID: ownerID || ReactComponentTreeHook.getOwnerID(parentID),
	      parentID: parentID
	    };
	    return tree;
	  }, {});
	}
	
	function resetMeasurements() {
	  var previousStartTime = currentFlushStartTime;
	  var previousMeasurements = currentFlushMeasurements || [];
	  var previousOperations = ReactHostOperationHistoryHook.getHistory();
	
	  if (currentFlushNesting === 0) {
	    currentFlushStartTime = null;
	    currentFlushMeasurements = null;
	    clearHistory();
	    return;
	  }
	
	  if (previousMeasurements.length || previousOperations.length) {
	    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
	    flushHistory.push({
	      duration: performanceNow() - previousStartTime,
	      measurements: previousMeasurements || [],
	      operations: previousOperations || [],
	      treeSnapshot: getTreeSnapshot(registeredIDs)
	    });
	  }
	
	  clearHistory();
	  currentFlushStartTime = performanceNow();
	  currentFlushMeasurements = [];
	}
	
	function checkDebugID(debugID) {
	  var allowRoot = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	  if (allowRoot && debugID === 0) {
	    return;
	  }
	  if (!debugID) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
	  }
	}
	
	function beginLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  currentTimerStartTime = performanceNow();
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	function endLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  if (_isProfiling) {
	    currentFlushMeasurements.push({
	      timerType: timerType,
	      instanceID: debugID,
	      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
	    });
	  }
	  currentTimerStartTime = null;
	  currentTimerNestedFlushDuration = null;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function pauseCurrentLifeCycleTimer() {
	  var currentTimer = {
	    startTime: currentTimerStartTime,
	    nestedFlushStartTime: performanceNow(),
	    debugID: currentTimerDebugID,
	    timerType: currentTimerType
	  };
	  lifeCycleTimerStack.push(currentTimer);
	  currentTimerStartTime = null;
	  currentTimerNestedFlushDuration = null;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function resumeCurrentLifeCycleTimer() {
	  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop();
	
	  var startTime = _lifeCycleTimerStack$.startTime;
	  var nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime;
	  var debugID = _lifeCycleTimerStack$.debugID;
	  var timerType = _lifeCycleTimerStack$.timerType;
	
	  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
	  currentTimerStartTime = startTime;
	  currentTimerNestedFlushDuration += nestedFlushDuration;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	var ReactDebugTool = {
	  addHook: function addHook(hook) {
	    hooks.push(hook);
	  },
	  removeHook: function removeHook(hook) {
	    for (var i = 0; i < hooks.length; i++) {
	      if (hooks[i] === hook) {
	        hooks.splice(i, 1);
	        i--;
	      }
	    }
	  },
	  isProfiling: function isProfiling() {
	    return _isProfiling;
	  },
	  beginProfiling: function beginProfiling() {
	    if (_isProfiling) {
	      return;
	    }
	
	    _isProfiling = true;
	    flushHistory.length = 0;
	    resetMeasurements();
	    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
	  },
	  endProfiling: function endProfiling() {
	    if (!_isProfiling) {
	      return;
	    }
	
	    _isProfiling = false;
	    resetMeasurements();
	    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
	  },
	  getFlushHistory: function getFlushHistory() {
	    return flushHistory;
	  },
	  onBeginFlush: function onBeginFlush() {
	    currentFlushNesting++;
	    resetMeasurements();
	    pauseCurrentLifeCycleTimer();
	    emitEvent('onBeginFlush');
	  },
	  onEndFlush: function onEndFlush() {
	    resetMeasurements();
	    currentFlushNesting--;
	    resumeCurrentLifeCycleTimer();
	    emitEvent('onEndFlush');
	  },
	  onBeginLifeCycleTimer: function onBeginLifeCycleTimer(debugID, timerType) {
	    checkDebugID(debugID);
	    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
	    beginLifeCycleTimer(debugID, timerType);
	  },
	  onEndLifeCycleTimer: function onEndLifeCycleTimer(debugID, timerType) {
	    checkDebugID(debugID);
	    endLifeCycleTimer(debugID, timerType);
	    emitEvent('onEndLifeCycleTimer', debugID, timerType);
	  },
	  onError: function onError(debugID) {
	    if (currentTimerDebugID != null) {
	      endLifeCycleTimer(currentTimerDebugID, currentTimerType);
	    }
	    emitEvent('onError', debugID);
	  },
	  onBeginProcessingChildContext: function onBeginProcessingChildContext() {
	    emitEvent('onBeginProcessingChildContext');
	  },
	  onEndProcessingChildContext: function onEndProcessingChildContext() {
	    emitEvent('onEndProcessingChildContext');
	  },
	  onHostOperation: function onHostOperation(debugID, type, payload) {
	    checkDebugID(debugID);
	    emitEvent('onHostOperation', debugID, type, payload);
	  },
	  onSetState: function onSetState() {
	    emitEvent('onSetState');
	  },
	  onSetChildren: function onSetChildren(debugID, childDebugIDs) {
	    checkDebugID(debugID);
	    childDebugIDs.forEach(checkDebugID);
	    emitEvent('onSetChildren', debugID, childDebugIDs);
	  },
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element, parentDebugID) {
	    checkDebugID(debugID);
	    checkDebugID(parentDebugID, true);
	    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
	  },
	  onMountComponent: function onMountComponent(debugID) {
	    checkDebugID(debugID);
	    emitEvent('onMountComponent', debugID);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUpdateComponent', debugID, element);
	  },
	  onUpdateComponent: function onUpdateComponent(debugID) {
	    checkDebugID(debugID);
	    emitEvent('onUpdateComponent', debugID);
	  },
	  onBeforeUnmountComponent: function onBeforeUnmountComponent(debugID) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUnmountComponent', debugID);
	  },
	  onUnmountComponent: function onUnmountComponent(debugID) {
	    checkDebugID(debugID);
	    emitEvent('onUnmountComponent', debugID);
	  },
	  onTestEvent: function onTestEvent() {
	    emitEvent('onTestEvent');
	  }
	};
	
	// TODO remove these when RN/www gets updated
	ReactDebugTool.addDevtool = ReactDebugTool.addHook;
	ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;
	
	ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
	ReactDebugTool.addHook(ReactComponentTreeHook);
	ReactDebugTool.addHook(ReactChildrenMutationWarningHook);
	var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	if (/[?&]react_perf\b/.test(url)) {
	  ReactDebugTool.beginProfiling();
	}
	
	module.exports = ReactDebugTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInvalidSetStateWarningHook
	 */
	
	'use strict';
	
	var warning = __webpack_require__(11);
	
	if (process.env.NODE_ENV !== 'production') {
	  var processingChildContext = false;
	
	  var warnInvalidSetState = function warnInvalidSetState() {
	    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
	  };
	}
	
	var ReactInvalidSetStateWarningHook = {
	  onBeginProcessingChildContext: function onBeginProcessingChildContext() {
	    processingChildContext = true;
	  },
	  onEndProcessingChildContext: function onEndProcessingChildContext() {
	    processingChildContext = false;
	  },
	  onSetState: function onSetState() {
	    warnInvalidSetState();
	  }
	};
	
	module.exports = ReactInvalidSetStateWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 65 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactHostOperationHistoryHook
	 */
	
	'use strict';
	
	var history = [];
	
	var ReactHostOperationHistoryHook = {
	  onHostOperation: function onHostOperation(debugID, type, payload) {
	    history.push({
	      instanceID: debugID,
	      type: type,
	      payload: payload
	    });
	  },
	  clearHistory: function clearHistory() {
	    if (ReactHostOperationHistoryHook._preventClearing) {
	      // Should only be used for tests.
	      return;
	    }
	
	    history = [];
	  },
	  getHistory: function getHistory() {
	    return history;
	  }
	};
	
	module.exports = ReactHostOperationHistoryHook;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildrenMutationWarningHook
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(28);
	
	var warning = __webpack_require__(11);
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element._shadowChildren === undefined) {
	    return;
	  }
	  if (element._shadowChildren === element.props.children) {
	    return;
	  }
	  var isMutated = false;
	  if (Array.isArray(element._shadowChildren)) {
	    if (element._shadowChildren.length === element.props.children.length) {
	      for (var i = 0; i < element._shadowChildren.length; i++) {
	        if (element._shadowChildren[i] !== element.props.children[i]) {
	          isMutated = true;
	        }
	      }
	    } else {
	      isMutated = true;
	    }
	  }
	  if (!Array.isArray(element._shadowChildren) || isMutated) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Component\'s children should not be mutated.%s', ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	}
	
	var ReactChildrenMutationWarningHook = {
	  onMountComponent: function onMountComponent(debugID) {
	    handleElement(debugID, ReactComponentTreeHook.getElement(debugID));
	  },
	  onUpdateComponent: function onUpdateComponent(debugID) {
	    handleElement(debugID, ReactComponentTreeHook.getElement(debugID));
	  }
	};
	
	module.exports = ReactChildrenMutationWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var performance = __webpack_require__(68);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(49);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function reinitializeTransaction() {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function isInTransaction() {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function perform(method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function initializeAll(startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function closeAll(startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	var Transaction = {
	
	  Mixin: Mixin,
	
	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}
	
	};
	
	module.exports = Transaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 70 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	
	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }
	
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(49);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 72 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 * 
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	
	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }
	
	  if (nodeName === 'textarea') {
	    return true;
	  }
	
	  return false;
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */
	
	'use strict';
	
	var keyOf = __webpack_require__(25);
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(41);
	var EventPropagators = __webpack_require__(42);
	var ReactDOMComponentTree = __webpack_require__(36);
	var SyntheticMouseEvent = __webpack_require__(75);
	
	var keyOf = __webpack_require__(25);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
	    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
	
	    return [leave, enter];
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(76);
	var ViewportMetrics = __webpack_require__(77);
	
	var getEventModifierState = __webpack_require__(78);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function button(event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function relatedTarget(event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function pageX(event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function pageY(event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(53);
	
	var getEventTarget = __webpack_require__(70);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function view(event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function detail(event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 77 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function refreshScrollValues(scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 78 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(37);
	
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: 0,
	    acceptCharset: 0,
	    accessKey: 0,
	    action: 0,
	    allowFullScreen: HAS_BOOLEAN_VALUE,
	    allowTransparency: 0,
	    alt: 0,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: 0,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: HAS_BOOLEAN_VALUE,
	    cellPadding: 0,
	    cellSpacing: 0,
	    charSet: 0,
	    challenge: 0,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    cite: 0,
	    classID: 0,
	    className: 0,
	    cols: HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: 0,
	    content: 0,
	    contentEditable: 0,
	    contextMenu: 0,
	    controls: HAS_BOOLEAN_VALUE,
	    coords: 0,
	    crossOrigin: 0,
	    data: 0, // For `<object />` acts as `src`.
	    dateTime: 0,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: 0,
	    disabled: HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: 0,
	    encType: 0,
	    form: 0,
	    formAction: 0,
	    formEncType: 0,
	    formMethod: 0,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: 0,
	    frameBorder: 0,
	    headers: 0,
	    height: 0,
	    hidden: HAS_BOOLEAN_VALUE,
	    high: 0,
	    href: 0,
	    hrefLang: 0,
	    htmlFor: 0,
	    httpEquiv: 0,
	    icon: 0,
	    id: 0,
	    inputMode: 0,
	    integrity: 0,
	    is: 0,
	    keyParams: 0,
	    keyType: 0,
	    kind: 0,
	    label: 0,
	    lang: 0,
	    list: 0,
	    loop: HAS_BOOLEAN_VALUE,
	    low: 0,
	    manifest: 0,
	    marginHeight: 0,
	    marginWidth: 0,
	    max: 0,
	    maxLength: 0,
	    media: 0,
	    mediaGroup: 0,
	    method: 0,
	    min: 0,
	    minLength: 0,
	    // Caution; `option.selected` is not updated if `select.multiple` is
	    // disabled with `removeAttribute`.
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: 0,
	    nonce: 0,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: 0,
	    pattern: 0,
	    placeholder: 0,
	    poster: 0,
	    preload: 0,
	    profile: 0,
	    radioGroup: 0,
	    readOnly: HAS_BOOLEAN_VALUE,
	    referrerPolicy: 0,
	    rel: 0,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: 0,
	    rows: HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: HAS_NUMERIC_VALUE,
	    sandbox: 0,
	    scope: 0,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: 0,
	    seamless: HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: 0,
	    size: HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: 0,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: 0,
	    src: 0,
	    srcDoc: 0,
	    srcLang: 0,
	    srcSet: 0,
	    start: HAS_NUMERIC_VALUE,
	    step: 0,
	    style: 0,
	    summary: 0,
	    tabIndex: 0,
	    target: 0,
	    title: 0,
	    // Setting .type throws on non-<input> tags
	    type: 0,
	    useMap: 0,
	    value: 0,
	    width: 0,
	    wmode: 0,
	    wrap: 0,
	
	    /**
	     * RDFa Properties
	     */
	    about: 0,
	    datatype: 0,
	    inlist: 0,
	    prefix: 0,
	    // property is also supported for OpenGraph in meta tags.
	    property: 0,
	    resource: 0,
	    'typeof': 0,
	    vocab: 0,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: 0,
	    autoCorrect: 0,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: 0,
	    // color is for Safari mask-icon link
	    color: 0,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: 0,
	    itemScope: HAS_BOOLEAN_VALUE,
	    itemType: 0,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: 0,
	    itemRef: 0,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: 0,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: 0,
	    // IE-only attribute that controls focus behavior
	    unselectable: 0
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {}
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(81);
	var ReactDOMIDOperations = __webpack_require__(93);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 */
	
	'use strict';
	
	var DOMLazyTree = __webpack_require__(82);
	var Danger = __webpack_require__(88);
	var ReactMultiChildUpdateTypes = __webpack_require__(92);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactInstrumentation = __webpack_require__(62);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(85);
	var setInnerHTML = __webpack_require__(84);
	var setTextContent = __webpack_require__(86);
	
	function getNodeAfter(parentNode, node) {
	  // Special case for text components, which return [open, close] comments
	  // from getHostNode.
	  if (Array.isArray(node)) {
	    node = node[1];
	  }
	  return node ? node.nextSibling : parentNode.firstChild;
	}
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
	  // We rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
	  // we are careful to use `null`.)
	  parentNode.insertBefore(childNode, referenceNode);
	});
	
	function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
	  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
	}
	
	function moveChild(parentNode, childNode, referenceNode) {
	  if (Array.isArray(childNode)) {
	    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
	  } else {
	    insertChildAt(parentNode, childNode, referenceNode);
	  }
	}
	
	function removeChild(parentNode, childNode) {
	  if (Array.isArray(childNode)) {
	    var closingComment = childNode[1];
	    childNode = childNode[0];
	    removeDelimitedText(parentNode, childNode, closingComment);
	    parentNode.removeChild(closingComment);
	  }
	  parentNode.removeChild(childNode);
	}
	
	function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
	  var node = openingComment;
	  while (true) {
	    var nextNode = node.nextSibling;
	    insertChildAt(parentNode, node, referenceNode);
	    if (node === closingComment) {
	      break;
	    }
	    node = nextNode;
	  }
	}
	
	function removeDelimitedText(parentNode, startNode, closingComment) {
	  while (true) {
	    var node = startNode.nextSibling;
	    if (node === closingComment) {
	      // The closing comment is removed by ReactMultiChild.
	      break;
	    } else {
	      parentNode.removeChild(node);
	    }
	  }
	}
	
	function replaceDelimitedText(openingComment, closingComment, stringText) {
	  var parentNode = openingComment.parentNode;
	  var nodeAfterComment = openingComment.nextSibling;
	  if (nodeAfterComment === closingComment) {
	    // There are no text nodes between the opening and closing comments; insert
	    // a new one if stringText isn't empty.
	    if (stringText) {
	      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
	    }
	  } else {
	    if (stringText) {
	      // Set the text content of the first node after the opening comment, and
	      // remove all following nodes up until the closing comment.
	      setTextContent(nodeAfterComment, stringText);
	      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
	    } else {
	      removeDelimitedText(parentNode, openingComment, closingComment);
	    }
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID, 'replace text', stringText);
	  }
	}
	
	var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
	if (process.env.NODE_ENV !== 'production') {
	  dangerouslyReplaceNodeWithMarkup = function dangerouslyReplaceNodeWithMarkup(oldChild, markup, prevInstance) {
	    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
	    if (prevInstance._debugID !== 0) {
	      ReactInstrumentation.debugTool.onHostOperation(prevInstance._debugID, 'replace with', markup.toString());
	    } else {
	      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
	      if (nextInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation(nextInstance._debugID, 'mount', markup.toString());
	      }
	    }
	  };
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
	
	  replaceDelimitedText: replaceDelimitedText,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  processUpdates: function processUpdates(parentNode, updates) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      var update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'insert child', { toIndex: update.toIndex, content: update.content.toString() });
	          }
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'move child', { fromIndex: update.fromIndex, toIndex: update.toIndex });
	          }
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace children', update.content.toString());
	          }
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace text', update.content.toString());
	          }
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          removeChild(parentNode, update.fromNode);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'remove child', { fromIndex: update.fromIndex });
	          }
	          break;
	      }
	    }
	  }
	
	};
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMLazyTree
	 */
	
	'use strict';
	
	var DOMNamespaces = __webpack_require__(83);
	var setInnerHTML = __webpack_require__(84);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(85);
	var setTextContent = __webpack_require__(86);
	
	var ELEMENT_NODE_TYPE = 1;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * In IE (8-11) and Edge, appending nodes with no children is dramatically
	 * faster than appending a full subtree, so we essentially queue up the
	 * .appendChild calls here and apply them so each node is added to its parent
	 * before any children are added.
	 *
	 * In other browsers, doing so is slower or neutral compared to the other order
	 * (in Firefox, twice as slow) so we only do this inversion in IE.
	 *
	 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
	 */
	var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
	
	function insertTreeChildren(tree) {
	  if (!enableLazy) {
	    return;
	  }
	  var node = tree.node;
	  var children = tree.children;
	  if (children.length) {
	    for (var i = 0; i < children.length; i++) {
	      insertTreeBefore(node, children[i], null);
	    }
	  } else if (tree.html != null) {
	    setInnerHTML(node, tree.html);
	  } else if (tree.text != null) {
	    setTextContent(node, tree.text);
	  }
	}
	
	var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
	  // DocumentFragments aren't actually part of the DOM after insertion so
	  // appending children won't update the DOM. We need to ensure the fragment
	  // is properly populated first, breaking out of our lazy approach for just
	  // this level. Also, some <object> plugins (like Flash Player) will read
	  // <param> nodes immediately upon insertion into the DOM, so <object>
	  // must also be populated prior to insertion into the DOM.
	  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
	    insertTreeChildren(tree);
	    parentNode.insertBefore(tree.node, referenceNode);
	  } else {
	    parentNode.insertBefore(tree.node, referenceNode);
	    insertTreeChildren(tree);
	  }
	});
	
	function replaceChildWithTree(oldNode, newTree) {
	  oldNode.parentNode.replaceChild(newTree.node, oldNode);
	  insertTreeChildren(newTree);
	}
	
	function queueChild(parentTree, childTree) {
	  if (enableLazy) {
	    parentTree.children.push(childTree);
	  } else {
	    parentTree.node.appendChild(childTree.node);
	  }
	}
	
	function queueHTML(tree, html) {
	  if (enableLazy) {
	    tree.html = html;
	  } else {
	    setInnerHTML(tree.node, html);
	  }
	}
	
	function queueText(tree, text) {
	  if (enableLazy) {
	    tree.text = text;
	  } else {
	    setTextContent(tree.node, text);
	  }
	}
	
	function toString() {
	  return this.node.nodeName;
	}
	
	function DOMLazyTree(node) {
	  return {
	    node: node,
	    children: [],
	    html: null,
	    text: null,
	    toString: toString
	  };
	}
	
	DOMLazyTree.insertTreeBefore = insertTreeBefore;
	DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
	DOMLazyTree.queueChild = queueChild;
	DOMLazyTree.queueHTML = queueHTML;
	DOMLazyTree.queueText = queueText;
	
	module.exports = DOMLazyTree;

/***/ },
/* 83 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMNamespaces
	 */
	
	'use strict';
	
	var DOMNamespaces = {
	  html: 'http://www.w3.org/1999/xhtml',
	  mathml: 'http://www.w3.org/1998/Math/MathML',
	  svg: 'http://www.w3.org/2000/svg'
	};
	
	module.exports = DOMNamespaces;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(49);
	var DOMNamespaces = __webpack_require__(83);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(85);
	
	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node
	  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var newNodes = reusableSVGContainer.firstChild.childNodes;
	    for (var i = 0; i < newNodes.length; i++) {
	      node.appendChild(newNodes[i]);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function setInnerHTML(node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	  testElement = null;
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 85 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createMicrosoftUnsafeLocalFunction
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */
	
	var createMicrosoftUnsafeLocalFunction = function createMicrosoftUnsafeLocalFunction(func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};
	
	module.exports = createMicrosoftUnsafeLocalFunction;

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(49);
	var escapeTextContentForBrowser = __webpack_require__(87);
	var setInnerHTML = __webpack_require__(84);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function setTextContent(node, text) {
	  if (text) {
	    var firstChild = node.firstChild;
	
	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function setTextContent(node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 87 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * Based on the escape-html library, which is used under the MIT License below:
	 *
	 * Copyright (c) 2012-2013 TJ Holowaychuk
	 * Copyright (c) 2015 Andreas Lubbe
	 * Copyright (c) 2015 Tiancheng "Timothy" Gu
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * 'Software'), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */
	
	'use strict';
	
	// code copied and modified from escape-html
	/**
	 * Module variables.
	 * @private
	 */
	
	var matchHtmlRegExp = /["'&<>]/;
	
	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */
	
	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);
	
	  if (!match) {
	    return str;
	  }
	
	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;
	
	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }
	
	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }
	
	    lastIndex = index + 1;
	    html += escape;
	  }
	
	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
	// end code copied and modified from escape-html
	
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  if (typeof text === 'boolean' || typeof text === 'number') {
	    // this shortcircuit helps perf for types that we know will never have
	    // special characters, especially given that this function is used often
	    // for numeric dom ids.
	    return '' + text;
	  }
	  return escapeHtml(text);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var DOMLazyTree = __webpack_require__(82);
	var ExecutionEnvironment = __webpack_require__(49);
	
	var createNodesFromMarkup = __webpack_require__(89);
	var emptyFunction = __webpack_require__(12);
	var invariant = __webpack_require__(8);
	
	var Danger = {
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function dangerouslyReplaceNodeWithMarkup(oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
	    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
	
	    if (typeof markup === 'string') {
	      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	      oldChild.parentNode.replaceChild(newChild, oldChild);
	    } else {
	      DOMLazyTree.replaceChildWithTree(oldChild, markup);
	    }
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	var ExecutionEnvironment = __webpack_require__(49);
	
	var createArrayFromMixed = __webpack_require__(90);
	var getMarkupWrap = __webpack_require__(91);
	var invariant = __webpack_require__(8);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = Array.from(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
	  // in old versions of Safari).
	  !(!Array.isArray(obj) && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
	
	  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	var ExecutionEnvironment = __webpack_require__(49);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(23);
	
	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});
	
	module.exports = ReactMultiChildUpdateTypes;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(81);
	var ReactDOMComponentTree = __webpack_require__(36);
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function dangerouslyProcessChildrenUpdates(parentInst, updates) {
	    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
	    DOMChildrenOperations.processUpdates(node, updates);
	  }
	};
	
	module.exports = ReactDOMIDOperations;

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var AutoFocusUtils = __webpack_require__(95);
	var CSSPropertyOperations = __webpack_require__(97);
	var DOMLazyTree = __webpack_require__(82);
	var DOMNamespaces = __webpack_require__(83);
	var DOMProperty = __webpack_require__(37);
	var DOMPropertyOperations = __webpack_require__(105);
	var EventConstants = __webpack_require__(41);
	var EventPluginHub = __webpack_require__(43);
	var EventPluginRegistry = __webpack_require__(44);
	var ReactBrowserEventEmitter = __webpack_require__(107);
	var ReactDOMButton = __webpack_require__(110);
	var ReactDOMComponentFlags = __webpack_require__(38);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactDOMInput = __webpack_require__(112);
	var ReactDOMOption = __webpack_require__(114);
	var ReactDOMSelect = __webpack_require__(115);
	var ReactDOMTextarea = __webpack_require__(116);
	var ReactInstrumentation = __webpack_require__(62);
	var ReactMultiChild = __webpack_require__(117);
	var ReactServerRenderingTransaction = __webpack_require__(129);
	
	var emptyFunction = __webpack_require__(12);
	var escapeTextContentForBrowser = __webpack_require__(87);
	var invariant = __webpack_require__(8);
	var isEventSupported = __webpack_require__(71);
	var keyOf = __webpack_require__(25);
	var shallowEqual = __webpack_require__(124);
	var validateDOMNesting = __webpack_require__(132);
	var warning = __webpack_require__(11);
	
	var Flags = ReactDOMComponentFlags;
	var deleteListener = EventPluginHub.deleteListener;
	var getNode = ReactDOMComponentTree.getNodeFromInstance;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = EventPluginRegistry.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });
	var RESERVED_PROPS = {
	  children: null,
	  dangerouslySetInnerHTML: null,
	  suppressContentEditableWarning: null
	};
	
	// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
	var DOC_FRAGMENT_TYPE = 11;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	function friendlyStringify(obj) {
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined because undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[component._tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
	    !(_typeof(props.dangerouslySetInnerHTML) === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
	  }
	  !(props.style == null || _typeof(props.style) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
	}
	
	function enqueuePutListener(inst, registrationName, listener, transaction) {
	  if (transaction instanceof ReactServerRenderingTransaction) {
	    return;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
	  }
	  var containerInfo = inst._hostContainerInfo;
	  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
	  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
	  listenTo(registrationName, doc);
	  transaction.getReactMountReady().enqueue(putListener, {
	    inst: inst,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	function inputPostMount() {
	  var inst = this;
	  ReactDOMInput.postMountWrapper(inst);
	}
	
	function textareaPostMount() {
	  var inst = this;
	  ReactDOMTextarea.postMountWrapper(inst);
	}
	
	function optionPostMount() {
	  var inst = this;
	  ReactDOMOption.postMountWrapper(inst);
	}
	
	var setContentChildForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  setContentChildForInstrumentation = function setContentChildForInstrumentation(content) {
	    var hasExistingContent = this._contentDebugID != null;
	    var debugID = this._debugID;
	    // This ID represents the inlined child that has no backing instance:
	    var contentDebugID = -debugID;
	
	    if (content == null) {
	      if (hasExistingContent) {
	        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
	      }
	      this._contentDebugID = null;
	      return;
	    }
	
	    this._contentDebugID = contentDebugID;
	    if (hasExistingContent) {
	      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
	      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
	    } else {
	      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
	      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
	      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
	    }
	  };
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
	  var node = getNode(inst);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
	
	  switch (inst._tag) {
	    case 'iframe':
	    case 'object':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // Create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }
	      break;
	    case 'source':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node)];
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	    case 'input':
	    case 'select':
	    case 'textarea':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topInvalid, 'invalid', node)];
	      break;
	  }
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = _assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	var globalIdCounter = 1;
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(element) {
	  var tag = element.type;
	  validateDangerousTag(tag);
	  this._currentElement = element;
	  this._tag = tag.toLowerCase();
	  this._namespaceURI = null;
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._hostNode = null;
	  this._hostParent = null;
	  this._rootNodeID = 0;
	  this._domID = 0;
	  this._hostContainerInfo = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._flags = 0;
	  if (process.env.NODE_ENV !== 'production') {
	    this._ancestorInfo = null;
	    setContentChildForInstrumentation.call(this, null);
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?ReactDOMComponent} the parent component instance
	   * @param {?object} info about the host container
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    this._rootNodeID = globalIdCounter++;
	    this._domID = hostContainerInfo._idCounter++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getHostProps(this, props, hostParent);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, hostParent);
	        props = ReactDOMInput.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, hostParent);
	        props = ReactDOMOption.getHostProps(this, props);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, hostParent);
	        props = ReactDOMSelect.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, hostParent);
	        props = ReactDOMTextarea.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	    }
	
	    assertValidProps(this, props);
	
	    // We create tags in the namespace of their parent container, except HTML
	    // tags get no namespace.
	    var namespaceURI;
	    var parentTag;
	    if (hostParent != null) {
	      namespaceURI = hostParent._namespaceURI;
	      parentTag = hostParent._tag;
	    } else if (hostContainerInfo._tag) {
	      namespaceURI = hostContainerInfo._namespaceURI;
	      parentTag = hostContainerInfo._tag;
	    }
	    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
	      namespaceURI = DOMNamespaces.html;
	    }
	    if (namespaceURI === DOMNamespaces.html) {
	      if (this._tag === 'svg') {
	        namespaceURI = DOMNamespaces.svg;
	      } else if (this._tag === 'math') {
	        namespaceURI = DOMNamespaces.mathml;
	      }
	    }
	    this._namespaceURI = namespaceURI;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo._tag) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(this._tag, this, parentInfo);
	      }
	      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var el;
	      if (namespaceURI === DOMNamespaces.html) {
	        if (this._tag === 'script') {
	          // Create the script via .innerHTML so its "parser-inserted" flag is
	          // set to true and it does not execute
	          var div = ownerDocument.createElement('div');
	          var type = this._currentElement.type;
	          div.innerHTML = '<' + type + '></' + type + '>';
	          el = div.removeChild(div.firstChild);
	        } else if (props.is) {
	          el = ownerDocument.createElement(this._currentElement.type, props.is);
	        } else {
	          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
	          // See discussion in https://github.com/facebook/react/pull/6896
	          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	          el = ownerDocument.createElement(this._currentElement.type);
	        }
	      } else {
	        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
	      }
	      ReactDOMComponentTree.precacheNode(this, el);
	      this._flags |= Flags.hasCachedChildNodes;
	      if (!this._hostParent) {
	        DOMPropertyOperations.setAttributeForRoot(el);
	      }
	      this._updateDOMProperties(null, props, transaction);
	      var lazyTree = DOMLazyTree(el);
	      this._createInitialChildren(transaction, props, context, lazyTree);
	      mountImage = lazyTree;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(inputPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'textarea':
	        transaction.getReactMountReady().enqueue(textareaPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'select':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'button':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'option':
	        transaction.getReactMountReady().enqueue(optionPostMount, this);
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function _createOpenTagMarkupAndPutListeners(transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = _assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    if (!this._hostParent) {
	      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
	    }
	    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
	    return ret;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function _createContentMarkup(transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function _createInitialChildren(transaction, props, context, lazyTree) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, contentToUse);
	        }
	        DOMLazyTree.queueText(lazyTree, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function receiveComponent(nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getHostProps(this, lastProps);
	        nextProps = ReactDOMButton.getHostProps(this, nextProps);
	        break;
	      case 'input':
	        lastProps = ReactDOMInput.getHostProps(this, lastProps);
	        nextProps = ReactDOMInput.getHostProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getHostProps(this, lastProps);
	        nextProps = ReactDOMOption.getHostProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
	        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
	        break;
	      case 'textarea':
	        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
	        break;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    switch (this._tag) {
	      case 'input':
	        // Update the wrapper around inputs *after* updating props. This has to
	        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
	        // raise warnings and prevent the new value from being assigned.
	        ReactDOMInput.updateWrapper(this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        break;
	      case 'select':
	        // <select> value update needs to occur after <option> children
	        // reconciliation
	        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	        break;
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function _updateDOMProperties(lastProps, nextProps, transaction) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, lastProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = _assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        var node = getNode(this);
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertently setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function _updateDOMChildren(lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[_typeof(lastProps.children)] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[_typeof(nextProps.children)] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, nextContent);
	        }
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    } else if (nextChildren != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        setContentChildForInstrumentation.call(this, null);
	      }
	
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  getHostNode: function getHostNode() {
	    return getNode(this);
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function unmountComponent(safely) {
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
	        break;
	    }
	
	    this.unmountChildren(safely);
	    ReactDOMComponentTree.uncacheNode(this);
	    EventPluginHub.deleteAllListeners(this);
	    this._rootNodeID = 0;
	    this._domID = 0;
	    this._wrapperState = null;
	
	    if (process.env.NODE_ENV !== 'production') {
	      setContentChildForInstrumentation.call(this, null);
	    }
	  },
	
	  getPublicInstance: function getPublicInstance() {
	    return getNode(this);
	  }
	
	};
	
	_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 */
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(36);
	
	var focusNode = __webpack_require__(96);
	
	var AutoFocusUtils = {
	  focusDOMComponent: function focusDOMComponent() {
	    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 96 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(98);
	var ExecutionEnvironment = __webpack_require__(49);
	var ReactInstrumentation = __webpack_require__(62);
	
	var camelizeStyleName = __webpack_require__(99);
	var dangerousStyleValue = __webpack_require__(101);
	var hyphenateStyleName = __webpack_require__(102);
	var memoizeStringOnly = __webpack_require__(104);
	var warning = __webpack_require__(11);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;
	
	  var warnHyphenatedStyleName = function warnHyphenatedStyleName(name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnBadVendoredStyleName = function warnBadVendoredStyleName(name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value, owner) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	  };
	
	  var warnStyleValueIsNaN = function warnStyleValueIsNaN(name, value, owner) {
	    if (warnedForNaNValue) {
	      return;
	    }
	
	    warnedForNaNValue = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	  };
	
	  var checkRenderMessage = function checkRenderMessage(owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   * @param {ReactDOMComponent} component
	   */
	  var warnValidStyle = function warnValidStyle(name, value, component) {
	    var owner;
	    if (component) {
	      owner = component._currentElement._owner;
	    }
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name, owner);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name, owner);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value, owner);
	    }
	
	    if (typeof value === 'number' && isNaN(value)) {
	      warnStyleValueIsNaN(name, value, owner);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   * @return {?string}
	   */
	  createMarkupForStyles: function createMarkupForStyles(styles, component) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue, component);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   */
	  setValueForStyles: function setValueForStyles(node, styles, component) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(component._debugID, 'update styles', styles);
	    }
	
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName], component);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
	      if (styleName === 'float' || styleName === 'cssFloat') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 98 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridRow: true,
	  gridColumn: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(100);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 100 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(98);
	var warning = __webpack_require__(11);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	var styleWarnings = {};
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @param {ReactDOMComponent} component
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, component) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    if (process.env.NODE_ENV !== 'production') {
	      // Allow '0' to pass through without warning. 0 is already special and
	      // doesn't require units, so we don't need to warn about it.
	      if (component && value !== '0') {
	        var owner = component._currentElement._owner;
	        var ownerName = owner ? owner.getName() : null;
	        if (ownerName && !styleWarnings[ownerName]) {
	          styleWarnings[ownerName] = {};
	        }
	        var warned = false;
	        if (ownerName) {
	          var warnings = styleWarnings[ownerName];
	          warned = warnings[name];
	          if (!warned) {
	            warnings[name] = true;
	          }
	        }
	        if (!warned) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	        }
	      }
	    }
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(103);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 103 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 104 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(37);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactInstrumentation = __webpack_require__(62);
	
	var quoteAttributeValueForBrowser = __webpack_require__(106);
	var warning = __webpack_require__(11);
	
	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function createMarkupForID(id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function setAttributeForID(node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  createMarkupForRoot: function createMarkupForRoot() {
	    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
	  },
	
	  setAttributeForRoot: function setAttributeForRoot(node) {
	    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function createMarkupForProperty(name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function createMarkupForCustomAttribute(name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function setValueForProperty(node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	        return;
	      } else if (propertyInfo.mustUseProperty) {
	        // Contrary to `setAttribute`, object properties are properly
	        // `toString`ed by IE8/9.
	        node[propertyInfo.propertyName] = value;
	      } else {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
	    }
	  },
	
	  setValueForAttribute: function setValueForAttribute(node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
	    }
	  },
	
	  /**
	   * Deletes an attributes from a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForAttribute: function deleteValueForAttribute(node, name) {
	    node.removeAttribute(name);
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function deleteValueForProperty(node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseProperty) {
	        var propName = propertyInfo.propertyName;
	        if (propertyInfo.hasBooleanValue) {
	          node[propName] = false;
	        } else {
	          node[propName] = '';
	        }
	      } else {
	        node.removeAttribute(propertyInfo.attributeName);
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
	    }
	  }
	
	};
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(87);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var EventConstants = __webpack_require__(41);
	var EventPluginRegistry = __webpack_require__(44);
	var ReactEventEmitterMixin = __webpack_require__(108);
	var ViewportMetrics = __webpack_require__(77);
	
	var getVendorPrefixedEventName = __webpack_require__(109);
	var isEventSupported = __webpack_require__(71);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var hasEventPageXY;
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
	  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
	  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function injectReactEventListener(ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function setEnabled(enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function isEnabled() {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function listenTo(registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
	   * pageX/pageY isn't supported (legacy browsers).
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function ensureScrollValueMonitoring() {
	    if (hasEventPageXY === undefined) {
	      hasEventPageXY = document.createEvent && 'pageX' in document.createEvent('MouseEvent');
	    }
	    if (!hasEventPageXY && !isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  }
	
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(43);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   */
	  handleTopLevel: function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getVendorPrefixedEventName
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(49);
	
	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};
	
	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;
	  prefixes['ms' + styleProp] = 'MS' + eventName;
	  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
	
	  return prefixes;
	}
	
	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};
	
	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};
	
	/**
	 * Element to check for prefixes on.
	 */
	var style = {};
	
	/**
	 * Bootstrap if a DOM exists.
	 */
	if (ExecutionEnvironment.canUseDOM) {
	  style = document.createElement('div').style;
	
	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }
	
	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}
	
	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }
	
	  var prefixMap = vendorPrefixes[eventName];
	
	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }
	
	  return '';
	}
	
	module.exports = getVendorPrefixedEventName;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */
	
	'use strict';
	
	var DisabledInputUtils = __webpack_require__(111);
	
	/**
	 * Implements a <button> host component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getHostProps: DisabledInputUtils.getHostProps
	};
	
	module.exports = ReactDOMButton;

/***/ },
/* 111 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DisabledInputUtils
	 */
	
	'use strict';
	
	var disableableMouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,
	
	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};
	
	/**
	 * Implements a host component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var DisabledInputUtils = {
	  getHostProps: function getHostProps(inst, props) {
	    if (!props.disabled) {
	      return props;
	    }
	
	    // Copy the props, except the mouse listeners
	    var hostProps = {};
	    for (var key in props) {
	      if (!disableableMouseListenerNames[key] && props.hasOwnProperty(key)) {
	        hostProps[key] = props[key];
	      }
	    }
	
	    return hostProps;
	  }
	};
	
	module.exports = DisabledInputUtils;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var DisabledInputUtils = __webpack_require__(111);
	var DOMPropertyOperations = __webpack_require__(105);
	var LinkedValueUtils = __webpack_require__(113);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactUpdates = __webpack_require__(56);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	var didWarnValueLink = false;
	var didWarnCheckedLink = false;
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked !== undefined : props.value !== undefined;
	}
	
	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getHostProps: function getHostProps(inst, props) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var hostProps = _assign({
	      // Make sure we set .type before any other properties (setting .value
	      // before .type means .value is lost in IE11 and below)
	      type: undefined,
	      // Make sure we set .step before .value (setting .value before .step
	      // means .value is rounded on mount, based upon step precision)
	      step: undefined,
	      // Make sure we set .min & .max before .value (to ensure proper order
	      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
	      min: undefined,
	      max: undefined
	    }, DisabledInputUtils.getHostProps(inst, props), {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	
	      var owner = inst._currentElement._owner;
	
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnCheckedLink = true;
	      }
	      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnCheckedDefaultChecked = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnValueDefaultValue = true;
	      }
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	      initialValue: props.value != null ? props.value : defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      inst._wrapperState.controlled = isControlled(props);
	    }
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var controlled = isControlled(props);
	      var owner = inst._currentElement._owner;
	
	      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnUncontrolledToControlled = true;
	      }
	      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnControlledToUncontrolled = true;
	      }
	    }
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
	    }
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	    } else {
	      if (props.value == null && props.defaultValue != null) {
	        node.defaultValue = '' + props.defaultValue;
	      }
	      if (props.checked == null && props.defaultChecked != null) {
	        node.defaultChecked = !!props.defaultChecked;
	      }
	    }
	  },
	
	  postMountWrapper: function postMountWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Detach value from defaultValue. We won't do anything if we're working on
	    // submit or reset inputs as those values & defaultValues are linked. They
	    // are not resetable nodes so this operation doesn't matter and actually
	    // removes browser-default values (eg "Submit Query") when no value is
	    // provided.
	
	    switch (props.type) {
	      case 'submit':
	      case 'reset':
	        break;
	      case 'color':
	      case 'date':
	      case 'datetime':
	      case 'datetime-local':
	      case 'month':
	      case 'time':
	      case 'week':
	        // This fixes the no-show issue on iOS Safari and Android Chrome:
	        // https://github.com/facebook/react/issues/7233
	        node.value = '';
	        node.value = node.defaultValue;
	        break;
	      default:
	        node.value = node.value;
	        break;
	    }
	
	    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	    // this is needed to work around a chrome bug where setting defaultChecked
	    // will sometimes influence the value of checked (even after detachment).
	    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	    // We need to temporarily unset name to avoid disrupting radio button groups.
	    var name = node.name;
	    if (name !== '') {
	      node.name = '';
	    }
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !node.defaultChecked;
	    if (name !== '') {
	      node.name = name;
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactPropTypes = __webpack_require__(31);
	var ReactPropTypeLocations = __webpack_require__(22);
	var ReactPropTypesSecret = __webpack_require__(30);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
	}
	
	var propTypes = {
	  value: function value(props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function checked(props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function checkPropTypes(tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop, null, ReactPropTypesSecret);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function getValue(inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function getChecked(inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function executeOnChange(inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var ReactChildren = __webpack_require__(5);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactDOMSelect = __webpack_require__(115);
	
	var warning = __webpack_require__(11);
	var didWarnInvalidOptionChildren = false;
	
	function flattenChildren(children) {
	  var content = '';
	
	  // Flatten children and warn if they aren't strings or numbers;
	  // invalid types are ignored.
	  ReactChildren.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    if (typeof child === 'string' || typeof child === 'number') {
	      content += child;
	    } else if (!didWarnInvalidOptionChildren) {
	      didWarnInvalidOptionChildren = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
	    }
	  });
	
	  return content;
	}
	
	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function mountWrapper(inst, props, hostParent) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
	    }
	
	    // Look up whether this option is 'selected'
	    var selectValue = null;
	    if (hostParent != null) {
	      var selectParent = hostParent;
	
	      if (selectParent._tag === 'optgroup') {
	        selectParent = selectParent._hostParent;
	      }
	
	      if (selectParent != null && selectParent._tag === 'select') {
	        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
	      }
	    }
	
	    // If the value is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      var value;
	      if (props.value != null) {
	        value = props.value + '';
	      } else {
	        value = flattenChildren(props.children);
	      }
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  postMountWrapper: function postMountWrapper(inst) {
	    // value="" should make a value attribute (#6219)
	    var props = inst._currentElement.props;
	    if (props.value != null) {
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      node.setAttribute('value', props.value);
	    }
	  },
	
	  getHostProps: function getHostProps(inst, props) {
	    var hostProps = _assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      hostProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = flattenChildren(props.children);
	
	    if (content) {
	      hostProps.children = content;
	    }
	
	    return hostProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var DisabledInputUtils = __webpack_require__(111);
	var LinkedValueUtils = __webpack_require__(113);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactUpdates = __webpack_require__(56);
	
	var warning = __webpack_require__(11);
	
	var didWarnValueLink = false;
	var didWarnValueDefaultValue = false;
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  if (props.valueLink !== undefined && !didWarnValueLink) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
	    didWarnValueLink = true;
	  }
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    } else if (!props.multiple && isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  getHostProps: function getHostProps(inst, props) {
	    return _assign({}, DisabledInputUtils.getHostProps(inst, props), {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	
	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	      didWarnValueDefaultValue = true;
	    }
	  },
	
	  getSelectValueContext: function getSelectValueContext(inst) {
	    // ReactDOMOption looks at this initial value so the initial generated
	    // markup has correct `selected` attributes
	    return inst._wrapperState.initialValue;
	  },
	
	  postUpdateWrapper: function postUpdateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // this value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  if (this._rootNodeID) {
	    this._wrapperState.pendingUpdate = true;
	  }
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var DisabledInputUtils = __webpack_require__(111);
	var LinkedValueUtils = __webpack_require__(113);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactUpdates = __webpack_require__(56);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	var didWarnValueLink = false;
	var didWarnValDefaultVal = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getHostProps: function getHostProps(inst, props) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.  We could add a check in setTextContent
	    // to only set the value if/when the value differs from the node value (which would
	    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
	    // The value can be a boolean or object so that's why it's forced to be a string.
	    var hostProps = _assign({}, DisabledInputUtils.getHostProps(inst, props), {
	      value: undefined,
	      defaultValue: undefined,
	      children: '' + inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	        didWarnValDefaultVal = true;
	      }
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    var initialValue = value;
	
	    // Only bother fetching default value if we're going to use it
	    if (value == null) {
	      var defaultValue = props.defaultValue;
	      // TODO (yungsters): Remove support for children content in <textarea>.
	      var children = props.children;
	      if (children != null) {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
	        }
	        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
	        if (Array.isArray(children)) {
	          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
	          children = children[0];
	        }
	
	        defaultValue = '' + children;
	      }
	      if (defaultValue == null) {
	        defaultValue = '';
	      }
	      initialValue = defaultValue;
	    }
	
	    inst._wrapperState = {
	      initialValue: '' + initialValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	      if (props.defaultValue == null) {
	        node.defaultValue = newValue;
	      }
	    }
	    if (props.defaultValue != null) {
	      node.defaultValue = props.defaultValue;
	    }
	  },
	
	  postMountWrapper: function postMountWrapper(inst) {
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Warning: node.value may be the empty string at this point (IE11) if placeholder is set.
	    node.value = node.textContent; // Detach value from defaultValue
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactComponentEnvironment = __webpack_require__(118);
	var ReactInstanceMap = __webpack_require__(119);
	var ReactInstrumentation = __webpack_require__(62);
	var ReactMultiChildUpdateTypes = __webpack_require__(92);
	
	var ReactCurrentOwner = __webpack_require__(10);
	var ReactReconciler = __webpack_require__(59);
	var ReactChildReconciler = __webpack_require__(120);
	
	var emptyFunction = __webpack_require__(12);
	var flattenChildren = __webpack_require__(128);
	var invariant = __webpack_require__(8);
	
	/**
	 * Make an update for markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function makeInsertMarkup(markup, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for moving an existing element to another index.
	 *
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function makeMove(child, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: ReactReconciler.getHostNode(child),
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for removing an element at an index.
	 *
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function makeRemove(child, node) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: node,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the markup of a node.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function makeSetMarkup(markup) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the text content.
	 *
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function makeTextContent(textContent) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    content: textContent,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Push an update, if any, onto the queue. Creates a new queue if none is
	 * passed and always returns the queue. Mutative.
	 */
	function enqueue(queue, update) {
	  if (update) {
	    queue = queue || [];
	    queue.push(update);
	  }
	  return queue;
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue(inst, updateQueue) {
	  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
	}
	
	var setChildrenForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  var getDebugID = function getDebugID(inst) {
	    if (!inst._debugID) {
	      // Check for ART-like instances. TODO: This is silly/gross.
	      var internal;
	      if (internal = ReactInstanceMap.get(inst)) {
	        inst = internal;
	      }
	    }
	    return inst._debugID;
	  };
	  setChildrenForInstrumentation = function setChildrenForInstrumentation(children) {
	    var debugID = getDebugID(this);
	    // TODO: React Native empty components are also multichild.
	    // This means they still get into this method but don't have _debugID.
	    if (debugID !== 0) {
	      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
	        return children[key]._debugID;
	      }) : []);
	    }
	  };
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function _reconcilerInstantiateChildren(nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        var selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function _reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
	      var nextChildren;
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          return nextChildren;
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	      return nextChildren;
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function mountChildren(nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          var selfDebugID = 0;
	          if (process.env.NODE_ENV !== 'production') {
	            selfDebugID = getDebugID(this);
	          }
	          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, children);
	      }
	
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function updateTextContent(nextContent) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      // Set new text content.
	      var updates = [makeTextContent(nextContent)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function updateMarkup(nextMarkup) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      var updates = [makeSetMarkup(nextMarkup)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function updateChildren(nextNestedChildrenElements, transaction, context) {
	      // Hook used by React ART
	      this._updateChildren(nextNestedChildrenElements, transaction, context);
	    },
	
	    /**
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function _updateChildren(nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var removedNodes = {};
	      var mountImages = [];
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var updates = null;
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var nextIndex = 0;
	      var lastIndex = 0;
	      // `nextMountIndex` will increment for each newly mounted child.
	      var nextMountIndex = 0;
	      var lastPlacedNode = null;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            // The `removedNodes` loop below will actually remove the child.
	          }
	          // The child must be instantiated before it's mounted.
	          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
	          nextMountIndex++;
	        }
	        nextIndex++;
	        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
	      }
	      // Remove children that are no longer present.
	      for (name in removedNodes) {
	        if (removedNodes.hasOwnProperty(name)) {
	          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
	        }
	      }
	      if (updates) {
	        processQueue(this, updates);
	      }
	      this._renderedChildren = nextChildren;
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, nextChildren);
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted. It does not actually perform any
	     * backend operations.
	     *
	     * @internal
	     */
	    unmountChildren: function unmountChildren(safely) {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren, safely);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function moveChild(child, afterNode, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        return makeMove(child, afterNode, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function createChild(child, afterNode, mountImage) {
	      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function removeChild(child, node) {
	      return makeRemove(child, node);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildAtIndex: function _mountChildAtIndex(child, mountImage, afterNode, index, transaction, context) {
	      child._mountIndex = index;
	      return this.createChild(child, afterNode, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function _unmountChild(child, node) {
	      var update = this.removeChild(child, node);
	      child._mountIndex = null;
	      return update;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkup: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function injectEnvironment(environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
	      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 119 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function remove(key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function get(key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function has(key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function set(key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(59);
	
	var instantiateReactComponent = __webpack_require__(121);
	var KeyEscapeUtils = __webpack_require__(16);
	var shouldUpdateReactComponent = __webpack_require__(125);
	var traverseAllChildren = __webpack_require__(14);
	var warning = __webpack_require__(11);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(28);
	}
	
	function instantiateChild(childInstances, child, name, selfDebugID) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    if (!ReactComponentTreeHook) {
	      ReactComponentTreeHook = __webpack_require__(28);
	    }
	    if (!keyUnique) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	    }
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, true);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function instantiateChildren(nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
	  ) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	
	    if (process.env.NODE_ENV !== 'production') {
	      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
	        return instantiateChild(childInsts, child, name, selfDebugID);
	      }, childInstances);
	    } else {
	      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    }
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
	  ) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return;
	    }
	    var name;
	    var prevChild;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	          ReactReconciler.unmountComponent(prevChild, false);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, true);
	        nextChildren[name] = nextChildInstance;
	        // Creating mount image now ensures refs are resolved in right order
	        // (see https://github.com/facebook/react/pull/7101 for explanation).
	        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
	        mountImages.push(nextChildMountImage);
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        prevChild = prevChildren[name];
	        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	        ReactReconciler.unmountComponent(prevChild, false);
	      }
	    }
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function unmountChildren(renderedChildren, safely) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild, safely);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var ReactCompositeComponent = __webpack_require__(122);
	var ReactEmptyComponent = __webpack_require__(126);
	var ReactHostComponent = __webpack_require__(127);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function ReactCompositeComponentWrapper(element) {
	  this.construct(element);
	};
	_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	var nextDebugID = 1;
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {boolean} shouldHaveDebugID
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, shouldHaveDebugID) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = ReactEmptyComponent.create(instantiateReactComponent);
	  } else if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : _typeof(element.type), getDeclarationErrorAddendum(element._owner)) : _prodInvariant('130', element.type == null ? element.type : _typeof(element.type), getDeclarationErrorAddendum(element._owner)) : void 0;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactHostComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	
	      // We renamed this. Allow the old name for compat. :(
	      if (!instance.getHostNode) {
	        instance.getHostNode = instance.getNativeNode;
	      }
	    } else {
	      instance = new ReactCompositeComponentWrapper(element);
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactHostComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : _prodInvariant('131', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : void 0;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
	  }
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._debugID = shouldHaveDebugID ? nextDebugID++ : 0;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var ReactComponentEnvironment = __webpack_require__(118);
	var ReactCurrentOwner = __webpack_require__(10);
	var ReactElement = __webpack_require__(9);
	var ReactErrorUtils = __webpack_require__(46);
	var ReactInstanceMap = __webpack_require__(119);
	var ReactInstrumentation = __webpack_require__(62);
	var ReactNodeTypes = __webpack_require__(123);
	var ReactPropTypeLocations = __webpack_require__(22);
	var ReactReconciler = __webpack_require__(59);
	
	var checkReactTypeSpec = __webpack_require__(29);
	var emptyObject = __webpack_require__(19);
	var invariant = __webpack_require__(8);
	var shallowEqual = __webpack_require__(124);
	var shouldUpdateReactComponent = __webpack_require__(125);
	var warning = __webpack_require__(11);
	
	var CompositeTypes = {
	  ImpureClass: 0,
	  PureClass: 1,
	  StatelessFunctional: 2
	};
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  var element = Component(this.props, this.context, this.updater);
	  warnIfInvalidElement(Component, element);
	  return element;
	};
	
	function warnIfInvalidElement(Component, element) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || ReactElement.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	}
	
	function invokeComponentDidMountWithTimer() {
	  var publicInstance = this._instance;
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidMount');
	  }
	  publicInstance.componentDidMount();
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidMount');
	  }
	}
	
	function invokeComponentDidUpdateWithTimer(prevProps, prevState, prevContext) {
	  var publicInstance = this._instance;
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidUpdate');
	  }
	  publicInstance.componentDidUpdate(prevProps, prevState, prevContext);
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidUpdate');
	  }
	}
	
	function shouldConstruct(Component) {
	  return !!(Component.prototype && Component.prototype.isReactComponent);
	}
	
	function isPureComponent(Component) {
	  return !!(Component.prototype && Component.prototype.isPureReactComponent);
	}
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function construct(element) {
	    this._currentElement = element;
	    this._rootNodeID = 0;
	    this._compositeType = null;
	    this._instance = null;
	    this._hostParent = null;
	    this._hostContainerInfo = null;
	
	    // See ReactUpdateQueue
	    this._updateBatchNumber = null;
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedNodeType = null;
	    this._renderedComponent = null;
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	
	    // ComponentWillUnmount shall only be called once
	    this._calledComponentWillUnmount = false;
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._warnedAboutRefsInRender = false;
	    }
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} hostParent
	   * @param {?object} hostContainerInfo
	   * @param {?object} context
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var publicProps = this._currentElement.props;
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    var updateQueue = transaction.getUpdateQueue();
	
	    // Initialize the public class
	    var doConstruct = shouldConstruct(Component);
	    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
	    var renderedElement;
	
	    // Support functional components
	    if (!doConstruct && (inst == null || inst.render == null)) {
	      renderedElement = inst;
	      warnIfInvalidElement(Component, renderedElement);
	      !(inst === null || inst === false || ReactElement.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
	      inst = new StatelessComponent(Component);
	      this._compositeType = CompositeTypes.StatelessFunctional;
	    } else {
	      if (isPureComponent(Component)) {
	        this._compositeType = CompositeTypes.PureClass;
	      } else {
	        this._compositeType = CompositeTypes.ImpureClass;
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
	      }
	
	      var propsMutated = inst.props !== publicProps;
	      var componentName = Component.displayName || Component.name || 'Component';
	
	      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = updateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    var markup;
	    if (inst.unstable_handleError) {
	      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } else {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	
	    if (inst.componentDidMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(invokeComponentDidMountWithTimer, this);
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	    }
	
	    return markup;
	  },
	
	  _constructComponent: function _constructComponent(doConstruct, publicProps, publicContext, updateQueue) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactCurrentOwner.current = this;
	      try {
	        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	    }
	  },
	
	  _constructComponentWithoutOwner: function _constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue) {
	    var Component = this._currentElement.type;
	    var instanceOrElement;
	    if (doConstruct) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'ctor');
	        }
	      }
	      instanceOrElement = new Component(publicProps, publicContext, updateQueue);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'ctor');
	        }
	      }
	    } else {
	      // This can still be an instance in case of factory components
	      // but we'll count this as time spent rendering as the more common case.
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
	        }
	      }
	      instanceOrElement = Component(publicProps, publicContext, updateQueue);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
	        }
	      }
	    }
	    return instanceOrElement;
	  },
	
	  performInitialMountWithErrorHandling: function performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var markup;
	    var checkpoint = transaction.checkpoint();
	    try {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } catch (e) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onError();
	        }
	      }
	      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
	      transaction.rollback(checkpoint);
	      this._instance.unstable_handleError(e);
	      if (this._pendingStateQueue) {
	        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
	      }
	      checkpoint = transaction.checkpoint();
	
	      this._renderedComponent.unmountComponent(true);
	      transaction.rollback(checkpoint);
	
	      // Try again - we've informed the component about the error, so they can render an error message this time.
	      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	    return markup;
	  },
	
	  performInitialMount: function performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var inst = this._instance;
	    if (inst.componentWillMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillMount');
	        }
	      }
	      inst.componentWillMount();
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillMount');
	        }
	      }
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    var nodeType = ReactNodeTypes.getType(renderedElement);
	    this._renderedNodeType = nodeType;
	    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	    );
	    this._renderedComponent = child;
	
	    var selfDebugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      selfDebugID = this._debugID;
	    }
	    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), selfDebugID);
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, child._debugID !== 0 ? [child._debugID] : []);
	      }
	    }
	
	    return markup;
	  },
	
	  getHostNode: function getHostNode() {
	    return ReactReconciler.getHostNode(this._renderedComponent);
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent(safely) {
	    if (!this._renderedComponent) {
	      return;
	    }
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
	      inst._calledComponentWillUnmount = true;
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUnmount');
	        }
	      }
	      if (safely) {
	        var name = this.getName() + '.componentWillUnmount()';
	        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
	      } else {
	        inst.componentWillUnmount();
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUnmount');
	        }
	      }
	    }
	
	    if (this._renderedComponent) {
	      ReactReconciler.unmountComponent(this._renderedComponent, safely);
	      this._renderedNodeType = null;
	      this._renderedComponent = null;
	      this._instance = null;
	    }
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = 0;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function _maskContext(context) {
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    var maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function _processContext(context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkContextTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function _processChildContext(currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onBeginProcessingChildContext();
	    }
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onEndProcessingChildContext();
	    }
	    if (childContext) {
	      !(_typeof(Component.childContextTypes) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkContextTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
	      }
	      return _assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Assert that the context types are valid
	   *
	   * @param {object} typeSpecs Map of context field to a ReactPropType
	   * @param {object} values Runtime values that need to be type-checked
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkContextTypes: function _checkContextTypes(typeSpecs, values, location) {
	    checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
	  },
	
	  receiveComponent: function receiveComponent(nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
	    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    } else {
	      this._updateBatchNumber = null;
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    var willReceive = false;
	    var nextContext;
	
	    // Determine if the context has changed or not
	    if (this._context === nextUnmaskedContext) {
	      nextContext = inst.context;
	    } else {
	      nextContext = this._processContext(nextUnmaskedContext);
	      willReceive = true;
	    }
	
	    var prevProps = prevParentElement.props;
	    var nextProps = nextParentElement.props;
	
	    // Not a simple state update but a props update
	    if (prevParentElement !== nextParentElement) {
	      willReceive = true;
	    }
	
	    // An update here will schedule an update but immediately set
	    // _pendingStateQueue which will ensure that any state updates gets
	    // immediately reconciled instead of waiting for the next batch.
	    if (willReceive && inst.componentWillReceiveProps) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
	        }
	      }
	      inst.componentWillReceiveProps(nextProps, nextContext);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
	        }
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	    var shouldUpdate = true;
	
	    if (!this._pendingForceUpdate) {
	      if (inst.shouldComponentUpdate) {
	        if (process.env.NODE_ENV !== 'production') {
	          if (this._debugID !== 0) {
	            ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
	          }
	        }
	        shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	        if (process.env.NODE_ENV !== 'production') {
	          if (this._debugID !== 0) {
	            ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
	          }
	        }
	      } else {
	        if (this._compositeType === CompositeTypes.PureClass) {
	          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
	        }
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
	    }
	
	    this._updateBatchNumber = null;
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function _processPendingState(props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = _assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function _performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUpdate');
	        }
	      }
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUpdate');
	        }
	      }
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(invokeComponentDidUpdateWithTimer.bind(this, prevProps, prevState, prevContext), this);
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	      }
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function _updateRenderedComponent(transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
	      ReactReconciler.unmountComponent(prevComponentInstance, false);
	
	      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
	      this._renderedNodeType = nodeType;
	      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	      );
	      this._renderedComponent = child;
	
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = this._debugID;
	      }
	      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), selfDebugID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onSetChildren(this._debugID, child._debugID !== 0 ? [child._debugID] : []);
	        }
	      }
	
	      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
	    }
	  },
	
	  /**
	   * Overridden in shallow rendering.
	   *
	   * @protected
	   */
	  _replaceNodeWithMarkup: function _replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance) {
	    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function _renderValidatedComponentWithoutOwnerOrContext() {
	    var inst = this._instance;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
	      }
	    }
	    var renderedComponent = inst.render();
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (renderedComponent === undefined && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }
	
	    return renderedComponent;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function _renderValidatedComponent() {
	    var renderedComponent;
	    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
	      ReactCurrentOwner.current = this;
	      try {
	        renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    return renderedComponent;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function attachRef(ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function detachRef(ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function getName() {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function getPublicInstance() {
	    var inst = this._instance;
	    if (this._compositeType === CompositeTypes.StatelessFunctional) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	var ReactCompositeComponent = {
	
	  Mixin: ReactCompositeComponentMixin
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNodeTypes
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactElement = __webpack_require__(9);
	
	var invariant = __webpack_require__(8);
	
	var ReactNodeTypes = {
	  HOST: 0,
	  COMPOSITE: 1,
	  EMPTY: 2,
	
	  getType: function getType(node) {
	    if (node === null || node === false) {
	      return ReactNodeTypes.EMPTY;
	    } else if (ReactElement.isValidElement(node)) {
	      if (typeof node.type === 'function') {
	        return ReactNodeTypes.COMPOSITE;
	      } else {
	        return ReactNodeTypes.HOST;
	      }
	    }
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
	  }
	};
	
	module.exports = ReactNodeTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 124 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */
	
	/*eslint-disable no-self-compare */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }
	
	  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 125 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement);
	  var nextType = typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement);
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 126 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */
	
	'use strict';
	
	var emptyComponentFactory;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponentFactory: function injectEmptyComponentFactory(factory) {
	    emptyComponentFactory = factory;
	  }
	};
	
	var ReactEmptyComponent = {
	  create: function create(instantiate) {
	    return emptyComponentFactory(instantiate);
	  }
	};
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactHostComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var invariant = __webpack_require__(8);
	
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around host tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactHostComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function injectGenericComponentClass(componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function injectTextComponentClass(componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function injectComponentClasses(componentClasses) {
	    _assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a host internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
	  return new genericComponentClass(element);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactHostComponent = {
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactHostComponentInjection
	};
	
	module.exports = ReactHostComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var KeyEscapeUtils = __webpack_require__(16);
	var traverseAllChildren = __webpack_require__(14);
	var warning = __webpack_require__(11);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(28);
	}
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 * @param {number=} selfDebugID Optional debugID of the current internal instance.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
	  // We found a component instance.
	  if (traverseContext && (typeof traverseContext === 'undefined' ? 'undefined' : _typeof(traverseContext)) === 'object') {
	    var result = traverseContext;
	    var keyUnique = result[name] === undefined;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!ReactComponentTreeHook) {
	        ReactComponentTreeHook = __webpack_require__(28);
	      }
	      if (!keyUnique) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	      }
	    }
	    if (keyUnique && child != null) {
	      result[name] = child;
	    }
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children, selfDebugID) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	
	  if (process.env.NODE_ENV !== 'production') {
	    traverseAllChildren(children, function (traverseContext, child, name) {
	      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
	    }, result);
	  } else {
	    traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  }
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var PooledClass = __webpack_require__(6);
	var Transaction = __webpack_require__(69);
	var ReactInstrumentation = __webpack_require__(62);
	var ReactServerUpdateQueue = __webpack_require__(130);
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	var noopCallbackQueue = {
	  enqueue: function enqueue() {}
	};
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.useCreateElement = false;
	  this.updateQueue = new ReactServerUpdateQueue(this);
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return noopCallbackQueue;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function getUpdateQueue() {
	    return this.updateQueue;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {},
	
	  checkpoint: function checkpoint() {},
	
	  rollback: function rollback() {}
	};
	
	_assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerUpdateQueue
	 * 
	 */
	
	'use strict';
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var ReactUpdateQueue = __webpack_require__(131);
	var Transaction = __webpack_require__(69);
	var warning = __webpack_require__(11);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the update queue used for server rendering.
	 * It delegates to ReactUpdateQueue while server rendering is in progress and
	 * switches to ReactNoopUpdateQueue after the transaction has completed.
	 * @class ReactServerUpdateQueue
	 * @param {Transaction} transaction
	 */
	
	var ReactServerUpdateQueue = function () {
	  /* :: transaction: Transaction; */
	
	  function ReactServerUpdateQueue(transaction) {
	    _classCallCheck(this, ReactServerUpdateQueue);
	
	    this.transaction = transaction;
	  }
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	
	  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
	    return false;
	  };
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
	    }
	  };
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
	    } else {
	      warnNoop(publicInstance, 'forceUpdate');
	    }
	  };
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} completeState Next state.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
	    } else {
	      warnNoop(publicInstance, 'replaceState');
	    }
	  };
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} partialState Next partial state to be merged with state.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
	    } else {
	      warnNoop(publicInstance, 'setState');
	    }
	  };
	
	  return ReactServerUpdateQueue;
	}();
	
	module.exports = ReactServerUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactCurrentOwner = __webpack_require__(10);
	var ReactInstanceMap = __webpack_require__(119);
	var ReactInstrumentation = __webpack_require__(62);
	var ReactUpdates = __webpack_require__(56);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function formatUnexpectedArgument(arg) {
	  var type = typeof arg === 'undefined' ? 'undefined' : _typeof(arg);
	  if (type !== 'object') {
	    return type;
	  }
	  var displayName = arg.constructor && arg.constructor.name || type;
	  var keys = Object.keys(arg);
	  if (keys.length > 0 && keys.length < 20) {
	    return displayName + ' (keys: ' + keys.join(', ') + ')';
	  }
	  return displayName;
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var ctor = publicInstance.constructor;
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @param {string} callerName Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback, callerName) {
	    ReactUpdateQueue.validateCallback(callback, callerName);
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function enqueueCallbackInternal(internalInstance, callback) {
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onSetState();
	      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
	    }
	
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueElementInternal: function enqueueElementInternal(internalInstance, nextElement, nextContext) {
	    internalInstance._pendingElement = nextElement;
	    // TODO: introduce _pendingContext instead of setting it directly.
	    internalInstance._context = nextContext;
	    enqueueUpdate(internalInstance);
	  },
	
	  validateCallback: function validateCallback(callback, callerName) {
	    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var emptyFunction = __webpack_require__(12);
	var warning = __webpack_require__(11);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    current: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function updatedAncestorInfo(oldInfo, tag, instance) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.current = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function isTagValidWithParent(tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function findInvalidAncestorForTag(tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function findOwnerStack(instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    do {
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function validateDOMNesting(childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      var tagDisplayName = childTag;
	      if (childTag !== '#text') {
	        tagDisplayName = '<' + childTag + '>';
	      }
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>. ' + 'See %s.%s', tagDisplayName, ancestorTag, ownerInfo, info) : void 0;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
	      }
	    }
	  };
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMEmptyComponent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var DOMLazyTree = __webpack_require__(82);
	var ReactDOMComponentTree = __webpack_require__(36);
	
	var ReactDOMEmptyComponent = function ReactDOMEmptyComponent(instantiate) {
	  // ReactCompositeComponent uses this:
	  this._currentElement = null;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	  this._hostContainerInfo = null;
	  this._domID = 0;
	};
	_assign(ReactDOMEmptyComponent.prototype, {
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    var domID = hostContainerInfo._idCounter++;
	    this._domID = domID;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var nodeValue = ' react-empty: ' + this._domID + ' ';
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var node = ownerDocument.createComment(nodeValue);
	      ReactDOMComponentTree.precacheNode(this, node);
	      return DOMLazyTree(node);
	    } else {
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd insert a comment node, but since this is a situation
	        // where React won't take over (static pages), we can simply return
	        // nothing.
	        return '';
	      }
	      return '<!--' + nodeValue + '-->';
	    }
	  },
	  receiveComponent: function receiveComponent() {},
	  getHostNode: function getHostNode() {
	    return ReactDOMComponentTree.getNodeFromInstance(this);
	  },
	  unmountComponent: function unmountComponent() {
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});
	
	module.exports = ReactDOMEmptyComponent;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTreeTraversal
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
	    depthB++;
	  }
	
	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = instA._hostParent;
	    depthA--;
	  }
	
	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = instB._hostParent;
	    depthB--;
	  }
	
	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB) {
	      return instA;
	    }
	    instA = instA._hostParent;
	    instB = instB._hostParent;
	  }
	  return null;
	}
	
	/**
	 * Return if A is an ancestor of B.
	 */
	function isAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	
	  while (instB) {
	    if (instB === instA) {
	      return true;
	    }
	    instB = instB._hostParent;
	  }
	  return false;
	}
	
	/**
	 * Return the parent instance of the passed-in instance.
	 */
	function getParentInstance(inst) {
	  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
	
	  return inst._hostParent;
	}
	
	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = inst._hostParent;
	  }
	  var i;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], false, arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], true, arg);
	  }
	}
	
	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (from && from !== common) {
	    pathFrom.push(from);
	    from = from._hostParent;
	  }
	  var pathTo = [];
	  while (to && to !== common) {
	    pathTo.push(to);
	    to = to._hostParent;
	  }
	  var i;
	  for (i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], true, argFrom);
	  }
	  for (i = pathTo.length; i-- > 0;) {
	    fn(pathTo[i], false, argTo);
	  }
	}
	
	module.exports = {
	  isAncestor: isAncestor,
	  getLowestCommonAncestor: getLowestCommonAncestor,
	  getParentInstance: getParentInstance,
	  traverseTwoPhase: traverseTwoPhase,
	  traverseEnterLeave: traverseEnterLeave
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var DOMChildrenOperations = __webpack_require__(81);
	var DOMLazyTree = __webpack_require__(82);
	var ReactDOMComponentTree = __webpack_require__(36);
	
	var escapeTextContentForBrowser = __webpack_require__(87);
	var invariant = __webpack_require__(8);
	var validateDOMNesting = __webpack_require__(132);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings between comment nodes so that they
	 * can undergo the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function ReactDOMTextComponent(text) {
	  // TODO: This is really a ReactText (ReactNode), not a ReactElement
	  this._currentElement = text;
	  this._stringText = '' + text;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	
	  // Properties
	  this._domID = 0;
	  this._mountIndex = 0;
	  this._closingComment = null;
	  this._commentNodes = null;
	};
	
	_assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo != null) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting('#text', this, parentInfo);
	      }
	    }
	
	    var domID = hostContainerInfo._idCounter++;
	    var openingValue = ' react-text: ' + domID + ' ';
	    var closingValue = ' /react-text ';
	    this._domID = domID;
	    this._hostParent = hostParent;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var openingComment = ownerDocument.createComment(openingValue);
	      var closingComment = ownerDocument.createComment(closingValue);
	      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
	      if (this._stringText) {
	        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
	      }
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
	      ReactDOMComponentTree.precacheNode(this, openingComment);
	      this._closingComment = closingComment;
	      return lazyTree;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this between comment nodes for the reasons stated
	        // above, but since this is a situation where React won't take over
	        // (static pages), we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function receiveComponent(nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var commentNodes = this.getHostNode();
	        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
	      }
	    }
	  },
	
	  getHostNode: function getHostNode() {
	    var hostNode = this._commentNodes;
	    if (hostNode) {
	      return hostNode;
	    }
	    if (!this._closingComment) {
	      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
	      var node = openingComment.nextSibling;
	      while (true) {
	        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
	        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
	          this._closingComment = node;
	          break;
	        }
	        node = node.nextSibling;
	      }
	    }
	    hostNode = [this._hostNode, this._closingComment];
	    this._commentNodes = hostNode;
	    return hostNode;
	  },
	
	  unmountComponent: function unmountComponent() {
	    this._closingComment = null;
	    this._commentNodes = null;
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var ReactUpdates = __webpack_require__(56);
	var Transaction = __webpack_require__(69);
	
	var emptyFunction = __webpack_require__(12);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function close() {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function batchedUpdates(callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var EventListener = __webpack_require__(138);
	var ExecutionEnvironment = __webpack_require__(49);
	var PooledClass = __webpack_require__(6);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactUpdates = __webpack_require__(56);
	
	var getEventTarget = __webpack_require__(70);
	var getUnboundedScrollPosition = __webpack_require__(139);
	
	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findParent(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst._hostParent) {
	    inst = inst._hostParent;
	  }
	  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
	  var container = rootNode.parentNode;
	  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	_assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function destructor() {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
	  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = ancestor && findParent(ancestor);
	  } while (ancestor);
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function setHandleTopLevel(handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function setEnabled(enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function isEnabled() {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function monitorScrollValue(refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function dispatchEvent(topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @typechecks
	 */
	
	var emptyFunction = __webpack_require__(12);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 139 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(37);
	var EventPluginHub = __webpack_require__(43);
	var EventPluginUtils = __webpack_require__(45);
	var ReactComponentEnvironment = __webpack_require__(118);
	var ReactClass = __webpack_require__(21);
	var ReactEmptyComponent = __webpack_require__(126);
	var ReactBrowserEventEmitter = __webpack_require__(107);
	var ReactHostComponent = __webpack_require__(127);
	var ReactUpdates = __webpack_require__(56);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventPluginUtils: EventPluginUtils.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  HostComponent: ReactHostComponent.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var CallbackQueue = __webpack_require__(57);
	var PooledClass = __webpack_require__(6);
	var ReactBrowserEventEmitter = __webpack_require__(107);
	var ReactInputSelection = __webpack_require__(142);
	var ReactInstrumentation = __webpack_require__(62);
	var Transaction = __webpack_require__(69);
	var ReactUpdateQueue = __webpack_require__(131);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function initialize() {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function close(previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function initialize() {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function close() {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(useCreateElement) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactDOMTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return this.reactMountReady;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function getUpdateQueue() {
	    return ReactUpdateQueue;
	  },
	
	  /**
	   * Save current transaction state -- if the return value from this method is
	   * passed to `rollback`, the transaction will be reset to that state.
	   */
	  checkpoint: function checkpoint() {
	    // reactMountReady is the our only stateful wrapper
	    return this.reactMountReady.checkpoint();
	  },
	
	  rollback: function rollback(checkpoint) {
	    this.reactMountReady.rollback(checkpoint);
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	_assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(143);
	
	var containsNode = __webpack_require__(145);
	var focusNode = __webpack_require__(96);
	var getActiveElement = __webpack_require__(148);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function hasSelectionCapabilities(elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function getSelectionInformation() {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function restoreSelection(priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function getSelection(input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function setSelection(input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (end === undefined) {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(49);
	
	var getNodeForCharacterOffset = __webpack_require__(144);
	var getTextContentAccessor = __webpack_require__(51);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (offsets.end === undefined) {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 144 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	var isTextNode = __webpack_require__(146);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var isNode = __webpack_require__(147);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 147 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 148 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 149 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */
	
	'use strict';
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	// We use attributes for everything SVG so let's avoid some duplication and run
	// code instead.
	// The following are all specified in the HTML config already so we exclude here.
	// - class (as className)
	// - color
	// - height
	// - id
	// - lang
	// - max
	// - media
	// - method
	// - min
	// - name
	// - style
	// - target
	// - type
	// - width
	var ATTRS = {
	  accentHeight: 'accent-height',
	  accumulate: 0,
	  additive: 0,
	  alignmentBaseline: 'alignment-baseline',
	  allowReorder: 'allowReorder',
	  alphabetic: 0,
	  amplitude: 0,
	  arabicForm: 'arabic-form',
	  ascent: 0,
	  attributeName: 'attributeName',
	  attributeType: 'attributeType',
	  autoReverse: 'autoReverse',
	  azimuth: 0,
	  baseFrequency: 'baseFrequency',
	  baseProfile: 'baseProfile',
	  baselineShift: 'baseline-shift',
	  bbox: 0,
	  begin: 0,
	  bias: 0,
	  by: 0,
	  calcMode: 'calcMode',
	  capHeight: 'cap-height',
	  clip: 0,
	  clipPath: 'clip-path',
	  clipRule: 'clip-rule',
	  clipPathUnits: 'clipPathUnits',
	  colorInterpolation: 'color-interpolation',
	  colorInterpolationFilters: 'color-interpolation-filters',
	  colorProfile: 'color-profile',
	  colorRendering: 'color-rendering',
	  contentScriptType: 'contentScriptType',
	  contentStyleType: 'contentStyleType',
	  cursor: 0,
	  cx: 0,
	  cy: 0,
	  d: 0,
	  decelerate: 0,
	  descent: 0,
	  diffuseConstant: 'diffuseConstant',
	  direction: 0,
	  display: 0,
	  divisor: 0,
	  dominantBaseline: 'dominant-baseline',
	  dur: 0,
	  dx: 0,
	  dy: 0,
	  edgeMode: 'edgeMode',
	  elevation: 0,
	  enableBackground: 'enable-background',
	  end: 0,
	  exponent: 0,
	  externalResourcesRequired: 'externalResourcesRequired',
	  fill: 0,
	  fillOpacity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  filter: 0,
	  filterRes: 'filterRes',
	  filterUnits: 'filterUnits',
	  floodColor: 'flood-color',
	  floodOpacity: 'flood-opacity',
	  focusable: 0,
	  fontFamily: 'font-family',
	  fontSize: 'font-size',
	  fontSizeAdjust: 'font-size-adjust',
	  fontStretch: 'font-stretch',
	  fontStyle: 'font-style',
	  fontVariant: 'font-variant',
	  fontWeight: 'font-weight',
	  format: 0,
	  from: 0,
	  fx: 0,
	  fy: 0,
	  g1: 0,
	  g2: 0,
	  glyphName: 'glyph-name',
	  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	  glyphOrientationVertical: 'glyph-orientation-vertical',
	  glyphRef: 'glyphRef',
	  gradientTransform: 'gradientTransform',
	  gradientUnits: 'gradientUnits',
	  hanging: 0,
	  horizAdvX: 'horiz-adv-x',
	  horizOriginX: 'horiz-origin-x',
	  ideographic: 0,
	  imageRendering: 'image-rendering',
	  'in': 0,
	  in2: 0,
	  intercept: 0,
	  k: 0,
	  k1: 0,
	  k2: 0,
	  k3: 0,
	  k4: 0,
	  kernelMatrix: 'kernelMatrix',
	  kernelUnitLength: 'kernelUnitLength',
	  kerning: 0,
	  keyPoints: 'keyPoints',
	  keySplines: 'keySplines',
	  keyTimes: 'keyTimes',
	  lengthAdjust: 'lengthAdjust',
	  letterSpacing: 'letter-spacing',
	  lightingColor: 'lighting-color',
	  limitingConeAngle: 'limitingConeAngle',
	  local: 0,
	  markerEnd: 'marker-end',
	  markerMid: 'marker-mid',
	  markerStart: 'marker-start',
	  markerHeight: 'markerHeight',
	  markerUnits: 'markerUnits',
	  markerWidth: 'markerWidth',
	  mask: 0,
	  maskContentUnits: 'maskContentUnits',
	  maskUnits: 'maskUnits',
	  mathematical: 0,
	  mode: 0,
	  numOctaves: 'numOctaves',
	  offset: 0,
	  opacity: 0,
	  operator: 0,
	  order: 0,
	  orient: 0,
	  orientation: 0,
	  origin: 0,
	  overflow: 0,
	  overlinePosition: 'overline-position',
	  overlineThickness: 'overline-thickness',
	  paintOrder: 'paint-order',
	  panose1: 'panose-1',
	  pathLength: 'pathLength',
	  patternContentUnits: 'patternContentUnits',
	  patternTransform: 'patternTransform',
	  patternUnits: 'patternUnits',
	  pointerEvents: 'pointer-events',
	  points: 0,
	  pointsAtX: 'pointsAtX',
	  pointsAtY: 'pointsAtY',
	  pointsAtZ: 'pointsAtZ',
	  preserveAlpha: 'preserveAlpha',
	  preserveAspectRatio: 'preserveAspectRatio',
	  primitiveUnits: 'primitiveUnits',
	  r: 0,
	  radius: 0,
	  refX: 'refX',
	  refY: 'refY',
	  renderingIntent: 'rendering-intent',
	  repeatCount: 'repeatCount',
	  repeatDur: 'repeatDur',
	  requiredExtensions: 'requiredExtensions',
	  requiredFeatures: 'requiredFeatures',
	  restart: 0,
	  result: 0,
	  rotate: 0,
	  rx: 0,
	  ry: 0,
	  scale: 0,
	  seed: 0,
	  shapeRendering: 'shape-rendering',
	  slope: 0,
	  spacing: 0,
	  specularConstant: 'specularConstant',
	  specularExponent: 'specularExponent',
	  speed: 0,
	  spreadMethod: 'spreadMethod',
	  startOffset: 'startOffset',
	  stdDeviation: 'stdDeviation',
	  stemh: 0,
	  stemv: 0,
	  stitchTiles: 'stitchTiles',
	  stopColor: 'stop-color',
	  stopOpacity: 'stop-opacity',
	  strikethroughPosition: 'strikethrough-position',
	  strikethroughThickness: 'strikethrough-thickness',
	  string: 0,
	  stroke: 0,
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeMiterlimit: 'stroke-miterlimit',
	  strokeOpacity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  surfaceScale: 'surfaceScale',
	  systemLanguage: 'systemLanguage',
	  tableValues: 'tableValues',
	  targetX: 'targetX',
	  targetY: 'targetY',
	  textAnchor: 'text-anchor',
	  textDecoration: 'text-decoration',
	  textRendering: 'text-rendering',
	  textLength: 'textLength',
	  to: 0,
	  transform: 0,
	  u1: 0,
	  u2: 0,
	  underlinePosition: 'underline-position',
	  underlineThickness: 'underline-thickness',
	  unicode: 0,
	  unicodeBidi: 'unicode-bidi',
	  unicodeRange: 'unicode-range',
	  unitsPerEm: 'units-per-em',
	  vAlphabetic: 'v-alphabetic',
	  vHanging: 'v-hanging',
	  vIdeographic: 'v-ideographic',
	  vMathematical: 'v-mathematical',
	  values: 0,
	  vectorEffect: 'vector-effect',
	  version: 0,
	  vertAdvY: 'vert-adv-y',
	  vertOriginX: 'vert-origin-x',
	  vertOriginY: 'vert-origin-y',
	  viewBox: 'viewBox',
	  viewTarget: 'viewTarget',
	  visibility: 0,
	  widths: 0,
	  wordSpacing: 'word-spacing',
	  writingMode: 'writing-mode',
	  x: 0,
	  xHeight: 'x-height',
	  x1: 0,
	  x2: 0,
	  xChannelSelector: 'xChannelSelector',
	  xlinkActuate: 'xlink:actuate',
	  xlinkArcrole: 'xlink:arcrole',
	  xlinkHref: 'xlink:href',
	  xlinkRole: 'xlink:role',
	  xlinkShow: 'xlink:show',
	  xlinkTitle: 'xlink:title',
	  xlinkType: 'xlink:type',
	  xmlBase: 'xml:base',
	  xmlns: 0,
	  xmlnsXlink: 'xmlns:xlink',
	  xmlLang: 'xml:lang',
	  xmlSpace: 'xml:space',
	  y: 0,
	  y1: 0,
	  y2: 0,
	  yChannelSelector: 'yChannelSelector',
	  z: 0,
	  zoomAndPan: 'zoomAndPan'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {},
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {}
	};
	
	Object.keys(ATTRS).forEach(function (key) {
	  SVGDOMPropertyConfig.Properties[key] = 0;
	  if (ATTRS[key]) {
	    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
	  }
	});
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(41);
	var EventPropagators = __webpack_require__(42);
	var ExecutionEnvironment = __webpack_require__(49);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactInputSelection = __webpack_require__(142);
	var SyntheticEvent = __webpack_require__(53);
	
	var getActiveElement = __webpack_require__(148);
	var isTextInputElement = __webpack_require__(72);
	var keyOf = __webpack_require__(25);
	var shallowEqual = __webpack_require__(124);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	var activeElement = null;
	var activeElementInst = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events. See #3639.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement = targetNode;
	          activeElementInst = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementInst = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function didPutListener(inst, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var EventConstants = __webpack_require__(41);
	var EventListener = __webpack_require__(138);
	var EventPropagators = __webpack_require__(42);
	var ReactDOMComponentTree = __webpack_require__(36);
	var SyntheticAnimationEvent = __webpack_require__(152);
	var SyntheticClipboardEvent = __webpack_require__(153);
	var SyntheticEvent = __webpack_require__(53);
	var SyntheticFocusEvent = __webpack_require__(154);
	var SyntheticKeyboardEvent = __webpack_require__(155);
	var SyntheticMouseEvent = __webpack_require__(75);
	var SyntheticDragEvent = __webpack_require__(158);
	var SyntheticTouchEvent = __webpack_require__(159);
	var SyntheticTransitionEvent = __webpack_require__(160);
	var SyntheticUIEvent = __webpack_require__(76);
	var SyntheticWheelEvent = __webpack_require__(161);
	
	var emptyFunction = __webpack_require__(12);
	var getEventCharCode = __webpack_require__(156);
	var invariant = __webpack_require__(8);
	var keyOf = __webpack_require__(25);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  animationEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationEnd: true }),
	      captured: keyOf({ onAnimationEndCapture: true })
	    }
	  },
	  animationIteration: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationIteration: true }),
	      captured: keyOf({ onAnimationIterationCapture: true })
	    }
	  },
	  animationStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationStart: true }),
	      captured: keyOf({ onAnimationStartCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  invalid: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInvalid: true }),
	      captured: keyOf({ onInvalidCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  transitionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTransitionEnd: true }),
	      captured: keyOf({ onTransitionEndCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};
	
	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topAnimationEnd: eventTypes.animationEnd,
	  topAnimationIteration: eventTypes.animationIteration,
	  topAnimationStart: eventTypes.animationStart,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topInvalid: eventTypes.invalid,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topTransitionEnd: eventTypes.transitionEnd,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};
	
	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}
	
	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};
	
	function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	}
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topInvalid:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topAnimationEnd:
	      case topLevelTypes.topAnimationIteration:
	      case topLevelTypes.topAnimationStart:
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case topLevelTypes.topTransitionEnd:
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function didPutListener(inst, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var key = getDictionaryKey(inst);
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      if (!onClickListeners[key]) {
	        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function willDeleteListener(inst, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      var key = getDictionaryKey(inst);
	      onClickListeners[key].remove();
	      delete onClickListeners[key];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticAnimationEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(53);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var AnimationEventInterface = {
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
	
	module.exports = SyntheticAnimationEvent;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(53);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function clipboardData(event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(76);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(76);
	
	var getEventCharCode = __webpack_require__(156);
	var getEventKey = __webpack_require__(157);
	var getEventModifierState = __webpack_require__(78);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function charCode(event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function keyCode(event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function which(event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 156 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(156);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(75);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(76);
	
	var getEventModifierState = __webpack_require__(78);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTransitionEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(53);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var TransitionEventInterface = {
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
	
	module.exports = SyntheticTransitionEvent;

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(75);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function deltaX(event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function deltaY(event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var DOMLazyTree = __webpack_require__(82);
	var DOMProperty = __webpack_require__(37);
	var ReactBrowserEventEmitter = __webpack_require__(107);
	var ReactCurrentOwner = __webpack_require__(10);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactDOMContainerInfo = __webpack_require__(163);
	var ReactDOMFeatureFlags = __webpack_require__(164);
	var ReactElement = __webpack_require__(9);
	var ReactFeatureFlags = __webpack_require__(58);
	var ReactInstanceMap = __webpack_require__(119);
	var ReactInstrumentation = __webpack_require__(62);
	var ReactMarkupChecksum = __webpack_require__(165);
	var ReactReconciler = __webpack_require__(59);
	var ReactUpdateQueue = __webpack_require__(131);
	var ReactUpdates = __webpack_require__(56);
	
	var emptyObject = __webpack_require__(19);
	var instantiateReactComponent = __webpack_require__(121);
	var invariant = __webpack_require__(8);
	var setInnerHTML = __webpack_require__(84);
	var shouldUpdateReactComponent = __webpack_require__(125);
	var warning = __webpack_require__(11);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var instancesByReactRootID = {};
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
	  var markerName;
	  if (ReactFeatureFlags.logTopLevelRenders) {
	    var wrappedElement = wrapperInstance._currentElement.props;
	    var type = wrappedElement.type;
	    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
	    console.time(markerName);
	  }
	
	  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
	  );
	
	  if (markerName) {
	    console.timeEnd(markerName);
	  }
	
	  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
	  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */
	  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container, safely) {
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onBeginFlush();
	  }
	  ReactReconciler.unmountComponent(instance, safely);
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onEndFlush();
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  if (rootEl) {
	    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
	    return !!(inst && inst._hostParent);
	  }
	}
	
	/**
	 * True if the supplied DOM node is a React DOM element and
	 * it has been rendered by another copy of React.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM has been rendered by another copy of React
	 * @internal
	 */
	function nodeIsRenderedByOtherInstance(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
	}
	
	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
	}
	
	/**
	 * True if the supplied DOM node is a valid React node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid React DOM node.
	 * @internal
	 */
	function isReactNode(node) {
	  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
	}
	
	function getHostRootInstanceInContainer(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
	  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
	}
	
	function getTopLevelWrapperInContainer(container) {
	  var root = getHostRootInstanceInContainer(container);
	  return root ? root._hostContainerInfo._topLevelWrapper : null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var topLevelRootCounter = 1;
	var TopLevelWrapper = function TopLevelWrapper() {
	  this.rootID = topLevelRootCounter++;
	};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /**
	   * Used by devtools. The keys are not important.
	   */
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function scrollMonitor(container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function _updateRootComponent(prevComponent, nextElement, nextContext, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    return prevComponent;
	  },
	
	  /**
	   * Render a new component into the DOM. Hooked by hooks!
	   *
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	    var componentInstance = instantiateReactComponent(nextElement, false);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
	
	    var wrapperID = componentInstance._instance.rootID;
	    instancesByReactRootID[wrapperID] = componentInstance;
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
	    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
	
	    var nextWrappedElement = ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
	
	    var nextContext;
	    if (parentComponent) {
	      var parentInst = ReactInstanceMap.get(parentComponent);
	      nextContext = parentInst._processChildContext(parentInst._context);
	    } else {
	      nextContext = emptyObject;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function render(nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function unmountComponentAtNode(container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	    if (!prevComponent) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }
	
	      return false;
	    }
	    delete instancesByReactRootID[prevComponent._instance.rootID];
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
	    return true;
	  },
	
	  _mountImageIntoNode: function _mountImageIntoNode(markup, container, instance, shouldReuseMarkup, transaction) {
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        ReactDOMComponentTree.precacheNode(instance, rootElement);
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      DOMLazyTree.insertTreeBefore(container, markup, null);
	    } else {
	      setInnerHTML(container, markup);
	      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
	      if (hostNode._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation(hostNode._debugID, 'mount', markup.toString());
	      }
	    }
	  }
	};
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMContainerInfo
	 */
	
	'use strict';
	
	var validateDOMNesting = __webpack_require__(132);
	
	var DOC_NODE_TYPE = 9;
	
	function ReactDOMContainerInfo(topLevelWrapper, node) {
	  var info = {
	    _topLevelWrapper: topLevelWrapper,
	    _idCounter: 1,
	    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
	    _node: node,
	    _tag: node ? node.nodeName.toLowerCase() : null,
	    _namespaceURI: node ? node.namespaceURI : null
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
	  }
	  return info;
	}
	
	module.exports = ReactDOMContainerInfo;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 164 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: true
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(166);
	
	var TAG_END = /\/?>/;
	var COMMENT_START = /^<\!\-\-/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function addChecksumToMarkup(markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags, comments and self-closing tags)
	    if (COMMENT_START.test(markup)) {
	      return markup;
	    } else {
	      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	    }
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function canReuseMarkup(markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 166 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 * 
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    var n = Math.min(i + 4096, m);
	    for (; i < n; i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactCurrentOwner = __webpack_require__(10);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactInstanceMap = __webpack_require__(119);
	
	var getHostComponentFromComposite = __webpack_require__(168);
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	
	  var inst = ReactInstanceMap.get(componentOrElement);
	  if (inst) {
	    inst = getHostComponentFromComposite(inst);
	    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
	  }
	
	  if (typeof componentOrElement.render === 'function') {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
	  }
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getHostComponentFromComposite
	 */
	
	'use strict';
	
	var ReactNodeTypes = __webpack_require__(123);
	
	function getHostComponentFromComposite(inst) {
	  var type;
	
	  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
	    inst = inst._renderedComponent;
	  }
	
	  if (type === ReactNodeTypes.HOST) {
	    return inst._renderedComponent;
	  } else if (type === ReactNodeTypes.EMPTY) {
	    return null;
	  }
	}
	
	module.exports = getHostComponentFromComposite;

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/
	
	'use strict';
	
	var ReactMount = __webpack_require__(162);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMUnknownPropertyHook
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(37);
	var EventPluginRegistry = __webpack_require__(44);
	var ReactComponentTreeHook = __webpack_require__(28);
	
	var warning = __webpack_require__(11);
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true,
	
	    autoFocus: true,
	    defaultValue: true,
	    valueLink: true,
	    defaultChecked: true,
	    checkedLink: true,
	    innerHTML: true,
	    suppressContentEditableWarning: true,
	    onFocusIn: true,
	    onFocusOut: true
	  };
	  var warnedProperties = {};
	
	  var validateProperty = function validateProperty(tagName, name, debugID) {
	    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
	      return true;
	    }
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return true;
	    }
	    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
	      return true;
	    }
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
	
	    if (standardName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else if (registrationName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else {
	      // We were unable to guess which prop the user intended.
	      // It is likely that the user was just blindly spreading/forwarding props
	      // Components should be careful to only render valid props/attributes.
	      // Warning will be invoked in warnUnknownProperties to allow grouping.
	      return false;
	    }
	  };
	}
	
	var warnUnknownProperties = function warnUnknownProperties(debugID, element) {
	  var unknownProps = [];
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      unknownProps.push(key);
	    }
	  }
	
	  var unknownPropString = unknownProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (unknownProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (unknownProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	};
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	  warnUnknownProperties(debugID, element);
	}
	
	var ReactDOMUnknownPropertyHook = {
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMUnknownPropertyHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMNullInputValuePropHook
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(28);
	
	var warning = __webpack_require__(11);
	
	var didWarnValueNull = false;
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
	    return;
	  }
	  if (element.props != null && element.props.value === null && !didWarnValueNull) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	
	    didWarnValueNull = true;
	  }
	}
	
	var ReactDOMNullInputValuePropHook = {
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMNullInputValuePropHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.connect = exports.Provider = undefined;
	
	var _Provider = __webpack_require__(173);
	
	var _Provider2 = _interopRequireDefault(_Provider);
	
	var _connect = __webpack_require__(176);
	
	var _connect2 = _interopRequireDefault(_connect);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}
	
	exports.Provider = _Provider2["default"];
	exports.connect = _connect2["default"];

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	exports["default"] = undefined;
	
	var _react = __webpack_require__(1);
	
	var _storeShape = __webpack_require__(174);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _warning = __webpack_require__(175);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var didWarnAboutReceivingStore = false;
	function warnAboutReceivingStore() {
	  if (didWarnAboutReceivingStore) {
	    return;
	  }
	  didWarnAboutReceivingStore = true;
	
	  (0, _warning2["default"])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
	}
	
	var Provider = function (_Component) {
	  _inherits(Provider, _Component);
	
	  Provider.prototype.getChildContext = function getChildContext() {
	    return { store: this.store };
	  };
	
	  function Provider(props, context) {
	    _classCallCheck(this, Provider);
	
	    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	    _this.store = props.store;
	    return _this;
	  }
	
	  Provider.prototype.render = function render() {
	    var children = this.props.children;
	
	    return _react.Children.only(children);
	  };
	
	  return Provider;
	}(_react.Component);
	
	exports["default"] = Provider;
	
	if (process.env.NODE_ENV !== 'production') {
	  Provider.prototype.componentWillReceiveProps = function (nextProps) {
	    var store = this.store;
	    var nextStore = nextProps.store;
	
	    if (store !== nextStore) {
	      warnAboutReceivingStore();
	    }
	  };
	}
	
	Provider.propTypes = {
	  store: _storeShape2["default"].isRequired,
	  children: _react.PropTypes.element.isRequired
	};
	Provider.childContextTypes = {
	  store: _storeShape2["default"].isRequired
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(1);
	
	exports["default"] = _react.PropTypes.shape({
	  subscribe: _react.PropTypes.func.isRequired,
	  dispatch: _react.PropTypes.func.isRequired,
	  getState: _react.PropTypes.func.isRequired
	});

/***/ },
/* 175 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that you can use this stack
	    // to find the callsite that caused this warning to fire.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.__esModule = true;
	exports["default"] = connect;
	
	var _react = __webpack_require__(1);
	
	var _storeShape = __webpack_require__(174);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _shallowEqual = __webpack_require__(177);
	
	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);
	
	var _wrapActionCreators = __webpack_require__(178);
	
	var _wrapActionCreators2 = _interopRequireDefault(_wrapActionCreators);
	
	var _warning = __webpack_require__(175);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _isPlainObject = __webpack_require__(181);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _hoistNonReactStatics = __webpack_require__(194);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _invariant = __webpack_require__(195);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var defaultMapStateToProps = function defaultMapStateToProps(state) {
	  return {};
	}; // eslint-disable-line no-unused-vars
	var defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {
	  return { dispatch: dispatch };
	};
	var defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {
	  return _extends({}, parentProps, stateProps, dispatchProps);
	};
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	var errorObject = { value: null };
	function tryCatch(fn, ctx) {
	  try {
	    return fn.apply(ctx);
	  } catch (e) {
	    errorObject.value = e;
	    return errorObject;
	  }
	}
	
	// Helps track hot reloading.
	var nextVersion = 0;
	
	function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
	  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
	
	  var shouldSubscribe = Boolean(mapStateToProps);
	  var mapState = mapStateToProps || defaultMapStateToProps;
	
	  var mapDispatch = undefined;
	  if (typeof mapDispatchToProps === 'function') {
	    mapDispatch = mapDispatchToProps;
	  } else if (!mapDispatchToProps) {
	    mapDispatch = defaultMapDispatchToProps;
	  } else {
	    mapDispatch = (0, _wrapActionCreators2["default"])(mapDispatchToProps);
	  }
	
	  var finalMergeProps = mergeProps || defaultMergeProps;
	  var _options$pure = options.pure;
	  var pure = _options$pure === undefined ? true : _options$pure;
	  var _options$withRef = options.withRef;
	  var withRef = _options$withRef === undefined ? false : _options$withRef;
	
	  var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps;
	
	  // Helps track hot reloading.
	  var version = nextVersion++;
	
	  return function wrapWithConnect(WrappedComponent) {
	    var connectDisplayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';
	
	    function checkStateShape(props, methodName) {
	      if (!(0, _isPlainObject2["default"])(props)) {
	        (0, _warning2["default"])(methodName + '() in ' + connectDisplayName + ' must return a plain object. ' + ('Instead received ' + props + '.'));
	      }
	    }
	
	    function computeMergedProps(stateProps, dispatchProps, parentProps) {
	      var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);
	      if (process.env.NODE_ENV !== 'production') {
	        checkStateShape(mergedProps, 'mergeProps');
	      }
	      return mergedProps;
	    }
	
	    var Connect = function (_Component) {
	      _inherits(Connect, _Component);
	
	      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
	        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;
	      };
	
	      function Connect(props, context) {
	        _classCallCheck(this, Connect);
	
	        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	        _this.version = version;
	        _this.store = props.store || context.store;
	
	        (0, _invariant2["default"])(_this.store, 'Could not find "store" in either the context or ' + ('props of "' + connectDisplayName + '". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass "store" as a prop to "' + connectDisplayName + '".'));
	
	        var storeState = _this.store.getState();
	        _this.state = { storeState: storeState };
	        _this.clearCache();
	        return _this;
	      }
	
	      Connect.prototype.computeStateProps = function computeStateProps(store, props) {
	        if (!this.finalMapStateToProps) {
	          return this.configureFinalMapState(store, props);
	        }
	
	        var state = store.getState();
	        var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(stateProps, 'mapStateToProps');
	        }
	        return stateProps;
	      };
	
	      Connect.prototype.configureFinalMapState = function configureFinalMapState(store, props) {
	        var mappedState = mapState(store.getState(), props);
	        var isFactory = typeof mappedState === 'function';
	
	        this.finalMapStateToProps = isFactory ? mappedState : mapState;
	        this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeStateProps(store, props);
	        }
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(mappedState, 'mapStateToProps');
	        }
	        return mappedState;
	      };
	
	      Connect.prototype.computeDispatchProps = function computeDispatchProps(store, props) {
	        if (!this.finalMapDispatchToProps) {
	          return this.configureFinalMapDispatch(store, props);
	        }
	
	        var dispatch = store.dispatch;
	
	        var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(dispatchProps, 'mapDispatchToProps');
	        }
	        return dispatchProps;
	      };
	
	      Connect.prototype.configureFinalMapDispatch = function configureFinalMapDispatch(store, props) {
	        var mappedDispatch = mapDispatch(store.dispatch, props);
	        var isFactory = typeof mappedDispatch === 'function';
	
	        this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;
	        this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeDispatchProps(store, props);
	        }
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(mappedDispatch, 'mapDispatchToProps');
	        }
	        return mappedDispatch;
	      };
	
	      Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {
	        var nextStateProps = this.computeStateProps(this.store, this.props);
	        if (this.stateProps && (0, _shallowEqual2["default"])(nextStateProps, this.stateProps)) {
	          return false;
	        }
	
	        this.stateProps = nextStateProps;
	        return true;
	      };
	
	      Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {
	        var nextDispatchProps = this.computeDispatchProps(this.store, this.props);
	        if (this.dispatchProps && (0, _shallowEqual2["default"])(nextDispatchProps, this.dispatchProps)) {
	          return false;
	        }
	
	        this.dispatchProps = nextDispatchProps;
	        return true;
	      };
	
	      Connect.prototype.updateMergedPropsIfNeeded = function updateMergedPropsIfNeeded() {
	        var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);
	        if (this.mergedProps && checkMergedEquals && (0, _shallowEqual2["default"])(nextMergedProps, this.mergedProps)) {
	          return false;
	        }
	
	        this.mergedProps = nextMergedProps;
	        return true;
	      };
	
	      Connect.prototype.isSubscribed = function isSubscribed() {
	        return typeof this.unsubscribe === 'function';
	      };
	
	      Connect.prototype.trySubscribe = function trySubscribe() {
	        if (shouldSubscribe && !this.unsubscribe) {
	          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));
	          this.handleChange();
	        }
	      };
	
	      Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {
	        if (this.unsubscribe) {
	          this.unsubscribe();
	          this.unsubscribe = null;
	        }
	      };
	
	      Connect.prototype.componentDidMount = function componentDidMount() {
	        this.trySubscribe();
	      };
	
	      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        if (!pure || !(0, _shallowEqual2["default"])(nextProps, this.props)) {
	          this.haveOwnPropsChanged = true;
	        }
	      };
	
	      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
	        this.tryUnsubscribe();
	        this.clearCache();
	      };
	
	      Connect.prototype.clearCache = function clearCache() {
	        this.dispatchProps = null;
	        this.stateProps = null;
	        this.mergedProps = null;
	        this.haveOwnPropsChanged = true;
	        this.hasStoreStateChanged = true;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	        this.renderedElement = null;
	        this.finalMapDispatchToProps = null;
	        this.finalMapStateToProps = null;
	      };
	
	      Connect.prototype.handleChange = function handleChange() {
	        if (!this.unsubscribe) {
	          return;
	        }
	
	        var storeState = this.store.getState();
	        var prevStoreState = this.state.storeState;
	        if (pure && prevStoreState === storeState) {
	          return;
	        }
	
	        if (pure && !this.doStatePropsDependOnOwnProps) {
	          var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);
	          if (!haveStatePropsChanged) {
	            return;
	          }
	          if (haveStatePropsChanged === errorObject) {
	            this.statePropsPrecalculationError = errorObject.value;
	          }
	          this.haveStatePropsBeenPrecalculated = true;
	        }
	
	        this.hasStoreStateChanged = true;
	        this.setState({ storeState: storeState });
	      };
	
	      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
	        (0, _invariant2["default"])(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');
	
	        return this.refs.wrappedInstance;
	      };
	
	      Connect.prototype.render = function render() {
	        var haveOwnPropsChanged = this.haveOwnPropsChanged;
	        var hasStoreStateChanged = this.hasStoreStateChanged;
	        var haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated;
	        var statePropsPrecalculationError = this.statePropsPrecalculationError;
	        var renderedElement = this.renderedElement;
	
	        this.haveOwnPropsChanged = false;
	        this.hasStoreStateChanged = false;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	
	        if (statePropsPrecalculationError) {
	          throw statePropsPrecalculationError;
	        }
	
	        var shouldUpdateStateProps = true;
	        var shouldUpdateDispatchProps = true;
	        if (pure && renderedElement) {
	          shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;
	          shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;
	        }
	
	        var haveStatePropsChanged = false;
	        var haveDispatchPropsChanged = false;
	        if (haveStatePropsBeenPrecalculated) {
	          haveStatePropsChanged = true;
	        } else if (shouldUpdateStateProps) {
	          haveStatePropsChanged = this.updateStatePropsIfNeeded();
	        }
	        if (shouldUpdateDispatchProps) {
	          haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();
	        }
	
	        var haveMergedPropsChanged = true;
	        if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {
	          haveMergedPropsChanged = this.updateMergedPropsIfNeeded();
	        } else {
	          haveMergedPropsChanged = false;
	        }
	
	        if (!haveMergedPropsChanged && renderedElement) {
	          return renderedElement;
	        }
	
	        if (withRef) {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, _extends({}, this.mergedProps, {
	            ref: 'wrappedInstance'
	          }));
	        } else {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, this.mergedProps);
	        }
	
	        return this.renderedElement;
	      };
	
	      return Connect;
	    }(_react.Component);
	
	    Connect.displayName = connectDisplayName;
	    Connect.WrappedComponent = WrappedComponent;
	    Connect.contextTypes = {
	      store: _storeShape2["default"]
	    };
	    Connect.propTypes = {
	      store: _storeShape2["default"]
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
	        if (this.version === version) {
	          return;
	        }
	
	        // We are hot reloading!
	        this.version = version;
	        this.trySubscribe();
	        this.clearCache();
	      };
	    }
	
	    return (0, _hoistNonReactStatics2["default"])(Connect, WrappedComponent);
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 177 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = shallowEqual;
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var hasOwn = Object.prototype.hasOwnProperty;
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = wrapActionCreators;
	
	var _redux = __webpack_require__(179);
	
	function wrapActionCreators(actionCreators) {
	  return function (dispatch) {
	    return (0, _redux.bindActionCreators)(actionCreators, dispatch);
	  };
	}

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(180);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(189);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(191);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(192);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(193);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(190);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  (0, _warning2['default'])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2['default'];
	exports.combineReducers = _combineReducers2['default'];
	exports.bindActionCreators = _bindActionCreators2['default'];
	exports.applyMiddleware = _applyMiddleware2['default'];
	exports.compose = _compose2['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports['default'] = createStore;
	
	var _isPlainObject = __webpack_require__(181);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(186);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [preloadedState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, preloadedState, enhancer) {
	  var _ref2;
	
	  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = preloadedState;
	    preloadedState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, preloadedState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = preloadedState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing what changed. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2['default'])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	      subscribe: function subscribe(observer) {
	        if ((typeof observer === 'undefined' ? 'undefined' : _typeof(observer)) !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2['default']] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2['default']] = observable, _ref2;
	}

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var getPrototype = __webpack_require__(182),
	    isHostObject = __webpack_require__(184),
	    isObjectLike = __webpack_require__(185);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
	        return false;
	    }
	    var proto = getPrototype(value);
	    if (proto === null) {
	        return true;
	    }
	    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
	}
	
	module.exports = isPlainObject;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var overArg = __webpack_require__(183);
	
	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);
	
	module.exports = getPrototype;

/***/ },
/* 183 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function (arg) {
	    return func(transform(arg));
	  };
	}
	
	module.exports = overArg;

/***/ },
/* 184 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	module.exports = isHostObject;

/***/ },
/* 185 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
	}
	
	module.exports = isObjectLike;

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(187);

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _ponyfill = __webpack_require__(188);
	
	var _ponyfill2 = _interopRequireDefault(_ponyfill);
	
	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var root = undefined; /* global window */
	
	if (typeof global !== 'undefined') {
		root = global;
	} else if (typeof window !== 'undefined') {
		root = window;
	}
	
	var result = (0, _ponyfill2['default'])(root);
	exports['default'] = result;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 188 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports['default'] = symbolObservablePonyfill;
	function symbolObservablePonyfill(root) {
		var result;
		var _Symbol = root.Symbol;
	
		if (typeof _Symbol === 'function') {
			if (_Symbol.observable) {
				result = _Symbol.observable;
			} else {
				result = _Symbol('observable');
				_Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports['default'] = combineReducers;
	
	var _createStore = __webpack_require__(180);
	
	var _isPlainObject = __webpack_require__(181);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(190);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2['default'])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
	  });
	
	  unexpectedKeys.forEach(function (key) {
	    unexpectedKeyCache[key] = true;
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (typeof reducers[key] === 'undefined') {
	        (0, _warning2['default'])('No reducer provided for key "' + key + '"');
	      }
	    }
	
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  if (process.env.NODE_ENV !== 'production') {
	    var unexpectedKeyCache = {};
	  }
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
	      if (warningMessage) {
	        (0, _warning2['default'])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 190 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 191 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	exports['default'] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if ((typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports['default'] = applyMiddleware;
	
	var _compose = __webpack_require__(193);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, preloadedState, enhancer) {
	      var store = createStore(reducer, preloadedState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 193 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  }
	
	  if (funcs.length === 1) {
	    return funcs[0];
	  }
	
	  var last = funcs[funcs.length - 1];
	  var rest = funcs.slice(0, -1);
	  return function () {
	    return rest.reduceRight(function (composed, f) {
	      return f(composed);
	    }, last.apply(undefined, arguments));
	  };
	}

/***/ },
/* 194 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';
	
	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};
	
	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};
	
	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';
	
	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') {
	        // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);
	
	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }
	
	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {}
	            }
	        }
	    }
	
	    return targetComponent;
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 196 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	function createThunkMiddleware(extraArgument) {
	  return function (_ref) {
	    var dispatch = _ref.dispatch;
	    var getState = _ref.getState;
	    return function (next) {
	      return function (action) {
	        if (typeof action === 'function') {
	          return action(dispatch, getState, extraArgument);
	        }
	
	        return next(action);
	      };
	    };
	  };
	}
	
	var thunk = createThunkMiddleware();
	thunk.withExtraArgument = createThunkMiddleware;
	
	exports['default'] = thunk;

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(172);
	
	var _actions = __webpack_require__(198);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var App = function (_Component) {
	  _inherits(App, _Component);
	
	  function App() {
	    _classCallCheck(this, App);
	
	    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));
	  }
	
	  _createClass(App, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      var _props = this.props;
	      var display = _props.display;
	      var dispatch = _props.dispatch;
	
	
	      return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement(
	          'button',
	          { onClick: function onClick() {
	              return dispatch((0, _actions.connectSocket)());
	            } },
	          'Connect'
	        ),
	        _react2.default.createElement('br', null),
	        _react2.default.createElement('br', null),
	        _react2.default.createElement(
	          'button',
	          { onClick: function onClick() {
	              return dispatch((0, _actions.disconnectSocket)());
	            } },
	          'DisConnect'
	        ),
	        _react2.default.createElement('br', null),
	        _react2.default.createElement('br', null),
	        _react2.default.createElement('input', { ref: 'message' }),
	        _react2.default.createElement(
	          'button',
	          { onClick: function onClick() {
	              return dispatch((0, _actions.sendMessage)(_this2.refs.message.value));
	            } },
	          'Send Message'
	        ),
	        _react2.default.createElement(
	          'div',
	          null,
	          display
	        )
	      );
	    }
	  }]);
	
	  return App;
	}(_react.Component);
	
	exports.default = (0, _reactRedux.connect)(function (state) {
	  return {
	    display: state.display
	  };
	})(App);

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.connectSocket = connectSocket;
	exports.disconnectSocket = disconnectSocket;
	exports.receiveMessage = receiveMessage;
	exports.postMessage = postMessage;
	exports.sendMessage = sendMessage;
	
	var _socket = __webpack_require__(199);
	
	var _socket2 = _interopRequireDefault(_socket);
	
	var _constants = __webpack_require__(246);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function connectSocket() {
	  return function (dispatch) {
	    var socket = (0, _socket2.default)();
	    socket.on('result', function (data) {
	      dispatch({
	        type: _constants.UPDATE,
	        name: 'Jason'
	      });
	    });
	    dispatch({
	      type: _constants.CONNECT,
	      socket: socket
	    });
	  };
	}
	
	function disconnectSocket() {
	  return function (dispatch, state) {
	    var socket = state().socket;
	    Object.keys(socket).length > 0 ? socket.disconnect() : null;
	    dispatch({
	      type: _constants.DISCONNECT
	    });
	  };
	}
	
	function receiveMessage(message) {
	  return {
	    type: _constants.RECEIVE_MESSAGE,
	    message: message
	  };
	}
	
	function postMessage(text) {
	  return {
	    type: _constants.POST_MESSAGE,
	    text: text
	  };
	}
	
	function sendMessage(message) {
	  return function (dispatch, state) {
	    var socket = state().socket;
	    socket.emit('message', { message: message });
	  };
	}

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/**
	 * Module dependencies.
	 */
	
	var url = __webpack_require__(200);
	var parser = __webpack_require__(205);
	var Manager = __webpack_require__(213);
	var debug = __webpack_require__(202)('socket.io-client');
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = lookup;
	
	/**
	 * Managers cache.
	 */
	
	var cache = exports.managers = {};
	
	/**
	 * Looks up an existing `Manager` for multiplexing.
	 * If the user summons:
	 *
	 *   `io('http://localhost/a');`
	 *   `io('http://localhost/b');`
	 *
	 * We reuse the existing instance based on same scheme/port/host,
	 * and we initialize sockets for each namespace.
	 *
	 * @api public
	 */
	
	function lookup(uri, opts) {
	  if ((typeof uri === 'undefined' ? 'undefined' : _typeof(uri)) == 'object') {
	    opts = uri;
	    uri = undefined;
	  }
	
	  opts = opts || {};
	
	  var parsed = url(uri);
	  var source = parsed.source;
	  var id = parsed.id;
	  var path = parsed.path;
	  var sameNamespace = cache[id] && path in cache[id].nsps;
	  var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;
	
	  var io;
	
	  if (newConnection) {
	    debug('ignoring socket cache for %s', source);
	    io = Manager(source, opts);
	  } else {
	    if (!cache[id]) {
	      debug('new io instance for %s', source);
	      cache[id] = Manager(source, opts);
	    }
	    io = cache[id];
	  }
	
	  return io.socket(parsed.path);
	}
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = parser.protocol;
	
	/**
	 * `connect`.
	 *
	 * @param {String} uri
	 * @api public
	 */
	
	exports.connect = lookup;
	
	/**
	 * Expose constructors for standalone build.
	 *
	 * @api public
	 */
	
	exports.Manager = __webpack_require__(213);
	exports.Socket = __webpack_require__(239);

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var parseuri = __webpack_require__(201);
	var debug = __webpack_require__(202)('socket.io-client:url');
	
	/**
	 * Module exports.
	 */
	
	module.exports = url;
	
	/**
	 * URL parser.
	 *
	 * @param {String} url
	 * @param {Object} An object meant to mimic window.location.
	 *                 Defaults to window.location.
	 * @api public
	 */
	
	function url(uri, loc) {
	  var obj = uri;
	
	  // default to window.location
	  var loc = loc || global.location;
	  if (null == uri) uri = loc.protocol + '//' + loc.host;
	
	  // relative path support
	  if ('string' == typeof uri) {
	    if ('/' == uri.charAt(0)) {
	      if ('/' == uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.host + uri;
	      }
	    }
	
	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      debug('protocol-less url %s', uri);
	      if ('undefined' != typeof loc) {
	        uri = loc.protocol + '//' + uri;
	      } else {
	        uri = 'https://' + uri;
	      }
	    }
	
	    // parse
	    debug('parse %s', uri);
	    obj = parseuri(uri);
	  }
	
	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = '80';
	    } else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = '443';
	    }
	  }
	
	  obj.path = obj.path || '/';
	
	  var ipv6 = obj.host.indexOf(':') !== -1;
	  var host = ipv6 ? '[' + obj.host + ']' : obj.host;
	
	  // define unique id
	  obj.id = obj.protocol + '://' + host + ':' + obj.port;
	  // define href
	  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : ':' + obj.port);
	
	  return obj;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 201 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */
	
	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
	
	var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
	
	module.exports = function parseuri(str) {
	    var src = str,
	        b = str.indexOf('['),
	        e = str.indexOf(']');
	
	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }
	
	    var m = re.exec(str || ''),
	        uri = {},
	        i = 14;
	
	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }
	
	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }
	
	    return uri;
	};

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(203);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return 'WebkitAppearance' in document.documentElement.style ||
	  // is firebug? http://stackoverflow.com/a/398120/376773
	  window.console && (console.firebug || console.exception && console.table) ||
	  // is firefox >= v31?
	  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function (v) {
	  return JSON.stringify(v);
	};
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function (match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch (e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch (e) {}
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(204);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {}
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}

/***/ },
/* 204 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function (val, options) {
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long ? long(val) : short(val);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function long(ms) {
	  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var debug = __webpack_require__(202)('socket.io-parser');
	var json = __webpack_require__(206);
	var isArray = __webpack_require__(209);
	var Emitter = __webpack_require__(210);
	var binary = __webpack_require__(211);
	var isBuf = __webpack_require__(212);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = 4;
	
	/**
	 * Packet types.
	 *
	 * @api public
	 */
	
	exports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'ACK', 'ERROR', 'BINARY_EVENT', 'BINARY_ACK'];
	
	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */
	
	exports.CONNECT = 0;
	
	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */
	
	exports.DISCONNECT = 1;
	
	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */
	
	exports.EVENT = 2;
	
	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */
	
	exports.ACK = 3;
	
	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */
	
	exports.ERROR = 4;
	
	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */
	
	exports.BINARY_EVENT = 5;
	
	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */
	
	exports.BINARY_ACK = 6;
	
	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */
	
	exports.Encoder = Encoder;
	
	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */
	
	exports.Decoder = Decoder;
	
	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */
	
	function Encoder() {}
	
	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */
	
	Encoder.prototype.encode = function (obj, callback) {
	  debug('encoding packet %j', obj);
	
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    encodeAsBinary(obj, callback);
	  } else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};
	
	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */
	
	function encodeAsString(obj) {
	  var str = '';
	  var nsp = false;
	
	  // first is type
	  str += obj.type;
	
	  // attachments if we have them
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    str += obj.attachments;
	    str += '-';
	  }
	
	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' != obj.nsp) {
	    nsp = true;
	    str += obj.nsp;
	  }
	
	  // immediately followed by the id
	  if (null != obj.id) {
	    if (nsp) {
	      str += ',';
	      nsp = false;
	    }
	    str += obj.id;
	  }
	
	  // json data
	  if (null != obj.data) {
	    if (nsp) str += ',';
	    str += json.stringify(obj.data);
	  }
	
	  debug('encoded %j as %s', obj, str);
	  return str;
	}
	
	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */
	
	function encodeAsBinary(obj, callback) {
	
	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;
	
	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }
	
	  binary.removeBlobs(obj, writeEncoding);
	}
	
	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */
	
	function Decoder() {
	  this.reconstructor = null;
	}
	
	/**
	 * Mix in `Emitter` with Decoder.
	 */
	
	Emitter(Decoder.prototype);
	
	/**
	 * Decodes an ecoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */
	
	Decoder.prototype.add = function (obj) {
	  var packet;
	  if ('string' == typeof obj) {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) {
	      // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);
	
	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments === 0) {
	        this.emit('decoded', packet);
	      }
	    } else {
	      // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  } else if (isBuf(obj) || obj.base64) {
	    // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) {
	        // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  } else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};
	
	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */
	
	function decodeString(str) {
	  var p = {};
	  var i = 0;
	
	  // look up type
	  p.type = Number(str.charAt(0));
	  if (null == exports.types[p.type]) return error();
	
	  // look up attachments if type binary
	  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
	    var buf = '';
	    while (str.charAt(++i) != '-') {
	      buf += str.charAt(i);
	      if (i == str.length) break;
	    }
	    if (buf != Number(buf) || str.charAt(i) != '-') {
	      throw new Error('Illegal attachments');
	    }
	    p.attachments = Number(buf);
	  }
	
	  // look up namespace (if any)
	  if ('/' == str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' == c) break;
	      p.nsp += c;
	      if (i == str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }
	
	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' !== next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i == str.length) break;
	    }
	    p.id = Number(p.id);
	  }
	
	  // look up json data
	  if (str.charAt(++i)) {
	    try {
	      p.data = json.parse(str.substr(i));
	    } catch (e) {
	      return error();
	    }
	  }
	
	  debug('decoded %s as %j', str, p);
	  return p;
	}
	
	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */
	
	Decoder.prototype.destroy = function () {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};
	
	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */
	
	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}
	
	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */
	
	BinaryReconstructor.prototype.takeBinaryData = function (binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length == this.reconPack.attachments) {
	    // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};
	
	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */
	
	BinaryReconstructor.prototype.finishedReconstruction = function () {
	  this.reconPack = null;
	  this.buffers = [];
	};
	
	function error(data) {
	  return {
	    type: exports.ERROR,
	    data: 'parser error'
	  };
	}

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
	;(function () {
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__(208);
	
	  // A set of types used to distinguish objects from primitives.
	  var objectTypes = {
	    "function": true,
	    "object": true
	  };
	
	  // Detect the `exports` object exposed by CommonJS implementations.
	  var freeExports = objectTypes[ false ? "undefined" : _typeof(exports)] && exports && !exports.nodeType && exports;
	
	  // Use the `global` object exposed by Node (including Browserify via
	  // `insert-module-globals`), Narwhal, and Ringo as the default context,
	  // and the `window` object in browsers. Rhino exports a `global` function
	  // instead.
	  var root = objectTypes[typeof window === "undefined" ? "undefined" : _typeof(window)] && window || this,
	      freeGlobal = freeExports && objectTypes[ false ? "undefined" : _typeof(module)] && module && !module.nodeType && (typeof global === "undefined" ? "undefined" : _typeof(global)) == "object" && global;
	
	  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
	    root = freeGlobal;
	  }
	
	  // Public: Initializes JSON 3 using the given `context` object, attaching the
	  // `stringify` and `parse` functions to the specified `exports` object.
	  function runInContext(context, exports) {
	    context || (context = root["Object"]());
	    exports || (exports = root["Object"]());
	
	    // Native constructor aliases.
	    var Number = context["Number"] || root["Number"],
	        String = context["String"] || root["String"],
	        Object = context["Object"] || root["Object"],
	        Date = context["Date"] || root["Date"],
	        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
	        TypeError = context["TypeError"] || root["TypeError"],
	        Math = context["Math"] || root["Math"],
	        nativeJSON = context["JSON"] || root["JSON"];
	
	    // Delegate to the native `stringify` and `parse` implementations.
	    if ((typeof nativeJSON === "undefined" ? "undefined" : _typeof(nativeJSON)) == "object" && nativeJSON) {
	      exports.stringify = nativeJSON.stringify;
	      exports.parse = nativeJSON.parse;
	    }
	
	    // Convenience aliases.
	    var objectProto = Object.prototype,
	        getClass = objectProto.toString,
	        _isProperty,
	        _forEach,
	        undef;
	
	    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	    var isExtended = new Date(-3509827334573292);
	    try {
	      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	      // results for certain dates in Opera >= 10.53.
	      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	      // Safari < 2.0.2 stores the internal millisecond time value correctly,
	      // but clips the values returned by the date methods to the range of
	      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	    } catch (exception) {}
	
	    // Internal: Determines whether the native `JSON.stringify` and `parse`
	    // implementations are spec-compliant. Based on work by Ken Snyder.
	    function has(name) {
	      if (has[name] !== undef) {
	        // Return cached feature test result.
	        return has[name];
	      }
	      var isSupported;
	      if (name == "bug-string-char-index") {
	        // IE <= 7 doesn't support accessing string characters using square
	        // bracket notation. IE 8 only supports this for primitives.
	        isSupported = "a"[0] != "a";
	      } else if (name == "json") {
	        // Indicates whether both `JSON.stringify` and `JSON.parse` are
	        // supported.
	        isSupported = has("json-stringify") && has("json-parse");
	      } else {
	        var value,
	            serialized = "{\"a\":[1,true,false,null,\"\\u0000\\b\\n\\f\\r\\t\"]}";
	        // Test `JSON.stringify`.
	        if (name == "json-stringify") {
	          var stringify = exports.stringify,
	              stringifySupported = typeof stringify == "function" && isExtended;
	          if (stringifySupported) {
	            // A test function object with a custom `toJSON` method.
	            (value = function value() {
	              return 1;
	            }).toJSON = value;
	            try {
	              stringifySupported =
	              // Firefox 3.1b1 and b2 serialize string, number, and boolean
	              // primitives as object literals.
	              stringify(0) === "0" &&
	              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	              // literals.
	              stringify(new Number()) === "0" && stringify(new String()) == '""' &&
	              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	              // does not define a canonical JSON representation (this applies to
	              // objects with `toJSON` properties as well, *unless* they are nested
	              // within an object or array).
	              stringify(getClass) === undef &&
	              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	              // FF 3.1b3 pass this test.
	              stringify(undef) === undef &&
	              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	              // respectively, if the value is omitted entirely.
	              stringify() === undef &&
	              // FF 3.1b1, 2 throw an error if the given value is not a number,
	              // string, array, object, Boolean, or `null` literal. This applies to
	              // objects with custom `toJSON` methods as well, unless they are nested
	              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	              // methods entirely.
	              stringify(value) === "1" && stringify([value]) == "[1]" &&
	              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	              // `"[null]"`.
	              stringify([undef]) == "[null]" &&
	              // YUI 3.0.0b1 fails to serialize `null` literals.
	              stringify(null) == "null" &&
	              // FF 3.1b1, 2 halts serialization if an array contains a function:
	              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	              // elides non-JSON values from objects and arrays, unless they
	              // define custom `toJSON` methods.
	              stringify([undef, getClass, null]) == "[null,null,null]" &&
	              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	              // where character escape codes are expected (e.g., `\b` => `\u0008`).
	              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	              stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	              // serialize extended years.
	              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	              // The milliseconds are optional in ES 5, but required in 5.1.
	              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	              // four-digit years instead of six-digit years. Credits: @Yaffle.
	              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	              // values less than 1000. Credits: @Yaffle.
	              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	            } catch (exception) {
	              stringifySupported = false;
	            }
	          }
	          isSupported = stringifySupported;
	        }
	        // Test `JSON.parse`.
	        if (name == "json-parse") {
	          var parse = exports.parse;
	          if (typeof parse == "function") {
	            try {
	              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	              // Conforming implementations should also coerce the initial argument to
	              // a string prior to parsing.
	              if (parse("0") === 0 && !parse(false)) {
	                // Simple parsing test.
	                value = parse(serialized);
	                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	                if (parseSupported) {
	                  try {
	                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                    parseSupported = !parse('"\t"');
	                  } catch (exception) {}
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                      // certain octal literals.
	                      parseSupported = parse("01") !== 1;
	                    } catch (exception) {}
	                  }
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                      // points. These environments, along with FF 3.1b1 and 2,
	                      // also allow trailing commas in JSON objects and arrays.
	                      parseSupported = parse("1.") !== 1;
	                    } catch (exception) {}
	                  }
	                }
	              }
	            } catch (exception) {
	              parseSupported = false;
	            }
	          }
	          isSupported = parseSupported;
	        }
	      }
	      return has[name] = !!isSupported;
	    }
	
	    if (!has("json")) {
	      // Common `[[Class]]` name aliases.
	      var functionClass = "[object Function]",
	          dateClass = "[object Date]",
	          numberClass = "[object Number]",
	          stringClass = "[object String]",
	          arrayClass = "[object Array]",
	          booleanClass = "[object Boolean]";
	
	      // Detect incomplete support for accessing string characters by index.
	      var charIndexBuggy = has("bug-string-char-index");
	
	      // Define additional utility methods if the `Date` methods are buggy.
	      if (!isExtended) {
	        var floor = Math.floor;
	        // A mapping between the months of the year and the number of days between
	        // January 1st and the first of the respective month.
	        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	        // Internal: Calculates the number of days between the Unix epoch and the
	        // first day of the given month.
	        var getDay = function getDay(year, month) {
	          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	        };
	      }
	
	      // Internal: Determines if a property is a direct property of the given
	      // object. Delegates to the native `Object#hasOwnProperty` method.
	      if (!(_isProperty = objectProto.hasOwnProperty)) {
	        _isProperty = function isProperty(property) {
	          var members = {},
	              constructor;
	          if ((members.__proto__ = null, members.__proto__ = {
	            // The *proto* property cannot be set multiple times in recent
	            // versions of Firefox and SeaMonkey.
	            "toString": 1
	          }, members).toString != getClass) {
	            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	            // supports the mutable *proto* property.
	            _isProperty = function isProperty(property) {
	              // Capture and break the object's prototype chain (see section 8.6.2
	              // of the ES 5.1 spec). The parenthesized expression prevents an
	              // unsafe transformation by the Closure Compiler.
	              var original = this.__proto__,
	                  result = property in (this.__proto__ = null, this);
	              // Restore the original prototype chain.
	              this.__proto__ = original;
	              return result;
	            };
	          } else {
	            // Capture a reference to the top-level `Object` constructor.
	            constructor = members.constructor;
	            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	            // other environments.
	            _isProperty = function isProperty(property) {
	              var parent = (this.constructor || constructor).prototype;
	              return property in this && !(property in parent && this[property] === parent[property]);
	            };
	          }
	          members = null;
	          return _isProperty.call(this, property);
	        };
	      }
	
	      // Internal: Normalizes the `for...in` iteration algorithm across
	      // environments. Each enumerated key is yielded to a `callback` function.
	      _forEach = function forEach(object, callback) {
	        var size = 0,
	            Properties,
	            members,
	            property;
	
	        // Tests for bugs in the current environment's `for...in` algorithm. The
	        // `valueOf` property inherits the non-enumerable flag from
	        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	        (Properties = function Properties() {
	          this.valueOf = 0;
	        }).prototype.valueOf = 0;
	
	        // Iterate over a new instance of the `Properties` class.
	        members = new Properties();
	        for (property in members) {
	          // Ignore all properties inherited from `Object.prototype`.
	          if (_isProperty.call(members, property)) {
	            size++;
	          }
	        }
	        Properties = members = null;
	
	        // Normalize the iteration algorithm.
	        if (!size) {
	          // A list of non-enumerable properties inherited from `Object.prototype`.
	          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	          // properties.
	          _forEach = function forEach(object, callback) {
	            var isFunction = getClass.call(object) == functionClass,
	                property,
	                length;
	            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[_typeof(object.hasOwnProperty)] && object.hasOwnProperty || _isProperty;
	            for (property in object) {
	              // Gecko <= 1.0 enumerates the `prototype` property of functions under
	              // certain conditions; IE does not.
	              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for each non-enumerable property.
	            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property)) {}
	          };
	        } else if (size == 2) {
	          // Safari <= 2.0.4 enumerates shadowed properties twice.
	          _forEach = function forEach(object, callback) {
	            // Create a set of iterated properties.
	            var members = {},
	                isFunction = getClass.call(object) == functionClass,
	                property;
	            for (property in object) {
	              // Store each property name to prevent double enumeration. The
	              // `prototype` property of functions is not enumerated due to cross-
	              // environment inconsistencies.
	              if (!(isFunction && property == "prototype") && !_isProperty.call(members, property) && (members[property] = 1) && _isProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	          };
	        } else {
	          // No bugs detected; use the standard `for...in` algorithm.
	          _forEach = function forEach(object, callback) {
	            var isFunction = getClass.call(object) == functionClass,
	                property,
	                isConstructor;
	            for (property in object) {
	              if (!(isFunction && property == "prototype") && _isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for the `constructor` property due to
	            // cross-environment inconsistencies.
	            if (isConstructor || _isProperty.call(object, property = "constructor")) {
	              callback(property);
	            }
	          };
	        }
	        return _forEach(object, callback);
	      };
	
	      // Public: Serializes a JavaScript `value` as a JSON string. The optional
	      // `filter` argument may specify either a function that alters how object and
	      // array members are serialized, or an array of strings and numbers that
	      // indicates which properties should be serialized. The optional `width`
	      // argument may be either a string or number that specifies the indentation
	      // level of the output.
	      if (!has("json-stringify")) {
	        // Internal: A map of control characters and their escaped equivalents.
	        var Escapes = {
	          92: "\\\\",
	          34: '\\"',
	          8: "\\b",
	          12: "\\f",
	          10: "\\n",
	          13: "\\r",
	          9: "\\t"
	        };
	
	        // Internal: Converts `value` into a zero-padded string such that its
	        // length is at least equal to `width`. The `width` must be <= 6.
	        var leadingZeroes = "000000";
	        var toPaddedString = function toPaddedString(width, value) {
	          // The `|| 0` expression is necessary to work around a bug in
	          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	          return (leadingZeroes + (value || 0)).slice(-width);
	        };
	
	        // Internal: Double-quotes a string `value`, replacing all ASCII control
	        // characters (characters with code unit values between 0 and 31) with
	        // their escaped equivalents. This is an implementation of the
	        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	        var unicodePrefix = "\\u00";
	        var quote = function quote(value) {
	          var result = '"',
	              index = 0,
	              length = value.length,
	              useCharIndex = !charIndexBuggy || length > 10;
	          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
	          for (; index < length; index++) {
	            var charCode = value.charCodeAt(index);
	            // If the character is a control character, append its Unicode or
	            // shorthand escape sequence; otherwise, append the character as-is.
	            switch (charCode) {
	              case 8:case 9:case 10:case 12:case 13:case 34:case 92:
	                result += Escapes[charCode];
	                break;
	              default:
	                if (charCode < 32) {
	                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                  break;
	                }
	                result += useCharIndex ? symbols[index] : value.charAt(index);
	            }
	          }
	          return result + '"';
	        };
	
	        // Internal: Recursively serializes an object. Implements the
	        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	        var serialize = function serialize(property, object, callback, properties, whitespace, indentation, stack) {
	          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	          try {
	            // Necessary for host object support.
	            value = object[property];
	          } catch (exception) {}
	          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
	            className = getClass.call(value);
	            if (className == dateClass && !_isProperty.call(value, "toJSON")) {
	              if (value > -1 / 0 && value < 1 / 0) {
	                // Dates are serialized according to the `Date#toJSON` method
	                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	                // for the ISO 8601 date time string format.
	                if (getDay) {
	                  // Manually compute the year, month, date, hours, minutes,
	                  // seconds, and milliseconds if the `getUTC*` methods are
	                  // buggy. Adapted from @Yaffle's `date-shim` project.
	                  date = floor(value / 864e5);
	                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) {}
	                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) {}
	                  date = 1 + date - getDay(year, month);
	                  // The `time` value specifies the time within the day (see ES
	                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                  // to compute `A modulo B`, as the `%` operator does not
	                  // correspond to the `modulo` operation for negative numbers.
	                  time = (value % 864e5 + 864e5) % 864e5;
	                  // The hours, minutes, seconds, and milliseconds are obtained by
	                  // decomposing the time within the day. See section 15.9.1.10.
	                  hours = floor(time / 36e5) % 24;
	                  minutes = floor(time / 6e4) % 60;
	                  seconds = floor(time / 1e3) % 60;
	                  milliseconds = time % 1e3;
	                } else {
	                  year = value.getUTCFullYear();
	                  month = value.getUTCMonth();
	                  date = value.getUTCDate();
	                  hours = value.getUTCHours();
	                  minutes = value.getUTCMinutes();
	                  seconds = value.getUTCSeconds();
	                  milliseconds = value.getUTCMilliseconds();
	                }
	                // Serialize extended years correctly.
	                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                // Months, dates, hours, minutes, and seconds should have two
	                // digits; milliseconds should have three.
	                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                // Milliseconds are optional in ES 5.0, but required in 5.1.
	                "." + toPaddedString(3, milliseconds) + "Z";
	              } else {
	                value = null;
	              }
	            } else if (typeof value.toJSON == "function" && (className != numberClass && className != stringClass && className != arrayClass || _isProperty.call(value, "toJSON"))) {
	              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	              // ignores all `toJSON` methods on these objects unless they are
	              // defined directly on an instance.
	              value = value.toJSON(property);
	            }
	          }
	          if (callback) {
	            // If a replacement function was provided, call it to obtain the value
	            // for serialization.
	            value = callback.call(object, property, value);
	          }
	          if (value === null) {
	            return "null";
	          }
	          className = getClass.call(value);
	          if (className == booleanClass) {
	            // Booleans are represented literally.
	            return "" + value;
	          } else if (className == numberClass) {
	            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	            // `"null"`.
	            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	          } else if (className == stringClass) {
	            // Strings are double-quoted and escaped.
	            return quote("" + value);
	          }
	          // Recursively serialize objects and arrays.
	          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object") {
	            // Check for cyclic structures. This is a linear search; performance
	            // is inversely proportional to the number of unique nested objects.
	            for (length = stack.length; length--;) {
	              if (stack[length] === value) {
	                // Cyclic structures cannot be serialized by `JSON.stringify`.
	                throw TypeError();
	              }
	            }
	            // Add the object to the stack of traversed objects.
	            stack.push(value);
	            results = [];
	            // Save the current indentation level and indent one additional level.
	            prefix = indentation;
	            indentation += whitespace;
	            if (className == arrayClass) {
	              // Recursively serialize array elements.
	              for (index = 0, length = value.length; index < length; index++) {
	                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	                results.push(element === undef ? "null" : element);
	              }
	              result = results.length ? whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : "[" + results.join(",") + "]" : "[]";
	            } else {
	              // Recursively serialize object members. Members are selected from
	              // either a user-specified list of property names, or the object
	              // itself.
	              _forEach(properties || value, function (property) {
	                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	                if (element !== undef) {
	                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                  // is not the empty string, let `member` {quote(property) + ":"}
	                  // be the concatenation of `member` and the `space` character."
	                  // The "`space` character" refers to the literal space
	                  // character, not the `space` {width} argument provided to
	                  // `JSON.stringify`.
	                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	                }
	              });
	              result = results.length ? whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : "{" + results.join(",") + "}" : "{}";
	            }
	            // Remove the object from the traversed object stack.
	            stack.pop();
	            return result;
	          }
	        };
	
	        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	        exports.stringify = function (source, filter, width) {
	          var whitespace, callback, properties, className;
	          if (objectTypes[typeof filter === "undefined" ? "undefined" : _typeof(filter)] && filter) {
	            if ((className = getClass.call(filter)) == functionClass) {
	              callback = filter;
	            } else if (className == arrayClass) {
	              // Convert the property names array into a makeshift set.
	              properties = {};
	              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], (className = getClass.call(value), className == stringClass || className == numberClass) && (properties[value] = 1)) {}
	            }
	          }
	          if (width) {
	            if ((className = getClass.call(width)) == numberClass) {
	              // Convert the `width` to an integer and create a string containing
	              // `width` number of space characters.
	              if ((width -= width % 1) > 0) {
	                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ") {}
	              }
	            } else if (className == stringClass) {
	              whitespace = width.length <= 10 ? width : width.slice(0, 10);
	            }
	          }
	          // Opera <= 7.54u2 discards the values associated with empty string keys
	          // (`""`) only if they are used directly within an object member list
	          // (e.g., `!("" in { "": 1})`).
	          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	        };
	      }
	
	      // Public: Parses a JSON source string.
	      if (!has("json-parse")) {
	        var fromCharCode = String.fromCharCode;
	
	        // Internal: A map of escaped control characters and their unescaped
	        // equivalents.
	        var Unescapes = {
	          92: "\\",
	          34: '"',
	          47: "/",
	          98: "\b",
	          116: "\t",
	          110: "\n",
	          102: "\f",
	          114: "\r"
	        };
	
	        // Internal: Stores the parser state.
	        var Index, Source;
	
	        // Internal: Resets the parser state and throws a `SyntaxError`.
	        var abort = function abort() {
	          Index = Source = null;
	          throw SyntaxError();
	        };
	
	        // Internal: Returns the next token, or `"$"` if the parser has reached
	        // the end of the source string. A token may be a string, number, `null`
	        // literal, or Boolean literal.
	        var lex = function lex() {
	          var source = Source,
	              length = source.length,
	              value,
	              begin,
	              position,
	              isSigned,
	              charCode;
	          while (Index < length) {
	            charCode = source.charCodeAt(Index);
	            switch (charCode) {
	              case 9:case 10:case 13:case 32:
	                // Skip whitespace tokens, including tabs, carriage returns, line
	                // feeds, and space characters.
	                Index++;
	                break;
	              case 123:case 125:case 91:case 93:case 58:case 44:
	                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	                // the current position.
	                value = charIndexBuggy ? source.charAt(Index) : source[Index];
	                Index++;
	                return value;
	              case 34:
	                // `"` delimits a JSON string; advance to the next character and
	                // begin parsing the string. String tokens are prefixed with the
	                // sentinel `@` character to distinguish them from punctuators and
	                // end-of-string tokens.
	                for (value = "@", Index++; Index < length;) {
	                  charCode = source.charCodeAt(Index);
	                  if (charCode < 32) {
	                    // Unescaped ASCII control characters (those with a code unit
	                    // less than the space character) are not permitted.
	                    abort();
	                  } else if (charCode == 92) {
	                    // A reverse solidus (`\`) marks the beginning of an escaped
	                    // control character (including `"`, `\`, and `/`) or Unicode
	                    // escape sequence.
	                    charCode = source.charCodeAt(++Index);
	                    switch (charCode) {
	                      case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:
	                        // Revive escaped control characters.
	                        value += Unescapes[charCode];
	                        Index++;
	                        break;
	                      case 117:
	                        // `\u` marks the beginning of a Unicode escape sequence.
	                        // Advance to the first character and validate the
	                        // four-digit code point.
	                        begin = ++Index;
	                        for (position = Index + 4; Index < position; Index++) {
	                          charCode = source.charCodeAt(Index);
	                          // A valid sequence comprises four hexdigits (case-
	                          // insensitive) that form a single hexadecimal value.
	                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                            // Invalid Unicode escape sequence.
	                            abort();
	                          }
	                        }
	                        // Revive the escaped character.
	                        value += fromCharCode("0x" + source.slice(begin, Index));
	                        break;
	                      default:
	                        // Invalid escape sequence.
	                        abort();
	                    }
	                  } else {
	                    if (charCode == 34) {
	                      // An unescaped double-quote character marks the end of the
	                      // string.
	                      break;
	                    }
	                    charCode = source.charCodeAt(Index);
	                    begin = Index;
	                    // Optimize for the common case where a string is valid.
	                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                      charCode = source.charCodeAt(++Index);
	                    }
	                    // Append the string as-is.
	                    value += source.slice(begin, Index);
	                  }
	                }
	                if (source.charCodeAt(Index) == 34) {
	                  // Advance to the next character and return the revived string.
	                  Index++;
	                  return value;
	                }
	                // Unterminated string.
	                abort();
	              default:
	                // Parse numbers and literals.
	                begin = Index;
	                // Advance past the negative sign, if one is specified.
	                if (charCode == 45) {
	                  isSigned = true;
	                  charCode = source.charCodeAt(++Index);
	                }
	                // Parse an integer or floating-point value.
	                if (charCode >= 48 && charCode <= 57) {
	                  // Leading zeroes are interpreted as octal literals.
	                  if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {
	                    // Illegal octal literal.
	                    abort();
	                  }
	                  isSigned = false;
	                  // Parse the integer component.
	                  for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++) {}
	                  // Floats cannot contain a leading decimal point; however, this
	                  // case is already accounted for by the parser.
	                  if (source.charCodeAt(Index) == 46) {
	                    position = ++Index;
	                    // Parse the decimal component.
	                    for (; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
	                    if (position == Index) {
	                      // Illegal trailing decimal.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Parse exponents. The `e` denoting the exponent is
	                  // case-insensitive.
	                  charCode = source.charCodeAt(Index);
	                  if (charCode == 101 || charCode == 69) {
	                    charCode = source.charCodeAt(++Index);
	                    // Skip past the sign following the exponent, if one is
	                    // specified.
	                    if (charCode == 43 || charCode == 45) {
	                      Index++;
	                    }
	                    // Parse the exponential component.
	                    for (position = Index; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
	                    if (position == Index) {
	                      // Illegal empty exponent.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Coerce the parsed value to a JavaScript number.
	                  return +source.slice(begin, Index);
	                }
	                // A negative sign may only precede numbers.
	                if (isSigned) {
	                  abort();
	                }
	                // `true`, `false`, and `null` literals.
	                if (source.slice(Index, Index + 4) == "true") {
	                  Index += 4;
	                  return true;
	                } else if (source.slice(Index, Index + 5) == "false") {
	                  Index += 5;
	                  return false;
	                } else if (source.slice(Index, Index + 4) == "null") {
	                  Index += 4;
	                  return null;
	                }
	                // Unrecognized token.
	                abort();
	            }
	          }
	          // Return the sentinel `$` character if the parser has reached the end
	          // of the source string.
	          return "$";
	        };
	
	        // Internal: Parses a JSON `value` token.
	        var get = function get(value) {
	          var results, hasMembers;
	          if (value == "$") {
	            // Unexpected end of input.
	            abort();
	          }
	          if (typeof value == "string") {
	            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	              // Remove the sentinel `@` character.
	              return value.slice(1);
	            }
	            // Parse object and array literals.
	            if (value == "[") {
	              // Parses a JSON array, returning a new JavaScript array.
	              results = [];
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing square bracket marks the end of the array literal.
	                if (value == "]") {
	                  break;
	                }
	                // If the array literal contains elements, the current token
	                // should be a comma separating the previous element from the
	                // next.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "]") {
	                      // Unexpected trailing `,` in array literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each array element.
	                    abort();
	                  }
	                }
	                // Elisions and leading commas are not permitted.
	                if (value == ",") {
	                  abort();
	                }
	                results.push(get(value));
	              }
	              return results;
	            } else if (value == "{") {
	              // Parses a JSON object, returning a new JavaScript object.
	              results = {};
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing curly brace marks the end of the object literal.
	                if (value == "}") {
	                  break;
	                }
	                // If the object literal contains members, the current token
	                // should be a comma separator.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "}") {
	                      // Unexpected trailing `,` in object literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each object member.
	                    abort();
	                  }
	                }
	                // Leading commas are not permitted, object property names must be
	                // double-quoted strings, and a `:` must separate each property
	                // name and value.
	                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                  abort();
	                }
	                results[value.slice(1)] = get(lex());
	              }
	              return results;
	            }
	            // Unexpected token encountered.
	            abort();
	          }
	          return value;
	        };
	
	        // Internal: Updates a traversed object member.
	        var update = function update(source, property, callback) {
	          var element = walk(source, property, callback);
	          if (element === undef) {
	            delete source[property];
	          } else {
	            source[property] = element;
	          }
	        };
	
	        // Internal: Recursively traverses a parsed JSON object, invoking the
	        // `callback` function for each value. This is an implementation of the
	        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	        var walk = function walk(source, property, callback) {
	          var value = source[property],
	              length;
	          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
	            // `forEach` can't be used to traverse an array in Opera <= 8.54
	            // because its `Object#hasOwnProperty` implementation returns `false`
	            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	            if (getClass.call(value) == arrayClass) {
	              for (length = value.length; length--;) {
	                update(value, length, callback);
	              }
	            } else {
	              _forEach(value, function (property) {
	                update(value, property, callback);
	              });
	            }
	          }
	          return callback.call(source, property, value);
	        };
	
	        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	        exports.parse = function (source, callback) {
	          var result, value;
	          Index = 0;
	          Source = "" + source;
	          result = get(lex());
	          // If a JSON string contains multiple tokens, it is invalid.
	          if (lex() != "$") {
	            abort();
	          }
	          // Reset the parser state.
	          Index = Source = null;
	          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	        };
	      }
	    }
	
	    exports["runInContext"] = runInContext;
	    return exports;
	  }
	
	  if (freeExports && !isLoader) {
	    // Export for CommonJS environments.
	    runInContext(root, freeExports);
	  } else {
	    // Export for web browsers and JavaScript engines.
	    var nativeJSON = root.JSON,
	        previousJSON = root["JSON3"],
	        isRestored = false;
	
	    var JSON3 = runInContext(root, root["JSON3"] = {
	      // Public: Restores the original value of the global `JSON` object and
	      // returns a reference to the `JSON3` object.
	      "noConflict": function noConflict() {
	        if (!isRestored) {
	          isRestored = true;
	          root.JSON = nativeJSON;
	          root["JSON3"] = previousJSON;
	          nativeJSON = previousJSON = null;
	        }
	        return JSON3;
	      }
	    });
	
	    root.JSON = {
	      "parse": JSON3.parse,
	      "stringify": JSON3.stringify
	    };
	  }
	
	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(207)(module), (function() { return this; }())))

/***/ },
/* 207 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ },
/* 208 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 209 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};

/***/ },
/* 210 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || []).push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function (event, fn) {
	  var self = this;
	  this._callbacks = this._callbacks || {};
	
	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function (event) {
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1),
	      callbacks = this._callbacks[event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function (event) {
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function (event) {
	  return !!this.listeners(event).length;
	};

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/*global Blob,File*/
	
	/**
	 * Module requirements
	 */
	
	var isArray = __webpack_require__(209);
	var isBuf = __webpack_require__(212);
	
	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */
	
	exports.deconstructPacket = function (packet) {
	  var buffers = [];
	  var packetData = packet.data;
	
	  function _deconstructPacket(data) {
	    if (!data) return data;
	
	    if (isBuf(data)) {
	      var placeholder = { _placeholder: true, num: buffers.length };
	      buffers.push(data);
	      return placeholder;
	    } else if (isArray(data)) {
	      var newData = new Array(data.length);
	      for (var i = 0; i < data.length; i++) {
	        newData[i] = _deconstructPacket(data[i]);
	      }
	      return newData;
	    } else if ('object' == (typeof data === 'undefined' ? 'undefined' : _typeof(data)) && !(data instanceof Date)) {
	      var newData = {};
	      for (var key in data) {
	        newData[key] = _deconstructPacket(data[key]);
	      }
	      return newData;
	    }
	    return data;
	  }
	
	  var pack = packet;
	  pack.data = _deconstructPacket(packetData);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return { packet: pack, buffers: buffers };
	};
	
	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */
	
	exports.reconstructPacket = function (packet, buffers) {
	  var curPlaceHolder = 0;
	
	  function _reconstructPacket(data) {
	    if (data && data._placeholder) {
	      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
	      return buf;
	    } else if (isArray(data)) {
	      for (var i = 0; i < data.length; i++) {
	        data[i] = _reconstructPacket(data[i]);
	      }
	      return data;
	    } else if (data && 'object' == (typeof data === 'undefined' ? 'undefined' : _typeof(data))) {
	      for (var key in data) {
	        data[key] = _reconstructPacket(data[key]);
	      }
	      return data;
	    }
	    return data;
	  }
	
	  packet.data = _reconstructPacket(packet.data);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};
	
	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */
	
	exports.removeBlobs = function (data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;
	
	    // convert any blob
	    if (global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
	      pendingBlobs++;
	
	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function () {
	        // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        } else {
	          bloblessData = this.result;
	        }
	
	        // if nothing pending its callback time
	        if (! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };
	
	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) {
	      // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (obj && 'object' == (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) && !isBuf(obj)) {
	      // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }
	
	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 212 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	module.exports = isBuf;
	
	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */
	
	function isBuf(obj) {
	  return global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/**
	 * Module dependencies.
	 */
	
	var eio = __webpack_require__(214);
	var Socket = __webpack_require__(239);
	var Emitter = __webpack_require__(240);
	var parser = __webpack_require__(205);
	var on = __webpack_require__(242);
	var bind = __webpack_require__(243);
	var debug = __webpack_require__(202)('socket.io-client:manager');
	var indexOf = __webpack_require__(237);
	var Backoff = __webpack_require__(245);
	
	/**
	 * IE6+ hasOwnProperty
	 */
	
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * Module exports
	 */
	
	module.exports = Manager;
	
	/**
	 * `Manager` constructor.
	 *
	 * @param {String} engine instance or engine uri/opts
	 * @param {Object} options
	 * @api public
	 */
	
	function Manager(uri, opts) {
	  if (!(this instanceof Manager)) return new Manager(uri, opts);
	  if (uri && 'object' == (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};
	
	  opts.path = opts.path || '/socket.io';
	  this.nsps = {};
	  this.subs = [];
	  this.opts = opts;
	  this.reconnection(opts.reconnection !== false);
	  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	  this.reconnectionDelay(opts.reconnectionDelay || 1000);
	  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	  this.randomizationFactor(opts.randomizationFactor || 0.5);
	  this.backoff = new Backoff({
	    min: this.reconnectionDelay(),
	    max: this.reconnectionDelayMax(),
	    jitter: this.randomizationFactor()
	  });
	  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	  this.readyState = 'closed';
	  this.uri = uri;
	  this.connecting = [];
	  this.lastPing = null;
	  this.encoding = false;
	  this.packetBuffer = [];
	  this.encoder = new parser.Encoder();
	  this.decoder = new parser.Decoder();
	  this.autoConnect = opts.autoConnect !== false;
	  if (this.autoConnect) this.open();
	}
	
	/**
	 * Propagate given event to sockets and emit on `this`
	 *
	 * @api private
	 */
	
	Manager.prototype.emitAll = function () {
	  this.emit.apply(this, arguments);
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
	    }
	  }
	};
	
	/**
	 * Update `socket.id` of all sockets
	 *
	 * @api private
	 */
	
	Manager.prototype.updateSocketIds = function () {
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].id = this.engine.id;
	    }
	  }
	};
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Manager.prototype);
	
	/**
	 * Sets the `reconnection` config.
	 *
	 * @param {Boolean} true/false if it should automatically reconnect
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnection = function (v) {
	  if (!arguments.length) return this._reconnection;
	  this._reconnection = !!v;
	  return this;
	};
	
	/**
	 * Sets the reconnection attempts config.
	 *
	 * @param {Number} max reconnection attempts before giving up
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionAttempts = function (v) {
	  if (!arguments.length) return this._reconnectionAttempts;
	  this._reconnectionAttempts = v;
	  return this;
	};
	
	/**
	 * Sets the delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelay = function (v) {
	  if (!arguments.length) return this._reconnectionDelay;
	  this._reconnectionDelay = v;
	  this.backoff && this.backoff.setMin(v);
	  return this;
	};
	
	Manager.prototype.randomizationFactor = function (v) {
	  if (!arguments.length) return this._randomizationFactor;
	  this._randomizationFactor = v;
	  this.backoff && this.backoff.setJitter(v);
	  return this;
	};
	
	/**
	 * Sets the maximum delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelayMax = function (v) {
	  if (!arguments.length) return this._reconnectionDelayMax;
	  this._reconnectionDelayMax = v;
	  this.backoff && this.backoff.setMax(v);
	  return this;
	};
	
	/**
	 * Sets the connection timeout. `false` to disable
	 *
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.timeout = function (v) {
	  if (!arguments.length) return this._timeout;
	  this._timeout = v;
	  return this;
	};
	
	/**
	 * Starts trying to reconnect if reconnection is enabled and we have not
	 * started reconnecting yet
	 *
	 * @api private
	 */
	
	Manager.prototype.maybeReconnectOnOpen = function () {
	  // Only try to reconnect if it's the first time we're connecting
	  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
	    // keeps reconnection from firing twice for the same reconnection loop
	    this.reconnect();
	  }
	};
	
	/**
	 * Sets the current transport `socket`.
	 *
	 * @param {Function} optional, callback
	 * @return {Manager} self
	 * @api public
	 */
	
	Manager.prototype.open = Manager.prototype.connect = function (fn) {
	  debug('readyState %s', this.readyState);
	  if (~this.readyState.indexOf('open')) return this;
	
	  debug('opening %s', this.uri);
	  this.engine = eio(this.uri, this.opts);
	  var socket = this.engine;
	  var self = this;
	  this.readyState = 'opening';
	  this.skipReconnect = false;
	
	  // emit `open`
	  var openSub = on(socket, 'open', function () {
	    self.onopen();
	    fn && fn();
	  });
	
	  // emit `connect_error`
	  var errorSub = on(socket, 'error', function (data) {
	    debug('connect_error');
	    self.cleanup();
	    self.readyState = 'closed';
	    self.emitAll('connect_error', data);
	    if (fn) {
	      var err = new Error('Connection error');
	      err.data = data;
	      fn(err);
	    } else {
	      // Only do this if there is no fn to handle the error
	      self.maybeReconnectOnOpen();
	    }
	  });
	
	  // emit `connect_timeout`
	  if (false !== this._timeout) {
	    var timeout = this._timeout;
	    debug('connect attempt will timeout after %d', timeout);
	
	    // set timer
	    var timer = setTimeout(function () {
	      debug('connect attempt timed out after %d', timeout);
	      openSub.destroy();
	      socket.close();
	      socket.emit('error', 'timeout');
	      self.emitAll('connect_timeout', timeout);
	    }, timeout);
	
	    this.subs.push({
	      destroy: function destroy() {
	        clearTimeout(timer);
	      }
	    });
	  }
	
	  this.subs.push(openSub);
	  this.subs.push(errorSub);
	
	  return this;
	};
	
	/**
	 * Called upon transport open.
	 *
	 * @api private
	 */
	
	Manager.prototype.onopen = function () {
	  debug('open');
	
	  // clear old subs
	  this.cleanup();
	
	  // mark as open
	  this.readyState = 'open';
	  this.emit('open');
	
	  // add new subs
	  var socket = this.engine;
	  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
	  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
	  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
	  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
	  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
	  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
	};
	
	/**
	 * Called upon a ping.
	 *
	 * @api private
	 */
	
	Manager.prototype.onping = function () {
	  this.lastPing = new Date();
	  this.emitAll('ping');
	};
	
	/**
	 * Called upon a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.onpong = function () {
	  this.emitAll('pong', new Date() - this.lastPing);
	};
	
	/**
	 * Called with data.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondata = function (data) {
	  this.decoder.add(data);
	};
	
	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondecoded = function (packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon socket error.
	 *
	 * @api private
	 */
	
	Manager.prototype.onerror = function (err) {
	  debug('error', err);
	  this.emitAll('error', err);
	};
	
	/**
	 * Creates a new socket for the given `nsp`.
	 *
	 * @return {Socket}
	 * @api public
	 */
	
	Manager.prototype.socket = function (nsp) {
	  var socket = this.nsps[nsp];
	  if (!socket) {
	    socket = new Socket(this, nsp);
	    this.nsps[nsp] = socket;
	    var self = this;
	    socket.on('connecting', onConnecting);
	    socket.on('connect', function () {
	      socket.id = self.engine.id;
	    });
	
	    if (this.autoConnect) {
	      // manually call here since connecting evnet is fired before listening
	      onConnecting();
	    }
	  }
	
	  function onConnecting() {
	    if (!~indexOf(self.connecting, socket)) {
	      self.connecting.push(socket);
	    }
	  }
	
	  return socket;
	};
	
	/**
	 * Called upon a socket close.
	 *
	 * @param {Socket} socket
	 */
	
	Manager.prototype.destroy = function (socket) {
	  var index = indexOf(this.connecting, socket);
	  if (~index) this.connecting.splice(index, 1);
	  if (this.connecting.length) return;
	
	  this.close();
	};
	
	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Manager.prototype.packet = function (packet) {
	  debug('writing packet %j', packet);
	  var self = this;
	
	  if (!self.encoding) {
	    // encode, then write to engine with result
	    self.encoding = true;
	    this.encoder.encode(packet, function (encodedPackets) {
	      for (var i = 0; i < encodedPackets.length; i++) {
	        self.engine.write(encodedPackets[i], packet.options);
	      }
	      self.encoding = false;
	      self.processPacketQueue();
	    });
	  } else {
	    // add packet to the queue
	    self.packetBuffer.push(packet);
	  }
	};
	
	/**
	 * If packet buffer is non-empty, begins encoding the
	 * next packet in line.
	 *
	 * @api private
	 */
	
	Manager.prototype.processPacketQueue = function () {
	  if (this.packetBuffer.length > 0 && !this.encoding) {
	    var pack = this.packetBuffer.shift();
	    this.packet(pack);
	  }
	};
	
	/**
	 * Clean up transport subscriptions and packet buffer.
	 *
	 * @api private
	 */
	
	Manager.prototype.cleanup = function () {
	  debug('cleanup');
	
	  var sub;
	  while (sub = this.subs.shift()) {
	    sub.destroy();
	  }this.packetBuffer = [];
	  this.encoding = false;
	  this.lastPing = null;
	
	  this.decoder.destroy();
	};
	
	/**
	 * Close the current socket.
	 *
	 * @api private
	 */
	
	Manager.prototype.close = Manager.prototype.disconnect = function () {
	  debug('disconnect');
	  this.skipReconnect = true;
	  this.reconnecting = false;
	  if ('opening' == this.readyState) {
	    // `onclose` will not fire because
	    // an open event never happened
	    this.cleanup();
	  }
	  this.backoff.reset();
	  this.readyState = 'closed';
	  if (this.engine) this.engine.close();
	};
	
	/**
	 * Called upon engine close.
	 *
	 * @api private
	 */
	
	Manager.prototype.onclose = function (reason) {
	  debug('onclose');
	
	  this.cleanup();
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.emit('close', reason);
	
	  if (this._reconnection && !this.skipReconnect) {
	    this.reconnect();
	  }
	};
	
	/**
	 * Attempt a reconnection.
	 *
	 * @api private
	 */
	
	Manager.prototype.reconnect = function () {
	  if (this.reconnecting || this.skipReconnect) return this;
	
	  var self = this;
	
	  if (this.backoff.attempts >= this._reconnectionAttempts) {
	    debug('reconnect failed');
	    this.backoff.reset();
	    this.emitAll('reconnect_failed');
	    this.reconnecting = false;
	  } else {
	    var delay = this.backoff.duration();
	    debug('will wait %dms before reconnect attempt', delay);
	
	    this.reconnecting = true;
	    var timer = setTimeout(function () {
	      if (self.skipReconnect) return;
	
	      debug('attempting reconnect');
	      self.emitAll('reconnect_attempt', self.backoff.attempts);
	      self.emitAll('reconnecting', self.backoff.attempts);
	
	      // check again for the case socket closed in above events
	      if (self.skipReconnect) return;
	
	      self.open(function (err) {
	        if (err) {
	          debug('reconnect attempt error');
	          self.reconnecting = false;
	          self.reconnect();
	          self.emitAll('reconnect_error', err.data);
	        } else {
	          debug('reconnect success');
	          self.onreconnect();
	        }
	      });
	    }, delay);
	
	    this.subs.push({
	      destroy: function destroy() {
	        clearTimeout(timer);
	      }
	    });
	  }
	};
	
	/**
	 * Called upon successful reconnect.
	 *
	 * @api private
	 */
	
	Manager.prototype.onreconnect = function () {
	  var attempt = this.backoff.attempts;
	  this.reconnecting = false;
	  this.backoff.reset();
	  this.updateSocketIds();
	  this.emitAll('reconnect', attempt);
	};

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(215);

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(216);
	
	/**
	 * Exports parser
	 *
	 * @api public
	 *
	 */
	module.exports.parser = __webpack_require__(223);

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/**
	 * Module dependencies.
	 */
	
	var transports = __webpack_require__(217);
	var Emitter = __webpack_require__(210);
	var debug = __webpack_require__(202)('engine.io-client:socket');
	var index = __webpack_require__(237);
	var parser = __webpack_require__(223);
	var parseuri = __webpack_require__(201);
	var parsejson = __webpack_require__(238);
	var parseqs = __webpack_require__(231);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Socket;
	
	/**
	 * Noop function.
	 *
	 * @api private
	 */
	
	function noop() {}
	
	/**
	 * Socket constructor.
	 *
	 * @param {String|Object} uri or options
	 * @param {Object} options
	 * @api public
	 */
	
	function Socket(uri, opts) {
	  if (!(this instanceof Socket)) return new Socket(uri, opts);
	
	  opts = opts || {};
	
	  if (uri && 'object' == (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) {
	    opts = uri;
	    uri = null;
	  }
	
	  if (uri) {
	    uri = parseuri(uri);
	    opts.hostname = uri.host;
	    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
	    opts.port = uri.port;
	    if (uri.query) opts.query = uri.query;
	  } else if (opts.host) {
	    opts.hostname = parseuri(opts.host).host;
	  }
	
	  this.secure = null != opts.secure ? opts.secure : global.location && 'https:' == location.protocol;
	
	  if (opts.hostname && !opts.port) {
	    // if no port is specified manually, use the protocol default
	    opts.port = this.secure ? '443' : '80';
	  }
	
	  this.agent = opts.agent || false;
	  this.hostname = opts.hostname || (global.location ? location.hostname : 'localhost');
	  this.port = opts.port || (global.location && location.port ? location.port : this.secure ? 443 : 80);
	  this.query = opts.query || {};
	  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
	  this.upgrade = false !== opts.upgrade;
	  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
	  this.forceJSONP = !!opts.forceJSONP;
	  this.jsonp = false !== opts.jsonp;
	  this.forceBase64 = !!opts.forceBase64;
	  this.enablesXDR = !!opts.enablesXDR;
	  this.timestampParam = opts.timestampParam || 't';
	  this.timestampRequests = opts.timestampRequests;
	  this.transports = opts.transports || ['polling', 'websocket'];
	  this.readyState = '';
	  this.writeBuffer = [];
	  this.policyPort = opts.policyPort || 843;
	  this.rememberUpgrade = opts.rememberUpgrade || false;
	  this.binaryType = null;
	  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
	  this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || {} : false;
	
	  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
	  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
	    this.perMessageDeflate.threshold = 1024;
	  }
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx || null;
	  this.key = opts.key || null;
	  this.passphrase = opts.passphrase || null;
	  this.cert = opts.cert || null;
	  this.ca = opts.ca || null;
	  this.ciphers = opts.ciphers || null;
	  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	  if (freeGlobal.global === freeGlobal) {
	    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
	      this.extraHeaders = opts.extraHeaders;
	    }
	  }
	
	  this.open();
	}
	
	Socket.priorWebsocketSuccess = false;
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	Socket.protocol = parser.protocol; // this is an int
	
	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */
	
	Socket.Socket = Socket;
	Socket.Transport = __webpack_require__(222);
	Socket.transports = __webpack_require__(217);
	Socket.parser = __webpack_require__(223);
	
	/**
	 * Creates transport of the given type.
	 *
	 * @param {String} transport name
	 * @return {Transport}
	 * @api private
	 */
	
	Socket.prototype.createTransport = function (name) {
	  debug('creating transport "%s"', name);
	  var query = clone(this.query);
	
	  // append engine.io protocol identifier
	  query.EIO = parser.protocol;
	
	  // transport name
	  query.transport = name;
	
	  // session id if we already have one
	  if (this.id) query.sid = this.id;
	
	  var transport = new transports[name]({
	    agent: this.agent,
	    hostname: this.hostname,
	    port: this.port,
	    secure: this.secure,
	    path: this.path,
	    query: query,
	    forceJSONP: this.forceJSONP,
	    jsonp: this.jsonp,
	    forceBase64: this.forceBase64,
	    enablesXDR: this.enablesXDR,
	    timestampRequests: this.timestampRequests,
	    timestampParam: this.timestampParam,
	    policyPort: this.policyPort,
	    socket: this,
	    pfx: this.pfx,
	    key: this.key,
	    passphrase: this.passphrase,
	    cert: this.cert,
	    ca: this.ca,
	    ciphers: this.ciphers,
	    rejectUnauthorized: this.rejectUnauthorized,
	    perMessageDeflate: this.perMessageDeflate,
	    extraHeaders: this.extraHeaders
	  });
	
	  return transport;
	};
	
	function clone(obj) {
	  var o = {};
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}
	
	/**
	 * Initializes transport to use and starts probe.
	 *
	 * @api private
	 */
	Socket.prototype.open = function () {
	  var transport;
	  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
	    transport = 'websocket';
	  } else if (0 === this.transports.length) {
	    // Emit error on next tick so it can be listened to
	    var self = this;
	    setTimeout(function () {
	      self.emit('error', 'No transports available');
	    }, 0);
	    return;
	  } else {
	    transport = this.transports[0];
	  }
	  this.readyState = 'opening';
	
	  // Retry with the next transport if the transport is disabled (jsonp: false)
	  try {
	    transport = this.createTransport(transport);
	  } catch (e) {
	    this.transports.shift();
	    this.open();
	    return;
	  }
	
	  transport.open();
	  this.setTransport(transport);
	};
	
	/**
	 * Sets the current transport. Disables the existing one (if any).
	 *
	 * @api private
	 */
	
	Socket.prototype.setTransport = function (transport) {
	  debug('setting transport %s', transport.name);
	  var self = this;
	
	  if (this.transport) {
	    debug('clearing existing transport %s', this.transport.name);
	    this.transport.removeAllListeners();
	  }
	
	  // set up transport
	  this.transport = transport;
	
	  // set up transport listeners
	  transport.on('drain', function () {
	    self.onDrain();
	  }).on('packet', function (packet) {
	    self.onPacket(packet);
	  }).on('error', function (e) {
	    self.onError(e);
	  }).on('close', function () {
	    self.onClose('transport close');
	  });
	};
	
	/**
	 * Probes a transport.
	 *
	 * @param {String} transport name
	 * @api private
	 */
	
	Socket.prototype.probe = function (name) {
	  debug('probing transport "%s"', name);
	  var transport = this.createTransport(name, { probe: 1 }),
	      failed = false,
	      self = this;
	
	  Socket.priorWebsocketSuccess = false;
	
	  function onTransportOpen() {
	    if (self.onlyBinaryUpgrades) {
	      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
	      failed = failed || upgradeLosesBinary;
	    }
	    if (failed) return;
	
	    debug('probe transport "%s" opened', name);
	    transport.send([{ type: 'ping', data: 'probe' }]);
	    transport.once('packet', function (msg) {
	      if (failed) return;
	      if ('pong' == msg.type && 'probe' == msg.data) {
	        debug('probe transport "%s" pong', name);
	        self.upgrading = true;
	        self.emit('upgrading', transport);
	        if (!transport) return;
	        Socket.priorWebsocketSuccess = 'websocket' == transport.name;
	
	        debug('pausing current transport "%s"', self.transport.name);
	        self.transport.pause(function () {
	          if (failed) return;
	          if ('closed' == self.readyState) return;
	          debug('changing transport and sending upgrade packet');
	
	          cleanup();
	
	          self.setTransport(transport);
	          transport.send([{ type: 'upgrade' }]);
	          self.emit('upgrade', transport);
	          transport = null;
	          self.upgrading = false;
	          self.flush();
	        });
	      } else {
	        debug('probe transport "%s" failed', name);
	        var err = new Error('probe error');
	        err.transport = transport.name;
	        self.emit('upgradeError', err);
	      }
	    });
	  }
	
	  function freezeTransport() {
	    if (failed) return;
	
	    // Any callback called by transport should be ignored since now
	    failed = true;
	
	    cleanup();
	
	    transport.close();
	    transport = null;
	  }
	
	  //Handle any error that happens while probing
	  function onerror(err) {
	    var error = new Error('probe error: ' + err);
	    error.transport = transport.name;
	
	    freezeTransport();
	
	    debug('probe transport "%s" failed because of error: %s', name, err);
	
	    self.emit('upgradeError', error);
	  }
	
	  function onTransportClose() {
	    onerror("transport closed");
	  }
	
	  //When the socket is closed while we're probing
	  function onclose() {
	    onerror("socket closed");
	  }
	
	  //When the socket is upgraded while we're probing
	  function onupgrade(to) {
	    if (transport && to.name != transport.name) {
	      debug('"%s" works - aborting "%s"', to.name, transport.name);
	      freezeTransport();
	    }
	  }
	
	  //Remove all listeners on the transport and on self
	  function cleanup() {
	    transport.removeListener('open', onTransportOpen);
	    transport.removeListener('error', onerror);
	    transport.removeListener('close', onTransportClose);
	    self.removeListener('close', onclose);
	    self.removeListener('upgrading', onupgrade);
	  }
	
	  transport.once('open', onTransportOpen);
	  transport.once('error', onerror);
	  transport.once('close', onTransportClose);
	
	  this.once('close', onclose);
	  this.once('upgrading', onupgrade);
	
	  transport.open();
	};
	
	/**
	 * Called when connection is deemed open.
	 *
	 * @api public
	 */
	
	Socket.prototype.onOpen = function () {
	  debug('socket open');
	  this.readyState = 'open';
	  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
	  this.emit('open');
	  this.flush();
	
	  // we check for `readyState` in case an `open`
	  // listener already closed the socket
	  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
	    debug('starting upgrade probes');
	    for (var i = 0, l = this.upgrades.length; i < l; i++) {
	      this.probe(this.upgrades[i]);
	    }
	  }
	};
	
	/**
	 * Handles a packet.
	 *
	 * @api private
	 */
	
	Socket.prototype.onPacket = function (packet) {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
	
	    this.emit('packet', packet);
	
	    // Socket is live - any packet counts
	    this.emit('heartbeat');
	
	    switch (packet.type) {
	      case 'open':
	        this.onHandshake(parsejson(packet.data));
	        break;
	
	      case 'pong':
	        this.setPing();
	        this.emit('pong');
	        break;
	
	      case 'error':
	        var err = new Error('server error');
	        err.code = packet.data;
	        this.onError(err);
	        break;
	
	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug('packet received with socket readyState "%s"', this.readyState);
	  }
	};
	
	/**
	 * Called upon handshake completion.
	 *
	 * @param {Object} handshake obj
	 * @api private
	 */
	
	Socket.prototype.onHandshake = function (data) {
	  this.emit('handshake', data);
	  this.id = data.sid;
	  this.transport.query.sid = data.sid;
	  this.upgrades = this.filterUpgrades(data.upgrades);
	  this.pingInterval = data.pingInterval;
	  this.pingTimeout = data.pingTimeout;
	  this.onOpen();
	  // In case open handler closes socket
	  if ('closed' == this.readyState) return;
	  this.setPing();
	
	  // Prolong liveness of socket on heartbeat
	  this.removeListener('heartbeat', this.onHeartbeat);
	  this.on('heartbeat', this.onHeartbeat);
	};
	
	/**
	 * Resets ping timeout.
	 *
	 * @api private
	 */
	
	Socket.prototype.onHeartbeat = function (timeout) {
	  clearTimeout(this.pingTimeoutTimer);
	  var self = this;
	  self.pingTimeoutTimer = setTimeout(function () {
	    if ('closed' == self.readyState) return;
	    self.onClose('ping timeout');
	  }, timeout || self.pingInterval + self.pingTimeout);
	};
	
	/**
	 * Pings server every `this.pingInterval` and expects response
	 * within `this.pingTimeout` or closes connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.setPing = function () {
	  var self = this;
	  clearTimeout(self.pingIntervalTimer);
	  self.pingIntervalTimer = setTimeout(function () {
	    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
	    self.ping();
	    self.onHeartbeat(self.pingTimeout);
	  }, self.pingInterval);
	};
	
	/**
	* Sends a ping packet.
	*
	* @api private
	*/
	
	Socket.prototype.ping = function () {
	  var self = this;
	  this.sendPacket('ping', function () {
	    self.emit('ping');
	  });
	};
	
	/**
	 * Called on `drain` event
	 *
	 * @api private
	 */
	
	Socket.prototype.onDrain = function () {
	  this.writeBuffer.splice(0, this.prevBufferLen);
	
	  // setting prevBufferLen = 0 is very important
	  // for example, when upgrading, upgrade packet is sent over,
	  // and a nonzero prevBufferLen could cause problems on `drain`
	  this.prevBufferLen = 0;
	
	  if (0 === this.writeBuffer.length) {
	    this.emit('drain');
	  } else {
	    this.flush();
	  }
	};
	
	/**
	 * Flush write buffers.
	 *
	 * @api private
	 */
	
	Socket.prototype.flush = function () {
	  if ('closed' != this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
	    debug('flushing %d packets in socket', this.writeBuffer.length);
	    this.transport.send(this.writeBuffer);
	    // keep track of current length of writeBuffer
	    // splice writeBuffer and callbackBuffer on `drain`
	    this.prevBufferLen = this.writeBuffer.length;
	    this.emit('flush');
	  }
	};
	
	/**
	 * Sends a message.
	 *
	 * @param {String} message.
	 * @param {Function} callback function.
	 * @param {Object} options.
	 * @return {Socket} for chaining.
	 * @api public
	 */
	
	Socket.prototype.write = Socket.prototype.send = function (msg, options, fn) {
	  this.sendPacket('message', msg, options, fn);
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type.
	 * @param {String} data.
	 * @param {Object} options.
	 * @param {Function} callback function.
	 * @api private
	 */
	
	Socket.prototype.sendPacket = function (type, data, options, fn) {
	  if ('function' == typeof data) {
	    fn = data;
	    data = undefined;
	  }
	
	  if ('function' == typeof options) {
	    fn = options;
	    options = null;
	  }
	
	  if ('closing' == this.readyState || 'closed' == this.readyState) {
	    return;
	  }
	
	  options = options || {};
	  options.compress = false !== options.compress;
	
	  var packet = {
	    type: type,
	    data: data,
	    options: options
	  };
	  this.emit('packetCreate', packet);
	  this.writeBuffer.push(packet);
	  if (fn) this.once('flush', fn);
	  this.flush();
	};
	
	/**
	 * Closes the connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.readyState = 'closing';
	
	    var self = this;
	
	    if (this.writeBuffer.length) {
	      this.once('drain', function () {
	        if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      });
	    } else if (this.upgrading) {
	      waitForUpgrade();
	    } else {
	      close();
	    }
	  }
	
	  function close() {
	    self.onClose('forced close');
	    debug('socket closing - telling transport to close');
	    self.transport.close();
	  }
	
	  function cleanupAndClose() {
	    self.removeListener('upgrade', cleanupAndClose);
	    self.removeListener('upgradeError', cleanupAndClose);
	    close();
	  }
	
	  function waitForUpgrade() {
	    // wait for upgrade to finish since we can't send packets while pausing a transport
	    self.once('upgrade', cleanupAndClose);
	    self.once('upgradeError', cleanupAndClose);
	  }
	
	  return this;
	};
	
	/**
	 * Called upon transport error
	 *
	 * @api private
	 */
	
	Socket.prototype.onError = function (err) {
	  debug('socket error %j', err);
	  Socket.priorWebsocketSuccess = false;
	  this.emit('error', err);
	  this.onClose('transport error', err);
	};
	
	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */
	
	Socket.prototype.onClose = function (reason, desc) {
	  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
	    debug('socket close with reason: "%s"', reason);
	    var self = this;
	
	    // clear timers
	    clearTimeout(this.pingIntervalTimer);
	    clearTimeout(this.pingTimeoutTimer);
	
	    // stop event from firing again for transport
	    this.transport.removeAllListeners('close');
	
	    // ensure transport won't stay open
	    this.transport.close();
	
	    // ignore further transport communication
	    this.transport.removeAllListeners();
	
	    // set ready state
	    this.readyState = 'closed';
	
	    // clear session id
	    this.id = null;
	
	    // emit close event
	    this.emit('close', reason, desc);
	
	    // clean buffers after, so users can still
	    // grab the buffers on `close` event
	    self.writeBuffer = [];
	    self.prevBufferLen = 0;
	  }
	};
	
	/**
	 * Filters upgrades, returning only those matching client transports.
	 *
	 * @param {Array} server upgrades
	 * @api private
	 *
	 */
	
	Socket.prototype.filterUpgrades = function (upgrades) {
	  var filteredUpgrades = [];
	  for (var i = 0, j = upgrades.length; i < j; i++) {
	    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
	  }
	  return filteredUpgrades;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * Module dependencies
	 */
	
	var XMLHttpRequest = __webpack_require__(218);
	var XHR = __webpack_require__(220);
	var JSONP = __webpack_require__(234);
	var websocket = __webpack_require__(235);
	
	/**
	 * Export transports.
	 */
	
	exports.polling = polling;
	exports.websocket = websocket;
	
	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */
	
	function polling(opts) {
	  var xhr;
	  var xd = false;
	  var xs = false;
	  var jsonp = false !== opts.jsonp;
	
	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    xd = opts.hostname != location.hostname || port != opts.port;
	    xs = opts.secure != isSSL;
	  }
	
	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new XMLHttpRequest(opts);
	
	  if ('open' in xhr && !opts.forceJSONP) {
	    return new XHR(opts);
	  } else {
	    if (!jsonp) throw new Error('JSONP disabled');
	    return new JSONP(opts);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	// browser shim for xmlhttprequest module
	var hasCORS = __webpack_require__(219);
	
	module.exports = function (opts) {
	  var xdomain = opts.xdomain;
	
	  // scheme must be same when usign XDomainRequest
	  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
	  var xscheme = opts.xscheme;
	
	  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
	  // https://github.com/Automattic/engine.io-client/pull/217
	  var enablesXDR = opts.enablesXDR;
	
	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) {}
	
	  // Use XDomainRequest for IE8 if enablesXDR is true
	  // because loading bar keeps flashing when using jsonp-polling
	  // https://github.com/yujiosaka/socke.io-ie8-loading-example
	  try {
	    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
	      return new XDomainRequest();
	    }
	  } catch (e) {}
	
	  if (!xdomain) {
	    try {
	      return new ActiveXObject('Microsoft.XMLHTTP');
	    } catch (e) {}
	  }
	};

/***/ },
/* 219 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Module exports.
	 *
	 * Logic borrowed from Modernizr:
	 *
	 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
	 */
	
	try {
	  module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
	} catch (err) {
	  // if XMLHttp support is disabled in IE then it will throw
	  // when trying to create
	  module.exports = false;
	}

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * Module requirements.
	 */
	
	var XMLHttpRequest = __webpack_require__(218);
	var Polling = __webpack_require__(221);
	var Emitter = __webpack_require__(210);
	var inherit = __webpack_require__(232);
	var debug = __webpack_require__(202)('engine.io-client:polling-xhr');
	
	/**
	 * Module exports.
	 */
	
	module.exports = XHR;
	module.exports.Request = Request;
	
	/**
	 * Empty function
	 */
	
	function empty() {}
	
	/**
	 * XHR Polling constructor.
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function XHR(opts) {
	  Polling.call(this, opts);
	
	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    this.xd = opts.hostname != global.location.hostname || port != opts.port;
	    this.xs = opts.secure != isSSL;
	  } else {
	    this.extraHeaders = opts.extraHeaders;
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(XHR, Polling);
	
	/**
	 * XHR supports binary
	 */
	
	XHR.prototype.supportsBinary = true;
	
	/**
	 * Creates a request.
	 *
	 * @param {String} method
	 * @api private
	 */
	
	XHR.prototype.request = function (opts) {
	  opts = opts || {};
	  opts.uri = this.uri();
	  opts.xd = this.xd;
	  opts.xs = this.xs;
	  opts.agent = this.agent || false;
	  opts.supportsBinary = this.supportsBinary;
	  opts.enablesXDR = this.enablesXDR;
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  // other options for Node.js client
	  opts.extraHeaders = this.extraHeaders;
	
	  return new Request(opts);
	};
	
	/**
	 * Sends data.
	 *
	 * @param {String} data to send.
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	XHR.prototype.doWrite = function (data, fn) {
	  var isBinary = typeof data !== 'string' && data !== undefined;
	  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
	  var self = this;
	  req.on('success', fn);
	  req.on('error', function (err) {
	    self.onError('xhr post error', err);
	  });
	  this.sendXhr = req;
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	XHR.prototype.doPoll = function () {
	  debug('xhr poll');
	  var req = this.request();
	  var self = this;
	  req.on('data', function (data) {
	    self.onData(data);
	  });
	  req.on('error', function (err) {
	    self.onError('xhr poll error', err);
	  });
	  this.pollXhr = req;
	};
	
	/**
	 * Request constructor
	 *
	 * @param {Object} options
	 * @api public
	 */
	
	function Request(opts) {
	  this.method = opts.method || 'GET';
	  this.uri = opts.uri;
	  this.xd = !!opts.xd;
	  this.xs = !!opts.xs;
	  this.async = false !== opts.async;
	  this.data = undefined != opts.data ? opts.data : null;
	  this.agent = opts.agent;
	  this.isBinary = opts.isBinary;
	  this.supportsBinary = opts.supportsBinary;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	
	  this.create();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Request.prototype);
	
	/**
	 * Creates the XHR object and sends the request.
	 *
	 * @api private
	 */
	
	Request.prototype.create = function () {
	  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  var xhr = this.xhr = new XMLHttpRequest(opts);
	  var self = this;
	
	  try {
	    debug('xhr open %s: %s', this.method, this.uri);
	    xhr.open(this.method, this.uri, this.async);
	    try {
	      if (this.extraHeaders) {
	        xhr.setDisableHeaderCheck(true);
	        for (var i in this.extraHeaders) {
	          if (this.extraHeaders.hasOwnProperty(i)) {
	            xhr.setRequestHeader(i, this.extraHeaders[i]);
	          }
	        }
	      }
	    } catch (e) {}
	    if (this.supportsBinary) {
	      // This has to be done after open because Firefox is stupid
	      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
	      xhr.responseType = 'arraybuffer';
	    }
	
	    if ('POST' == this.method) {
	      try {
	        if (this.isBinary) {
	          xhr.setRequestHeader('Content-type', 'application/octet-stream');
	        } else {
	          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        }
	      } catch (e) {}
	    }
	
	    // ie6 check
	    if ('withCredentials' in xhr) {
	      xhr.withCredentials = true;
	    }
	
	    if (this.hasXDR()) {
	      xhr.onload = function () {
	        self.onLoad();
	      };
	      xhr.onerror = function () {
	        self.onError(xhr.responseText);
	      };
	    } else {
	      xhr.onreadystatechange = function () {
	        if (4 != xhr.readyState) return;
	        if (200 == xhr.status || 1223 == xhr.status) {
	          self.onLoad();
	        } else {
	          // make sure the `error` event handler that's user-set
	          // does not throw in the same tick and gets caught here
	          setTimeout(function () {
	            self.onError(xhr.status);
	          }, 0);
	        }
	      };
	    }
	
	    debug('xhr data %s', this.data);
	    xhr.send(this.data);
	  } catch (e) {
	    // Need to defer since .create() is called directly fhrom the constructor
	    // and thus the 'error' event can only be only bound *after* this exception
	    // occurs.  Therefore, also, we cannot throw here at all.
	    setTimeout(function () {
	      self.onError(e);
	    }, 0);
	    return;
	  }
	
	  if (global.document) {
	    this.index = Request.requestsCount++;
	    Request.requests[this.index] = this;
	  }
	};
	
	/**
	 * Called upon successful response.
	 *
	 * @api private
	 */
	
	Request.prototype.onSuccess = function () {
	  this.emit('success');
	  this.cleanup();
	};
	
	/**
	 * Called if we have data.
	 *
	 * @api private
	 */
	
	Request.prototype.onData = function (data) {
	  this.emit('data', data);
	  this.onSuccess();
	};
	
	/**
	 * Called upon error.
	 *
	 * @api private
	 */
	
	Request.prototype.onError = function (err) {
	  this.emit('error', err);
	  this.cleanup(true);
	};
	
	/**
	 * Cleans up house.
	 *
	 * @api private
	 */
	
	Request.prototype.cleanup = function (fromError) {
	  if ('undefined' == typeof this.xhr || null === this.xhr) {
	    return;
	  }
	  // xmlhttprequest
	  if (this.hasXDR()) {
	    this.xhr.onload = this.xhr.onerror = empty;
	  } else {
	    this.xhr.onreadystatechange = empty;
	  }
	
	  if (fromError) {
	    try {
	      this.xhr.abort();
	    } catch (e) {}
	  }
	
	  if (global.document) {
	    delete Request.requests[this.index];
	  }
	
	  this.xhr = null;
	};
	
	/**
	 * Called upon load.
	 *
	 * @api private
	 */
	
	Request.prototype.onLoad = function () {
	  var data;
	  try {
	    var contentType;
	    try {
	      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
	    } catch (e) {}
	    if (contentType === 'application/octet-stream') {
	      data = this.xhr.response;
	    } else {
	      if (!this.supportsBinary) {
	        data = this.xhr.responseText;
	      } else {
	        try {
	          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
	        } catch (e) {
	          var ui8Arr = new Uint8Array(this.xhr.response);
	          var dataArray = [];
	          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
	            dataArray.push(ui8Arr[idx]);
	          }
	
	          data = String.fromCharCode.apply(null, dataArray);
	        }
	      }
	    }
	  } catch (e) {
	    this.onError(e);
	  }
	  if (null != data) {
	    this.onData(data);
	  }
	};
	
	/**
	 * Check if it has XDomainRequest.
	 *
	 * @api private
	 */
	
	Request.prototype.hasXDR = function () {
	  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
	};
	
	/**
	 * Aborts the request.
	 *
	 * @api public
	 */
	
	Request.prototype.abort = function () {
	  this.cleanup();
	};
	
	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */
	
	if (global.document) {
	  Request.requestsCount = 0;
	  Request.requests = {};
	  if (global.attachEvent) {
	    global.attachEvent('onunload', unloadHandler);
	  } else if (global.addEventListener) {
	    global.addEventListener('beforeunload', unloadHandler, false);
	  }
	}
	
	function unloadHandler() {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(222);
	var parseqs = __webpack_require__(231);
	var parser = __webpack_require__(223);
	var inherit = __webpack_require__(232);
	var yeast = __webpack_require__(233);
	var debug = __webpack_require__(202)('engine.io-client:polling');
	
	/**
	 * Module exports.
	 */
	
	module.exports = Polling;
	
	/**
	 * Is XHR2 supported?
	 */
	
	var hasXHR2 = function () {
	  var XMLHttpRequest = __webpack_require__(218);
	  var xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	}();
	
	/**
	 * Polling interface.
	 *
	 * @param {Object} opts
	 * @api private
	 */
	
	function Polling(opts) {
	  var forceBase64 = opts && opts.forceBase64;
	  if (!hasXHR2 || forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(Polling, Transport);
	
	/**
	 * Transport name.
	 */
	
	Polling.prototype.name = 'polling';
	
	/**
	 * Opens the socket (triggers polling). We write a PING message to determine
	 * when the transport is open.
	 *
	 * @api private
	 */
	
	Polling.prototype.doOpen = function () {
	  this.poll();
	};
	
	/**
	 * Pauses polling.
	 *
	 * @param {Function} callback upon buffers are flushed and transport is paused
	 * @api private
	 */
	
	Polling.prototype.pause = function (onPause) {
	  var pending = 0;
	  var self = this;
	
	  this.readyState = 'pausing';
	
	  function pause() {
	    debug('paused');
	    self.readyState = 'paused';
	    onPause();
	  }
	
	  if (this.polling || !this.writable) {
	    var total = 0;
	
	    if (this.polling) {
	      debug('we are currently polling - waiting to pause');
	      total++;
	      this.once('pollComplete', function () {
	        debug('pre-pause polling complete');
	        --total || pause();
	      });
	    }
	
	    if (!this.writable) {
	      debug('we are currently writing - waiting to pause');
	      total++;
	      this.once('drain', function () {
	        debug('pre-pause writing complete');
	        --total || pause();
	      });
	    }
	  } else {
	    pause();
	  }
	};
	
	/**
	 * Starts polling cycle.
	 *
	 * @api public
	 */
	
	Polling.prototype.poll = function () {
	  debug('polling');
	  this.polling = true;
	  this.doPoll();
	  this.emit('poll');
	};
	
	/**
	 * Overloads onData to detect payloads.
	 *
	 * @api private
	 */
	
	Polling.prototype.onData = function (data) {
	  var self = this;
	  debug('polling got data %s', data);
	  var callback = function callback(packet, index, total) {
	    // if its the first message we consider the transport open
	    if ('opening' == self.readyState) {
	      self.onOpen();
	    }
	
	    // if its a close packet, we close the ongoing requests
	    if ('close' == packet.type) {
	      self.onClose();
	      return false;
	    }
	
	    // otherwise bypass onData and handle the message
	    self.onPacket(packet);
	  };
	
	  // decode payload
	  parser.decodePayload(data, this.socket.binaryType, callback);
	
	  // if an event did not trigger closing
	  if ('closed' != this.readyState) {
	    // if we got data we're not polling
	    this.polling = false;
	    this.emit('pollComplete');
	
	    if ('open' == this.readyState) {
	      this.poll();
	    } else {
	      debug('ignoring poll - transport state "%s"', this.readyState);
	    }
	  }
	};
	
	/**
	 * For polling, send a close packet.
	 *
	 * @api private
	 */
	
	Polling.prototype.doClose = function () {
	  var self = this;
	
	  function close() {
	    debug('writing close packet');
	    self.write([{ type: 'close' }]);
	  }
	
	  if ('open' == this.readyState) {
	    debug('transport open - closing');
	    close();
	  } else {
	    // in case we're trying to close while
	    // handshaking is in progress (GH-164)
	    debug('transport not open - deferring close');
	    this.once('open', close);
	  }
	};
	
	/**
	 * Writes a packets payload.
	 *
	 * @param {Array} data packets
	 * @param {Function} drain callback
	 * @api private
	 */
	
	Polling.prototype.write = function (packets) {
	  var self = this;
	  this.writable = false;
	  var callbackfn = function callbackfn() {
	    self.writable = true;
	    self.emit('drain');
	  };
	
	  var self = this;
	  parser.encodePayload(packets, this.supportsBinary, function (data) {
	    self.doWrite(data, callbackfn);
	  });
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	Polling.prototype.uri = function () {
	  var query = this.query || {};
	  var schema = this.secure ? 'https' : 'http';
	  var port = '';
	
	  // cache busting is forced
	  if (false !== this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }
	
	  if (!this.supportsBinary && !query.sid) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // avoid port if default for schema
	  if (this.port && ('https' == schema && this.port != 443 || 'http' == schema && this.port != 80)) {
	    port = ':' + this.port;
	  }
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(223);
	var Emitter = __webpack_require__(210);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Transport;
	
	/**
	 * Transport abstract constructor.
	 *
	 * @param {Object} options.
	 * @api private
	 */
	
	function Transport(opts) {
	  this.path = opts.path;
	  this.hostname = opts.hostname;
	  this.port = opts.port;
	  this.secure = opts.secure;
	  this.query = opts.query;
	  this.timestampParam = opts.timestampParam;
	  this.timestampRequests = opts.timestampRequests;
	  this.readyState = '';
	  this.agent = opts.agent || false;
	  this.socket = opts.socket;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Transport.prototype);
	
	/**
	 * Emits an error.
	 *
	 * @param {String} str
	 * @return {Transport} for chaining
	 * @api public
	 */
	
	Transport.prototype.onError = function (msg, desc) {
	  var err = new Error(msg);
	  err.type = 'TransportError';
	  err.description = desc;
	  this.emit('error', err);
	  return this;
	};
	
	/**
	 * Opens the transport.
	 *
	 * @api public
	 */
	
	Transport.prototype.open = function () {
	  if ('closed' == this.readyState || '' == this.readyState) {
	    this.readyState = 'opening';
	    this.doOpen();
	  }
	
	  return this;
	};
	
	/**
	 * Closes the transport.
	 *
	 * @api private
	 */
	
	Transport.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.doClose();
	    this.onClose();
	  }
	
	  return this;
	};
	
	/**
	 * Sends multiple packets.
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	Transport.prototype.send = function (packets) {
	  if ('open' == this.readyState) {
	    this.write(packets);
	  } else {
	    throw new Error('Transport not open');
	  }
	};
	
	/**
	 * Called upon open
	 *
	 * @api private
	 */
	
	Transport.prototype.onOpen = function () {
	  this.readyState = 'open';
	  this.writable = true;
	  this.emit('open');
	};
	
	/**
	 * Called with data.
	 *
	 * @param {String} data
	 * @api private
	 */
	
	Transport.prototype.onData = function (data) {
	  var packet = parser.decodePacket(data, this.socket.binaryType);
	  this.onPacket(packet);
	};
	
	/**
	 * Called with a decoded packet.
	 */
	
	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon close.
	 *
	 * @api private
	 */
	
	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var keys = __webpack_require__(224);
	var hasBinary = __webpack_require__(225);
	var sliceBuffer = __webpack_require__(226);
	var base64encoder = __webpack_require__(227);
	var after = __webpack_require__(228);
	var utf8 = __webpack_require__(229);
	
	/**
	 * Check if we are running an android browser. That requires us to use
	 * ArrayBuffer with polling transports...
	 *
	 * http://ghinda.net/jpeg-blob-ajax-android/
	 */
	
	var isAndroid = navigator.userAgent.match(/Android/i);
	
	/**
	 * Check if we are running in PhantomJS.
	 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
	 * https://github.com/ariya/phantomjs/issues/11395
	 * @type boolean
	 */
	var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);
	
	/**
	 * When true, avoids using Blobs to encode payloads.
	 * @type boolean
	 */
	var dontSendBlobs = isAndroid || isPhantomJS;
	
	/**
	 * Current protocol version.
	 */
	
	exports.protocol = 3;
	
	/**
	 * Packet types.
	 */
	
	var packets = exports.packets = {
	  open: 0 // non-ws
	  , close: 1 // non-ws
	  , ping: 2,
	  pong: 3,
	  message: 4,
	  upgrade: 5,
	  noop: 6
	};
	
	var packetslist = keys(packets);
	
	/**
	 * Premade error packet.
	 */
	
	var err = { type: 'error', data: 'parser error' };
	
	/**
	 * Create a blob api even for blob builder when vendor prefixes exist
	 */
	
	var Blob = __webpack_require__(230);
	
	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */
	
	exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	  if ('function' == typeof supportsBinary) {
	    callback = supportsBinary;
	    supportsBinary = false;
	  }
	
	  if ('function' == typeof utf8encode) {
	    callback = utf8encode;
	    utf8encode = null;
	  }
	
	  var data = packet.data === undefined ? undefined : packet.data.buffer || packet.data;
	
	  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
	    return encodeArrayBuffer(packet, supportsBinary, callback);
	  } else if (Blob && data instanceof global.Blob) {
	    return encodeBlob(packet, supportsBinary, callback);
	  }
	
	  // might be an object with { base64: true, data: dataAsBase64String }
	  if (data && data.base64) {
	    return encodeBase64Object(packet, callback);
	  }
	
	  // Sending data as a utf-8 string
	  var encoded = packets[packet.type];
	
	  // data fragment is optional
	  if (undefined !== packet.data) {
	    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
	  }
	
	  return callback('' + encoded);
	};
	
	function encodeBase64Object(packet, callback) {
	  // packet data is an object { base64: true, data: dataAsBase64String }
	  var message = 'b' + exports.packets[packet.type] + packet.data.data;
	  return callback(message);
	}
	
	/**
	 * Encode packet helpers for binary types
	 */
	
	function encodeArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var data = packet.data;
	  var contentArray = new Uint8Array(data);
	  var resultBuffer = new Uint8Array(1 + data.byteLength);
	
	  resultBuffer[0] = packets[packet.type];
	  for (var i = 0; i < contentArray.length; i++) {
	    resultBuffer[i + 1] = contentArray[i];
	  }
	
	  return callback(resultBuffer.buffer);
	}
	
	function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var fr = new FileReader();
	  fr.onload = function () {
	    packet.data = fr.result;
	    exports.encodePacket(packet, supportsBinary, true, callback);
	  };
	  return fr.readAsArrayBuffer(packet.data);
	}
	
	function encodeBlob(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  if (dontSendBlobs) {
	    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
	  }
	
	  var length = new Uint8Array(1);
	  length[0] = packets[packet.type];
	  var blob = new Blob([length.buffer, packet.data]);
	
	  return callback(blob);
	}
	
	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */
	
	exports.encodeBase64Packet = function (packet, callback) {
	  var message = 'b' + exports.packets[packet.type];
	  if (Blob && packet.data instanceof global.Blob) {
	    var fr = new FileReader();
	    fr.onload = function () {
	      var b64 = fr.result.split(',')[1];
	      callback(message + b64);
	    };
	    return fr.readAsDataURL(packet.data);
	  }
	
	  var b64data;
	  try {
	    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
	  } catch (e) {
	    // iPhone Safari doesn't let you apply with typed arrays
	    var typed = new Uint8Array(packet.data);
	    var basic = new Array(typed.length);
	    for (var i = 0; i < typed.length; i++) {
	      basic[i] = typed[i];
	    }
	    b64data = String.fromCharCode.apply(null, basic);
	  }
	  message += global.btoa(b64data);
	  return callback(message);
	};
	
	/**
	 * Decodes a packet. Changes format to Blob if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */
	
	exports.decodePacket = function (data, binaryType, utf8decode) {
	  // String data
	  if (typeof data == 'string' || data === undefined) {
	    if (data.charAt(0) == 'b') {
	      return exports.decodeBase64Packet(data.substr(1), binaryType);
	    }
	
	    if (utf8decode) {
	      try {
	        data = utf8.decode(data);
	      } catch (e) {
	        return err;
	      }
	    }
	    var type = data.charAt(0);
	
	    if (Number(type) != type || !packetslist[type]) {
	      return err;
	    }
	
	    if (data.length > 1) {
	      return { type: packetslist[type], data: data.substring(1) };
	    } else {
	      return { type: packetslist[type] };
	    }
	  }
	
	  var asArray = new Uint8Array(data);
	  var type = asArray[0];
	  var rest = sliceBuffer(data, 1);
	  if (Blob && binaryType === 'blob') {
	    rest = new Blob([rest]);
	  }
	  return { type: packetslist[type], data: rest };
	};
	
	/**
	 * Decodes a packet encoded in a base64 string
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */
	
	exports.decodeBase64Packet = function (msg, binaryType) {
	  var type = packetslist[msg.charAt(0)];
	  if (!global.ArrayBuffer) {
	    return { type: type, data: { base64: true, data: msg.substr(1) } };
	  }
	
	  var data = base64encoder.decode(msg.substr(1));
	
	  if (binaryType === 'blob' && Blob) {
	    data = new Blob([data]);
	  }
	
	  return { type: type, data: data };
	};
	
	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	exports.encodePayload = function (packets, supportsBinary, callback) {
	  if (typeof supportsBinary == 'function') {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }
	
	  var isBinary = hasBinary(packets);
	
	  if (supportsBinary && isBinary) {
	    if (Blob && !dontSendBlobs) {
	      return exports.encodePayloadAsBlob(packets, callback);
	    }
	
	    return exports.encodePayloadAsArrayBuffer(packets, callback);
	  }
	
	  if (!packets.length) {
	    return callback('0:');
	  }
	
	  function setLengthHeader(message) {
	    return message.length + ':' + message;
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function (message) {
	      doneCallback(null, setLengthHeader(message));
	    });
	  }
	
	  map(packets, encodeOne, function (err, results) {
	    return callback(results.join(''));
	  });
	};
	
	/**
	 * Async array map using after
	 */
	
	function map(ary, each, done) {
	  var result = new Array(ary.length);
	  var next = after(ary.length, done);
	
	  var eachWithIndex = function eachWithIndex(i, el, cb) {
	    each(el, function (error, msg) {
	      result[i] = msg;
	      cb(error, result);
	    });
	  };
	
	  for (var i = 0; i < ary.length; i++) {
	    eachWithIndex(i, ary[i], next);
	  }
	}
	
	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */
	
	exports.decodePayload = function (data, binaryType, callback) {
	  if (typeof data != 'string') {
	    return exports.decodePayloadAsBinary(data, binaryType, callback);
	  }
	
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var packet;
	  if (data == '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	  var length = '',
	      n,
	      msg;
	
	  for (var i = 0, l = data.length; i < l; i++) {
	    var chr = data.charAt(i);
	
	    if (':' != chr) {
	      length += chr;
	    } else {
	      if ('' == length || length != (n = Number(length))) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      msg = data.substr(i + 1, n);
	
	      if (length != msg.length) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      if (msg.length) {
	        packet = exports.decodePacket(msg, binaryType, true);
	
	        if (err.type == packet.type && err.data == packet.data) {
	          // parser error in individual packet - ignoring payload
	          return callback(err, 0, 1);
	        }
	
	        var ret = callback(packet, i + n, l);
	        if (false === ret) return;
	      }
	
	      // advance cursor
	      i += n;
	      length = '';
	    }
	  }
	
	  if (length != '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	};
	
	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {ArrayBuffer} encoded payload
	 * @api private
	 */
	
	exports.encodePayloadAsArrayBuffer = function (packets, callback) {
	  if (!packets.length) {
	    return callback(new ArrayBuffer(0));
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function (data) {
	      return doneCallback(null, data);
	    });
	  }
	
	  map(packets, encodeOne, function (err, encodedPackets) {
	    var totalLength = encodedPackets.reduce(function (acc, p) {
	      var len;
	      if (typeof p === 'string') {
	        len = p.length;
	      } else {
	        len = p.byteLength;
	      }
	      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
	    }, 0);
	
	    var resultArray = new Uint8Array(totalLength);
	
	    var bufferIndex = 0;
	    encodedPackets.forEach(function (p) {
	      var isString = typeof p === 'string';
	      var ab = p;
	      if (isString) {
	        var view = new Uint8Array(p.length);
	        for (var i = 0; i < p.length; i++) {
	          view[i] = p.charCodeAt(i);
	        }
	        ab = view.buffer;
	      }
	
	      if (isString) {
	        // not true binary
	        resultArray[bufferIndex++] = 0;
	      } else {
	        // true binary
	        resultArray[bufferIndex++] = 1;
	      }
	
	      var lenStr = ab.byteLength.toString();
	      for (var i = 0; i < lenStr.length; i++) {
	        resultArray[bufferIndex++] = parseInt(lenStr[i]);
	      }
	      resultArray[bufferIndex++] = 255;
	
	      var view = new Uint8Array(ab);
	      for (var i = 0; i < view.length; i++) {
	        resultArray[bufferIndex++] = view[i];
	      }
	    });
	
	    return callback(resultArray.buffer);
	  });
	};
	
	/**
	 * Encode as Blob
	 */
	
	exports.encodePayloadAsBlob = function (packets, callback) {
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function (encoded) {
	      var binaryIdentifier = new Uint8Array(1);
	      binaryIdentifier[0] = 1;
	      if (typeof encoded === 'string') {
	        var view = new Uint8Array(encoded.length);
	        for (var i = 0; i < encoded.length; i++) {
	          view[i] = encoded.charCodeAt(i);
	        }
	        encoded = view.buffer;
	        binaryIdentifier[0] = 0;
	      }
	
	      var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;
	
	      var lenStr = len.toString();
	      var lengthAry = new Uint8Array(lenStr.length + 1);
	      for (var i = 0; i < lenStr.length; i++) {
	        lengthAry[i] = parseInt(lenStr[i]);
	      }
	      lengthAry[lenStr.length] = 255;
	
	      if (Blob) {
	        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
	        doneCallback(null, blob);
	      }
	    });
	  }
	
	  map(packets, encodeOne, function (err, results) {
	    return callback(new Blob(results));
	  });
	};
	
	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary
	 *
	 * @param {ArrayBuffer} data, callback method
	 * @api public
	 */
	
	exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var bufferTail = data;
	  var buffers = [];
	
	  var numberTooLong = false;
	  while (bufferTail.byteLength > 0) {
	    var tailArray = new Uint8Array(bufferTail);
	    var isString = tailArray[0] === 0;
	    var msgLength = '';
	
	    for (var i = 1;; i++) {
	      if (tailArray[i] == 255) break;
	
	      if (msgLength.length > 310) {
	        numberTooLong = true;
	        break;
	      }
	
	      msgLength += tailArray[i];
	    }
	
	    if (numberTooLong) return callback(err, 0, 1);
	
	    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
	    msgLength = parseInt(msgLength);
	
	    var msg = sliceBuffer(bufferTail, 0, msgLength);
	    if (isString) {
	      try {
	        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
	      } catch (e) {
	        // iPhone Safari doesn't let you apply to typed arrays
	        var typed = new Uint8Array(msg);
	        msg = '';
	        for (var i = 0; i < typed.length; i++) {
	          msg += String.fromCharCode(typed[i]);
	        }
	      }
	    }
	
	    buffers.push(msg);
	    bufferTail = sliceBuffer(bufferTail, msgLength);
	  }
	
	  var total = buffers.length;
	  buffers.forEach(function (buffer, i) {
	    callback(exports.decodePacket(buffer, binaryType, true), i, total);
	  });
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 224 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */
	
	module.exports = Object.keys || function keys(obj) {
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;
	
	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/*
	 * Module requirements.
	 */
	
	var isArray = __webpack_require__(209);
	
	/**
	 * Module exports.
	 */
	
	module.exports = hasBinary;
	
	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */
	
	function hasBinary(data) {
	
	  function _hasBinary(obj) {
	    if (!obj) return false;
	
	    if (global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer || global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
	      return true;
	    }
	
	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	        if (_hasBinary(obj[i])) {
	          return true;
	        }
	      }
	    } else if (obj && 'object' == (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) {
	      if (obj.toJSON) {
	        obj = obj.toJSON();
	      }
	
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  }
	
	  return _hasBinary(data);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 226 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * An abstraction for slicing an arraybuffer even when
	 * ArrayBuffer.prototype.slice is not supported
	 *
	 * @api public
	 */
	
	module.exports = function (arraybuffer, start, end) {
	  var bytes = arraybuffer.byteLength;
	  start = start || 0;
	  end = end || bytes;
	
	  if (arraybuffer.slice) {
	    return arraybuffer.slice(start, end);
	  }
	
	  if (start < 0) {
	    start += bytes;
	  }
	  if (end < 0) {
	    end += bytes;
	  }
	  if (end > bytes) {
	    end = bytes;
	  }
	
	  if (start >= bytes || start >= end || bytes === 0) {
	    return new ArrayBuffer(0);
	  }
	
	  var abv = new Uint8Array(arraybuffer);
	  var result = new Uint8Array(end - start);
	  for (var i = start, ii = 0; i < end; i++, ii++) {
	    result[ii] = abv[i];
	  }
	  return result.buffer;
	};

/***/ },
/* 227 */
/***/ function(module, exports) {

	"use strict";
	
	/*
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */
	(function (chars) {
	  "use strict";
	
	  exports.encode = function (arraybuffer) {
	    var bytes = new Uint8Array(arraybuffer),
	        i,
	        len = bytes.length,
	        base64 = "";
	
	    for (i = 0; i < len; i += 3) {
	      base64 += chars[bytes[i] >> 2];
	      base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
	      base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
	      base64 += chars[bytes[i + 2] & 63];
	    }
	
	    if (len % 3 === 2) {
	      base64 = base64.substring(0, base64.length - 1) + "=";
	    } else if (len % 3 === 1) {
	      base64 = base64.substring(0, base64.length - 2) + "==";
	    }
	
	    return base64;
	  };
	
	  exports.decode = function (base64) {
	    var bufferLength = base64.length * 0.75,
	        len = base64.length,
	        i,
	        p = 0,
	        encoded1,
	        encoded2,
	        encoded3,
	        encoded4;
	
	    if (base64[base64.length - 1] === "=") {
	      bufferLength--;
	      if (base64[base64.length - 2] === "=") {
	        bufferLength--;
	      }
	    }
	
	    var arraybuffer = new ArrayBuffer(bufferLength),
	        bytes = new Uint8Array(arraybuffer);
	
	    for (i = 0; i < len; i += 4) {
	      encoded1 = chars.indexOf(base64[i]);
	      encoded2 = chars.indexOf(base64[i + 1]);
	      encoded3 = chars.indexOf(base64[i + 2]);
	      encoded4 = chars.indexOf(base64[i + 3]);
	
	      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
	      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
	      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
	    }
	
	    return arraybuffer;
	  };
	})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

/***/ },
/* 228 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = after;
	
	function after(count, callback, err_cb) {
	    var bail = false;
	    err_cb = err_cb || noop;
	    proxy.count = count;
	
	    return count === 0 ? callback() : proxy;
	
	    function proxy(err, result) {
	        if (proxy.count <= 0) {
	            throw new Error('after called too many times');
	        }
	        --proxy.count;
	
	        // after first error, rest are passed to err_cb
	        if (err) {
	            bail = true;
	            callback(err);
	            // future error callbacks will go to error handler
	            callback = err_cb;
	        } else if (proxy.count === 0 && !bail) {
	            callback(null, result);
	        }
	    }
	}
	
	function noop() {}

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function (root) {
	
		// Detect free variables `exports`
		var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports;
	
		// Detect free variable `module`
		var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && module.exports == freeExports && module;
	
		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}
	
		/*--------------------------------------------------------------------------*/
	
		var stringFromCharCode = String.fromCharCode;
	
		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) {
						// low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}
	
		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
			}
		}
		/*--------------------------------------------------------------------------*/
	
		function createByte(codePoint, shift) {
			return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
		}
	
		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) {
				// 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) {
				// 2-byte sequence
				symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
			} else if ((codePoint & 0xFFFF0000) == 0) {
				// 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
				symbol += createByte(codePoint, 6);
			} else if ((codePoint & 0xFFE00000) == 0) {
				// 4-byte sequence
				symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
			return symbol;
		}
	
		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}
	
		/*--------------------------------------------------------------------------*/
	
		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}
	
			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}
	
			// If we end up here, its not a continuation byte
			throw Error('Invalid continuation byte');
		}
	
		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;
	
			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}
	
			if (byteIndex == byteCount) {
				return false;
			}
	
			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}
	
			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = (byte1 & 0x1F) << 6 | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = (byte1 & 0x0F) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}
	
			throw Error('Invalid UTF-8 detected');
		}
	
		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}
	
		/*--------------------------------------------------------------------------*/
	
		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};
	
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if ("function" == 'function' && _typeof(__webpack_require__(208)) == 'object' && __webpack_require__(208)) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && !freeExports.nodeType) {
			if (freeModule) {
				// in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.utf8 = utf8;
		}
	})(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(207)(module), (function() { return this; }())))

/***/ },
/* 230 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * Create a blob builder even when vendor prefixes exist
	 */
	
	var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder;
	
	/**
	 * Check if Blob constructor is supported
	 */
	
	var blobSupported = function () {
	  try {
	    var a = new Blob(['hi']);
	    return a.size === 2;
	  } catch (e) {
	    return false;
	  }
	}();
	
	/**
	 * Check if Blob constructor supports ArrayBufferViews
	 * Fails in Safari 6, so we need to map to ArrayBuffers there.
	 */
	
	var blobSupportsArrayBufferView = blobSupported && function () {
	  try {
	    var b = new Blob([new Uint8Array([1, 2])]);
	    return b.size === 2;
	  } catch (e) {
	    return false;
	  }
	}();
	
	/**
	 * Check if BlobBuilder is supported
	 */
	
	var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;
	
	/**
	 * Helper function that maps ArrayBufferViews to ArrayBuffers
	 * Used by BlobBuilder constructor and old browsers that didn't
	 * support it in the Blob constructor.
	 */
	
	function mapArrayBufferViews(ary) {
	  for (var i = 0; i < ary.length; i++) {
	    var chunk = ary[i];
	    if (chunk.buffer instanceof ArrayBuffer) {
	      var buf = chunk.buffer;
	
	      // if this is a subarray, make a copy so we only
	      // include the subarray region from the underlying buffer
	      if (chunk.byteLength !== buf.byteLength) {
	        var copy = new Uint8Array(chunk.byteLength);
	        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
	        buf = copy.buffer;
	      }
	
	      ary[i] = buf;
	    }
	  }
	}
	
	function BlobBuilderConstructor(ary, options) {
	  options = options || {};
	
	  var bb = new BlobBuilder();
	  mapArrayBufferViews(ary);
	
	  for (var i = 0; i < ary.length; i++) {
	    bb.append(ary[i]);
	  }
	
	  return options.type ? bb.getBlob(options.type) : bb.getBlob();
	};
	
	function BlobConstructor(ary, options) {
	  mapArrayBufferViews(ary);
	  return new Blob(ary, options || {});
	};
	
	module.exports = function () {
	  if (blobSupported) {
	    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
	  } else if (blobBuilderSupported) {
	    return BlobBuilderConstructor;
	  } else {
	    return undefined;
	  }
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 231 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */
	
	exports.encode = function (obj) {
	  var str = '';
	
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }
	
	  return str;
	};
	
	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */
	
	exports.decode = function (qs) {
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	};

/***/ },
/* 232 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = function (a, b) {
	  var fn = function fn() {};
	  fn.prototype = b.prototype;
	  a.prototype = new fn();
	  a.prototype.constructor = a;
	};

/***/ },
/* 233 */
/***/ function(module, exports) {

	'use strict';
	
	var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
	    length = 64,
	    map = {},
	    seed = 0,
	    i = 0,
	    prev;
	
	/**
	 * Return a string representing the specified number.
	 *
	 * @param {Number} num The number to convert.
	 * @returns {String} The string representation of the number.
	 * @api public
	 */
	function encode(num) {
	  var encoded = '';
	
	  do {
	    encoded = alphabet[num % length] + encoded;
	    num = Math.floor(num / length);
	  } while (num > 0);
	
	  return encoded;
	}
	
	/**
	 * Return the integer value specified by the given string.
	 *
	 * @param {String} str The string to convert.
	 * @returns {Number} The integer value represented by the string.
	 * @api public
	 */
	function decode(str) {
	  var decoded = 0;
	
	  for (i = 0; i < str.length; i++) {
	    decoded = decoded * length + map[str.charAt(i)];
	  }
	
	  return decoded;
	}
	
	/**
	 * Yeast: A tiny growing id generator.
	 *
	 * @returns {String} A unique id.
	 * @api public
	 */
	function yeast() {
	  var now = encode(+new Date());
	
	  if (now !== prev) return seed = 0, prev = now;
	  return now + '.' + encode(seed++);
	}
	
	//
	// Map each character to its index.
	//
	for (; i < length; i++) {
	  map[alphabet[i]] = i;
	} //
	// Expose the `yeast`, `encode` and `decode` functions.
	//
	yeast.encode = encode;
	yeast.decode = decode;
	module.exports = yeast;

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * Module requirements.
	 */
	
	var Polling = __webpack_require__(221);
	var inherit = __webpack_require__(232);
	
	/**
	 * Module exports.
	 */
	
	module.exports = JSONPPolling;
	
	/**
	 * Cached regular expressions.
	 */
	
	var rNewline = /\n/g;
	var rEscapedNewline = /\\n/g;
	
	/**
	 * Global JSONP callbacks.
	 */
	
	var callbacks;
	
	/**
	 * Callbacks count.
	 */
	
	var index = 0;
	
	/**
	 * Noop.
	 */
	
	function empty() {}
	
	/**
	 * JSONP Polling constructor.
	 *
	 * @param {Object} opts.
	 * @api public
	 */
	
	function JSONPPolling(opts) {
	  Polling.call(this, opts);
	
	  this.query = this.query || {};
	
	  // define global callbacks array if not present
	  // we do this here (lazily) to avoid unneeded global pollution
	  if (!callbacks) {
	    // we need to consider multiple engines in the same page
	    if (!global.___eio) global.___eio = [];
	    callbacks = global.___eio;
	  }
	
	  // callback identifier
	  this.index = callbacks.length;
	
	  // add callback to jsonp global
	  var self = this;
	  callbacks.push(function (msg) {
	    self.onData(msg);
	  });
	
	  // append to query string
	  this.query.j = this.index;
	
	  // prevent spurious errors from being emitted when the window is unloaded
	  if (global.document && global.addEventListener) {
	    global.addEventListener('beforeunload', function () {
	      if (self.script) self.script.onerror = empty;
	    }, false);
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(JSONPPolling, Polling);
	
	/*
	 * JSONP only supports binary as base64 encoded strings
	 */
	
	JSONPPolling.prototype.supportsBinary = false;
	
	/**
	 * Closes the socket.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doClose = function () {
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  if (this.form) {
	    this.form.parentNode.removeChild(this.form);
	    this.form = null;
	    this.iframe = null;
	  }
	
	  Polling.prototype.doClose.call(this);
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doPoll = function () {
	  var self = this;
	  var script = document.createElement('script');
	
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  script.async = true;
	  script.src = this.uri();
	  script.onerror = function (e) {
	    self.onError('jsonp poll error', e);
	  };
	
	  var insertAt = document.getElementsByTagName('script')[0];
	  if (insertAt) {
	    insertAt.parentNode.insertBefore(script, insertAt);
	  } else {
	    (document.head || document.body).appendChild(script);
	  }
	  this.script = script;
	
	  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
	
	  if (isUAgecko) {
	    setTimeout(function () {
	      var iframe = document.createElement('iframe');
	      document.body.appendChild(iframe);
	      document.body.removeChild(iframe);
	    }, 100);
	  }
	};
	
	/**
	 * Writes with a hidden iframe.
	 *
	 * @param {String} data to send
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	JSONPPolling.prototype.doWrite = function (data, fn) {
	  var self = this;
	
	  if (!this.form) {
	    var form = document.createElement('form');
	    var area = document.createElement('textarea');
	    var id = this.iframeId = 'eio_iframe_' + this.index;
	    var iframe;
	
	    form.className = 'socketio';
	    form.style.position = 'absolute';
	    form.style.top = '-1000px';
	    form.style.left = '-1000px';
	    form.target = id;
	    form.method = 'POST';
	    form.setAttribute('accept-charset', 'utf-8');
	    area.name = 'd';
	    form.appendChild(area);
	    document.body.appendChild(form);
	
	    this.form = form;
	    this.area = area;
	  }
	
	  this.form.action = this.uri();
	
	  function complete() {
	    initIframe();
	    fn();
	  }
	
	  function initIframe() {
	    if (self.iframe) {
	      try {
	        self.form.removeChild(self.iframe);
	      } catch (e) {
	        self.onError('jsonp polling iframe removal error', e);
	      }
	    }
	
	    try {
	      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
	      iframe = document.createElement(html);
	    } catch (e) {
	      iframe = document.createElement('iframe');
	      iframe.name = self.iframeId;
	      iframe.src = 'javascript:0';
	    }
	
	    iframe.id = self.iframeId;
	
	    self.form.appendChild(iframe);
	    self.iframe = iframe;
	  }
	
	  initIframe();
	
	  // escape \n to prevent it from being converted into \r\n by some UAs
	  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	  data = data.replace(rEscapedNewline, '\\\n');
	  this.area.value = data.replace(rNewline, '\\n');
	
	  try {
	    this.form.submit();
	  } catch (e) {}
	
	  if (this.iframe.attachEvent) {
	    this.iframe.onreadystatechange = function () {
	      if (self.iframe.readyState == 'complete') {
	        complete();
	      }
	    };
	  } else {
	    this.iframe.onload = complete;
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(222);
	var parser = __webpack_require__(223);
	var parseqs = __webpack_require__(231);
	var inherit = __webpack_require__(232);
	var yeast = __webpack_require__(233);
	var debug = __webpack_require__(202)('engine.io-client:websocket');
	var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
	
	/**
	 * Get either the `WebSocket` or `MozWebSocket` globals
	 * in the browser or try to resolve WebSocket-compatible
	 * interface exposed by `ws` for Node-like environment.
	 */
	
	var WebSocket = BrowserWebSocket;
	if (!WebSocket && typeof window === 'undefined') {
	  try {
	    WebSocket = __webpack_require__(236);
	  } catch (e) {}
	}
	
	/**
	 * Module exports.
	 */
	
	module.exports = WS;
	
	/**
	 * WebSocket transport constructor.
	 *
	 * @api {Object} connection options
	 * @api public
	 */
	
	function WS(opts) {
	  var forceBase64 = opts && opts.forceBase64;
	  if (forceBase64) {
	    this.supportsBinary = false;
	  }
	  this.perMessageDeflate = opts.perMessageDeflate;
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(WS, Transport);
	
	/**
	 * Transport name.
	 *
	 * @api public
	 */
	
	WS.prototype.name = 'websocket';
	
	/*
	 * WebSockets support binary
	 */
	
	WS.prototype.supportsBinary = true;
	
	/**
	 * Opens socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doOpen = function () {
	  if (!this.check()) {
	    // let probe timeout
	    return;
	  }
	
	  var self = this;
	  var uri = this.uri();
	  var protocols = void 0;
	  var opts = {
	    agent: this.agent,
	    perMessageDeflate: this.perMessageDeflate
	  };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  if (this.extraHeaders) {
	    opts.headers = this.extraHeaders;
	  }
	
	  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);
	
	  if (this.ws.binaryType === undefined) {
	    this.supportsBinary = false;
	  }
	
	  if (this.ws.supports && this.ws.supports.binary) {
	    this.supportsBinary = true;
	    this.ws.binaryType = 'buffer';
	  } else {
	    this.ws.binaryType = 'arraybuffer';
	  }
	
	  this.addEventListeners();
	};
	
	/**
	 * Adds event listeners to the socket
	 *
	 * @api private
	 */
	
	WS.prototype.addEventListeners = function () {
	  var self = this;
	
	  this.ws.onopen = function () {
	    self.onOpen();
	  };
	  this.ws.onclose = function () {
	    self.onClose();
	  };
	  this.ws.onmessage = function (ev) {
	    self.onData(ev.data);
	  };
	  this.ws.onerror = function (e) {
	    self.onError('websocket error', e);
	  };
	};
	
	/**
	 * Override `onData` to use a timer on iOS.
	 * See: https://gist.github.com/mloughran/2052006
	 *
	 * @api private
	 */
	
	if ('undefined' != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
	  WS.prototype.onData = function (data) {
	    var self = this;
	    setTimeout(function () {
	      Transport.prototype.onData.call(self, data);
	    }, 0);
	  };
	}
	
	/**
	 * Writes data to socket.
	 *
	 * @param {Array} array of packets.
	 * @api private
	 */
	
	WS.prototype.write = function (packets) {
	  var self = this;
	  this.writable = false;
	
	  // encodePacket efficient as it uses WS framing
	  // no need for encodePayload
	  var total = packets.length;
	  for (var i = 0, l = total; i < l; i++) {
	    (function (packet) {
	      parser.encodePacket(packet, self.supportsBinary, function (data) {
	        if (!BrowserWebSocket) {
	          // always create a new object (GH-437)
	          var opts = {};
	          if (packet.options) {
	            opts.compress = packet.options.compress;
	          }
	
	          if (self.perMessageDeflate) {
	            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
	            if (len < self.perMessageDeflate.threshold) {
	              opts.compress = false;
	            }
	          }
	        }
	
	        //Sometimes the websocket has already been closed but the browser didn't
	        //have a chance of informing us about it yet, in that case send will
	        //throw an error
	        try {
	          if (BrowserWebSocket) {
	            // TypeError is thrown when passing the second argument on Safari
	            self.ws.send(data);
	          } else {
	            self.ws.send(data, opts);
	          }
	        } catch (e) {
	          debug('websocket closed before onclose event');
	        }
	
	        --total || done();
	      });
	    })(packets[i]);
	  }
	
	  function done() {
	    self.emit('flush');
	
	    // fake drain
	    // defer to next tick to allow Socket to clear writeBuffer
	    setTimeout(function () {
	      self.writable = true;
	      self.emit('drain');
	    }, 0);
	  }
	};
	
	/**
	 * Called upon close
	 *
	 * @api private
	 */
	
	WS.prototype.onClose = function () {
	  Transport.prototype.onClose.call(this);
	};
	
	/**
	 * Closes socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doClose = function () {
	  if (typeof this.ws !== 'undefined') {
	    this.ws.close();
	  }
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	WS.prototype.uri = function () {
	  var query = this.query || {};
	  var schema = this.secure ? 'wss' : 'ws';
	  var port = '';
	
	  // avoid port if default for schema
	  if (this.port && ('wss' == schema && this.port != 443 || 'ws' == schema && this.port != 80)) {
	    port = ':' + this.port;
	  }
	
	  // append timestamp to URI
	  if (this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }
	
	  // communicate binary support capabilities
	  if (!this.supportsBinary) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};
	
	/**
	 * Feature detection for WebSocket.
	 *
	 * @return {Boolean} whether this transport is available.
	 * @api public
	 */
	
	WS.prototype.check = function () {
	  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 236 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 237 */
/***/ function(module, exports) {

	"use strict";
	
	var indexOf = [].indexOf;
	
	module.exports = function (arr, obj) {
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 238 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * JSON parse.
	 *
	 * @see Based on jQuery#parseJSON (MIT) and JSON2
	 * @api private
	 */
	
	var rvalidchars = /^[\],:{}\s]*$/;
	var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
	var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
	var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
	var rtrimLeft = /^\s+/;
	var rtrimRight = /\s+$/;
	
	module.exports = function parsejson(data) {
	  if ('string' != typeof data || !data) {
	    return null;
	  }
	
	  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');
	
	  // Attempt to parse using the native JSON parser first
	  if (global.JSON && JSON.parse) {
	    return JSON.parse(data);
	  }
	
	  if (rvalidchars.test(data.replace(rvalidescape, '@').replace(rvalidtokens, ']').replace(rvalidbraces, ''))) {
	    return new Function('return ' + data)();
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(205);
	var Emitter = __webpack_require__(240);
	var toArray = __webpack_require__(241);
	var on = __webpack_require__(242);
	var bind = __webpack_require__(243);
	var debug = __webpack_require__(202)('socket.io-client:socket');
	var hasBin = __webpack_require__(244);
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = Socket;
	
	/**
	 * Internal events (blacklisted).
	 * These events can't be emitted by the user.
	 *
	 * @api private
	 */
	
	var events = {
	  connect: 1,
	  connect_error: 1,
	  connect_timeout: 1,
	  connecting: 1,
	  disconnect: 1,
	  error: 1,
	  reconnect: 1,
	  reconnect_attempt: 1,
	  reconnect_failed: 1,
	  reconnect_error: 1,
	  reconnecting: 1,
	  ping: 1,
	  pong: 1
	};
	
	/**
	 * Shortcut to `Emitter#emit`.
	 */
	
	var emit = Emitter.prototype.emit;
	
	/**
	 * `Socket` constructor.
	 *
	 * @api public
	 */
	
	function Socket(io, nsp) {
	  this.io = io;
	  this.nsp = nsp;
	  this.json = this; // compat
	  this.ids = 0;
	  this.acks = {};
	  this.receiveBuffer = [];
	  this.sendBuffer = [];
	  this.connected = false;
	  this.disconnected = true;
	  if (this.io.autoConnect) this.open();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Subscribe to open, close and packet events
	 *
	 * @api private
	 */
	
	Socket.prototype.subEvents = function () {
	  if (this.subs) return;
	
	  var io = this.io;
	  this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];
	};
	
	/**
	 * "Opens" the socket.
	 *
	 * @api public
	 */
	
	Socket.prototype.open = Socket.prototype.connect = function () {
	  if (this.connected) return this;
	
	  this.subEvents();
	  this.io.open(); // ensure open
	  if ('open' == this.io.readyState) this.onopen();
	  this.emit('connecting');
	  return this;
	};
	
	/**
	 * Sends a `message` event.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.send = function () {
	  var args = toArray(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};
	
	/**
	 * Override `emit`.
	 * If the event is in `events`, it's emitted normally.
	 *
	 * @param {String} event name
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.emit = function (ev) {
	  if (events.hasOwnProperty(ev)) {
	    emit.apply(this, arguments);
	    return this;
	  }
	
	  var args = toArray(arguments);
	  var parserType = parser.EVENT; // default
	  if (hasBin(args)) {
	    parserType = parser.BINARY_EVENT;
	  } // binary
	  var packet = { type: parserType, data: args };
	
	  packet.options = {};
	  packet.options.compress = !this.flags || false !== this.flags.compress;
	
	  // event ack callback
	  if ('function' == typeof args[args.length - 1]) {
	    debug('emitting packet with ack id %d', this.ids);
	    this.acks[this.ids] = args.pop();
	    packet.id = this.ids++;
	  }
	
	  if (this.connected) {
	    this.packet(packet);
	  } else {
	    this.sendBuffer.push(packet);
	  }
	
	  delete this.flags;
	
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.packet = function (packet) {
	  packet.nsp = this.nsp;
	  this.io.packet(packet);
	};
	
	/**
	 * Called upon engine `open`.
	 *
	 * @api private
	 */
	
	Socket.prototype.onopen = function () {
	  debug('transport is open - connecting');
	
	  // write connect packet if necessary
	  if ('/' != this.nsp) {
	    this.packet({ type: parser.CONNECT });
	  }
	};
	
	/**
	 * Called upon engine `close`.
	 *
	 * @param {String} reason
	 * @api private
	 */
	
	Socket.prototype.onclose = function (reason) {
	  debug('close (%s)', reason);
	  this.connected = false;
	  this.disconnected = true;
	  delete this.id;
	  this.emit('disconnect', reason);
	};
	
	/**
	 * Called with socket packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onpacket = function (packet) {
	  if (packet.nsp != this.nsp) return;
	
	  switch (packet.type) {
	    case parser.CONNECT:
	      this.onconnect();
	      break;
	
	    case parser.EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.BINARY_EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.ACK:
	      this.onack(packet);
	      break;
	
	    case parser.BINARY_ACK:
	      this.onack(packet);
	      break;
	
	    case parser.DISCONNECT:
	      this.ondisconnect();
	      break;
	
	    case parser.ERROR:
	      this.emit('error', packet.data);
	      break;
	  }
	};
	
	/**
	 * Called upon a server event.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onevent = function (packet) {
	  var args = packet.data || [];
	  debug('emitting event %j', args);
	
	  if (null != packet.id) {
	    debug('attaching ack callback to event');
	    args.push(this.ack(packet.id));
	  }
	
	  if (this.connected) {
	    emit.apply(this, args);
	  } else {
	    this.receiveBuffer.push(args);
	  }
	};
	
	/**
	 * Produces an ack callback to emit with an event.
	 *
	 * @api private
	 */
	
	Socket.prototype.ack = function (id) {
	  var self = this;
	  var sent = false;
	  return function () {
	    // prevent double callbacks
	    if (sent) return;
	    sent = true;
	    var args = toArray(arguments);
	    debug('sending ack %j', args);
	
	    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
	    self.packet({
	      type: type,
	      id: id,
	      data: args
	    });
	  };
	};
	
	/**
	 * Called upon a server acknowlegement.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onack = function (packet) {
	  var ack = this.acks[packet.id];
	  if ('function' == typeof ack) {
	    debug('calling ack %s with %j', packet.id, packet.data);
	    ack.apply(this, packet.data);
	    delete this.acks[packet.id];
	  } else {
	    debug('bad ack %s', packet.id);
	  }
	};
	
	/**
	 * Called upon server connect.
	 *
	 * @api private
	 */
	
	Socket.prototype.onconnect = function () {
	  this.connected = true;
	  this.disconnected = false;
	  this.emit('connect');
	  this.emitBuffered();
	};
	
	/**
	 * Emit buffered events (received and emitted).
	 *
	 * @api private
	 */
	
	Socket.prototype.emitBuffered = function () {
	  var i;
	  for (i = 0; i < this.receiveBuffer.length; i++) {
	    emit.apply(this, this.receiveBuffer[i]);
	  }
	  this.receiveBuffer = [];
	
	  for (i = 0; i < this.sendBuffer.length; i++) {
	    this.packet(this.sendBuffer[i]);
	  }
	  this.sendBuffer = [];
	};
	
	/**
	 * Called upon server disconnect.
	 *
	 * @api private
	 */
	
	Socket.prototype.ondisconnect = function () {
	  debug('server disconnect (%s)', this.nsp);
	  this.destroy();
	  this.onclose('io server disconnect');
	};
	
	/**
	 * Called upon forced client/server side disconnections,
	 * this method ensures the manager stops tracking us and
	 * that reconnections don't get triggered for this.
	 *
	 * @api private.
	 */
	
	Socket.prototype.destroy = function () {
	  if (this.subs) {
	    // clean subscriptions to avoid reconnections
	    for (var i = 0; i < this.subs.length; i++) {
	      this.subs[i].destroy();
	    }
	    this.subs = null;
	  }
	
	  this.io.destroy(this);
	};
	
	/**
	 * Disconnects the socket manually.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.close = Socket.prototype.disconnect = function () {
	  if (this.connected) {
	    debug('performing disconnect (%s)', this.nsp);
	    this.packet({ type: parser.DISCONNECT });
	  }
	
	  // remove socket from pool
	  this.destroy();
	
	  if (this.connected) {
	    // fire events
	    this.onclose('io client disconnect');
	  }
	  return this;
	};
	
	/**
	 * Sets the compress flag.
	 *
	 * @param {Boolean} if `true`, compresses the sending data
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.compress = function (compress) {
	  this.flags = this.flags || {};
	  this.flags.compress = compress;
	  return this;
	};

/***/ },
/* 240 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function (event, fn) {
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function (event) {
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1),
	      callbacks = this._callbacks['$' + event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function (event) {
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function (event) {
	  return !!this.listeners(event).length;
	};

/***/ },
/* 241 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = toArray;
	
	function toArray(list, index) {
	    var array = [];
	
	    index = index || 0;
	
	    for (var i = index || 0; i < list.length; i++) {
	        array[i - index] = list[i];
	    }
	
	    return array;
	}

/***/ },
/* 242 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Module exports.
	 */
	
	module.exports = on;
	
	/**
	 * Helper for subscriptions.
	 *
	 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
	 * @param {String} event name
	 * @param {Function} callback
	 * @api public
	 */
	
	function on(obj, ev, fn) {
	  obj.on(ev, fn);
	  return {
	    destroy: function destroy() {
	      obj.removeListener(ev, fn);
	    }
	  };
	}

/***/ },
/* 243 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Slice reference.
	 */
	
	var slice = [].slice;
	
	/**
	 * Bind `obj` to `fn`.
	 *
	 * @param {Object} obj
	 * @param {Function|String} fn or string
	 * @return {Function}
	 * @api public
	 */
	
	module.exports = function (obj, fn) {
	  if ('string' == typeof fn) fn = obj[fn];
	  if ('function' != typeof fn) throw new Error('bind() requires a function');
	  var args = slice.call(arguments, 2);
	  return function () {
	    return fn.apply(obj, args.concat(slice.call(arguments)));
	  };
	};

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/*
	 * Module requirements.
	 */
	
	var isArray = __webpack_require__(209);
	
	/**
	 * Module exports.
	 */
	
	module.exports = hasBinary;
	
	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */
	
	function hasBinary(data) {
	
	  function _hasBinary(obj) {
	    if (!obj) return false;
	
	    if (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer || global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
	      return true;
	    }
	
	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	        if (_hasBinary(obj[i])) {
	          return true;
	        }
	      }
	    } else if (obj && 'object' == (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) {
	      // see: https://github.com/Automattic/has-binary/pull/4
	      if (obj.toJSON && 'function' == typeof obj.toJSON) {
	        obj = obj.toJSON();
	      }
	
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  }
	
	  return _hasBinary(data);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 245 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Expose `Backoff`.
	 */
	
	module.exports = Backoff;
	
	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}
	
	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */
	
	Backoff.prototype.duration = function () {
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand = Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};
	
	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */
	
	Backoff.prototype.reset = function () {
	  this.attempts = 0;
	};
	
	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMin = function (min) {
	  this.ms = min;
	};
	
	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMax = function (max) {
	  this.max = max;
	};
	
	/**
	 * Set the jitter
	 *
	 * @api public
	 */
	
	Backoff.prototype.setJitter = function (jitter) {
	  this.jitter = jitter;
	};

/***/ },
/* 246 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var CONNECT = exports.CONNECT = 'CONNECT';
	var DISCONNECT = exports.DISCONNECT = 'DISCONNECT';
	var POST_MESSAGE = exports.POST_MESSAGE = 'POST_MESSAGE';
	var RECEIVE_MESSAGE = exports.RECEIVE_MESSAGE = 'RECEIVE_MESSAGE';
	var UPDATE = exports.UPDATE = 'UPDATE';

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _redux = __webpack_require__(179);
	
	function socket() {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var action = arguments[1];
	
	  switch (action.type) {
	    case 'CONNECT':
	      return action.socket;
	    case 'DISCONNECT':
	      return {};
	    default:
	      return state;
	  }
	}
	
	function display() {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];
	  var action = arguments[1];
	
	  switch (action.type) {
	    case 'UPDATE':
	      return action.name;
	    default:
	      return state;
	  }
	}
	
	exports.default = (0, _redux.combineReducers)({
	  display: display,
	  socket: socket
	});

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNzNjMGNiNjdlOGYwYjNhMmU0MjYiLCJ3ZWJwYWNrOi8vLy4vYXBwLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvcmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9LZXlFc2NhcGVVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHVyZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENsYXNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9rZXlNaXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9rZXlPZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnRGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRJbmplY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9FdmVudENvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVycm9yVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvYWNjdW11bGF0ZUludG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DYWxsYmFja1F1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFJlZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE93bmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5zdHJ1bWVudGF0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RGVidWdUb29sLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3BlcmZvcm1hbmNlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50VGFyZ2V0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2lzRXZlbnRTdXBwb3J0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvaXNUZXh0SW5wdXRFbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY1VJRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvVmlld3BvcnRNZXRyaWNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0RPTUxhenlUcmVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0RPTU5hbWVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2V0SW5uZXJIVE1MLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2V0VGV4dENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0Rhbmdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvZ2V0TWFya3VwV3JhcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9BdXRvRm9jdXNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NhbWVsaXplLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01CdXR0b24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRGlzYWJsZWRJbnB1dFV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NSW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvTGlua2VkVmFsdWVVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTU9wdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTVNlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTVRleHRhcmVhLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TXVsdGlDaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE5vZGVUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SG9zdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9mbGF0dGVuQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01UcmVlVHJhdmVyc2FsLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5wdXRTZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NWR0RPTVByb3BlcnR5Q29uZmlnLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljS2V5Ym9hcmRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudENoYXJDb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50S2V5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNUb3VjaEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TW91bnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NRmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TWFya3VwQ2hlY2tzdW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvYWRsZXIzMi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9maW5kRE9NTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvbGliL2NvbXBvbmVudHMvUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvc3RvcmVTaGFwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvbGliL2NvbXBvbmVudHMvY29ubmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy9zaGFsbG93RXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvd3JhcEFjdGlvbkNyZWF0b3JzLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2NyZWF0ZVN0b3JlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNIb3N0T2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc3ltYm9sLW9ic2VydmFibGUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc3ltYm9sLW9ic2VydmFibGUvbGliL3BvbnlmaWxsLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2NvbWJpbmVSZWR1Y2Vycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2JpbmRBY3Rpb25DcmVhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9hcHBseU1pZGRsZXdhcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvY29tcG9zZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vaW52YXJpYW50L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC10aHVuay9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9BcHAuanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzIiwid2VicGFjazovLy8uL34vcGFyc2V1cmkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9kZWJ1Zy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZGVidWcvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1wYXJzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tcGFyc2VyL34vanNvbjMvbGliL2pzb24zLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzIiwid2VicGFjazovLy8uL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tcGFyc2VyL2lzLWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvbGliL21hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oYXMtY29ycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy14aHIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1wYXJzZXIvfi9oYXMtYmluYXJ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FmdGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdXRmOC91dGY4LmpzIiwid2VicGFjazovLy8uL34vYmxvYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlcXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3llYXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanMiLCJ3ZWJwYWNrOi8vL3dzIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vLi9+L2luZGV4b2YvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZWpzb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi90by1hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzIiwid2VicGFjazovLy8uL34vY29tcG9uZW50LWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oYXMtYmluYXJ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYmFja28yL2luZGV4LmpzIiwid2VicGFjazovLy8uL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9yZWR1Y2Vycy5qcyJdLCJuYW1lcyI6WyJzdG9yZSIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIl9hc3NpZ24iLCJSZWFjdENoaWxkcmVuIiwiUmVhY3RDb21wb25lbnQiLCJSZWFjdFB1cmVDb21wb25lbnQiLCJSZWFjdENsYXNzIiwiUmVhY3RET01GYWN0b3JpZXMiLCJSZWFjdEVsZW1lbnQiLCJSZWFjdFByb3BUeXBlcyIsIlJlYWN0VmVyc2lvbiIsIm9ubHlDaGlsZCIsIndhcm5pbmciLCJjcmVhdGVFbGVtZW50IiwiY3JlYXRlRmFjdG9yeSIsImNsb25lRWxlbWVudCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIlJlYWN0RWxlbWVudFZhbGlkYXRvciIsIl9fc3ByZWFkIiwid2FybmVkIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJSZWFjdCIsIkNoaWxkcmVuIiwibWFwIiwiZm9yRWFjaCIsImNvdW50IiwidG9BcnJheSIsIm9ubHkiLCJDb21wb25lbnQiLCJQdXJlQ29tcG9uZW50IiwiaXNWYWxpZEVsZW1lbnQiLCJQcm9wVHlwZXMiLCJjcmVhdGVDbGFzcyIsImNyZWF0ZU1peGluIiwibWl4aW4iLCJET00iLCJ2ZXJzaW9uIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJ0aXRsZSIsImJyb3dzZXIiLCJhcmd2IiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJiaW5kaW5nIiwibmFtZSIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siLCJoYXNPd25Qcm9wZXJ0eSIsIk9iamVjdCIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvT2JqZWN0IiwidmFsIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwic2hvdWxkVXNlTmF0aXZlIiwiYXNzaWduIiwidGVzdDEiLCJTdHJpbmciLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidGVzdDIiLCJmcm9tQ2hhckNvZGUiLCJvcmRlcjIiLCJuIiwiam9pbiIsInRlc3QzIiwic3BsaXQiLCJsZXR0ZXIiLCJrZXlzIiwidGFyZ2V0Iiwic291cmNlIiwiZnJvbSIsInRvIiwic3ltYm9scyIsInMiLCJrZXkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJQb29sZWRDbGFzcyIsImVtcHR5RnVuY3Rpb24iLCJ0cmF2ZXJzZUFsbENoaWxkcmVuIiwidHdvQXJndW1lbnRQb29sZXIiLCJmb3VyQXJndW1lbnRQb29sZXIiLCJ1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCIsImVzY2FwZVVzZXJQcm92aWRlZEtleSIsInRleHQiLCJyZXBsYWNlIiwiRm9yRWFjaEJvb2tLZWVwaW5nIiwiZm9yRWFjaEZ1bmN0aW9uIiwiZm9yRWFjaENvbnRleHQiLCJmdW5jIiwiY29udGV4dCIsImRlc3RydWN0b3IiLCJhZGRQb29saW5nVG8iLCJmb3JFYWNoU2luZ2xlQ2hpbGQiLCJib29rS2VlcGluZyIsImNoaWxkIiwiZm9yRWFjaENoaWxkcmVuIiwiY2hpbGRyZW4iLCJmb3JFYWNoRnVuYyIsInRyYXZlcnNlQ29udGV4dCIsImdldFBvb2xlZCIsInJlbGVhc2UiLCJNYXBCb29rS2VlcGluZyIsIm1hcFJlc3VsdCIsImtleVByZWZpeCIsIm1hcEZ1bmN0aW9uIiwibWFwQ29udGV4dCIsInJlc3VsdCIsIm1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJjaGlsZEtleSIsIm1hcHBlZENoaWxkIiwiaXNBcnJheSIsIm1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwiLCJ0aGF0UmV0dXJuc0FyZ3VtZW50IiwiY2xvbmVBbmRSZXBsYWNlS2V5IiwicHJlZml4IiwiZXNjYXBlZFByZWZpeCIsIm1hcENoaWxkcmVuIiwiZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkiLCJjb3VudENoaWxkcmVuIiwiX3Byb2RJbnZhcmlhbnQiLCJpbnZhcmlhbnQiLCJvbmVBcmd1bWVudFBvb2xlciIsImNvcHlGaWVsZHNGcm9tIiwiS2xhc3MiLCJpbnN0YW5jZVBvb2wiLCJpbnN0YW5jZSIsInBvcCIsImExIiwiYTIiLCJ0aHJlZUFyZ3VtZW50UG9vbGVyIiwiYTMiLCJhNCIsImZpdmVBcmd1bWVudFBvb2xlciIsImE1Iiwic3RhbmRhcmRSZWxlYXNlciIsInBvb2xTaXplIiwiREVGQVVMVF9QT09MX1NJWkUiLCJERUZBVUxUX1BPT0xFUiIsIkNvcHlDb25zdHJ1Y3RvciIsInBvb2xlciIsIk5ld0tsYXNzIiwicmVhY3RQcm9kSW52YXJpYW50IiwiY29kZSIsImFyZ0NvdW50IiwibWVzc2FnZSIsImFyZ0lkeCIsImVuY29kZVVSSUNvbXBvbmVudCIsImVycm9yIiwiZnJhbWVzVG9Qb3AiLCJjb25kaXRpb24iLCJmb3JtYXQiLCJhIiwiYiIsImMiLCJkIiwiZiIsImFyZ0luZGV4IiwiUmVhY3RDdXJyZW50T3duZXIiLCJjYW5EZWZpbmVQcm9wZXJ0eSIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlN5bWJvbCIsIlJFU0VSVkVEX1BST1BTIiwicmVmIiwiX19zZWxmIiwiX19zb3VyY2UiLCJzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biIsInNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5IiwiZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIiLCJwcm9wcyIsImRpc3BsYXlOYW1lIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ1JlZiIsInR5cGUiLCJzZWxmIiwib3duZXIiLCJlbGVtZW50IiwiJCR0eXBlb2YiLCJfb3duZXIiLCJfc3RvcmUiLCJzaGFkb3dDaGlsZHJlbiIsInNsaWNlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJ2YWxpZGF0ZWQiLCJfc2VsZiIsIl9zaGFkb3dDaGlsZHJlbiIsIl9zb3VyY2UiLCJmcmVlemUiLCJwcm9wTmFtZSIsIl9fcHJvdG9fXyIsImNoaWxkcmVuTGVuZ3RoIiwiY2hpbGRBcnJheSIsImRlZmF1bHRQcm9wcyIsImN1cnJlbnQiLCJmYWN0b3J5IiwiYmluZCIsIm9sZEVsZW1lbnQiLCJuZXdLZXkiLCJuZXdFbGVtZW50Iiwib2JqZWN0IiwicHJpbnRXYXJuaW5nIiwiX2xlbiIsIl9rZXkiLCJjb25zb2xlIiwieCIsImluZGV4T2YiLCJfbGVuMiIsIl9rZXkyIiwibWFrZUVtcHR5RnVuY3Rpb24iLCJhcmciLCJ0aGF0UmV0dXJucyIsInRoYXRSZXR1cm5zRmFsc2UiLCJ0aGF0UmV0dXJuc1RydWUiLCJ0aGF0UmV0dXJuc051bGwiLCJ0aGF0UmV0dXJuc1RoaXMiLCJnZXRJdGVyYXRvckZuIiwiS2V5RXNjYXBlVXRpbHMiLCJTRVBBUkFUT1IiLCJTVUJTRVBBUkFUT1IiLCJkaWRXYXJuQWJvdXRNYXBzIiwiZ2V0Q29tcG9uZW50S2V5IiwiY29tcG9uZW50IiwiaW5kZXgiLCJlc2NhcGUiLCJ0b1N0cmluZyIsInRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsIiwibmFtZVNvRmFyIiwiY2FsbGJhY2siLCJuZXh0TmFtZSIsInN1YnRyZWVDb3VudCIsIm5leHROYW1lUHJlZml4IiwiaXRlcmF0b3JGbiIsIml0ZXJhdG9yIiwic3RlcCIsImVudHJpZXMiLCJpaSIsIm5leHQiLCJkb25lIiwibWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSIsIm1hcHNBc0NoaWxkcmVuT3duZXJOYW1lIiwiZ2V0TmFtZSIsImVudHJ5IiwiYWRkZW5kdW0iLCJfaXNSZWFjdEVsZW1lbnQiLCJjaGlsZHJlblN0cmluZyIsIklURVJBVE9SX1NZTUJPTCIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwibWF5YmVJdGVyYWJsZSIsImVzY2FwZVJlZ2V4IiwiZXNjYXBlckxvb2t1cCIsImVzY2FwZWRTdHJpbmciLCJtYXRjaCIsInVuZXNjYXBlIiwidW5lc2NhcGVSZWdleCIsInVuZXNjYXBlckxvb2t1cCIsImtleVN1YnN0cmluZyIsInN1YnN0cmluZyIsIlJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIiwiZW1wdHlPYmplY3QiLCJ1cGRhdGVyIiwicmVmcyIsImlzUmVhY3RDb21wb25lbnQiLCJzZXRTdGF0ZSIsInBhcnRpYWxTdGF0ZSIsImVucXVldWVTZXRTdGF0ZSIsImVucXVldWVDYWxsYmFjayIsImZvcmNlVXBkYXRlIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiZGVwcmVjYXRlZEFQSXMiLCJpc01vdW50ZWQiLCJyZXBsYWNlU3RhdGUiLCJkZWZpbmVEZXByZWNhdGlvbldhcm5pbmciLCJtZXRob2ROYW1lIiwiaW5mbyIsImZuTmFtZSIsIndhcm5Ob29wIiwicHVibGljSW5zdGFuY2UiLCJjYWxsZXJOYW1lIiwiY29uc3RydWN0b3IiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiY29tcGxldGVTdGF0ZSIsIkNvbXBvbmVudER1bW15IiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJSZWFjdFByb3BUeXBlTG9jYXRpb25zIiwiUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMiLCJrZXlNaXJyb3IiLCJrZXlPZiIsIk1JWElOU19LRVkiLCJtaXhpbnMiLCJTcGVjUG9saWN5IiwiREVGSU5FX09OQ0UiLCJERUZJTkVfTUFOWSIsIk9WRVJSSURFX0JBU0UiLCJERUZJTkVfTUFOWV9NRVJHRUQiLCJpbmplY3RlZE1peGlucyIsIlJlYWN0Q2xhc3NJbnRlcmZhY2UiLCJzdGF0aWNzIiwicHJvcFR5cGVzIiwiY29udGV4dFR5cGVzIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJnZXREZWZhdWx0UHJvcHMiLCJnZXRJbml0aWFsU3RhdGUiLCJnZXRDaGlsZENvbnRleHQiLCJyZW5kZXIiLCJjb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJ1cGRhdGVDb21wb25lbnQiLCJSRVNFUlZFRF9TUEVDX0tFWVMiLCJDb25zdHJ1Y3RvciIsIm1peFNwZWNJbnRvQ29tcG9uZW50IiwidmFsaWRhdGVUeXBlRGVmIiwiY2hpbGRDb250ZXh0IiwiY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24iLCJwcm9wIiwibWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQiLCJhdXRvYmluZCIsInR5cGVEZWYiLCJsb2NhdGlvbiIsInZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUiLCJpc0FscmVhZHlEZWZpbmVkIiwic3BlY1BvbGljeSIsIlJlYWN0Q2xhc3NNaXhpbiIsInNwZWMiLCJ0eXBlb2ZTcGVjIiwiaXNNaXhpblZhbGlkIiwicHJvdG8iLCJhdXRvQmluZFBhaXJzIiwiX19yZWFjdEF1dG9CaW5kUGFpcnMiLCJwcm9wZXJ0eSIsImlzUmVhY3RDbGFzc01ldGhvZCIsImlzRnVuY3Rpb24iLCJzaG91bGRBdXRvQmluZCIsImNyZWF0ZUNoYWluZWRGdW5jdGlvbiIsImlzUmVzZXJ2ZWQiLCJpc0luaGVyaXRlZCIsIm1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMiLCJvbmUiLCJ0d28iLCJtZXJnZWRSZXN1bHQiLCJjaGFpbmVkRnVuY3Rpb24iLCJiaW5kQXV0b0JpbmRNZXRob2QiLCJtZXRob2QiLCJib3VuZE1ldGhvZCIsIl9fcmVhY3RCb3VuZENvbnRleHQiLCJfX3JlYWN0Qm91bmRNZXRob2QiLCJfX3JlYWN0Qm91bmRBcmd1bWVudHMiLCJjb21wb25lbnROYW1lIiwiX2JpbmQiLCJuZXdUaGlzIiwicmVib3VuZE1ldGhvZCIsImJpbmRBdXRvQmluZE1ldGhvZHMiLCJwYWlycyIsImF1dG9CaW5kS2V5IiwibmV3U3RhdGUiLCJSZWFjdENsYXNzQ29tcG9uZW50Iiwic3RhdGUiLCJpbml0aWFsU3RhdGUiLCJfaXNNb2NrRnVuY3Rpb24iLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJpbmplY3Rpb24iLCJpbmplY3RNaXhpbiIsIm9iaiIsInJldCIsIm9uZUtleU9iaiIsImNyZWF0ZURPTUZhY3RvcnkiLCJhYmJyIiwiYWRkcmVzcyIsImFyZWEiLCJhcnRpY2xlIiwiYXNpZGUiLCJhdWRpbyIsImJhc2UiLCJiZGkiLCJiZG8iLCJiaWciLCJibG9ja3F1b3RlIiwiYm9keSIsImJyIiwiYnV0dG9uIiwiY2FudmFzIiwiY2FwdGlvbiIsImNpdGUiLCJjb2wiLCJjb2xncm91cCIsImRhdGEiLCJkYXRhbGlzdCIsImRkIiwiZGVsIiwiZGV0YWlscyIsImRmbiIsImRpYWxvZyIsImRpdiIsImRsIiwiZHQiLCJlbSIsImVtYmVkIiwiZmllbGRzZXQiLCJmaWdjYXB0aW9uIiwiZmlndXJlIiwiZm9vdGVyIiwiZm9ybSIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImhlYWQiLCJoZWFkZXIiLCJoZ3JvdXAiLCJociIsImh0bWwiLCJpZnJhbWUiLCJpbWciLCJpbnB1dCIsImlucyIsImtiZCIsImtleWdlbiIsImxhYmVsIiwibGVnZW5kIiwibGkiLCJsaW5rIiwibWFpbiIsIm1hcmsiLCJtZW51IiwibWVudWl0ZW0iLCJtZXRhIiwibWV0ZXIiLCJuYXYiLCJub3NjcmlwdCIsIm9sIiwib3B0Z3JvdXAiLCJvcHRpb24iLCJvdXRwdXQiLCJwIiwicGFyYW0iLCJwaWN0dXJlIiwicHJlIiwicHJvZ3Jlc3MiLCJxIiwicnAiLCJydCIsInJ1YnkiLCJzYW1wIiwic2NyaXB0Iiwic2VjdGlvbiIsInNlbGVjdCIsInNtYWxsIiwic3BhbiIsInN0cm9uZyIsInN0eWxlIiwic3ViIiwic3VtbWFyeSIsInN1cCIsInRhYmxlIiwidGJvZHkiLCJ0ZCIsInRleHRhcmVhIiwidGZvb3QiLCJ0aCIsInRoZWFkIiwidGltZSIsInRyIiwidHJhY2siLCJ1IiwidWwiLCJ2aWRlbyIsIndiciIsImNpcmNsZSIsImNsaXBQYXRoIiwiZGVmcyIsImVsbGlwc2UiLCJnIiwiaW1hZ2UiLCJsaW5lIiwibGluZWFyR3JhZGllbnQiLCJtYXNrIiwicGF0aCIsInBhdHRlcm4iLCJwb2x5Z29uIiwicG9seWxpbmUiLCJyYWRpYWxHcmFkaWVudCIsInJlY3QiLCJzdG9wIiwic3ZnIiwidHNwYW4iLCJSZWFjdENvbXBvbmVudFRyZWVIb29rIiwiY2hlY2tSZWFjdFR5cGVTcGVjIiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwiZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsInBhcmVudFR5cGUiLCJwYXJlbnROYW1lIiwidmFsaWRhdGVFeHBsaWNpdEtleSIsIm1lbW9pemVyIiwidW5pcXVlS2V5IiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJnZXRDdXJyZW50U3RhY2tBZGRlbmR1bSIsInZhbGlkYXRlQ2hpbGRLZXlzIiwibm9kZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwiY29tcG9uZW50Q2xhc3MiLCJ2YWxpZFR5cGUiLCJ2YWxpZGF0ZWRGYWN0b3J5IiwiaXNOYXRpdmUiLCJmbiIsImZ1bmNUb1N0cmluZyIsIkZ1bmN0aW9uIiwicmVJc05hdGl2ZSIsIlJlZ0V4cCIsInRlc3QiLCJlcnIiLCJjYW5Vc2VDb2xsZWN0aW9ucyIsIk1hcCIsIlNldCIsIml0ZW1NYXAiLCJyb290SURTZXQiLCJpdGVtQnlLZXkiLCJyb290QnlLZXkiLCJ1bm1vdW50ZWRJRHMiLCJnZXRLZXlGcm9tSUQiLCJpZCIsImdldElERnJvbUtleSIsInBhcnNlSW50Iiwic3Vic3RyIiwicmVtb3ZlIiwiY3JlYXRlIiwicGFyZW50SUQiLCJpdGVtIiwiY2hpbGRJRHMiLCJ1cGRhdGVDb3VudCIsInNldCIsImFkZFJvb3QiLCJhZGQiLCJyZW1vdmVSb290IiwiZ2V0UmVnaXN0ZXJlZElEcyIsImdldFJvb3RJRHMiLCJwdXJnZURlZXAiLCJkZXNjcmliZUNvbXBvbmVudEZyYW1lIiwib3duZXJOYW1lIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiZ2V0RGlzcGxheU5hbWUiLCJkZXNjcmliZUlEIiwiZ2V0RWxlbWVudCIsIm93bmVySUQiLCJnZXRPd25lcklEIiwib25TZXRDaGlsZHJlbiIsIm5leHRDaGlsZElEcyIsIm5leHRDaGlsZElEIiwibmV4dENoaWxkIiwib25CZWZvcmVNb3VudENvbXBvbmVudCIsIm9uQmVmb3JlVXBkYXRlQ29tcG9uZW50Iiwib25Nb3VudENvbXBvbmVudCIsImlzUm9vdCIsIm9uVXBkYXRlQ29tcG9uZW50Iiwib25Vbm1vdW50Q29tcG9uZW50IiwicHVyZ2VVbm1vdW50ZWRDb21wb25lbnRzIiwiX3ByZXZlbnRQdXJnaW5nIiwidG9wRWxlbWVudCIsImN1cnJlbnRPd25lciIsIl9kZWJ1Z0lEIiwiZ2V0U3RhY2tBZGRlbmR1bUJ5SUQiLCJnZXRQYXJlbnRJRCIsImdldENoaWxkSURzIiwiZ2V0U291cmNlIiwiZ2V0VGV4dCIsImdldFVwZGF0ZUNvdW50IiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJkZWJ1Z0lEIiwidHlwZVNwZWNOYW1lIiwiZXgiLCJjb21wb25lbnRTdGFja0luZm8iLCJBTk9OWU1PVVMiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsImJvb2wiLCJudW1iZXIiLCJzdHJpbmciLCJzeW1ib2wiLCJhbnkiLCJjcmVhdGVBbnlUeXBlQ2hlY2tlciIsImFycmF5T2YiLCJjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIiLCJjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIiLCJpbnN0YW5jZU9mIiwiY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlciIsImNyZWF0ZU5vZGVDaGVja2VyIiwib2JqZWN0T2YiLCJjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyIiwib25lT2YiLCJjcmVhdGVFbnVtVHlwZUNoZWNrZXIiLCJvbmVPZlR5cGUiLCJjcmVhdGVVbmlvblR5cGVDaGVja2VyIiwic2hhcGUiLCJjcmVhdGVTaGFwZVR5cGVDaGVja2VyIiwiaXMiLCJ5IiwiUHJvcFR5cGVFcnJvciIsInN0YWNrIiwiY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIiLCJ2YWxpZGF0ZSIsIm1hbnVhbFByb3BUeXBlQ2FsbENhY2hlIiwiY2hlY2tUeXBlIiwiaXNSZXF1aXJlZCIsInByb3BGdWxsTmFtZSIsInNlY3JldCIsImNhY2hlS2V5IiwibG9jYXRpb25OYW1lIiwiY2hhaW5lZENoZWNrVHlwZSIsImV4cGVjdGVkVHlwZSIsInByb3BWYWx1ZSIsInByb3BUeXBlIiwiZ2V0UHJvcFR5cGUiLCJwcmVjaXNlVHlwZSIsImdldFByZWNpc2VUeXBlIiwidHlwZUNoZWNrZXIiLCJleHBlY3RlZENsYXNzIiwiZXhwZWN0ZWRDbGFzc05hbWUiLCJhY3R1YWxDbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJleHBlY3RlZFZhbHVlcyIsInZhbHVlc1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsImlzTm9kZSIsInNoYXBlVHlwZXMiLCJldmVyeSIsImlzU3ltYm9sIiwiRGF0ZSIsIlJlYWN0RE9NQ29tcG9uZW50VHJlZSIsIlJlYWN0RGVmYXVsdEluamVjdGlvbiIsIlJlYWN0TW91bnQiLCJSZWFjdFJlY29uY2lsZXIiLCJSZWFjdFVwZGF0ZXMiLCJmaW5kRE9NTm9kZSIsImdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlIiwicmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJpbmplY3QiLCJSZWFjdERPTSIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsImJhdGNoZWRVcGRhdGVzIiwidW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJDb21wb25lbnRUcmVlIiwiZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUiLCJnZXROb2RlRnJvbUluc3RhbmNlIiwiaW5zdCIsIl9yZW5kZXJlZENvbXBvbmVudCIsIk1vdW50IiwiUmVjb25jaWxlciIsIkV4ZWN1dGlvbkVudmlyb25tZW50IiwiY2FuVXNlRE9NIiwid2luZG93IiwidG9wIiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwic2hvd0ZpbGVVcmxNZXNzYWdlIiwicHJvdG9jb2wiLCJkZWJ1ZyIsInRlc3RGdW5jIiwidGVzdEZuIiwiaWVDb21wYXRpYmlsaXR5TW9kZSIsImRvY3VtZW50TW9kZSIsImV4cGVjdGVkRmVhdHVyZXMiLCJub3ciLCJ0cmltIiwiUmVhY3RJbnN0cnVtZW50YXRpb24iLCJSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2siLCJSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2siLCJkZWJ1Z1Rvb2wiLCJhZGRIb29rIiwiRE9NUHJvcGVydHkiLCJSZWFjdERPTUNvbXBvbmVudEZsYWdzIiwiQVRUUl9OQU1FIiwiSURfQVRUUklCVVRFX05BTUUiLCJGbGFncyIsImludGVybmFsSW5zdGFuY2VLZXkiLCJNYXRoIiwicmFuZG9tIiwiZ2V0UmVuZGVyZWRIb3N0T3JUZXh0RnJvbUNvbXBvbmVudCIsInJlbmRlcmVkIiwicHJlY2FjaGVOb2RlIiwiaG9zdEluc3QiLCJfaG9zdE5vZGUiLCJ1bmNhY2hlTm9kZSIsInByZWNhY2hlQ2hpbGROb2RlcyIsIl9mbGFncyIsImhhc0NhY2hlZENoaWxkTm9kZXMiLCJfcmVuZGVyZWRDaGlsZHJlbiIsImNoaWxkTm9kZSIsImZpcnN0Q2hpbGQiLCJvdXRlciIsImNoaWxkSW5zdCIsImNoaWxkSUQiLCJfZG9tSUQiLCJuZXh0U2libGluZyIsIm5vZGVUeXBlIiwiZ2V0QXR0cmlidXRlIiwibm9kZVZhbHVlIiwicGFyZW50cyIsInBhcmVudE5vZGUiLCJjbG9zZXN0IiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSIsIl9ob3N0UGFyZW50IiwiY2hlY2tNYXNrIiwiYml0bWFzayIsIkRPTVByb3BlcnR5SW5qZWN0aW9uIiwiTVVTVF9VU0VfUFJPUEVSVFkiLCJIQVNfQk9PTEVBTl9WQUxVRSIsIkhBU19OVU1FUklDX1ZBTFVFIiwiSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUiLCJIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFIiwiaW5qZWN0RE9NUHJvcGVydHlDb25maWciLCJkb21Qcm9wZXJ0eUNvbmZpZyIsIkluamVjdGlvbiIsIlByb3BlcnRpZXMiLCJET01BdHRyaWJ1dGVOYW1lc3BhY2VzIiwiRE9NQXR0cmlidXRlTmFtZXMiLCJET01Qcm9wZXJ0eU5hbWVzIiwiRE9NTXV0YXRpb25NZXRob2RzIiwiaXNDdXN0b21BdHRyaWJ1dGUiLCJfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMiLCJwcm9wZXJ0aWVzIiwibG93ZXJDYXNlZCIsInRvTG93ZXJDYXNlIiwicHJvcENvbmZpZyIsInByb3BlcnR5SW5mbyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVOYW1lc3BhY2UiLCJwcm9wZXJ0eU5hbWUiLCJtdXRhdGlvbk1ldGhvZCIsIm11c3RVc2VQcm9wZXJ0eSIsImhhc0Jvb2xlYW5WYWx1ZSIsImhhc051bWVyaWNWYWx1ZSIsImhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlIiwiaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSIsImdldFBvc3NpYmxlU3RhbmRhcmROYW1lIiwiQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiIsIlJPT1RfQVRUUklCVVRFX05BTUUiLCJBVFRSSUJVVEVfTkFNRV9DSEFSIiwiaXNDdXN0b21BdHRyaWJ1dGVGbiIsIkJlZm9yZUlucHV0RXZlbnRQbHVnaW4iLCJDaGFuZ2VFdmVudFBsdWdpbiIsIkRlZmF1bHRFdmVudFBsdWdpbk9yZGVyIiwiRW50ZXJMZWF2ZUV2ZW50UGx1Z2luIiwiSFRNTERPTVByb3BlcnR5Q29uZmlnIiwiUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQiLCJSZWFjdERPTUNvbXBvbmVudCIsIlJlYWN0RE9NRW1wdHlDb21wb25lbnQiLCJSZWFjdERPTVRyZWVUcmF2ZXJzYWwiLCJSZWFjdERPTVRleHRDb21wb25lbnQiLCJSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5IiwiUmVhY3RFdmVudExpc3RlbmVyIiwiUmVhY3RJbmplY3Rpb24iLCJSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uIiwiU1ZHRE9NUHJvcGVydHlDb25maWciLCJTZWxlY3RFdmVudFBsdWdpbiIsIlNpbXBsZUV2ZW50UGx1Z2luIiwiYWxyZWFkeUluamVjdGVkIiwiRXZlbnRFbWl0dGVyIiwiaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyIiwiRXZlbnRQbHVnaW5IdWIiLCJpbmplY3RFdmVudFBsdWdpbk9yZGVyIiwiRXZlbnRQbHVnaW5VdGlscyIsImluamVjdENvbXBvbmVudFRyZWUiLCJpbmplY3RUcmVlVHJhdmVyc2FsIiwiaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lIiwiSG9zdENvbXBvbmVudCIsImluamVjdEdlbmVyaWNDb21wb25lbnRDbGFzcyIsImluamVjdFRleHRDb21wb25lbnRDbGFzcyIsIkVtcHR5Q29tcG9uZW50IiwiaW5qZWN0RW1wdHlDb21wb25lbnRGYWN0b3J5IiwiaW5zdGFudGlhdGUiLCJVcGRhdGVzIiwiaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24iLCJpbmplY3RCYXRjaGluZ1N0cmF0ZWd5IiwiaW5qZWN0RW52aXJvbm1lbnQiLCJFdmVudENvbnN0YW50cyIsIkV2ZW50UHJvcGFnYXRvcnMiLCJGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUiLCJTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50IiwiU3ludGhldGljSW5wdXRFdmVudCIsIkVORF9LRVlDT0RFUyIsIlNUQVJUX0tFWUNPREUiLCJjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IiwiY2FuVXNlVGV4dElucHV0RXZlbnQiLCJpc1ByZXN0byIsInVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhIiwib3BlcmEiLCJTUEFDRUJBUl9DT0RFIiwiU1BBQ0VCQVJfQ0hBUiIsInRvcExldmVsVHlwZXMiLCJldmVudFR5cGVzIiwiYmVmb3JlSW5wdXQiLCJwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyIsImJ1YmJsZWQiLCJvbkJlZm9yZUlucHV0IiwiY2FwdHVyZWQiLCJvbkJlZm9yZUlucHV0Q2FwdHVyZSIsImRlcGVuZGVuY2llcyIsInRvcENvbXBvc2l0aW9uRW5kIiwidG9wS2V5UHJlc3MiLCJ0b3BUZXh0SW5wdXQiLCJ0b3BQYXN0ZSIsImNvbXBvc2l0aW9uRW5kIiwib25Db21wb3NpdGlvbkVuZCIsIm9uQ29tcG9zaXRpb25FbmRDYXB0dXJlIiwidG9wQmx1ciIsInRvcEtleURvd24iLCJ0b3BLZXlVcCIsInRvcE1vdXNlRG93biIsImNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlIiwidG9wQ29tcG9zaXRpb25TdGFydCIsImNvbXBvc2l0aW9uVXBkYXRlIiwib25Db21wb3NpdGlvblVwZGF0ZSIsIm9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlIiwidG9wQ29tcG9zaXRpb25VcGRhdGUiLCJoYXNTcGFjZUtleXByZXNzIiwiaXNLZXlwcmVzc0NvbW1hbmQiLCJuYXRpdmVFdmVudCIsImN0cmxLZXkiLCJhbHRLZXkiLCJtZXRhS2V5IiwiZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUiLCJ0b3BMZXZlbFR5cGUiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCIsImtleUNvZGUiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQiLCJnZXREYXRhRnJvbUN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiY3VycmVudENvbXBvc2l0aW9uIiwiZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQiLCJ0YXJnZXRJbnN0IiwibmF0aXZlRXZlbnRUYXJnZXQiLCJldmVudFR5cGUiLCJmYWxsYmFja0RhdGEiLCJnZXREYXRhIiwiZXZlbnQiLCJjdXN0b21EYXRhIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyIsImdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMiLCJ3aGljaCIsImNoYXJzIiwiZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzIiwiZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQiLCJleHRyYWN0RXZlbnRzIiwiUHJvcGFnYXRpb25QaGFzZXMiLCJ0b3BBYm9ydCIsInRvcEFuaW1hdGlvbkVuZCIsInRvcEFuaW1hdGlvbkl0ZXJhdGlvbiIsInRvcEFuaW1hdGlvblN0YXJ0IiwidG9wQ2FuUGxheSIsInRvcENhblBsYXlUaHJvdWdoIiwidG9wQ2hhbmdlIiwidG9wQ2xpY2siLCJ0b3BDb250ZXh0TWVudSIsInRvcENvcHkiLCJ0b3BDdXQiLCJ0b3BEb3VibGVDbGljayIsInRvcERyYWciLCJ0b3BEcmFnRW5kIiwidG9wRHJhZ0VudGVyIiwidG9wRHJhZ0V4aXQiLCJ0b3BEcmFnTGVhdmUiLCJ0b3BEcmFnT3ZlciIsInRvcERyYWdTdGFydCIsInRvcERyb3AiLCJ0b3BEdXJhdGlvbkNoYW5nZSIsInRvcEVtcHRpZWQiLCJ0b3BFbmNyeXB0ZWQiLCJ0b3BFbmRlZCIsInRvcEVycm9yIiwidG9wRm9jdXMiLCJ0b3BJbnB1dCIsInRvcEludmFsaWQiLCJ0b3BMb2FkIiwidG9wTG9hZGVkRGF0YSIsInRvcExvYWRlZE1ldGFkYXRhIiwidG9wTG9hZFN0YXJ0IiwidG9wTW91c2VNb3ZlIiwidG9wTW91c2VPdXQiLCJ0b3BNb3VzZU92ZXIiLCJ0b3BNb3VzZVVwIiwidG9wUGF1c2UiLCJ0b3BQbGF5IiwidG9wUGxheWluZyIsInRvcFByb2dyZXNzIiwidG9wUmF0ZUNoYW5nZSIsInRvcFJlc2V0IiwidG9wU2Nyb2xsIiwidG9wU2Vla2VkIiwidG9wU2Vla2luZyIsInRvcFNlbGVjdGlvbkNoYW5nZSIsInRvcFN0YWxsZWQiLCJ0b3BTdWJtaXQiLCJ0b3BTdXNwZW5kIiwidG9wVGltZVVwZGF0ZSIsInRvcFRvdWNoQ2FuY2VsIiwidG9wVG91Y2hFbmQiLCJ0b3BUb3VjaE1vdmUiLCJ0b3BUb3VjaFN0YXJ0IiwidG9wVHJhbnNpdGlvbkVuZCIsInRvcFZvbHVtZUNoYW5nZSIsInRvcFdhaXRpbmciLCJ0b3BXaGVlbCIsImFjY3VtdWxhdGVJbnRvIiwiZm9yRWFjaEFjY3VtdWxhdGVkIiwiZ2V0TGlzdGVuZXIiLCJsaXN0ZW5lckF0UGhhc2UiLCJwcm9wYWdhdGlvblBoYXNlIiwicmVnaXN0cmF0aW9uTmFtZSIsImRpc3BhdGNoQ29uZmlnIiwiYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyIsInVwd2FyZHMiLCJwaGFzZSIsImxpc3RlbmVyIiwiX2Rpc3BhdGNoTGlzdGVuZXJzIiwiX2Rpc3BhdGNoSW5zdGFuY2VzIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSIsInRyYXZlcnNlVHdvUGhhc2UiLCJfdGFyZ2V0SW5zdCIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0IiwicGFyZW50SW5zdCIsImdldFBhcmVudEluc3RhbmNlIiwiYWNjdW11bGF0ZURpc3BhdGNoZXMiLCJpZ25vcmVkRGlyZWN0aW9uIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUiLCJldmVudHMiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCIsImFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyIsImxlYXZlIiwiZW50ZXIiLCJ0cmF2ZXJzZUVudGVyTGVhdmUiLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyIsIkV2ZW50UGx1Z2luUmVnaXN0cnkiLCJSZWFjdEVycm9yVXRpbHMiLCJsaXN0ZW5lckJhbmsiLCJldmVudFF1ZXVlIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlIiwic2ltdWxhdGVkIiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyIiwiaXNQZXJzaXN0ZW50IiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwiLCJnZXREaWN0aW9uYXJ5S2V5IiwiX3Jvb3ROb2RlSUQiLCJwdXRMaXN0ZW5lciIsImJhbmtGb3JSZWdpc3RyYXRpb25OYW1lIiwiUGx1Z2luTW9kdWxlIiwicmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMiLCJkaWRQdXRMaXN0ZW5lciIsImRlbGV0ZUxpc3RlbmVyIiwid2lsbERlbGV0ZUxpc3RlbmVyIiwiZGVsZXRlQWxsTGlzdGVuZXJzIiwicGx1Z2lucyIsInBvc3NpYmxlUGx1Z2luIiwiZXh0cmFjdGVkRXZlbnRzIiwiZW5xdWV1ZUV2ZW50cyIsInByb2Nlc3NFdmVudFF1ZXVlIiwicHJvY2Vzc2luZ0V2ZW50UXVldWUiLCJyZXRocm93Q2F1Z2h0RXJyb3IiLCJfX3B1cmdlIiwiX19nZXRMaXN0ZW5lckJhbmsiLCJFdmVudFBsdWdpbk9yZGVyIiwibmFtZXNUb1BsdWdpbnMiLCJyZWNvbXB1dGVQbHVnaW5PcmRlcmluZyIsInBsdWdpbk5hbWUiLCJwbHVnaW5JbmRleCIsInB1Ymxpc2hlZEV2ZW50cyIsImV2ZW50TmFtZSIsInB1Ymxpc2hFdmVudEZvclBsdWdpbiIsImV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyIsInBoYXNlTmFtZSIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUiLCJwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZSIsInJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMiLCJsb3dlckNhc2VkTmFtZSIsInBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMiLCJvbmRibGNsaWNrIiwiSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyIsImlzT3JkZXJpbmdEaXJ0eSIsImdldFBsdWdpbk1vZHVsZUZvckV2ZW50IiwiX3Jlc2V0RXZlbnRQbHVnaW5zIiwiVHJlZVRyYXZlcnNhbCIsIkluamVjdGVkIiwiaXNBbmNlc3RvciIsImdldExvd2VzdENvbW1vbkFuY2VzdG9yIiwiaXNFbmRpc2giLCJpc01vdmVpc2giLCJpc1N0YXJ0aXNoIiwidmFsaWRhdGVFdmVudERpc3BhdGNoZXMiLCJkaXNwYXRjaExpc3RlbmVycyIsImRpc3BhdGNoSW5zdGFuY2VzIiwibGlzdGVuZXJzSXNBcnIiLCJsaXN0ZW5lcnNMZW4iLCJpbnN0YW5jZXNJc0FyciIsImluc3RhbmNlc0xlbiIsImV4ZWN1dGVEaXNwYXRjaCIsImN1cnJlbnRUYXJnZXQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2giLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsIiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSIsImV4ZWN1dGVEaXJlY3REaXNwYXRjaCIsImRpc3BhdGNoTGlzdGVuZXIiLCJkaXNwYXRjaEluc3RhbmNlIiwicmVzIiwiaGFzRGlzcGF0Y2hlcyIsImFyZ0Zyb20iLCJhcmdUbyIsImNhdWdodEVycm9yIiwiZGlzcGF0Y2hFdmVudCIsImNyZWF0ZUV2ZW50IiwiZmFrZU5vZGUiLCJib3VuZEZ1bmMiLCJldnRUeXBlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2dCIsImluaXRFdmVudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhcnIiLCJjYiIsInNjb3BlIiwiY2FuVXNlV29ya2VycyIsIldvcmtlciIsImNhblVzZUV2ZW50TGlzdGVuZXJzIiwiYXR0YWNoRXZlbnQiLCJjYW5Vc2VWaWV3cG9ydCIsInNjcmVlbiIsImlzSW5Xb3JrZXIiLCJnZXRUZXh0Q29udGVudEFjY2Vzc29yIiwicm9vdCIsIl9yb290IiwiX3N0YXJ0VGV4dCIsIl9mYWxsYmFja1RleHQiLCJzdGFydCIsInN0YXJ0VmFsdWUiLCJzdGFydExlbmd0aCIsImVuZCIsImVuZFZhbHVlIiwiZW5kTGVuZ3RoIiwibWluRW5kIiwic2xpY2VUYWlsIiwiY29udGVudEtleSIsImRvY3VtZW50RWxlbWVudCIsIlN5bnRoZXRpY0V2ZW50IiwiQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSIsImRpc3BhdGNoTWFya2VyIiwiYXVnbWVudENsYXNzIiwiZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkiLCJpc1Byb3h5U3VwcG9ydGVkIiwiUHJveHkiLCJzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcyIsIkV2ZW50SW50ZXJmYWNlIiwiZXZlbnRQaGFzZSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwidGltZVN0YW1wIiwiZGVmYXVsdFByZXZlbnRlZCIsImlzVHJ1c3RlZCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiSW50ZXJmYWNlIiwibm9ybWFsaXplIiwicmV0dXJuVmFsdWUiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJjYW5jZWxCdWJibGUiLCJwZXJzaXN0IiwiZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbiIsImNvbnN0cnVjdCIsInRoYXQiLCJDbGFzcyIsIlN1cGVyIiwiRSIsImdldFZhbCIsImFjdGlvbiIsIndhcm4iLCJ3YXJuaW5nQ29uZGl0aW9uIiwiSW5wdXRFdmVudEludGVyZmFjZSIsImdldEV2ZW50VGFyZ2V0IiwiaXNFdmVudFN1cHBvcnRlZCIsImlzVGV4dElucHV0RWxlbWVudCIsImNoYW5nZSIsIm9uQ2hhbmdlIiwib25DaGFuZ2VDYXB0dXJlIiwiYWN0aXZlRWxlbWVudCIsImFjdGl2ZUVsZW1lbnRJbnN0IiwiYWN0aXZlRWxlbWVudFZhbHVlIiwiYWN0aXZlRWxlbWVudFZhbHVlUHJvcCIsInNob3VsZFVzZUNoYW5nZUV2ZW50IiwiZWxlbSIsIm5vZGVOYW1lIiwiZG9lc0NoYW5nZUV2ZW50QnViYmxlIiwibWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCIsInJ1bkV2ZW50SW5CYXRjaCIsInN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCIsInN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4IiwiZGV0YWNoRXZlbnQiLCJnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQiLCJoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFOCIsImlzSW5wdXRFdmVudFN1cHBvcnRlZCIsIm5ld1ZhbHVlUHJvcCIsInN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSIsImhhbmRsZVByb3BlcnR5Q2hhbmdlIiwic3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJzcmNFbGVtZW50IiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnQiLCJoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUUiLCJnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudElFIiwic2hvdWxkVXNlQ2xpY2tFdmVudCIsImdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50IiwidGFyZ2V0Tm9kZSIsImdldFRhcmdldEluc3RGdW5jIiwiaGFuZGxlRXZlbnRGdW5jIiwiQ2FsbGJhY2tRdWV1ZSIsIlJlYWN0RmVhdHVyZUZsYWdzIiwiVHJhbnNhY3Rpb24iLCJkaXJ0eUNvbXBvbmVudHMiLCJ1cGRhdGVCYXRjaE51bWJlciIsImFzYXBDYWxsYmFja1F1ZXVlIiwiYXNhcEVucXVldWVkIiwiYmF0Y2hpbmdTdHJhdGVneSIsImVuc3VyZUluamVjdGVkIiwiTkVTVEVEX1VQREFURVMiLCJpbml0aWFsaXplIiwiZGlydHlDb21wb25lbnRzTGVuZ3RoIiwiY2xvc2UiLCJzcGxpY2UiLCJmbHVzaEJhdGNoZWRVcGRhdGVzIiwiVVBEQVRFX1FVRVVFSU5HIiwiY2FsbGJhY2tRdWV1ZSIsInJlc2V0Iiwibm90aWZ5QWxsIiwiVFJBTlNBQ1RJT05fV1JBUFBFUlMiLCJSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uIiwicmVpbml0aWFsaXplVHJhbnNhY3Rpb24iLCJyZWNvbmNpbGVUcmFuc2FjdGlvbiIsIk1peGluIiwiZ2V0VHJhbnNhY3Rpb25XcmFwcGVycyIsInBlcmZvcm0iLCJtb3VudE9yZGVyQ29tcGFyYXRvciIsImMxIiwiYzIiLCJfbW91bnRPcmRlciIsInJ1bkJhdGNoZWRVcGRhdGVzIiwidHJhbnNhY3Rpb24iLCJzb3J0IiwiY2FsbGJhY2tzIiwiX3BlbmRpbmdDYWxsYmFja3MiLCJtYXJrZXJOYW1lIiwibG9nVG9wTGV2ZWxSZW5kZXJzIiwibmFtZWRDb21wb25lbnQiLCJfY3VycmVudEVsZW1lbnQiLCJwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkiLCJ0aW1lRW5kIiwiaiIsImVucXVldWUiLCJnZXRQdWJsaWNJbnN0YW5jZSIsImVucXVldWVVcGRhdGUiLCJpc0JhdGNoaW5nVXBkYXRlcyIsIl91cGRhdGVCYXRjaE51bWJlciIsImFzYXAiLCJSZWFjdFVwZGF0ZXNJbmplY3Rpb24iLCJSZWNvbmNpbGVUcmFuc2FjdGlvbiIsIl9iYXRjaGluZ1N0cmF0ZWd5IiwiX2NhbGxiYWNrcyIsIl9jb250ZXh0cyIsImNvbnRleHRzIiwiY2hlY2twb2ludCIsInJvbGxiYWNrIiwiUmVhY3RSZWYiLCJhdHRhY2hSZWZzIiwibW91bnRDb21wb25lbnQiLCJpbnRlcm5hbEluc3RhbmNlIiwiaG9zdFBhcmVudCIsImhvc3RDb250YWluZXJJbmZvIiwicGFyZW50RGVidWdJRCIsIm1hcmt1cCIsImdldFJlYWN0TW91bnRSZWFkeSIsImdldEhvc3ROb2RlIiwidW5tb3VudENvbXBvbmVudCIsInNhZmVseSIsIm9uQmVmb3JlVW5tb3VudENvbXBvbmVudCIsImRldGFjaFJlZnMiLCJyZWNlaXZlQ29tcG9uZW50IiwibmV4dEVsZW1lbnQiLCJwcmV2RWxlbWVudCIsIl9jb250ZXh0IiwicmVmc0NoYW5nZWQiLCJzaG91bGRVcGRhdGVSZWZzIiwiUmVhY3RPd25lciIsImF0dGFjaFJlZiIsImFkZENvbXBvbmVudEFzUmVmVG8iLCJkZXRhY2hSZWYiLCJyZW1vdmVDb21wb25lbnRBc1JlZkZyb20iLCJwcmV2RW1wdHkiLCJuZXh0RW1wdHkiLCJpc1ZhbGlkT3duZXIiLCJvd25lclB1YmxpY0luc3RhbmNlIiwiUmVhY3REZWJ1Z1Rvb2wiLCJSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rIiwiUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2siLCJSZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vayIsInBlcmZvcm1hbmNlTm93IiwiaG9va3MiLCJkaWRIb29rVGhyb3dGb3JFdmVudCIsImNhbGxIb29rIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiYXJnNCIsImFyZzUiLCJlbWl0RXZlbnQiLCJob29rIiwiaXNQcm9maWxpbmciLCJmbHVzaEhpc3RvcnkiLCJsaWZlQ3ljbGVUaW1lclN0YWNrIiwiY3VycmVudEZsdXNoTmVzdGluZyIsImN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyIsImN1cnJlbnRGbHVzaFN0YXJ0VGltZSIsImN1cnJlbnRUaW1lckRlYnVnSUQiLCJjdXJyZW50VGltZXJTdGFydFRpbWUiLCJjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uIiwiY3VycmVudFRpbWVyVHlwZSIsImxpZmVDeWNsZVRpbWVySGFzV2FybmVkIiwiY2xlYXJIaXN0b3J5IiwiZ2V0VHJlZVNuYXBzaG90IiwicmVnaXN0ZXJlZElEcyIsInJlZHVjZSIsInRyZWUiLCJyZXNldE1lYXN1cmVtZW50cyIsInByZXZpb3VzU3RhcnRUaW1lIiwicHJldmlvdXNNZWFzdXJlbWVudHMiLCJwcmV2aW91c09wZXJhdGlvbnMiLCJnZXRIaXN0b3J5IiwiZHVyYXRpb24iLCJtZWFzdXJlbWVudHMiLCJvcGVyYXRpb25zIiwidHJlZVNuYXBzaG90IiwiY2hlY2tEZWJ1Z0lEIiwiYWxsb3dSb290IiwiYmVnaW5MaWZlQ3ljbGVUaW1lciIsInRpbWVyVHlwZSIsImVuZExpZmVDeWNsZVRpbWVyIiwiaW5zdGFuY2VJRCIsInBhdXNlQ3VycmVudExpZmVDeWNsZVRpbWVyIiwiY3VycmVudFRpbWVyIiwic3RhcnRUaW1lIiwibmVzdGVkRmx1c2hTdGFydFRpbWUiLCJyZXN1bWVDdXJyZW50TGlmZUN5Y2xlVGltZXIiLCJfbGlmZUN5Y2xlVGltZXJTdGFjayQiLCJuZXN0ZWRGbHVzaER1cmF0aW9uIiwicmVtb3ZlSG9vayIsImJlZ2luUHJvZmlsaW5nIiwiZW5kUHJvZmlsaW5nIiwiZ2V0Rmx1c2hIaXN0b3J5Iiwib25CZWdpbkZsdXNoIiwib25FbmRGbHVzaCIsIm9uQmVnaW5MaWZlQ3ljbGVUaW1lciIsIm9uRW5kTGlmZUN5Y2xlVGltZXIiLCJvbkVycm9yIiwib25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQiLCJvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQiLCJvbkhvc3RPcGVyYXRpb24iLCJwYXlsb2FkIiwib25TZXRTdGF0ZSIsImNoaWxkRGVidWdJRHMiLCJvblRlc3RFdmVudCIsImFkZERldnRvb2wiLCJyZW1vdmVEZXZ0b29sIiwidXJsIiwiaHJlZiIsInByb2Nlc3NpbmdDaGlsZENvbnRleHQiLCJ3YXJuSW52YWxpZFNldFN0YXRlIiwiaGlzdG9yeSIsIl9wcmV2ZW50Q2xlYXJpbmciLCJoYW5kbGVFbGVtZW50IiwiaXNNdXRhdGVkIiwicGVyZm9ybWFuY2UiLCJtc1BlcmZvcm1hbmNlIiwid2Via2l0UGVyZm9ybWFuY2UiLCJ0cmFuc2FjdGlvbldyYXBwZXJzIiwid3JhcHBlckluaXREYXRhIiwiX2lzSW5UcmFuc2FjdGlvbiIsImlzSW5UcmFuc2FjdGlvbiIsImVycm9yVGhyb3duIiwiaW5pdGlhbGl6ZUFsbCIsImNsb3NlQWxsIiwic3RhcnRJbmRleCIsIndyYXBwZXIiLCJPQlNFUlZFRF9FUlJPUiIsImluaXREYXRhIiwiY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQiLCJ1c2VIYXNGZWF0dXJlIiwiaW1wbGVtZW50YXRpb24iLCJoYXNGZWF0dXJlIiwiZXZlbnROYW1lU3VmZml4IiwiY2FwdHVyZSIsImlzU3VwcG9ydGVkIiwic2V0QXR0cmlidXRlIiwic3VwcG9ydGVkSW5wdXRUeXBlcyIsIlJlc3BvbmRlckV2ZW50UGx1Z2luIiwiVGFwRXZlbnRQbHVnaW4iLCJTeW50aGV0aWNNb3VzZUV2ZW50IiwibW91c2VFbnRlciIsIm9uTW91c2VFbnRlciIsIm1vdXNlTGVhdmUiLCJvbk1vdXNlTGVhdmUiLCJyZWxhdGVkVGFyZ2V0IiwiZnJvbUVsZW1lbnQiLCJ3aW4iLCJkb2MiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJwYXJlbnRXaW5kb3ciLCJyZWxhdGVkIiwidG9FbGVtZW50IiwiZnJvbU5vZGUiLCJ0b05vZGUiLCJTeW50aGV0aWNVSUV2ZW50IiwiVmlld3BvcnRNZXRyaWNzIiwiZ2V0RXZlbnRNb2RpZmllclN0YXRlIiwiTW91c2VFdmVudEludGVyZmFjZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImNsaWVudFkiLCJzaGlmdEtleSIsImdldE1vZGlmaWVyU3RhdGUiLCJidXR0b25zIiwicGFnZVgiLCJjdXJyZW50U2Nyb2xsTGVmdCIsInBhZ2VZIiwiY3VycmVudFNjcm9sbFRvcCIsIlVJRXZlbnRJbnRlcmZhY2UiLCJ2aWV3IiwicmVmcmVzaFNjcm9sbFZhbHVlcyIsInNjcm9sbFBvc2l0aW9uIiwibW9kaWZpZXJLZXlUb1Byb3AiLCJtb2RpZmllclN0YXRlR2V0dGVyIiwia2V5QXJnIiwic3ludGhldGljRXZlbnQiLCJrZXlQcm9wIiwiYWNjZXB0IiwiYWNjZXB0Q2hhcnNldCIsImFjY2Vzc0tleSIsImFsbG93RnVsbFNjcmVlbiIsImFsbG93VHJhbnNwYXJlbmN5IiwiYWx0IiwiYXN5bmMiLCJhdXRvQ29tcGxldGUiLCJhdXRvUGxheSIsImNlbGxQYWRkaW5nIiwiY2VsbFNwYWNpbmciLCJjaGFyU2V0IiwiY2hhbGxlbmdlIiwiY2hlY2tlZCIsImNsYXNzSUQiLCJjbGFzc05hbWUiLCJjb2xzIiwiY29sU3BhbiIsImNvbnRlbnQiLCJjb250ZW50RWRpdGFibGUiLCJjb250ZXh0TWVudSIsImNvbnRyb2xzIiwiY29vcmRzIiwiY3Jvc3NPcmlnaW4iLCJkYXRlVGltZSIsImRlZmVyIiwiZGlzYWJsZWQiLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImVuY1R5cGUiLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtTWV0aG9kIiwiZm9ybU5vVmFsaWRhdGUiLCJmb3JtVGFyZ2V0IiwiZnJhbWVCb3JkZXIiLCJoZWFkZXJzIiwiaGVpZ2h0IiwiaGlkZGVuIiwiaGlnaCIsImhyZWZMYW5nIiwiaHRtbEZvciIsImh0dHBFcXVpdiIsImljb24iLCJpbnB1dE1vZGUiLCJpbnRlZ3JpdHkiLCJrZXlQYXJhbXMiLCJrZXlUeXBlIiwia2luZCIsImxhbmciLCJsaXN0IiwibG9vcCIsImxvdyIsIm1hbmlmZXN0IiwibWFyZ2luSGVpZ2h0IiwibWFyZ2luV2lkdGgiLCJtYXgiLCJtYXhMZW5ndGgiLCJtZWRpYSIsIm1lZGlhR3JvdXAiLCJtaW4iLCJtaW5MZW5ndGgiLCJtdWx0aXBsZSIsIm11dGVkIiwibm9uY2UiLCJub1ZhbGlkYXRlIiwib3BlbiIsIm9wdGltdW0iLCJwbGFjZWhvbGRlciIsInBvc3RlciIsInByZWxvYWQiLCJwcm9maWxlIiwicmFkaW9Hcm91cCIsInJlYWRPbmx5IiwicmVmZXJyZXJQb2xpY3kiLCJyZWwiLCJyZXF1aXJlZCIsInJldmVyc2VkIiwicm9sZSIsInJvd3MiLCJyb3dTcGFuIiwic2FuZGJveCIsInNjb3BlZCIsInNjcm9sbGluZyIsInNlYW1sZXNzIiwic2VsZWN0ZWQiLCJzaXplIiwic2l6ZXMiLCJzcGVsbENoZWNrIiwic3JjIiwic3JjRG9jIiwic3JjTGFuZyIsInNyY1NldCIsInRhYkluZGV4IiwidXNlTWFwIiwid2lkdGgiLCJ3bW9kZSIsIndyYXAiLCJhYm91dCIsImRhdGF0eXBlIiwiaW5saXN0IiwicmVzb3VyY2UiLCJ2b2NhYiIsImF1dG9DYXBpdGFsaXplIiwiYXV0b0NvcnJlY3QiLCJhdXRvU2F2ZSIsImNvbG9yIiwiaXRlbVByb3AiLCJpdGVtU2NvcGUiLCJpdGVtVHlwZSIsIml0ZW1JRCIsIml0ZW1SZWYiLCJyZXN1bHRzIiwic2VjdXJpdHkiLCJ1bnNlbGVjdGFibGUiLCJET01DaGlsZHJlbk9wZXJhdGlvbnMiLCJSZWFjdERPTUlET3BlcmF0aW9ucyIsInByb2Nlc3NDaGlsZHJlblVwZGF0ZXMiLCJkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMiLCJyZXBsYWNlTm9kZVdpdGhNYXJrdXAiLCJkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCIsIkRPTUxhenlUcmVlIiwiRGFuZ2VyIiwiUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMiLCJjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uIiwic2V0SW5uZXJIVE1MIiwic2V0VGV4dENvbnRlbnQiLCJnZXROb2RlQWZ0ZXIiLCJpbnNlcnRDaGlsZEF0IiwicmVmZXJlbmNlTm9kZSIsImluc2VydEJlZm9yZSIsImluc2VydExhenlUcmVlQ2hpbGRBdCIsImNoaWxkVHJlZSIsImluc2VydFRyZWVCZWZvcmUiLCJtb3ZlQ2hpbGQiLCJtb3ZlRGVsaW1pdGVkVGV4dCIsInJlbW92ZUNoaWxkIiwiY2xvc2luZ0NvbW1lbnQiLCJyZW1vdmVEZWxpbWl0ZWRUZXh0Iiwib3BlbmluZ0NvbW1lbnQiLCJuZXh0Tm9kZSIsInN0YXJ0Tm9kZSIsInJlcGxhY2VEZWxpbWl0ZWRUZXh0Iiwic3RyaW5nVGV4dCIsIm5vZGVBZnRlckNvbW1lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsIm9sZENoaWxkIiwicHJldkluc3RhbmNlIiwibmV4dEluc3RhbmNlIiwicHJvY2Vzc1VwZGF0ZXMiLCJ1cGRhdGVzIiwicGFyZW50Tm9kZURlYnVnSUQiLCJrIiwidXBkYXRlIiwiSU5TRVJUX01BUktVUCIsImFmdGVyTm9kZSIsInRvSW5kZXgiLCJNT1ZFX0VYSVNUSU5HIiwiZnJvbUluZGV4IiwiU0VUX01BUktVUCIsIlRFWFRfQ09OVEVOVCIsIlJFTU9WRV9OT0RFIiwiRE9NTmFtZXNwYWNlcyIsIkVMRU1FTlRfTk9ERV9UWVBFIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFIiwiZW5hYmxlTGF6eSIsImluc2VydFRyZWVDaGlsZHJlbiIsIm5hbWVzcGFjZVVSSSIsInJlcGxhY2VDaGlsZFdpdGhUcmVlIiwib2xkTm9kZSIsIm5ld1RyZWUiLCJyZXBsYWNlQ2hpbGQiLCJxdWV1ZUNoaWxkIiwicGFyZW50VHJlZSIsImFwcGVuZENoaWxkIiwicXVldWVIVE1MIiwicXVldWVUZXh0IiwibWF0aG1sIiwiV0hJVEVTUEFDRV9URVNUIiwiTk9OVklTSUJMRV9URVNUIiwicmV1c2FibGVTVkdDb250YWluZXIiLCJpbm5lckhUTUwiLCJuZXdOb2RlcyIsImNoaWxkTm9kZXMiLCJ0ZXN0RWxlbWVudCIsInRleHROb2RlIiwiZGVsZXRlRGF0YSIsIk1TQXBwIiwiZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24iLCJhcmcwIiwiZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyIiwibGFzdENoaWxkIiwidGV4dENvbnRlbnQiLCJtYXRjaEh0bWxSZWdFeHAiLCJlc2NhcGVIdG1sIiwic3RyIiwiZXhlYyIsImxhc3RJbmRleCIsImNoYXJDb2RlQXQiLCJjcmVhdGVOb2Rlc0Zyb21NYXJrdXAiLCJuZXdDaGlsZCIsImNyZWF0ZUFycmF5RnJvbU1peGVkIiwiZ2V0TWFya3VwV3JhcCIsImR1bW15Tm9kZSIsIm5vZGVOYW1lUGF0dGVybiIsImdldE5vZGVOYW1lIiwibm9kZU5hbWVNYXRjaCIsImhhbmRsZVNjcmlwdCIsIndyYXBEZXB0aCIsInNjcmlwdHMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsIm5vZGVzIiwiY2FsbGVlIiwiaGFzQXJyYXlOYXR1cmUiLCJzaG91bGRXcmFwIiwic2VsZWN0V3JhcCIsInRhYmxlV3JhcCIsInRyV3JhcCIsInN2Z1dyYXAiLCJtYXJrdXBXcmFwIiwic3ZnRWxlbWVudHMiLCJBdXRvRm9jdXNVdGlscyIsIkNTU1Byb3BlcnR5T3BlcmF0aW9ucyIsIkRPTVByb3BlcnR5T3BlcmF0aW9ucyIsIlJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciIsIlJlYWN0RE9NQnV0dG9uIiwiUmVhY3RET01JbnB1dCIsIlJlYWN0RE9NT3B0aW9uIiwiUmVhY3RET01TZWxlY3QiLCJSZWFjdERPTVRleHRhcmVhIiwiUmVhY3RNdWx0aUNoaWxkIiwiUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbiIsInNoYWxsb3dFcXVhbCIsInZhbGlkYXRlRE9NTmVzdGluZyIsImdldE5vZGUiLCJsaXN0ZW5UbyIsIkNPTlRFTlRfVFlQRVMiLCJTVFlMRSIsIkhUTUwiLCJfX2h0bWwiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyIsIkRPQ19GUkFHTUVOVF9UWVBFIiwiZnJpZW5kbHlTdHJpbmdpZnkiLCJrZXlFc2NhcGVkIiwic3R5bGVNdXRhdGlvbldhcm5pbmciLCJjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUiLCJzdHlsZTEiLCJzdHlsZTIiLCJfdGFnIiwiaGFzaCIsImFzc2VydFZhbGlkUHJvcHMiLCJ2b2lkRWxlbWVudFRhZ3MiLCJvbkZvY3VzSW4iLCJvbkZvY3VzT3V0IiwiZW5xdWV1ZVB1dExpc3RlbmVyIiwiY29udGFpbmVySW5mbyIsIl9ob3N0Q29udGFpbmVySW5mbyIsImlzRG9jdW1lbnRGcmFnbWVudCIsIl9ub2RlIiwiX293bmVyRG9jdW1lbnQiLCJsaXN0ZW5lclRvUHV0IiwiaW5wdXRQb3N0TW91bnQiLCJwb3N0TW91bnRXcmFwcGVyIiwidGV4dGFyZWFQb3N0TW91bnQiLCJvcHRpb25Qb3N0TW91bnQiLCJzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24iLCJoYXNFeGlzdGluZ0NvbnRlbnQiLCJfY29udGVudERlYnVnSUQiLCJjb250ZW50RGVidWdJRCIsIm1lZGlhRXZlbnRzIiwidHJhcEJ1YmJsZWRFdmVudHNMb2NhbCIsIl93cmFwcGVyU3RhdGUiLCJsaXN0ZW5lcnMiLCJ0cmFwQnViYmxlZEV2ZW50IiwicG9zdFVwZGF0ZVNlbGVjdFdyYXBwZXIiLCJwb3N0VXBkYXRlV3JhcHBlciIsIm9taXR0ZWRDbG9zZVRhZ3MiLCJuZXdsaW5lRWF0aW5nVGFncyIsIlZBTElEX1RBR19SRUdFWCIsInZhbGlkYXRlZFRhZ0NhY2hlIiwidmFsaWRhdGVEYW5nZXJvdXNUYWciLCJ0YWciLCJpc0N1c3RvbUNvbXBvbmVudCIsInRhZ05hbWUiLCJnbG9iYWxJZENvdW50ZXIiLCJfbmFtZXNwYWNlVVJJIiwiX3ByZXZpb3VzU3R5bGUiLCJfcHJldmlvdXNTdHlsZUNvcHkiLCJfdG9wTGV2ZWxXcmFwcGVyIiwiX2FuY2VzdG9ySW5mbyIsIl9pZENvdW50ZXIiLCJnZXRIb3N0UHJvcHMiLCJtb3VudFdyYXBwZXIiLCJwYXJlbnRUYWciLCJwYXJlbnRJbmZvIiwidXBkYXRlZEFuY2VzdG9ySW5mbyIsIm1vdW50SW1hZ2UiLCJ1c2VDcmVhdGVFbGVtZW50IiwiZWwiLCJjcmVhdGVFbGVtZW50TlMiLCJzZXRBdHRyaWJ1dGVGb3JSb290IiwiX3VwZGF0ZURPTVByb3BlcnRpZXMiLCJsYXp5VHJlZSIsIl9jcmVhdGVJbml0aWFsQ2hpbGRyZW4iLCJ0YWdPcGVuIiwiX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnMiLCJ0YWdDb250ZW50IiwiX2NyZWF0ZUNvbnRlbnRNYXJrdXAiLCJhdXRvRm9jdXMiLCJmb2N1c0RPTUNvbXBvbmVudCIsInByb3BLZXkiLCJjcmVhdGVNYXJrdXBGb3JTdHlsZXMiLCJjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUiLCJjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eSIsInJlbmRlclRvU3RhdGljTWFya3VwIiwiY3JlYXRlTWFya3VwRm9yUm9vdCIsImNyZWF0ZU1hcmt1cEZvcklEIiwiY29udGVudFRvVXNlIiwiY2hpbGRyZW5Ub1VzZSIsIm1vdW50SW1hZ2VzIiwibW91bnRDaGlsZHJlbiIsImNoYXJBdCIsImxhc3RQcm9wcyIsIm5leHRQcm9wcyIsIl91cGRhdGVET01DaGlsZHJlbiIsInVwZGF0ZVdyYXBwZXIiLCJzdHlsZU5hbWUiLCJzdHlsZVVwZGF0ZXMiLCJsYXN0U3R5bGUiLCJkZWxldGVWYWx1ZUZvckF0dHJpYnV0ZSIsImRlbGV0ZVZhbHVlRm9yUHJvcGVydHkiLCJuZXh0UHJvcCIsImxhc3RQcm9wIiwic2V0VmFsdWVGb3JBdHRyaWJ1dGUiLCJzZXRWYWx1ZUZvclByb3BlcnR5Iiwic2V0VmFsdWVGb3JTdHlsZXMiLCJsYXN0Q29udGVudCIsIm5leHRDb250ZW50IiwibGFzdEh0bWwiLCJuZXh0SHRtbCIsImxhc3RDaGlsZHJlbiIsIm5leHRDaGlsZHJlbiIsImxhc3RIYXNDb250ZW50T3JIdG1sIiwibmV4dEhhc0NvbnRlbnRPckh0bWwiLCJ1cGRhdGVDaGlsZHJlbiIsInVwZGF0ZVRleHRDb250ZW50IiwidXBkYXRlTWFya3VwIiwidW5tb3VudENoaWxkcmVuIiwiZm9jdXNOb2RlIiwiZm9jdXMiLCJDU1NQcm9wZXJ0eSIsImNhbWVsaXplU3R5bGVOYW1lIiwiZGFuZ2Vyb3VzU3R5bGVWYWx1ZSIsImh5cGhlbmF0ZVN0eWxlTmFtZSIsIm1lbW9pemVTdHJpbmdPbmx5IiwicHJvY2Vzc1N0eWxlTmFtZSIsImhhc1Nob3J0aGFuZFByb3BlcnR5QnVnIiwic3R5bGVGbG9hdEFjY2Vzc29yIiwidGVtcFN0eWxlIiwiZm9udCIsImNzc0Zsb2F0IiwiYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuIiwiYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuIiwid2FybmVkU3R5bGVOYW1lcyIsIndhcm5lZFN0eWxlVmFsdWVzIiwid2FybmVkRm9yTmFOVmFsdWUiLCJ3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSIsImNoZWNrUmVuZGVyTWVzc2FnZSIsIndhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSIsInRvVXBwZXJDYXNlIiwid2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uIiwid2FyblN0eWxlVmFsdWVJc05hTiIsIndhcm5WYWxpZFN0eWxlIiwiaXNOYU4iLCJzdHlsZXMiLCJzZXJpYWxpemVkIiwic3R5bGVWYWx1ZSIsImV4cGFuc2lvbiIsInNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyIsImluZGl2aWR1YWxTdHlsZU5hbWUiLCJpc1VuaXRsZXNzTnVtYmVyIiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJib3JkZXJJbWFnZU91dHNldCIsImJvcmRlckltYWdlU2xpY2UiLCJib3JkZXJJbWFnZVdpZHRoIiwiYm94RmxleCIsImJveEZsZXhHcm91cCIsImJveE9yZGluYWxHcm91cCIsImNvbHVtbkNvdW50IiwiZmxleCIsImZsZXhHcm93IiwiZmxleFBvc2l0aXZlIiwiZmxleFNocmluayIsImZsZXhOZWdhdGl2ZSIsImZsZXhPcmRlciIsImdyaWRSb3ciLCJncmlkQ29sdW1uIiwiZm9udFdlaWdodCIsImxpbmVDbGFtcCIsImxpbmVIZWlnaHQiLCJvcGFjaXR5Iiwib3JkZXIiLCJvcnBoYW5zIiwidGFiU2l6ZSIsIndpZG93cyIsInpJbmRleCIsInpvb20iLCJmaWxsT3BhY2l0eSIsImZsb29kT3BhY2l0eSIsInN0b3BPcGFjaXR5Iiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlRGFzaG9mZnNldCIsInN0cm9rZU1pdGVybGltaXQiLCJzdHJva2VPcGFjaXR5Iiwic3Ryb2tlV2lkdGgiLCJwcmVmaXhLZXkiLCJwcmVmaXhlcyIsImJhY2tncm91bmQiLCJiYWNrZ3JvdW5kQXR0YWNobWVudCIsImJhY2tncm91bmRDb2xvciIsImJhY2tncm91bmRJbWFnZSIsImJhY2tncm91bmRQb3NpdGlvblgiLCJiYWNrZ3JvdW5kUG9zaXRpb25ZIiwiYmFja2dyb3VuZFJlcGVhdCIsImJhY2tncm91bmRQb3NpdGlvbiIsImJvcmRlciIsImJvcmRlcldpZHRoIiwiYm9yZGVyU3R5bGUiLCJib3JkZXJDb2xvciIsImJvcmRlckJvdHRvbSIsImJvcmRlckJvdHRvbVdpZHRoIiwiYm9yZGVyQm90dG9tU3R5bGUiLCJib3JkZXJCb3R0b21Db2xvciIsImJvcmRlckxlZnQiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJMZWZ0U3R5bGUiLCJib3JkZXJMZWZ0Q29sb3IiLCJib3JkZXJSaWdodCIsImJvcmRlclJpZ2h0V2lkdGgiLCJib3JkZXJSaWdodFN0eWxlIiwiYm9yZGVyUmlnaHRDb2xvciIsImJvcmRlclRvcCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyVG9wU3R5bGUiLCJib3JkZXJUb3BDb2xvciIsImZvbnRTdHlsZSIsImZvbnRWYXJpYW50IiwiZm9udFNpemUiLCJmb250RmFtaWx5Iiwib3V0bGluZSIsIm91dGxpbmVXaWR0aCIsIm91dGxpbmVTdHlsZSIsIm91dGxpbmVDb2xvciIsImNhbWVsaXplIiwibXNQYXR0ZXJuIiwiX2h5cGhlblBhdHRlcm4iLCJfIiwiY2hhcmFjdGVyIiwic3R5bGVXYXJuaW5ncyIsImlzRW1wdHkiLCJpc05vbk51bWVyaWMiLCJ3YXJuaW5ncyIsImh5cGhlbmF0ZSIsIl91cHBlcmNhc2VQYXR0ZXJuIiwiY2FjaGUiLCJxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlciIsIlZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYIiwiaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSIsInZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSIsImlzQXR0cmlidXRlTmFtZVNhZmUiLCJzaG91bGRJZ25vcmVWYWx1ZSIsInNldEF0dHJpYnV0ZUZvcklEIiwibmFtZXNwYWNlIiwic2V0QXR0cmlidXRlTlMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJSZWFjdEV2ZW50RW1pdHRlck1peGluIiwiZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUiLCJoYXNFdmVudFBhZ2VYWSIsImFscmVhZHlMaXN0ZW5pbmdUbyIsImlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlIiwicmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyIiwidG9wRXZlbnRNYXBwaW5nIiwidG9wTGlzdGVuZXJzSURLZXkiLCJnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudCIsIm1vdW50QXQiLCJzZXRIYW5kbGVUb3BMZXZlbCIsImhhbmRsZVRvcExldmVsIiwic2V0RW5hYmxlZCIsImVuYWJsZWQiLCJpc0VuYWJsZWQiLCJjb250ZW50RG9jdW1lbnRIYW5kbGUiLCJpc0xpc3RlbmluZyIsImRlcGVuZGVuY3kiLCJ0cmFwQ2FwdHVyZWRFdmVudCIsIldJTkRPV19IQU5ETEUiLCJoYW5kbGVyQmFzZU5hbWUiLCJoYW5kbGUiLCJlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3JpbmciLCJyZWZyZXNoIiwibW9uaXRvclNjcm9sbFZhbHVlIiwicnVuRXZlbnRRdWV1ZUluQmF0Y2giLCJtYWtlUHJlZml4TWFwIiwic3R5bGVQcm9wIiwidmVuZG9yUHJlZml4ZXMiLCJhbmltYXRpb25lbmQiLCJhbmltYXRpb25pdGVyYXRpb24iLCJhbmltYXRpb25zdGFydCIsInRyYW5zaXRpb25lbmQiLCJwcmVmaXhlZEV2ZW50TmFtZXMiLCJhbmltYXRpb24iLCJ0cmFuc2l0aW9uIiwicHJlZml4TWFwIiwiRGlzYWJsZWRJbnB1dFV0aWxzIiwiZGlzYWJsZWFibGVNb3VzZUxpc3RlbmVyTmFtZXMiLCJvbkNsaWNrIiwib25Eb3VibGVDbGljayIsIm9uTW91c2VEb3duIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlVXAiLCJvbkNsaWNrQ2FwdHVyZSIsIm9uRG91YmxlQ2xpY2tDYXB0dXJlIiwib25Nb3VzZURvd25DYXB0dXJlIiwib25Nb3VzZU1vdmVDYXB0dXJlIiwib25Nb3VzZVVwQ2FwdHVyZSIsImhvc3RQcm9wcyIsIkxpbmtlZFZhbHVlVXRpbHMiLCJkaWRXYXJuVmFsdWVMaW5rIiwiZGlkV2FybkNoZWNrZWRMaW5rIiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlIiwiZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCIsImRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQiLCJkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkIiwiZm9yY2VVcGRhdGVJZk1vdW50ZWQiLCJpc0NvbnRyb2xsZWQiLCJ1c2VzQ2hlY2tlZCIsImdldFZhbHVlIiwiZ2V0Q2hlY2tlZCIsImRlZmF1bHRDaGVja2VkIiwiZGVmYXVsdFZhbHVlIiwiaW5pdGlhbFZhbHVlIiwiaW5pdGlhbENoZWNrZWQiLCJjaGVja1Byb3BUeXBlcyIsInZhbHVlTGluayIsImNoZWNrZWRMaW5rIiwiX2hhbmRsZUNoYW5nZSIsImNvbnRyb2xsZWQiLCJuZXdWYWx1ZSIsImV4ZWN1dGVPbkNoYW5nZSIsInJvb3ROb2RlIiwicXVlcnlSb290IiwiZ3JvdXAiLCJxdWVyeVNlbGVjdG9yQWxsIiwib3RoZXJOb2RlIiwib3RoZXJJbnN0YW5jZSIsImhhc1JlYWRPbmx5VmFsdWUiLCJfYXNzZXJ0U2luZ2xlTGluayIsImlucHV0UHJvcHMiLCJfYXNzZXJ0VmFsdWVMaW5rIiwiX2Fzc2VydENoZWNrZWRMaW5rIiwicmVxdWVzdENoYW5nZSIsImRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4iLCJmbGF0dGVuQ2hpbGRyZW4iLCJzZWxlY3RWYWx1ZSIsInNlbGVjdFBhcmVudCIsImdldFNlbGVjdFZhbHVlQ29udGV4dCIsInVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkIiwicGVuZGluZ1VwZGF0ZSIsInVwZGF0ZU9wdGlvbnMiLCJCb29sZWFuIiwidmFsdWVQcm9wTmFtZXMiLCJjaGVja1NlbGVjdFByb3BUeXBlcyIsInNlbGVjdGVkVmFsdWUiLCJvcHRpb25zIiwid2FzTXVsdGlwbGUiLCJkaWRXYXJuVmFsRGVmYXVsdFZhbCIsIlJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQiLCJSZWFjdEluc3RhbmNlTWFwIiwiUmVhY3RDaGlsZFJlY29uY2lsZXIiLCJtYWtlSW5zZXJ0TWFya3VwIiwibWFrZU1vdmUiLCJfbW91bnRJbmRleCIsIm1ha2VSZW1vdmUiLCJtYWtlU2V0TWFya3VwIiwibWFrZVRleHRDb250ZW50IiwicHJvY2Vzc1F1ZXVlIiwidXBkYXRlUXVldWUiLCJzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbiIsImdldERlYnVnSUQiLCJpbnRlcm5hbCIsIl9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbiIsIm5lc3RlZENoaWxkcmVuIiwic2VsZkRlYnVnSUQiLCJpbnN0YW50aWF0ZUNoaWxkcmVuIiwiX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbiIsInByZXZDaGlsZHJlbiIsIm5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIiwicmVtb3ZlZE5vZGVzIiwibmV4dE1hcmt1cCIsIl91cGRhdGVDaGlsZHJlbiIsIm5leHRJbmRleCIsIm5leHRNb3VudEluZGV4IiwibGFzdFBsYWNlZE5vZGUiLCJwcmV2Q2hpbGQiLCJfbW91bnRDaGlsZEF0SW5kZXgiLCJfdW5tb3VudENoaWxkIiwicmVuZGVyZWRDaGlsZHJlbiIsImNyZWF0ZUNoaWxkIiwiaW5qZWN0ZWQiLCJlbnZpcm9ubWVudCIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJoYXMiLCJpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Iiwic2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQiLCJpbnN0YW50aWF0ZUNoaWxkIiwiY2hpbGRJbnN0YW5jZXMiLCJrZXlVbmlxdWUiLCJuZXN0ZWRDaGlsZE5vZGVzIiwiY2hpbGRJbnN0cyIsIm5leHRDaGlsZEluc3RhbmNlIiwibmV4dENoaWxkTW91bnRJbWFnZSIsInJlbmRlcmVkQ2hpbGQiLCJSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCIsIlJlYWN0RW1wdHlDb21wb25lbnQiLCJSZWFjdEhvc3RDb21wb25lbnQiLCJSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIiLCJfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCIsImlzSW50ZXJuYWxDb21wb25lbnRUeXBlIiwibmV4dERlYnVnSUQiLCJzaG91bGRIYXZlRGVidWdJRCIsImNyZWF0ZUludGVybmFsQ29tcG9uZW50IiwiZ2V0TmF0aXZlTm9kZSIsImNyZWF0ZUluc3RhbmNlRm9yVGV4dCIsIl9tb3VudEltYWdlIiwicHJldmVudEV4dGVuc2lvbnMiLCJSZWFjdE5vZGVUeXBlcyIsIkNvbXBvc2l0ZVR5cGVzIiwiSW1wdXJlQ2xhc3MiLCJQdXJlQ2xhc3MiLCJTdGF0ZWxlc3NGdW5jdGlvbmFsIiwiU3RhdGVsZXNzQ29tcG9uZW50Iiwid2FybklmSW52YWxpZEVsZW1lbnQiLCJpbnZva2VDb21wb25lbnREaWRNb3VudFdpdGhUaW1lciIsIl9pbnN0YW5jZSIsImludm9rZUNvbXBvbmVudERpZFVwZGF0ZVdpdGhUaW1lciIsInByZXZQcm9wcyIsInByZXZTdGF0ZSIsInByZXZDb250ZXh0Iiwic2hvdWxkQ29uc3RydWN0IiwiaXNQdXJlQ29tcG9uZW50IiwibmV4dE1vdW50SUQiLCJSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluIiwiX2NvbXBvc2l0ZVR5cGUiLCJfcGVuZGluZ0VsZW1lbnQiLCJfcGVuZGluZ1N0YXRlUXVldWUiLCJfcGVuZGluZ1JlcGxhY2VTdGF0ZSIsIl9wZW5kaW5nRm9yY2VVcGRhdGUiLCJfcmVuZGVyZWROb2RlVHlwZSIsIl9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsInB1YmxpY1Byb3BzIiwicHVibGljQ29udGV4dCIsIl9wcm9jZXNzQ29udGV4dCIsImdldFVwZGF0ZVF1ZXVlIiwiZG9Db25zdHJ1Y3QiLCJfY29uc3RydWN0Q29tcG9uZW50IiwicmVuZGVyZWRFbGVtZW50IiwicHJvcHNNdXRhdGVkIiwiY29tcG9uZW50RGlkVW5tb3VudCIsInVuc3RhYmxlX2hhbmRsZUVycm9yIiwicGVyZm9ybUluaXRpYWxNb3VudFdpdGhFcnJvckhhbmRsaW5nIiwicGVyZm9ybUluaXRpYWxNb3VudCIsIl9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXIiLCJpbnN0YW5jZU9yRWxlbWVudCIsIl9wcm9jZXNzUGVuZGluZ1N0YXRlIiwiX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCIsImdldFR5cGUiLCJFTVBUWSIsIl9wcm9jZXNzQ2hpbGRDb250ZXh0IiwiX21hc2tDb250ZXh0IiwibWFza2VkQ29udGV4dCIsImNvbnRleHROYW1lIiwiX2NoZWNrQ29udGV4dFR5cGVzIiwiY3VycmVudENvbnRleHQiLCJuZXh0Q29udGV4dCIsInByZXZQYXJlbnRFbGVtZW50IiwibmV4dFBhcmVudEVsZW1lbnQiLCJwcmV2VW5tYXNrZWRDb250ZXh0IiwibmV4dFVubWFza2VkQ29udGV4dCIsIndpbGxSZWNlaXZlIiwibmV4dFN0YXRlIiwic2hvdWxkVXBkYXRlIiwiX3BlcmZvcm1Db21wb25lbnRVcGRhdGUiLCJwYXJ0aWFsIiwidW5tYXNrZWRDb250ZXh0IiwiaGFzQ29tcG9uZW50RGlkVXBkYXRlIiwiX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50IiwicHJldkNvbXBvbmVudEluc3RhbmNlIiwicHJldlJlbmRlcmVkRWxlbWVudCIsIm5leHRSZW5kZXJlZEVsZW1lbnQiLCJvbGRIb3N0Tm9kZSIsIl9yZXBsYWNlTm9kZVdpdGhNYXJrdXAiLCJfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0IiwicmVuZGVyZWRDb21wb25lbnQiLCJwdWJsaWNDb21wb25lbnRJbnN0YW5jZSIsIkhPU1QiLCJDT01QT1NJVEUiLCJvYmpBIiwib2JqQiIsImtleXNBIiwia2V5c0IiLCJwcmV2VHlwZSIsIm5leHRUeXBlIiwiZW1wdHlDb21wb25lbnRGYWN0b3J5IiwiUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiIsImdlbmVyaWNDb21wb25lbnRDbGFzcyIsInRhZ1RvQ29tcG9uZW50Q2xhc3MiLCJ0ZXh0Q29tcG9uZW50Q2xhc3MiLCJSZWFjdEhvc3RDb21wb25lbnRJbmplY3Rpb24iLCJpbmplY3RDb21wb25lbnRDbGFzc2VzIiwiY29tcG9uZW50Q2xhc3NlcyIsImlzVGV4dENvbXBvbmVudCIsImZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0IiwiUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSIsIm5vb3BDYWxsYmFja1F1ZXVlIiwiX2NsYXNzQ2FsbENoZWNrIiwiUmVhY3RVcGRhdGVRdWV1ZSIsImZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudCIsImdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZSIsImN0b3IiLCJ2YWxpZGF0ZUNhbGxiYWNrIiwiZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwiLCJlbnF1ZXVlRWxlbWVudEludGVybmFsIiwic3BlY2lhbFRhZ3MiLCJpblNjb3BlVGFncyIsImJ1dHRvblNjb3BlVGFncyIsImltcGxpZWRFbmRUYWdzIiwiZW1wdHlBbmNlc3RvckluZm8iLCJmb3JtVGFnIiwiYVRhZ0luU2NvcGUiLCJidXR0b25UYWdJblNjb3BlIiwibm9iclRhZ0luU2NvcGUiLCJwVGFnSW5CdXR0b25TY29wZSIsImxpc3RJdGVtVGFnQXV0b2Nsb3NpbmciLCJkbEl0ZW1UYWdBdXRvY2xvc2luZyIsIm9sZEluZm8iLCJhbmNlc3RvckluZm8iLCJpc1RhZ1ZhbGlkV2l0aFBhcmVudCIsImZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWciLCJmaW5kT3duZXJTdGFjayIsInJldmVyc2UiLCJkaWRXYXJuIiwiY2hpbGRUYWciLCJjaGlsZEluc3RhbmNlIiwiaW52YWxpZFBhcmVudCIsImludmFsaWRBbmNlc3RvciIsInByb2JsZW1hdGljIiwiYW5jZXN0b3JUYWciLCJhbmNlc3Rvckluc3RhbmNlIiwiYW5jZXN0b3JPd25lciIsImNoaWxkT3duZXJzIiwiYW5jZXN0b3JPd25lcnMiLCJtaW5TdGFja0xlbiIsImRlZXBlc3RDb21tb24iLCJVTktOT1dOIiwiY2hpbGRPd25lck5hbWVzIiwiYW5jZXN0b3JPd25lck5hbWVzIiwib3duZXJJbmZvIiwid2FybktleSIsInRhZ0Rpc3BsYXlOYW1lIiwiaXNUYWdWYWxpZEluQ29udGV4dCIsImRvbUlEIiwiY3JlYXRlQ29tbWVudCIsImluc3RBIiwiaW5zdEIiLCJkZXB0aEEiLCJ0ZW1wQSIsImRlcHRoQiIsInRlbXBCIiwiZGVwdGgiLCJjb21tb24iLCJwYXRoRnJvbSIsInBhdGhUbyIsIl9zdHJpbmdUZXh0IiwiX2Nsb3NpbmdDb21tZW50IiwiX2NvbW1lbnROb2RlcyIsIm9wZW5pbmdWYWx1ZSIsImNsb3NpbmdWYWx1ZSIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJlc2NhcGVkVGV4dCIsIm5leHRUZXh0IiwibmV4dFN0cmluZ1RleHQiLCJjb21tZW50Tm9kZXMiLCJob3N0Tm9kZSIsIlJFU0VUX0JBVENIRURfVVBEQVRFUyIsIkZMVVNIX0JBVENIRURfVVBEQVRFUyIsIlJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbiIsImFscmVhZHlCYXRjaGluZ1VwZGF0ZXMiLCJFdmVudExpc3RlbmVyIiwiZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24iLCJmaW5kUGFyZW50IiwiY29udGFpbmVyIiwiVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nIiwiYW5jZXN0b3JzIiwiaGFuZGxlVG9wTGV2ZWxJbXBsIiwiYW5jZXN0b3IiLCJfaGFuZGxlVG9wTGV2ZWwiLCJzY3JvbGxWYWx1ZU1vbml0b3IiLCJfZW5hYmxlZCIsImxpc3RlbiIsInJlZ2lzdGVyRGVmYXVsdCIsInNjcm9sbGFibGUiLCJwYWdlWE9mZnNldCIsInNjcm9sbExlZnQiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsIlJlYWN0SW5wdXRTZWxlY3Rpb24iLCJTRUxFQ1RJT05fUkVTVE9SQVRJT04iLCJnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbiIsInJlc3RvcmVTZWxlY3Rpb24iLCJFVkVOVF9TVVBQUkVTU0lPTiIsImN1cnJlbnRseUVuYWJsZWQiLCJwcmV2aW91c2x5RW5hYmxlZCIsIk9OX0RPTV9SRUFEWV9RVUVVRUlORyIsInJlYWN0TW91bnRSZWFkeSIsIlJlYWN0RE9NU2VsZWN0aW9uIiwiY29udGFpbnNOb2RlIiwiZ2V0QWN0aXZlRWxlbWVudCIsImlzSW5Eb2N1bWVudCIsImhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyIsImZvY3VzZWRFbGVtIiwic2VsZWN0aW9uUmFuZ2UiLCJnZXRTZWxlY3Rpb24iLCJwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uIiwiY3VyRm9jdXNlZEVsZW0iLCJwcmlvckZvY3VzZWRFbGVtIiwicHJpb3JTZWxlY3Rpb25SYW5nZSIsInNldFNlbGVjdGlvbiIsInNlbGVjdGlvbiIsInNlbGVjdGlvblN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwicmFuZ2UiLCJjcmVhdGVSYW5nZSIsInBhcmVudEVsZW1lbnQiLCJtb3ZlU3RhcnQiLCJtb3ZlRW5kIiwiZ2V0T2Zmc2V0cyIsIm9mZnNldHMiLCJjcmVhdGVUZXh0UmFuZ2UiLCJjb2xsYXBzZSIsInNldE9mZnNldHMiLCJnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0IiwiaXNDb2xsYXBzZWQiLCJhbmNob3JOb2RlIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNPZmZzZXQiLCJnZXRJRU9mZnNldHMiLCJzZWxlY3RlZFJhbmdlIiwic2VsZWN0ZWRMZW5ndGgiLCJmcm9tU3RhcnQiLCJkdXBsaWNhdGUiLCJtb3ZlVG9FbGVtZW50VGV4dCIsInNldEVuZFBvaW50Iiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJnZXRNb2Rlcm5PZmZzZXRzIiwicmFuZ2VDb3VudCIsImN1cnJlbnRSYW5nZSIsImdldFJhbmdlQXQiLCJzdGFydENvbnRhaW5lciIsImVuZENvbnRhaW5lciIsImlzU2VsZWN0aW9uQ29sbGFwc2VkIiwicmFuZ2VMZW5ndGgiLCJ0ZW1wUmFuZ2UiLCJjbG9uZVJhbmdlIiwic2VsZWN0Tm9kZUNvbnRlbnRzIiwic2V0RW5kIiwiaXNUZW1wUmFuZ2VDb2xsYXBzZWQiLCJkZXRlY3Rpb25SYW5nZSIsInNldFN0YXJ0IiwiaXNCYWNrd2FyZCIsImNvbGxhcHNlZCIsInNldElFT2Zmc2V0cyIsInNldE1vZGVybk9mZnNldHMiLCJleHRlbmQiLCJ0ZW1wIiwic3RhcnRNYXJrZXIiLCJlbmRNYXJrZXIiLCJvZmZzZXQiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsInVzZUlFT2Zmc2V0cyIsImdldExlYWZOb2RlIiwiZ2V0U2libGluZ05vZGUiLCJub2RlU3RhcnQiLCJub2RlRW5kIiwiaXNUZXh0Tm9kZSIsIm91dGVyTm9kZSIsImlubmVyTm9kZSIsImNvbnRhaW5zIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJOb2RlIiwiTlMiLCJ4bGluayIsInhtbCIsIkFUVFJTIiwiYWNjZW50SGVpZ2h0IiwiYWNjdW11bGF0ZSIsImFkZGl0aXZlIiwiYWxpZ25tZW50QmFzZWxpbmUiLCJhbGxvd1Jlb3JkZXIiLCJhbHBoYWJldGljIiwiYW1wbGl0dWRlIiwiYXJhYmljRm9ybSIsImFzY2VudCIsImF0dHJpYnV0ZVR5cGUiLCJhdXRvUmV2ZXJzZSIsImF6aW11dGgiLCJiYXNlRnJlcXVlbmN5IiwiYmFzZVByb2ZpbGUiLCJiYXNlbGluZVNoaWZ0IiwiYmJveCIsImJlZ2luIiwiYmlhcyIsImJ5IiwiY2FsY01vZGUiLCJjYXBIZWlnaHQiLCJjbGlwIiwiY2xpcFJ1bGUiLCJjbGlwUGF0aFVuaXRzIiwiY29sb3JJbnRlcnBvbGF0aW9uIiwiY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycyIsImNvbG9yUHJvZmlsZSIsImNvbG9yUmVuZGVyaW5nIiwiY29udGVudFNjcmlwdFR5cGUiLCJjb250ZW50U3R5bGVUeXBlIiwiY3Vyc29yIiwiY3giLCJjeSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZUNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkb21pbmFudEJhc2VsaW5lIiwiZHVyIiwiZHgiLCJkeSIsImVkZ2VNb2RlIiwiZWxldmF0aW9uIiwiZW5hYmxlQmFja2dyb3VuZCIsImV4cG9uZW50IiwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCIsImZpbGwiLCJmaWxsUnVsZSIsImZpbHRlciIsImZpbHRlclJlcyIsImZpbHRlclVuaXRzIiwiZmxvb2RDb2xvciIsImZvY3VzYWJsZSIsImZvbnRTaXplQWRqdXN0IiwiZm9udFN0cmV0Y2giLCJmeCIsImZ5IiwiZzEiLCJnMiIsImdseXBoTmFtZSIsImdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsIiwiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsIiwiZ2x5cGhSZWYiLCJncmFkaWVudFRyYW5zZm9ybSIsImdyYWRpZW50VW5pdHMiLCJoYW5naW5nIiwiaG9yaXpBZHZYIiwiaG9yaXpPcmlnaW5YIiwiaWRlb2dyYXBoaWMiLCJpbWFnZVJlbmRlcmluZyIsImluMiIsImludGVyY2VwdCIsImsxIiwiazIiLCJrMyIsIms0Iiwia2VybmVsTWF0cml4Iiwia2VybmVsVW5pdExlbmd0aCIsImtlcm5pbmciLCJrZXlQb2ludHMiLCJrZXlTcGxpbmVzIiwia2V5VGltZXMiLCJsZW5ndGhBZGp1c3QiLCJsZXR0ZXJTcGFjaW5nIiwibGlnaHRpbmdDb2xvciIsImxpbWl0aW5nQ29uZUFuZ2xlIiwibG9jYWwiLCJtYXJrZXJFbmQiLCJtYXJrZXJNaWQiLCJtYXJrZXJTdGFydCIsIm1hcmtlckhlaWdodCIsIm1hcmtlclVuaXRzIiwibWFya2VyV2lkdGgiLCJtYXNrQ29udGVudFVuaXRzIiwibWFza1VuaXRzIiwibWF0aGVtYXRpY2FsIiwibW9kZSIsIm51bU9jdGF2ZXMiLCJvcGVyYXRvciIsIm9yaWVudCIsIm9yaWVudGF0aW9uIiwib3JpZ2luIiwib3ZlcmZsb3ciLCJvdmVybGluZVBvc2l0aW9uIiwib3ZlcmxpbmVUaGlja25lc3MiLCJwYWludE9yZGVyIiwicGFub3NlMSIsInBhdGhMZW5ndGgiLCJwYXR0ZXJuQ29udGVudFVuaXRzIiwicGF0dGVyblRyYW5zZm9ybSIsInBhdHRlcm5Vbml0cyIsInBvaW50ZXJFdmVudHMiLCJwb2ludHMiLCJwb2ludHNBdFgiLCJwb2ludHNBdFkiLCJwb2ludHNBdFoiLCJwcmVzZXJ2ZUFscGhhIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsInByaW1pdGl2ZVVuaXRzIiwiciIsInJhZGl1cyIsInJlZlgiLCJyZWZZIiwicmVuZGVyaW5nSW50ZW50IiwicmVwZWF0Q291bnQiLCJyZXBlYXREdXIiLCJyZXF1aXJlZEV4dGVuc2lvbnMiLCJyZXF1aXJlZEZlYXR1cmVzIiwicmVzdGFydCIsInJvdGF0ZSIsInJ4IiwicnkiLCJzY2FsZSIsInNlZWQiLCJzaGFwZVJlbmRlcmluZyIsInNsb3BlIiwic3BhY2luZyIsInNwZWN1bGFyQ29uc3RhbnQiLCJzcGVjdWxhckV4cG9uZW50Iiwic3BlZWQiLCJzcHJlYWRNZXRob2QiLCJzdGREZXZpYXRpb24iLCJzdGVtaCIsInN0ZW12Iiwic3RpdGNoVGlsZXMiLCJzdG9wQ29sb3IiLCJzdHJpa2V0aHJvdWdoUG9zaXRpb24iLCJzdHJpa2V0aHJvdWdoVGhpY2tuZXNzIiwic3Ryb2tlIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwic3VyZmFjZVNjYWxlIiwic3lzdGVtTGFuZ3VhZ2UiLCJ0YWJsZVZhbHVlcyIsInRhcmdldFgiLCJ0YXJnZXRZIiwidGV4dEFuY2hvciIsInRleHREZWNvcmF0aW9uIiwidGV4dFJlbmRlcmluZyIsInRleHRMZW5ndGgiLCJ0cmFuc2Zvcm0iLCJ1MSIsInUyIiwidW5kZXJsaW5lUG9zaXRpb24iLCJ1bmRlcmxpbmVUaGlja25lc3MiLCJ1bmljb2RlIiwidW5pY29kZUJpZGkiLCJ1bmljb2RlUmFuZ2UiLCJ1bml0c1BlckVtIiwidkFscGhhYmV0aWMiLCJ2SGFuZ2luZyIsInZJZGVvZ3JhcGhpYyIsInZNYXRoZW1hdGljYWwiLCJ2ZWN0b3JFZmZlY3QiLCJ2ZXJ0QWR2WSIsInZlcnRPcmlnaW5YIiwidmVydE9yaWdpblkiLCJ2aWV3Qm94Iiwidmlld1RhcmdldCIsInZpc2liaWxpdHkiLCJ3aWR0aHMiLCJ3b3JkU3BhY2luZyIsIndyaXRpbmdNb2RlIiwieEhlaWdodCIsIngxIiwieDIiLCJ4Q2hhbm5lbFNlbGVjdG9yIiwieGxpbmtBY3R1YXRlIiwieGxpbmtBcmNyb2xlIiwieGxpbmtIcmVmIiwieGxpbmtSb2xlIiwieGxpbmtTaG93IiwieGxpbmtUaXRsZSIsInhsaW5rVHlwZSIsInhtbEJhc2UiLCJ4bWxucyIsInhtbG5zWGxpbmsiLCJ4bWxMYW5nIiwieG1sU3BhY2UiLCJ5MSIsInkyIiwieUNoYW5uZWxTZWxlY3RvciIsInoiLCJ6b29tQW5kUGFuIiwic2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50Iiwib25TZWxlY3QiLCJvblNlbGVjdENhcHR1cmUiLCJsYXN0U2VsZWN0aW9uIiwibW91c2VEb3duIiwiaGFzTGlzdGVuZXIiLCJPTl9TRUxFQ1RfS0VZIiwiYm91bmRpbmdUb3AiLCJsZWZ0IiwiYm91bmRpbmdMZWZ0IiwiY29uc3RydWN0U2VsZWN0RXZlbnQiLCJjdXJyZW50U2VsZWN0aW9uIiwiU3ludGhldGljQW5pbWF0aW9uRXZlbnQiLCJTeW50aGV0aWNDbGlwYm9hcmRFdmVudCIsIlN5bnRoZXRpY0ZvY3VzRXZlbnQiLCJTeW50aGV0aWNLZXlib2FyZEV2ZW50IiwiU3ludGhldGljRHJhZ0V2ZW50IiwiU3ludGhldGljVG91Y2hFdmVudCIsIlN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCIsIlN5bnRoZXRpY1doZWVsRXZlbnQiLCJnZXRFdmVudENoYXJDb2RlIiwiYWJvcnQiLCJvbkFib3J0Iiwib25BYm9ydENhcHR1cmUiLCJhbmltYXRpb25FbmQiLCJvbkFuaW1hdGlvbkVuZCIsIm9uQW5pbWF0aW9uRW5kQ2FwdHVyZSIsImFuaW1hdGlvbkl0ZXJhdGlvbiIsIm9uQW5pbWF0aW9uSXRlcmF0aW9uIiwib25BbmltYXRpb25JdGVyYXRpb25DYXB0dXJlIiwiYW5pbWF0aW9uU3RhcnQiLCJvbkFuaW1hdGlvblN0YXJ0Iiwib25BbmltYXRpb25TdGFydENhcHR1cmUiLCJibHVyIiwib25CbHVyIiwib25CbHVyQ2FwdHVyZSIsImNhblBsYXkiLCJvbkNhblBsYXkiLCJvbkNhblBsYXlDYXB0dXJlIiwiY2FuUGxheVRocm91Z2giLCJvbkNhblBsYXlUaHJvdWdoIiwib25DYW5QbGF5VGhyb3VnaENhcHR1cmUiLCJjbGljayIsIm9uQ29udGV4dE1lbnUiLCJvbkNvbnRleHRNZW51Q2FwdHVyZSIsImNvcHkiLCJvbkNvcHkiLCJvbkNvcHlDYXB0dXJlIiwiY3V0Iiwib25DdXQiLCJvbkN1dENhcHR1cmUiLCJkb3VibGVDbGljayIsImRyYWciLCJvbkRyYWciLCJvbkRyYWdDYXB0dXJlIiwiZHJhZ0VuZCIsIm9uRHJhZ0VuZCIsIm9uRHJhZ0VuZENhcHR1cmUiLCJkcmFnRW50ZXIiLCJvbkRyYWdFbnRlciIsIm9uRHJhZ0VudGVyQ2FwdHVyZSIsImRyYWdFeGl0Iiwib25EcmFnRXhpdCIsIm9uRHJhZ0V4aXRDYXB0dXJlIiwiZHJhZ0xlYXZlIiwib25EcmFnTGVhdmUiLCJvbkRyYWdMZWF2ZUNhcHR1cmUiLCJkcmFnT3ZlciIsIm9uRHJhZ092ZXIiLCJvbkRyYWdPdmVyQ2FwdHVyZSIsImRyYWdTdGFydCIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnU3RhcnRDYXB0dXJlIiwiZHJvcCIsIm9uRHJvcCIsIm9uRHJvcENhcHR1cmUiLCJkdXJhdGlvbkNoYW5nZSIsIm9uRHVyYXRpb25DaGFuZ2UiLCJvbkR1cmF0aW9uQ2hhbmdlQ2FwdHVyZSIsImVtcHRpZWQiLCJvbkVtcHRpZWQiLCJvbkVtcHRpZWRDYXB0dXJlIiwiZW5jcnlwdGVkIiwib25FbmNyeXB0ZWQiLCJvbkVuY3J5cHRlZENhcHR1cmUiLCJlbmRlZCIsIm9uRW5kZWQiLCJvbkVuZGVkQ2FwdHVyZSIsIm9uRXJyb3JDYXB0dXJlIiwib25Gb2N1cyIsIm9uRm9jdXNDYXB0dXJlIiwib25JbnB1dCIsIm9uSW5wdXRDYXB0dXJlIiwiaW52YWxpZCIsIm9uSW52YWxpZCIsIm9uSW52YWxpZENhcHR1cmUiLCJrZXlEb3duIiwib25LZXlEb3duIiwib25LZXlEb3duQ2FwdHVyZSIsImtleVByZXNzIiwib25LZXlQcmVzcyIsIm9uS2V5UHJlc3NDYXB0dXJlIiwia2V5VXAiLCJvbktleVVwIiwib25LZXlVcENhcHR1cmUiLCJsb2FkIiwib25Mb2FkIiwib25Mb2FkQ2FwdHVyZSIsImxvYWRlZERhdGEiLCJvbkxvYWRlZERhdGEiLCJvbkxvYWRlZERhdGFDYXB0dXJlIiwibG9hZGVkTWV0YWRhdGEiLCJvbkxvYWRlZE1ldGFkYXRhIiwib25Mb2FkZWRNZXRhZGF0YUNhcHR1cmUiLCJsb2FkU3RhcnQiLCJvbkxvYWRTdGFydCIsIm9uTG9hZFN0YXJ0Q2FwdHVyZSIsIm1vdXNlTW92ZSIsIm1vdXNlT3V0Iiwib25Nb3VzZU91dCIsIm9uTW91c2VPdXRDYXB0dXJlIiwibW91c2VPdmVyIiwib25Nb3VzZU92ZXIiLCJvbk1vdXNlT3ZlckNhcHR1cmUiLCJtb3VzZVVwIiwicGFzdGUiLCJvblBhc3RlIiwib25QYXN0ZUNhcHR1cmUiLCJwYXVzZSIsIm9uUGF1c2UiLCJvblBhdXNlQ2FwdHVyZSIsInBsYXkiLCJvblBsYXkiLCJvblBsYXlDYXB0dXJlIiwicGxheWluZyIsIm9uUGxheWluZyIsIm9uUGxheWluZ0NhcHR1cmUiLCJvblByb2dyZXNzIiwib25Qcm9ncmVzc0NhcHR1cmUiLCJyYXRlQ2hhbmdlIiwib25SYXRlQ2hhbmdlIiwib25SYXRlQ2hhbmdlQ2FwdHVyZSIsIm9uUmVzZXQiLCJvblJlc2V0Q2FwdHVyZSIsInNjcm9sbCIsIm9uU2Nyb2xsIiwib25TY3JvbGxDYXB0dXJlIiwic2Vla2VkIiwib25TZWVrZWQiLCJvblNlZWtlZENhcHR1cmUiLCJzZWVraW5nIiwib25TZWVraW5nIiwib25TZWVraW5nQ2FwdHVyZSIsInN0YWxsZWQiLCJvblN0YWxsZWQiLCJvblN0YWxsZWRDYXB0dXJlIiwic3VibWl0Iiwib25TdWJtaXQiLCJvblN1Ym1pdENhcHR1cmUiLCJzdXNwZW5kIiwib25TdXNwZW5kIiwib25TdXNwZW5kQ2FwdHVyZSIsInRpbWVVcGRhdGUiLCJvblRpbWVVcGRhdGUiLCJvblRpbWVVcGRhdGVDYXB0dXJlIiwidG91Y2hDYW5jZWwiLCJvblRvdWNoQ2FuY2VsIiwib25Ub3VjaENhbmNlbENhcHR1cmUiLCJ0b3VjaEVuZCIsIm9uVG91Y2hFbmQiLCJvblRvdWNoRW5kQ2FwdHVyZSIsInRvdWNoTW92ZSIsIm9uVG91Y2hNb3ZlIiwib25Ub3VjaE1vdmVDYXB0dXJlIiwidG91Y2hTdGFydCIsIm9uVG91Y2hTdGFydCIsIm9uVG91Y2hTdGFydENhcHR1cmUiLCJ0cmFuc2l0aW9uRW5kIiwib25UcmFuc2l0aW9uRW5kIiwib25UcmFuc2l0aW9uRW5kQ2FwdHVyZSIsInZvbHVtZUNoYW5nZSIsIm9uVm9sdW1lQ2hhbmdlIiwib25Wb2x1bWVDaGFuZ2VDYXB0dXJlIiwid2FpdGluZyIsIm9uV2FpdGluZyIsIm9uV2FpdGluZ0NhcHR1cmUiLCJ3aGVlbCIsIm9uV2hlZWwiLCJvbldoZWVsQ2FwdHVyZSIsInRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyIsIk9OX0NMSUNLX0tFWSIsIm9uQ2xpY2tMaXN0ZW5lcnMiLCJFdmVudENvbnN0cnVjdG9yIiwiQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UiLCJhbmltYXRpb25OYW1lIiwiZWxhcHNlZFRpbWUiLCJwc2V1ZG9FbGVtZW50IiwiQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UiLCJjbGlwYm9hcmREYXRhIiwiRm9jdXNFdmVudEludGVyZmFjZSIsImdldEV2ZW50S2V5IiwiS2V5Ym9hcmRFdmVudEludGVyZmFjZSIsInJlcGVhdCIsImxvY2FsZSIsImNoYXJDb2RlIiwibm9ybWFsaXplS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJEcmFnRXZlbnRJbnRlcmZhY2UiLCJkYXRhVHJhbnNmZXIiLCJUb3VjaEV2ZW50SW50ZXJmYWNlIiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIlRyYW5zaXRpb25FdmVudEludGVyZmFjZSIsIldoZWVsRXZlbnRJbnRlcmZhY2UiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImRlbHRhWiIsImRlbHRhTW9kZSIsIlJlYWN0RE9NQ29udGFpbmVySW5mbyIsIlJlYWN0RE9NRmVhdHVyZUZsYWdzIiwiUmVhY3RNYXJrdXBDaGVja3N1bSIsIlJPT1RfQVRUUl9OQU1FIiwiRE9DX05PREVfVFlQRSIsImluc3RhbmNlc0J5UmVhY3RSb290SUQiLCJmaXJzdERpZmZlcmVuY2VJbmRleCIsInN0cmluZzEiLCJzdHJpbmcyIiwibWluTGVuIiwiZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyIiwiaW50ZXJuYWxHZXRJRCIsIm1vdW50Q29tcG9uZW50SW50b05vZGUiLCJ3cmFwcGVySW5zdGFuY2UiLCJzaG91bGRSZXVzZU1hcmt1cCIsIndyYXBwZWRFbGVtZW50IiwiX21vdW50SW1hZ2VJbnRvTm9kZSIsImJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlIiwiY29tcG9uZW50SW5zdGFuY2UiLCJ1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUiLCJoYXNOb25Sb290UmVhY3RDaGlsZCIsInJvb3RFbCIsIm5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlIiwiaXNSZWFjdE5vZGUiLCJpc1ZhbGlkQ29udGFpbmVyIiwiaGFzQXR0cmlidXRlIiwiZ2V0SG9zdFJvb3RJbnN0YW5jZUluQ29udGFpbmVyIiwicHJldkhvc3RJbnN0YW5jZSIsImdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyIiwidG9wTGV2ZWxSb290Q291bnRlciIsIlRvcExldmVsV3JhcHBlciIsInJvb3RJRCIsIl9pbnN0YW5jZXNCeVJlYWN0Um9vdElEIiwic2Nyb2xsTW9uaXRvciIsInJlbmRlckNhbGxiYWNrIiwiX3VwZGF0ZVJvb3RDb21wb25lbnQiLCJwcmV2Q29tcG9uZW50IiwiX3JlbmRlck5ld1Jvb3RDb21wb25lbnQiLCJ3cmFwcGVySUQiLCJwYXJlbnRDb21wb25lbnQiLCJfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJuZXh0V3JhcHBlZEVsZW1lbnQiLCJwcmV2V3JhcHBlZEVsZW1lbnQiLCJwdWJsaWNJbnN0IiwidXBkYXRlZENhbGxiYWNrIiwicmVhY3RSb290RWxlbWVudCIsImNvbnRhaW5lckhhc1JlYWN0TWFya3VwIiwiY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQiLCJyb290RWxlbWVudFNpYmxpbmciLCJpc0NvbnRhaW5lclJlYWN0Um9vdCIsInJvb3RFbGVtZW50IiwiY2FuUmV1c2VNYXJrdXAiLCJjaGVja3N1bSIsIkNIRUNLU1VNX0FUVFJfTkFNRSIsInJvb3RNYXJrdXAiLCJvdXRlckhUTUwiLCJub3JtYWxpemVkTWFya3VwIiwibm9ybWFsaXplciIsImNvbnRlbnREb2N1bWVudCIsIndyaXRlIiwiZGlmZkluZGV4IiwiZGlmZmVyZW5jZSIsInRvcExldmVsV3JhcHBlciIsImFkbGVyMzIiLCJUQUdfRU5EIiwiQ09NTUVOVF9TVEFSVCIsImFkZENoZWNrc3VtVG9NYXJrdXAiLCJleGlzdGluZ0NoZWNrc3VtIiwibWFya3VwQ2hlY2tzdW0iLCJNT0QiLCJsIiwibSIsImNvbXBvbmVudE9yRWxlbWVudCIsInJlYWN0UHJvcHMiLCJ3YXJuZWRQcm9wZXJ0aWVzIiwidmFsaWRhdGVQcm9wZXJ0eSIsInN0YW5kYXJkTmFtZSIsIndhcm5Vbmtub3duUHJvcGVydGllcyIsInVua25vd25Qcm9wcyIsImlzVmFsaWQiLCJ1bmtub3duUHJvcFN0cmluZyIsImRpZFdhcm5WYWx1ZU51bGwiLCJfX2VzTW9kdWxlIiwiY29ubmVjdCIsIlByb3ZpZGVyIiwiX1Byb3ZpZGVyIiwiX1Byb3ZpZGVyMiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfY29ubmVjdCIsIl9jb25uZWN0MiIsIl9yZWFjdCIsIl9zdG9yZVNoYXBlIiwiX3N0b3JlU2hhcGUyIiwiX3dhcm5pbmciLCJfd2FybmluZzIiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIlJlZmVyZW5jZUVycm9yIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwic2V0UHJvdG90eXBlT2YiLCJkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSIsIndhcm5BYm91dFJlY2VpdmluZ1N0b3JlIiwiX0NvbXBvbmVudCIsIl90aGlzIiwibmV4dFN0b3JlIiwic3Vic2NyaWJlIiwiZGlzcGF0Y2giLCJnZXRTdGF0ZSIsIl9leHRlbmRzIiwiX3NoYWxsb3dFcXVhbCIsIl9zaGFsbG93RXF1YWwyIiwiX3dyYXBBY3Rpb25DcmVhdG9ycyIsIl93cmFwQWN0aW9uQ3JlYXRvcnMyIiwiX2lzUGxhaW5PYmplY3QiLCJfaXNQbGFpbk9iamVjdDIiLCJfaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJfaG9pc3ROb25SZWFjdFN0YXRpY3MyIiwiX2ludmFyaWFudCIsIl9pbnZhcmlhbnQyIiwiZGVmYXVsdE1hcFN0YXRlVG9Qcm9wcyIsImRlZmF1bHRNYXBEaXNwYXRjaFRvUHJvcHMiLCJkZWZhdWx0TWVyZ2VQcm9wcyIsInN0YXRlUHJvcHMiLCJkaXNwYXRjaFByb3BzIiwicGFyZW50UHJvcHMiLCJXcmFwcGVkQ29tcG9uZW50IiwiZXJyb3JPYmplY3QiLCJ0cnlDYXRjaCIsImN0eCIsIm5leHRWZXJzaW9uIiwibWFwU3RhdGVUb1Byb3BzIiwibWFwRGlzcGF0Y2hUb1Byb3BzIiwibWVyZ2VQcm9wcyIsInNob3VsZFN1YnNjcmliZSIsIm1hcFN0YXRlIiwibWFwRGlzcGF0Y2giLCJmaW5hbE1lcmdlUHJvcHMiLCJfb3B0aW9ucyRwdXJlIiwicHVyZSIsIl9vcHRpb25zJHdpdGhSZWYiLCJ3aXRoUmVmIiwiY2hlY2tNZXJnZWRFcXVhbHMiLCJ3cmFwV2l0aENvbm5lY3QiLCJjb25uZWN0RGlzcGxheU5hbWUiLCJjaGVja1N0YXRlU2hhcGUiLCJjb21wdXRlTWVyZ2VkUHJvcHMiLCJtZXJnZWRQcm9wcyIsIkNvbm5lY3QiLCJoYXZlT3duUHJvcHNDaGFuZ2VkIiwiaGFzU3RvcmVTdGF0ZUNoYW5nZWQiLCJzdG9yZVN0YXRlIiwiY2xlYXJDYWNoZSIsImNvbXB1dGVTdGF0ZVByb3BzIiwiZmluYWxNYXBTdGF0ZVRvUHJvcHMiLCJjb25maWd1cmVGaW5hbE1hcFN0YXRlIiwiZG9TdGF0ZVByb3BzRGVwZW5kT25Pd25Qcm9wcyIsIm1hcHBlZFN0YXRlIiwiaXNGYWN0b3J5IiwiY29tcHV0ZURpc3BhdGNoUHJvcHMiLCJmaW5hbE1hcERpc3BhdGNoVG9Qcm9wcyIsImNvbmZpZ3VyZUZpbmFsTWFwRGlzcGF0Y2giLCJkb0Rpc3BhdGNoUHJvcHNEZXBlbmRPbk93blByb3BzIiwibWFwcGVkRGlzcGF0Y2giLCJ1cGRhdGVTdGF0ZVByb3BzSWZOZWVkZWQiLCJuZXh0U3RhdGVQcm9wcyIsInVwZGF0ZURpc3BhdGNoUHJvcHNJZk5lZWRlZCIsIm5leHREaXNwYXRjaFByb3BzIiwidXBkYXRlTWVyZ2VkUHJvcHNJZk5lZWRlZCIsIm5leHRNZXJnZWRQcm9wcyIsImlzU3Vic2NyaWJlZCIsInVuc3Vic2NyaWJlIiwidHJ5U3Vic2NyaWJlIiwiaGFuZGxlQ2hhbmdlIiwidHJ5VW5zdWJzY3JpYmUiLCJoYXZlU3RhdGVQcm9wc0JlZW5QcmVjYWxjdWxhdGVkIiwic3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3IiLCJwcmV2U3RvcmVTdGF0ZSIsImhhdmVTdGF0ZVByb3BzQ2hhbmdlZCIsImdldFdyYXBwZWRJbnN0YW5jZSIsIndyYXBwZWRJbnN0YW5jZSIsInNob3VsZFVwZGF0ZVN0YXRlUHJvcHMiLCJzaG91bGRVcGRhdGVEaXNwYXRjaFByb3BzIiwiaGF2ZURpc3BhdGNoUHJvcHNDaGFuZ2VkIiwiaGF2ZU1lcmdlZFByb3BzQ2hhbmdlZCIsImhhc093biIsIndyYXBBY3Rpb25DcmVhdG9ycyIsIl9yZWR1eCIsImFjdGlvbkNyZWF0b3JzIiwiYmluZEFjdGlvbkNyZWF0b3JzIiwiY29tcG9zZSIsImFwcGx5TWlkZGxld2FyZSIsImNvbWJpbmVSZWR1Y2VycyIsImNyZWF0ZVN0b3JlIiwiX2NyZWF0ZVN0b3JlIiwiX2NyZWF0ZVN0b3JlMiIsIl9jb21iaW5lUmVkdWNlcnMiLCJfY29tYmluZVJlZHVjZXJzMiIsIl9iaW5kQWN0aW9uQ3JlYXRvcnMiLCJfYmluZEFjdGlvbkNyZWF0b3JzMiIsIl9hcHBseU1pZGRsZXdhcmUiLCJfYXBwbHlNaWRkbGV3YXJlMiIsIl9jb21wb3NlIiwiX2NvbXBvc2UyIiwiaXNDcnVzaGVkIiwiQWN0aW9uVHlwZXMiLCJfc3ltYm9sT2JzZXJ2YWJsZSIsIl9zeW1ib2xPYnNlcnZhYmxlMiIsIklOSVQiLCJyZWR1Y2VyIiwicHJlbG9hZGVkU3RhdGUiLCJlbmhhbmNlciIsIl9yZWYyIiwiY3VycmVudFJlZHVjZXIiLCJjdXJyZW50U3RhdGUiLCJjdXJyZW50TGlzdGVuZXJzIiwibmV4dExpc3RlbmVycyIsImlzRGlzcGF0Y2hpbmciLCJlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzIiwicmVwbGFjZVJlZHVjZXIiLCJuZXh0UmVkdWNlciIsIm9ic2VydmFibGUiLCJfcmVmIiwib3V0ZXJTdWJzY3JpYmUiLCJvYnNlcnZlciIsIm9ic2VydmVTdGF0ZSIsImdldFByb3RvdHlwZSIsImlzSG9zdE9iamVjdCIsImlzT2JqZWN0TGlrZSIsIm9iamVjdFRhZyIsImZ1bmNQcm90byIsIm9iamVjdFByb3RvIiwib2JqZWN0Q3RvclN0cmluZyIsIm9iamVjdFRvU3RyaW5nIiwiaXNQbGFpbk9iamVjdCIsIkN0b3IiLCJvdmVyQXJnIiwiZ2V0UHJvdG90eXBlT2YiLCJfcG9ueWZpbGwiLCJfcG9ueWZpbGwyIiwiZ2xvYmFsIiwic3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsIiwiX1N5bWJvbCIsImdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlIiwiYWN0aW9uVHlwZSIsImFjdGlvbk5hbWUiLCJnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlIiwiaW5wdXRTdGF0ZSIsInJlZHVjZXJzIiwidW5leHBlY3RlZEtleUNhY2hlIiwicmVkdWNlcktleXMiLCJhcmd1bWVudE5hbWUiLCJ1bmV4cGVjdGVkS2V5cyIsImFzc2VydFJlZHVjZXJTYW5pdHkiLCJmaW5hbFJlZHVjZXJzIiwiZmluYWxSZWR1Y2VyS2V5cyIsInNhbml0eUVycm9yIiwiY29tYmluYXRpb24iLCJ3YXJuaW5nTWVzc2FnZSIsImhhc0NoYW5nZWQiLCJwcmV2aW91c1N0YXRlRm9yS2V5IiwibmV4dFN0YXRlRm9yS2V5IiwiZXJyb3JNZXNzYWdlIiwiYmluZEFjdGlvbkNyZWF0b3IiLCJhY3Rpb25DcmVhdG9yIiwiYm91bmRBY3Rpb25DcmVhdG9ycyIsIm1pZGRsZXdhcmVzIiwiX2Rpc3BhdGNoIiwiY2hhaW4iLCJtaWRkbGV3YXJlQVBJIiwibWlkZGxld2FyZSIsImZ1bmNzIiwibGFzdCIsInJlc3QiLCJyZWR1Y2VSaWdodCIsImNvbXBvc2VkIiwiUkVBQ1RfU1RBVElDUyIsIktOT1dOX1NUQVRJQ1MiLCJjYWxsZXIiLCJhcml0eSIsImlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlIiwiaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJ0YXJnZXRDb21wb25lbnQiLCJzb3VyY2VDb21wb25lbnQiLCJjdXN0b21TdGF0aWNzIiwiY3JlYXRlVGh1bmtNaWRkbGV3YXJlIiwiZXh0cmFBcmd1bWVudCIsInRodW5rIiwid2l0aEV4dHJhQXJndW1lbnQiLCJBcHAiLCJjb25uZWN0U29ja2V0IiwiZGlzY29ubmVjdFNvY2tldCIsInJlY2VpdmVNZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJzZW5kTWVzc2FnZSIsInNvY2tldCIsImRpc2Nvbm5lY3QiLCJwYXJzZXIiLCJNYW5hZ2VyIiwibG9va3VwIiwibWFuYWdlcnMiLCJ1cmkiLCJvcHRzIiwicGFyc2VkIiwic2FtZU5hbWVzcGFjZSIsIm5zcHMiLCJuZXdDb25uZWN0aW9uIiwiZm9yY2VOZXciLCJtdWx0aXBsZXgiLCJpbyIsIlNvY2tldCIsInBhcnNldXJpIiwibG9jIiwiaG9zdCIsInBvcnQiLCJpcHY2IiwicmUiLCJwYXJ0cyIsImF1dGhvcml0eSIsImlwdjZ1cmkiLCJsb2ciLCJmb3JtYXRBcmdzIiwic2F2ZSIsInVzZUNvbG9ycyIsInN0b3JhZ2UiLCJjaHJvbWUiLCJsb2NhbHN0b3JhZ2UiLCJjb2xvcnMiLCJmaXJlYnVnIiwiZXhjZXB0aW9uIiwiJDEiLCJmb3JtYXR0ZXJzIiwidiIsImh1bWFuaXplIiwiZGlmZiIsImxhc3RDIiwibmFtZXNwYWNlcyIsInJlbW92ZUl0ZW0iLCJlbmFibGUiLCJsb2NhbFN0b3JhZ2UiLCJjb2VyY2UiLCJkaXNhYmxlIiwibmFtZXMiLCJza2lwcyIsInByZXZDb2xvciIsInByZXZUaW1lIiwic2VsZWN0Q29sb3IiLCJjdXJyIiwibXMiLCJwcmV2IiwiZm9ybWF0dGVyIiwibG9nRm4iLCJoIiwicGFyc2UiLCJsb25nIiwic2hvcnQiLCJwYXJzZUZsb2F0Iiwicm91bmQiLCJwbHVyYWwiLCJmbG9vciIsImNlaWwiLCJqc29uIiwiRW1pdHRlciIsImJpbmFyeSIsImlzQnVmIiwidHlwZXMiLCJDT05ORUNUIiwiRElTQ09OTkVDVCIsIkVWRU5UIiwiQUNLIiwiRVJST1IiLCJCSU5BUllfRVZFTlQiLCJCSU5BUllfQUNLIiwiRW5jb2RlciIsIkRlY29kZXIiLCJlbmNvZGUiLCJlbmNvZGVBc0JpbmFyeSIsImVuY29kaW5nIiwiZW5jb2RlQXNTdHJpbmciLCJuc3AiLCJhdHRhY2htZW50cyIsIndyaXRlRW5jb2RpbmciLCJibG9ibGVzc0RhdGEiLCJkZWNvbnN0cnVjdGlvbiIsImRlY29uc3RydWN0UGFja2V0IiwicGFjayIsInBhY2tldCIsImJ1ZmZlcnMiLCJ1bnNoaWZ0IiwicmVtb3ZlQmxvYnMiLCJyZWNvbnN0cnVjdG9yIiwiZGVjb2RlU3RyaW5nIiwiQmluYXJ5UmVjb25zdHJ1Y3RvciIsInJlY29uUGFjayIsImJhc2U2NCIsInRha2VCaW5hcnlEYXRhIiwiTnVtYmVyIiwiYnVmIiwiZGVzdHJveSIsImZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24iLCJiaW5EYXRhIiwicmVjb25zdHJ1Y3RQYWNrZXQiLCJpc0xvYWRlciIsIm9iamVjdFR5cGVzIiwiZnJlZUV4cG9ydHMiLCJmcmVlR2xvYmFsIiwicnVuSW5Db250ZXh0IiwiU3ludGF4RXJyb3IiLCJuYXRpdmVKU09OIiwiZ2V0Q2xhc3MiLCJpc1Byb3BlcnR5IiwidW5kZWYiLCJpc0V4dGVuZGVkIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwiZ2V0VVRDTWlsbGlzZWNvbmRzIiwic3RyaW5naWZ5U3VwcG9ydGVkIiwidG9KU09OIiwicGFyc2VTdXBwb3J0ZWQiLCJmdW5jdGlvbkNsYXNzIiwiZGF0ZUNsYXNzIiwibnVtYmVyQ2xhc3MiLCJzdHJpbmdDbGFzcyIsImFycmF5Q2xhc3MiLCJib29sZWFuQ2xhc3MiLCJjaGFySW5kZXhCdWdneSIsIk1vbnRocyIsImdldERheSIsInllYXIiLCJtb250aCIsIm1lbWJlcnMiLCJvcmlnaW5hbCIsInBhcmVudCIsInZhbHVlT2YiLCJoYXNQcm9wZXJ0eSIsImlzQ29uc3RydWN0b3IiLCJFc2NhcGVzIiwibGVhZGluZ1plcm9lcyIsInRvUGFkZGVkU3RyaW5nIiwidW5pY29kZVByZWZpeCIsInF1b3RlIiwidXNlQ2hhckluZGV4Iiwic2VyaWFsaXplIiwid2hpdGVzcGFjZSIsImluZGVudGF0aW9uIiwiZGF0ZSIsImhvdXJzIiwibWludXRlcyIsInNlY29uZHMiLCJtaWxsaXNlY29uZHMiLCJVbmVzY2FwZXMiLCJJbmRleCIsIlNvdXJjZSIsImxleCIsInBvc2l0aW9uIiwiaXNTaWduZWQiLCJoYXNNZW1iZXJzIiwid2FsayIsInByZXZpb3VzSlNPTiIsImlzUmVzdG9yZWQiLCJKU09OMyIsImRlZmluZSIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiaGFzTGlzdGVuZXJzIiwicGFja2V0RGF0YSIsIl9kZWNvbnN0cnVjdFBhY2tldCIsIl9wbGFjZWhvbGRlciIsIm51bSIsIm5ld0RhdGEiLCJjdXJQbGFjZUhvbGRlciIsIl9yZWNvbnN0cnVjdFBhY2tldCIsIl9yZW1vdmVCbG9icyIsImN1cktleSIsImNvbnRhaW5pbmdPYmplY3QiLCJCbG9iIiwiRmlsZSIsInBlbmRpbmdCbG9icyIsImZpbGVSZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJCdWZmZXIiLCJpc0J1ZmZlciIsIkFycmF5QnVmZmVyIiwiZWlvIiwiQmFja29mZiIsInN1YnMiLCJyZWNvbm5lY3Rpb24iLCJyZWNvbm5lY3Rpb25BdHRlbXB0cyIsIkluZmluaXR5IiwicmVjb25uZWN0aW9uRGVsYXkiLCJyZWNvbm5lY3Rpb25EZWxheU1heCIsInJhbmRvbWl6YXRpb25GYWN0b3IiLCJiYWNrb2ZmIiwiaml0dGVyIiwicmVhZHlTdGF0ZSIsImNvbm5lY3RpbmciLCJsYXN0UGluZyIsInBhY2tldEJ1ZmZlciIsImVuY29kZXIiLCJkZWNvZGVyIiwiYXV0b0Nvbm5lY3QiLCJlbWl0QWxsIiwidXBkYXRlU29ja2V0SWRzIiwiZW5naW5lIiwiX3JlY29ubmVjdGlvbiIsIl9yZWNvbm5lY3Rpb25BdHRlbXB0cyIsIl9yZWNvbm5lY3Rpb25EZWxheSIsInNldE1pbiIsIl9yYW5kb21pemF0aW9uRmFjdG9yIiwic2V0Sml0dGVyIiwiX3JlY29ubmVjdGlvbkRlbGF5TWF4Iiwic2V0TWF4IiwiX3RpbWVvdXQiLCJtYXliZVJlY29ubmVjdE9uT3BlbiIsInJlY29ubmVjdGluZyIsImF0dGVtcHRzIiwicmVjb25uZWN0Iiwic2tpcFJlY29ubmVjdCIsIm9wZW5TdWIiLCJvbm9wZW4iLCJlcnJvclN1YiIsImNsZWFudXAiLCJ0aW1lciIsIm9ucGluZyIsIm9ucG9uZyIsIm9uZGF0YSIsIm9uZGVjb2RlZCIsIm9uZXJyb3IiLCJvbkNvbm5lY3RpbmciLCJlbmNvZGVkUGFja2V0cyIsInByb2Nlc3NQYWNrZXRRdWV1ZSIsInNoaWZ0Iiwib25jbG9zZSIsInJlYXNvbiIsImRlbGF5Iiwib25yZWNvbm5lY3QiLCJhdHRlbXB0IiwidHJhbnNwb3J0cyIsInBhcnNlanNvbiIsInBhcnNlcXMiLCJob3N0bmFtZSIsInNlY3VyZSIsInF1ZXJ5IiwiYWdlbnQiLCJkZWNvZGUiLCJ1cGdyYWRlIiwiZm9yY2VKU09OUCIsImpzb25wIiwiZm9yY2VCYXNlNjQiLCJlbmFibGVzWERSIiwidGltZXN0YW1wUGFyYW0iLCJ0aW1lc3RhbXBSZXF1ZXN0cyIsIndyaXRlQnVmZmVyIiwicG9saWN5UG9ydCIsInJlbWVtYmVyVXBncmFkZSIsImJpbmFyeVR5cGUiLCJvbmx5QmluYXJ5VXBncmFkZXMiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsInRocmVzaG9sZCIsInBmeCIsInBhc3NwaHJhc2UiLCJjZXJ0IiwiY2EiLCJjaXBoZXJzIiwicmVqZWN0VW5hdXRob3JpemVkIiwiZXh0cmFIZWFkZXJzIiwicHJpb3JXZWJzb2NrZXRTdWNjZXNzIiwiVHJhbnNwb3J0IiwiY3JlYXRlVHJhbnNwb3J0IiwiY2xvbmUiLCJFSU8iLCJ0cmFuc3BvcnQiLCJzaWQiLCJvIiwic2V0VHJhbnNwb3J0Iiwib25EcmFpbiIsIm9uUGFja2V0Iiwib25DbG9zZSIsInByb2JlIiwiZmFpbGVkIiwib25UcmFuc3BvcnRPcGVuIiwidXBncmFkZUxvc2VzQmluYXJ5Iiwic3VwcG9ydHNCaW5hcnkiLCJzZW5kIiwibXNnIiwidXBncmFkaW5nIiwiZmx1c2giLCJmcmVlemVUcmFuc3BvcnQiLCJvblRyYW5zcG9ydENsb3NlIiwib251cGdyYWRlIiwib25PcGVuIiwidXBncmFkZXMiLCJvbkhhbmRzaGFrZSIsInNldFBpbmciLCJmaWx0ZXJVcGdyYWRlcyIsInBpbmdJbnRlcnZhbCIsInBpbmdUaW1lb3V0Iiwib25IZWFydGJlYXQiLCJwaW5nVGltZW91dFRpbWVyIiwicGluZ0ludGVydmFsVGltZXIiLCJwaW5nIiwic2VuZFBhY2tldCIsInByZXZCdWZmZXJMZW4iLCJjb21wcmVzcyIsIndhaXRGb3JVcGdyYWRlIiwiY2xlYW51cEFuZENsb3NlIiwiZGVzYyIsImZpbHRlcmVkVXBncmFkZXMiLCJYTUxIdHRwUmVxdWVzdCIsIlhIUiIsIkpTT05QIiwid2Vic29ja2V0IiwicG9sbGluZyIsInhociIsInhkIiwieHMiLCJpc1NTTCIsInhkb21haW4iLCJ4c2NoZW1lIiwiaGFzQ09SUyIsIlhEb21haW5SZXF1ZXN0IiwiQWN0aXZlWE9iamVjdCIsIlBvbGxpbmciLCJpbmhlcml0IiwiUmVxdWVzdCIsImVtcHR5IiwicmVxdWVzdCIsImRvV3JpdGUiLCJpc0JpbmFyeSIsInJlcSIsInNlbmRYaHIiLCJkb1BvbGwiLCJvbkRhdGEiLCJwb2xsWGhyIiwic2V0RGlzYWJsZUhlYWRlckNoZWNrIiwic2V0UmVxdWVzdEhlYWRlciIsInJlc3BvbnNlVHlwZSIsIndpdGhDcmVkZW50aWFscyIsImhhc1hEUiIsInJlc3BvbnNlVGV4dCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInN0YXR1cyIsInJlcXVlc3RzQ291bnQiLCJyZXF1ZXN0cyIsIm9uU3VjY2VzcyIsImZyb21FcnJvciIsImNvbnRlbnRUeXBlIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJyZXNwb25zZSIsIlVpbnQ4QXJyYXkiLCJ1aThBcnIiLCJkYXRhQXJyYXkiLCJpZHgiLCJ1bmxvYWRIYW5kbGVyIiwieWVhc3QiLCJoYXNYSFIyIiwiZG9PcGVuIiwicG9sbCIsInBlbmRpbmciLCJ0b3RhbCIsImRlY29kZVBheWxvYWQiLCJkb0Nsb3NlIiwicGFja2V0cyIsImNhbGxiYWNrZm4iLCJlbmNvZGVQYXlsb2FkIiwic2NoZW1hIiwiYjY0IiwiZGVzY3JpcHRpb24iLCJkZWNvZGVQYWNrZXQiLCJoYXNCaW5hcnkiLCJzbGljZUJ1ZmZlciIsImJhc2U2NGVuY29kZXIiLCJhZnRlciIsInV0ZjgiLCJpc0FuZHJvaWQiLCJpc1BoYW50b21KUyIsImRvbnRTZW5kQmxvYnMiLCJwb25nIiwicGFja2V0c2xpc3QiLCJlbmNvZGVQYWNrZXQiLCJ1dGY4ZW5jb2RlIiwiYnVmZmVyIiwiZW5jb2RlQXJyYXlCdWZmZXIiLCJlbmNvZGVCbG9iIiwiZW5jb2RlQmFzZTY0T2JqZWN0IiwiZW5jb2RlZCIsImVuY29kZUJhc2U2NFBhY2tldCIsImNvbnRlbnRBcnJheSIsInJlc3VsdEJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlciIsImZyIiwiYmxvYiIsInJlYWRBc0RhdGFVUkwiLCJiNjRkYXRhIiwidHlwZWQiLCJiYXNpYyIsImJ0b2EiLCJ1dGY4ZGVjb2RlIiwiZGVjb2RlQmFzZTY0UGFja2V0IiwiYXNBcnJheSIsImVuY29kZVBheWxvYWRBc0Jsb2IiLCJlbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciIsInNldExlbmd0aEhlYWRlciIsImVuY29kZU9uZSIsImRvbmVDYWxsYmFjayIsImFyeSIsImVhY2giLCJlYWNoV2l0aEluZGV4IiwiZGVjb2RlUGF5bG9hZEFzQmluYXJ5IiwiY2hyIiwidG90YWxMZW5ndGgiLCJhY2MiLCJyZXN1bHRBcnJheSIsImJ1ZmZlckluZGV4IiwiaXNTdHJpbmciLCJhYiIsImxlblN0ciIsImJpbmFyeUlkZW50aWZpZXIiLCJsZW5ndGhBcnkiLCJidWZmZXJUYWlsIiwibnVtYmVyVG9vTG9uZyIsInRhaWxBcnJheSIsIm1zZ0xlbmd0aCIsIl9oYXNCaW5hcnkiLCJhcnJheWJ1ZmZlciIsImJ5dGVzIiwiYWJ2IiwiYnVmZmVyTGVuZ3RoIiwiZW5jb2RlZDEiLCJlbmNvZGVkMiIsImVuY29kZWQzIiwiZW5jb2RlZDQiLCJlcnJfY2IiLCJiYWlsIiwicHJveHkiLCJmcmVlTW9kdWxlIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwidWNzMmRlY29kZSIsImNvdW50ZXIiLCJleHRyYSIsInVjczJlbmNvZGUiLCJjaGVja1NjYWxhclZhbHVlIiwiY29kZVBvaW50IiwiY3JlYXRlQnl0ZSIsImVuY29kZUNvZGVQb2ludCIsImNvZGVQb2ludHMiLCJieXRlU3RyaW5nIiwicmVhZENvbnRpbnVhdGlvbkJ5dGUiLCJieXRlSW5kZXgiLCJieXRlQ291bnQiLCJjb250aW51YXRpb25CeXRlIiwiYnl0ZUFycmF5IiwiZGVjb2RlU3ltYm9sIiwiYnl0ZTEiLCJieXRlMiIsImJ5dGUzIiwiYnl0ZTQiLCJ0bXAiLCJCbG9iQnVpbGRlciIsIldlYktpdEJsb2JCdWlsZGVyIiwiTVNCbG9iQnVpbGRlciIsIk1vekJsb2JCdWlsZGVyIiwiYmxvYlN1cHBvcnRlZCIsImJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyIsImJsb2JCdWlsZGVyU3VwcG9ydGVkIiwiYXBwZW5kIiwiZ2V0QmxvYiIsIm1hcEFycmF5QnVmZmVyVmlld3MiLCJjaHVuayIsImJ5dGVPZmZzZXQiLCJCbG9iQnVpbGRlckNvbnN0cnVjdG9yIiwiYmIiLCJCbG9iQ29uc3RydWN0b3IiLCJxcyIsInFyeSIsInBhaXIiLCJkZWNvZGVVUklDb21wb25lbnQiLCJhbHBoYWJldCIsImRlY29kZWQiLCJKU09OUFBvbGxpbmciLCJyTmV3bGluZSIsInJFc2NhcGVkTmV3bGluZSIsIl9fX2VpbyIsImluc2VydEF0IiwiaXNVQWdlY2tvIiwiaWZyYW1lSWQiLCJjb21wbGV0ZSIsImluaXRJZnJhbWUiLCJCcm93c2VyV2ViU29ja2V0IiwiV2ViU29ja2V0IiwiTW96V2ViU29ja2V0IiwiV1MiLCJjaGVjayIsInByb3RvY29scyIsIndzIiwic3VwcG9ydHMiLCJhZGRFdmVudExpc3RlbmVycyIsIm9ubWVzc2FnZSIsImV2IiwicnZhbGlkY2hhcnMiLCJydmFsaWRlc2NhcGUiLCJydmFsaWR0b2tlbnMiLCJydmFsaWRicmFjZXMiLCJydHJpbUxlZnQiLCJydHJpbVJpZ2h0IiwiaGFzQmluIiwiY29ubmVjdF9lcnJvciIsImNvbm5lY3RfdGltZW91dCIsInJlY29ubmVjdF9hdHRlbXB0IiwicmVjb25uZWN0X2ZhaWxlZCIsInJlY29ubmVjdF9lcnJvciIsImlkcyIsImFja3MiLCJyZWNlaXZlQnVmZmVyIiwic2VuZEJ1ZmZlciIsImNvbm5lY3RlZCIsImRpc2Nvbm5lY3RlZCIsInN1YkV2ZW50cyIsInBhcnNlclR5cGUiLCJmbGFncyIsIm9ucGFja2V0Iiwib25jb25uZWN0Iiwib25ldmVudCIsIm9uYWNrIiwib25kaXNjb25uZWN0IiwiYWNrIiwic2VudCIsImVtaXRCdWZmZXJlZCIsImZhY3RvciIsInBvdyIsInJhbmQiLCJkZXZpYXRpb24iLCJQT1NUX01FU1NBR0UiLCJSRUNFSVZFX01FU1NBR0UiLCJVUERBVEUiXSwi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Qng1RCxLQUFvQix5REFBWixFQUFZO0FBQUEsT0FBUjZ0QixNQUFROztBQUNuQyxXQUFPQSxPQUFPMTVCLElBQWQ7QUFDRSxVQUFLLFFBQUw7QUFDRSxjQUFPMDVCLE9BQU92aUMsSUFBZDtBQUNGO0FBQ0UsY0FBTzBVLEtBQVA7QUFKSjtBQU1EOzttQkFFYyw0QkFBZ0I7QUFDN0J3NUQsbUJBRDZCO0FBRTdCOHFCO0FBRjZCLEVBQWhCLEMiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCA3M2MwY2I2N2U4ZjBiM2EyZTQyNlxuICoqLyIsIi8vIGltcG9ydCBpbyBmcm9tICdzb2NrZXQuaW8tY2xpZW50Jztcbi8vXG4vLyBsZXQgc29ja2V0ID0gaW8oKTtcbi8vXG4vLyBzb2NrZXQub24oJ2Nvbm5lY3Rpb24nLCBzID0+IHtcbi8vICAgY29uc29sZS5sb2coJ2EgdXNlciBjb25uZWN0ZWQnKTtcbi8vICAgcy5vbignZGlzY29ubmVjdCcsIGZ1bmN0aW9uKCl7XG4vLyAgICAgY29uc29sZS5sb2coJ3VzZXIgZGlzY29ubmVjdGVkJyk7XG4vLyAgIH0pO1xuLy8gfSk7XG5cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHJlbmRlciB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IGNyZWF0ZVN0b3JlLCBhcHBseU1pZGRsZXdhcmUgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgdGh1bmtNaWRkbGV3YXJlIGZyb20gJ3JlZHV4LXRodW5rJztcblxuaW1wb3J0IEFwcCBmcm9tICcuL2NvbXBvbmVudHMvQXBwJztcbmltcG9ydCByZWR1Y2VyIGZyb20gJy4vcmVkdWNlcnMnO1xuXG5sZXQgc3RvcmUgPSBjcmVhdGVTdG9yZShcbiAgcmVkdWNlcixcbiAgYXBwbHlNaWRkbGV3YXJlKHRodW5rTWlkZGxld2FyZSlcbik7XG5cbnJlbmRlcihcbiAgPFByb3ZpZGVyIHN0b3JlPXtzdG9yZX0+XG4gICAgPEFwcCAvPlxuICA8L1Byb3ZpZGVyPixcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpXG4pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3QnKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9yZWFjdC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuJyk7XG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RQdXJlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdFB1cmVDb21wb25lbnQnKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZSgnLi9SZWFjdENsYXNzJyk7XG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmFjdG9yaWVzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgb25seUNoaWxkID0gcmVxdWlyZSgnLi9vbmx5Q2hpbGQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50O1xudmFyIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcbnZhciBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbiAgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50O1xuICBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG4gIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jbG9uZUVsZW1lbnQ7XG59XG5cbnZhciBfX3NwcmVhZCA9IF9hc3NpZ247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcod2FybmVkLCAnUmVhY3QuX19zcHJlYWQgaXMgZGVwcmVjYXRlZCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkLiBVc2UgJyArICdPYmplY3QuYXNzaWduIGRpcmVjdGx5IG9yIGFub3RoZXIgaGVscGVyIGZ1bmN0aW9uIHdpdGggc2ltaWxhciAnICsgJ3NlbWFudGljcy4gWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byB5b3VyIGNvbXBpbGVyLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LXNwcmVhZC1kZXByZWNhdGlvbiBmb3IgbW9yZSBkZXRhaWxzLicpIDogdm9pZCAwO1xuICAgIHdhcm5lZCA9IHRydWU7XG4gICAgcmV0dXJuIF9hc3NpZ24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIFJlYWN0ID0ge1xuXG4gIC8vIE1vZGVyblxuXG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBSZWFjdENoaWxkcmVuLm1hcCxcbiAgICBmb3JFYWNoOiBSZWFjdENoaWxkcmVuLmZvckVhY2gsXG4gICAgY291bnQ6IFJlYWN0Q2hpbGRyZW4uY291bnQsXG4gICAgdG9BcnJheTogUmVhY3RDaGlsZHJlbi50b0FycmF5LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnQsXG4gIFB1cmVDb21wb25lbnQ6IFJlYWN0UHVyZUNvbXBvbmVudCxcblxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudCxcbiAgaXNWYWxpZEVsZW1lbnQ6IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCxcblxuICAvLyBDbGFzc2ljXG5cbiAgUHJvcFR5cGVzOiBSZWFjdFByb3BUeXBlcyxcbiAgY3JlYXRlQ2xhc3M6IFJlYWN0Q2xhc3MuY3JlYXRlQ2xhc3MsXG4gIGNyZWF0ZUZhY3Rvcnk6IGNyZWF0ZUZhY3RvcnksXG4gIGNyZWF0ZU1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAvLyBDdXJyZW50bHkgYSBub29wLiBXaWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgYW5kIHRyYWNlIG1peGlucy5cbiAgICByZXR1cm4gbWl4aW47XG4gIH0sXG5cbiAgLy8gVGhpcyBsb29rcyBET00gc3BlY2lmaWMgYnV0IHRoZXNlIGFyZSBhY3R1YWxseSBpc29tb3JwaGljIGhlbHBlcnNcbiAgLy8gc2luY2UgdGhleSBhcmUganVzdCBnZW5lcmF0aW5nIERPTSBzdHJpbmdzLlxuICBET006IFJlYWN0RE9NRmFjdG9yaWVzLFxuXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICAvLyBEZXByZWNhdGVkIGhvb2sgZm9yIEpTWCBzcHJlYWQsIGRvbid0IHVzZSB0aGlzIGZvciBhbnl0aGluZy5cbiAgX19zcHJlYWQ6IF9fc3ByZWFkXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3QuanNcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyO1xudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcjtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiB0cmF2ZXJzYWwuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgRm9yRWFjaEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gZm9yRWFjaEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gdHJhdmVyc2FsIHdpdGguXG4gKiBAcGFyYW0gez8qfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gY29udGV4dCB3aXRoLlxuICovXG5mdW5jdGlvbiBGb3JFYWNoQm9va0tlZXBpbmcoZm9yRWFjaEZ1bmN0aW9uLCBmb3JFYWNoQ29udGV4dCkge1xuICB0aGlzLmZ1bmMgPSBmb3JFYWNoRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IGZvckVhY2hDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbkZvckVhY2hCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZvckVhY2hCb29rS2VlcGluZywgdHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYztcbiAgdmFyIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBGb3JFYWNoQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgRm9yRWFjaEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIG1hcHBpbmcuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgTWFwQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7ISp9IG1hcFJlc3VsdCBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBtYXBGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IG1hcENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqL1xuZnVuY3Rpb24gTWFwQm9va0tlZXBpbmcobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIHRoaXMucmVzdWx0ID0gbWFwUmVzdWx0O1xuICB0aGlzLmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgdGhpcy5mdW5jID0gbWFwRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuTWFwQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVzdWx0ID0gbnVsbDtcbiAgdGhpcy5rZXlQcmVmaXggPSBudWxsO1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oTWFwQm9va0tlZXBpbmcsIGZvdXJBcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQoYm9va0tlZXBpbmcsIGNoaWxkLCBjaGlsZEtleSkge1xuICB2YXIgcmVzdWx0ID0gYm9va0tlZXBpbmcucmVzdWx0O1xuICB2YXIga2V5UHJlZml4ID0gYm9va0tlZXBpbmcua2V5UHJlZml4O1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmM7XG4gIHZhciBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuXG4gIHZhciBtYXBwZWRDaGlsZCA9IGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG4gIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwobWFwcGVkQ2hpbGQsIHJlc3VsdCwgY2hpbGRLZXksIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gTWFwQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgTWFwQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuYywgY29udGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZER1bW15KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250ZXh0KSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSwgbnVsbCk7XG59XG5cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlYWN0Q2hpbGRyZW4gPSB7XG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbDogbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCxcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXlcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZHJlbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUG9vbGVkQ2xhc3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBTdGF0aWMgcG9vbGVycy4gU2V2ZXJhbCBjdXN0b20gdmVyc2lvbnMgZm9yIGVhY2ggcG90ZW50aWFsIG51bWJlciBvZlxuICogYXJndW1lbnRzLiBBIGNvbXBsZXRlbHkgZ2VuZXJpYyBwb29sZXIgaXMgZWFzeSB0byBpbXBsZW1lbnQsIGJ1dCB3b3VsZFxuICogcmVxdWlyZSBhY2Nlc3NpbmcgdGhlIGBhcmd1bWVudHNgIG9iamVjdC4gSW4gZWFjaCBvZiB0aGVzZSwgYHRoaXNgIHJlZmVycyB0b1xuICogdGhlIENsYXNzIGl0c2VsZiwgbm90IGFuIGluc3RhbmNlLiBJZiBhbnkgb3RoZXJzIGFyZSBuZWVkZWQsIHNpbXBseSBhZGQgdGhlbVxuICogaGVyZSwgb3IgaW4gdGhlaXIgb3duIGZpbGVzLlxuICovXG52YXIgb25lQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoY29weUZpZWxkc0Zyb20pIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgY29weUZpZWxkc0Zyb20pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGNvcHlGaWVsZHNGcm9tKTtcbiAgfVxufTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMikge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMik7XG4gIH1cbn07XG5cbnZhciB0aHJlZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMyk7XG4gIH1cbn07XG5cbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0KTtcbiAgfVxufTtcblxudmFyIGZpdmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICB9XG59O1xuXG52YXIgc3RhbmRhcmRSZWxlYXNlciA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICAhKGluc3RhbmNlIGluc3RhbmNlb2YgS2xhc3MpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGluc3RhbmNlIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiBfcHJvZEludmFyaWFudCgnMjUnKSA6IHZvaWQgMDtcbiAgaW5zdGFuY2UuZGVzdHJ1Y3RvcigpO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCA8IEtsYXNzLnBvb2xTaXplKSB7XG4gICAgS2xhc3MuaW5zdGFuY2VQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59O1xuXG52YXIgREVGQVVMVF9QT09MX1NJWkUgPSAxMDtcbnZhciBERUZBVUxUX1BPT0xFUiA9IG9uZUFyZ3VtZW50UG9vbGVyO1xuXG4vKipcbiAqIEF1Z21lbnRzIGBDb3B5Q29uc3RydWN0b3JgIHRvIGJlIGEgcG9vbGFibGUgY2xhc3MsIGF1Z21lbnRpbmcgb25seSB0aGUgY2xhc3NcbiAqIGl0c2VsZiAoc3RhdGljYWxseSkgbm90IGFkZGluZyBhbnkgcHJvdG90eXBpY2FsIGZpZWxkcy4gQW55IENvcHlDb25zdHJ1Y3RvclxuICogeW91IGdpdmUgdGhpcyBtYXkgaGF2ZSBhIGBwb29sU2l6ZWAgcHJvcGVydHksIGFuZCB3aWxsIGxvb2sgZm9yIGFcbiAqIHByb3RvdHlwaWNhbCBgZGVzdHJ1Y3RvcmAgb24gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvcHlDb25zdHJ1Y3RvciBDb25zdHJ1Y3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcG9vbGVyIEN1c3RvbWl6YWJsZSBwb29sZXIuXG4gKi9cbnZhciBhZGRQb29saW5nVG8gPSBmdW5jdGlvbiAoQ29weUNvbnN0cnVjdG9yLCBwb29sZXIpIHtcbiAgdmFyIE5ld0tsYXNzID0gQ29weUNvbnN0cnVjdG9yO1xuICBOZXdLbGFzcy5pbnN0YW5jZVBvb2wgPSBbXTtcbiAgTmV3S2xhc3MuZ2V0UG9vbGVkID0gcG9vbGVyIHx8IERFRkFVTFRfUE9PTEVSO1xuICBpZiAoIU5ld0tsYXNzLnBvb2xTaXplKSB7XG4gICAgTmV3S2xhc3MucG9vbFNpemUgPSBERUZBVUxUX1BPT0xfU0laRTtcbiAgfVxuICBOZXdLbGFzcy5yZWxlYXNlID0gc3RhbmRhcmRSZWxlYXNlcjtcbiAgcmV0dXJuIE5ld0tsYXNzO1xufTtcblxudmFyIFBvb2xlZENsYXNzID0ge1xuICBhZGRQb29saW5nVG86IGFkZFBvb2xpbmdUbyxcbiAgb25lQXJndW1lbnRQb29sZXI6IG9uZUFyZ3VtZW50UG9vbGVyLFxuICB0d29Bcmd1bWVudFBvb2xlcjogdHdvQXJndW1lbnRQb29sZXIsXG4gIHRocmVlQXJndW1lbnRQb29sZXI6IHRocmVlQXJndW1lbnRQb29sZXIsXG4gIGZvdXJBcmd1bWVudFBvb2xlcjogZm91ckFyZ3VtZW50UG9vbGVyLFxuICBmaXZlQXJndW1lbnRQb29sZXI6IGZpdmVBcmd1bWVudFBvb2xlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1Bvb2xlZENsYXNzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSByZWFjdFByb2RJbnZhcmlhbnRcbiAqIFxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG5mdW5jdGlvbiByZWFjdFByb2RJbnZhcmlhbnQoY29kZSkge1xuICB2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblxuICB2YXIgbWVzc2FnZSA9ICdNaW5pZmllZCBSZWFjdCBlcnJvciAjJyArIGNvZGUgKyAnOyB2aXNpdCAnICsgJ2h0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PScgKyBjb2RlO1xuXG4gIGZvciAodmFyIGFyZ0lkeCA9IDA7IGFyZ0lkeCA8IGFyZ0NvdW50OyBhcmdJZHgrKykge1xuICAgIG1lc3NhZ2UgKz0gJyZhcmdzW109JyArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYXJnSWR4ICsgMV0pO1xuICB9XG5cbiAgbWVzc2FnZSArPSAnIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCcgKyAnIGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLic7XG5cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgcmVhY3RQcm9kSW52YXJpYW50J3Mgb3duIGZyYW1lXG5cbiAgdGhyb3cgZXJyb3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3RQcm9kSW52YXJpYW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvaW52YXJpYW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RWxlbWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIG5vIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcbiAgICB2YXIgc2hhZG93Q2hpbGRyZW4gPSBBcnJheS5pc0FycmF5KHByb3BzLmNoaWxkcmVuKSA/IHByb3BzLmNoaWxkcmVuLnNsaWNlKDApIDogcHJvcHMuY2hpbGRyZW47XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzZWxmXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NoYWRvd0NoaWxkcmVuJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc2hhZG93Q2hpbGRyZW5cbiAgICAgIH0pO1xuICAgICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc291cmNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICBlbGVtZW50Ll9zZWxmID0gc2VsZjtcbiAgICAgIGVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuID0gc2hhZG93Q2hpbGRyZW47XG4gICAgICBlbGVtZW50Ll9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgIGNvbmZpZy5fX3Byb3RvX18gPT0gbnVsbCB8fCBjb25maWcuX19wcm90b19fID09PSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoLi4uKTogRXhwZWN0ZWQgcHJvcHMgYXJndW1lbnQgdG8gYmUgYSBwbGFpbiBvYmplY3QuICcgKyAnUHJvcGVydGllcyBkZWZpbmVkIGluIGl0cyBwcm90b3R5cGUgY2hhaW4gd2lsbCBiZSBpZ25vcmVkLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWZhY3RvcnlcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgZmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cbiAgLy8gVGhpcyBzaG91bGQgbm90IGJlIG5hbWVkIGBjb25zdHJ1Y3RvcmAgc2luY2UgdGhpcyBtYXkgbm90IGJlIHRoZSBmdW5jdGlvblxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGVsZW1lbnQsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleSA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2xvbmVlbGVtZW50XG4gKi9cblJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgIGNvbmZpZy5fX3Byb3RvX18gPT0gbnVsbCB8fCBjb25maWcuX19wcm90b19fID09PSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgJ1JlYWN0LmNsb25lRWxlbWVudCguLi4pOiBFeHBlY3RlZCBwcm9wcyBhcmd1bWVudCB0byBiZSBhIHBsYWluIG9iamVjdC4gJyArICdQcm9wZXJ0aWVzIGRlZmluZWQgaW4gaXRzIHByb3RvdHlwZSBjaGFpbiB3aWxsIGJlIGlnbm9yZWQuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cblJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn07XG5cblJlYWN0RWxlbWVudC5SRUFDVF9FTEVNRU5UX1RZUEUgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFbGVtZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q3VycmVudE93bmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDdXJyZW50T3duZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCAoeCkge31cbiAgICB9O1xuXG4gICAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICAgIH1cblxuICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvd2FybmluZy5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2FuRGVmaW5lUHJvcGVydHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4JywgeyBnZXQ6IGZ1bmN0aW9uICgpIHt9IH0pO1xuICAgIGNhbkRlZmluZVByb3BlcnR5ID0gdHJ1ZTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIElFIHdpbGwgZmFpbCBvbiBkZWZpbmVQcm9wZXJ0eVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FuRGVmaW5lUHJvcGVydHk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB0cmF2ZXJzZUFsbENoaWxkcmVuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICB2YXIgaWkgPSAwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyc7XG4gICAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgaWYgKG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lKSB7XG4gICAgICAgICAgICAgIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3QgeWV0IGZ1bGx5IHN1cHBvcnRlZC4gSXQgaXMgYW4gJyArICdleHBlcmltZW50YWwgZmVhdHVyZSB0aGF0IG1pZ2h0IGJlIHJlbW92ZWQuIENvbnZlcnQgaXQgdG8gYSAnICsgJ3NlcXVlbmNlIC8gaXRlcmFibGUgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLiVzJywgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgY2hpbGQgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBLZXlFc2NhcGVVdGlscy5lc2NhcGUoZW50cnlbMF0pICsgU1VCU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCAwKTtcbiAgICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkIG9yIHdyYXAgdGhlIG9iamVjdCB1c2luZyBjcmVhdGVGcmFnbWVudChvYmplY3QpIGZyb20gdGhlICcgKyAnUmVhY3QgYWRkLW9ucy4nO1xuICAgICAgICBpZiAoY2hpbGRyZW4uX2lzUmVhY3RFbGVtZW50KSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEl0IGxvb2tzIGxpa2UgeW91XFwncmUgdXNpbmcgYW4gZWxlbWVudCBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50ICcgKyAndmVyc2lvbiBvZiBSZWFjdC4gTWFrZSBzdXJlIHRvIHVzZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSArPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiBfcHJvZEludmFyaWFudCgnMzEnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlQWxsQ2hpbGRyZW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEl0ZXJhdG9yRm5cbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gKlxuICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gKlxuICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICogICAgICAgLi4uXG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvckZuO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0SXRlcmF0b3JGbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBLZXlFc2NhcGVVdGlsc1xuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFVuZXNjYXBlIGFuZCB1bndyYXAga2V5IGZvciBodW1hbi1yZWFkYWJsZSBkaXNwbGF5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byB1bmVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHVuZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlKGtleSkge1xuICB2YXIgdW5lc2NhcGVSZWdleCA9IC8oPTB8PTIpL2c7XG4gIHZhciB1bmVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0wJzogJz0nLFxuICAgICc9Mic6ICc6J1xuICB9O1xuICB2YXIga2V5U3Vic3RyaW5nID0ga2V5WzBdID09PSAnLicgJiYga2V5WzFdID09PSAnJCcgPyBrZXkuc3Vic3RyaW5nKDIpIDoga2V5LnN1YnN0cmluZygxKTtcblxuICByZXR1cm4gKCcnICsga2V5U3Vic3RyaW5nKS5yZXBsYWNlKHVuZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiB1bmVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbn1cblxudmFyIEtleUVzY2FwZVV0aWxzID0ge1xuICBlc2NhcGU6IGVzY2FwZSxcbiAgdW5lc2NhcGU6IHVuZXNjYXBlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleUVzY2FwZVV0aWxzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvS2V5RXNjYXBlVXRpbHMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBSZWFjdENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiBfcHJvZEludmFyaWFudCgnODUnKSA6IHZvaWQgMDtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKSA6IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2spIHt9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2VtcHR5T2JqZWN0LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHVyZUNvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUmVhY3RQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIC8vIER1cGxpY2F0ZWQgZnJvbSBSZWFjdENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZTtcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWFjdFB1cmVDb21wb25lbnQ7XG4vLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cbl9hc3NpZ24oUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlKTtcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHVyZUNvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UHVyZUNvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENsYXNzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIE1JWElOU19LRVkgPSBrZXlPZih7IG1peGluczogbnVsbCB9KTtcblxuLyoqXG4gKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q2xhc3NJbnRlcmZhY2VgLlxuICovXG52YXIgU3BlY1BvbGljeSA9IGtleU1pcnJvcih7XG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBkZWZpbmVkIG9ubHkgb25jZSBieSB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBvciBtaXhpbi5cbiAgICovXG4gIERFRklORV9PTkNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBieSBib3RoIHRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIGFuZCBtaXhpbnMuXG4gICAqIFN1YnNlcXVlbnQgZGVmaW5pdGlvbnMgd2lsbCBiZSBjaGFpbmVkLiBUaGVzZSBtZXRob2RzIG11c3QgcmV0dXJuIHZvaWQuXG4gICAqL1xuICBERUZJTkVfTUFOWTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIG92ZXJyaWRpbmcgdGhlIGJhc2UgY2xhc3MuXG4gICAqL1xuICBPVkVSUklERV9CQVNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBhcmUgc2ltaWxhciB0byBERUZJTkVfTUFOWSwgZXhjZXB0IHdlIGFzc3VtZSB0aGV5IHJldHVyblxuICAgKiBvYmplY3RzLiBXZSB0cnkgdG8gbWVyZ2UgdGhlIGtleXMgb2YgdGhlIHJldHVybiB2YWx1ZXMgb2YgYWxsIHRoZSBtaXhlZCBpblxuICAgKiBmdW5jdGlvbnMuIElmIHRoZXJlIGlzIGEga2V5IGNvbmZsaWN0IHdlIHRocm93LlxuICAgKi9cbiAgREVGSU5FX01BTllfTUVSR0VEOiBudWxsXG59KTtcblxudmFyIGluamVjdGVkTWl4aW5zID0gW107XG5cbi8qKlxuICogQ29tcG9zaXRlIGNvbXBvbmVudHMgYXJlIGhpZ2hlci1sZXZlbCBjb21wb25lbnRzIHRoYXQgY29tcG9zZSBvdGhlciBjb21wb3NpdGVcbiAqIG9yIGhvc3QgY29tcG9uZW50cy5cbiAqXG4gKiBUbyBjcmVhdGUgYSBuZXcgdHlwZSBvZiBgUmVhY3RDbGFzc2AsIHBhc3MgYSBzcGVjaWZpY2F0aW9uIG9mXG4gKiB5b3VyIG5ldyBjbGFzcyB0byBgUmVhY3QuY3JlYXRlQ2xhc3NgLiBUaGUgb25seSByZXF1aXJlbWVudCBvZiB5b3VyIGNsYXNzXG4gKiBzcGVjaWZpY2F0aW9uIGlzIHRoYXQgeW91IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIDxkaXY+SGVsbG8gV29ybGQ8L2Rpdj47XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBzdXBwb3J0cyBhIHNwZWNpZmljIHByb3RvY29sIG9mIG1ldGhvZHMgdGhhdCBoYXZlXG4gKiBzcGVjaWFsIG1lYW5pbmcgKGUuZy4gYHJlbmRlcmApLiBTZWUgYFJlYWN0Q2xhc3NJbnRlcmZhY2VgIGZvclxuICogbW9yZSB0aGUgY29tcHJlaGVuc2l2ZSBwcm90b2NvbC4gQW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlXG4gKiBjbGFzcyBzcGVjaWZpY2F0aW9uIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZSBwcm90b3R5cGUuXG4gKlxuICogQGludGVyZmFjZSBSZWFjdENsYXNzSW50ZXJmYWNlXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0Q2xhc3NJbnRlcmZhY2UgPSB7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIE1peGluIG9iamVjdHMgdG8gaW5jbHVkZSB3aGVuIGRlZmluaW5nIHlvdXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7YXJyYXl9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgbWl4aW5zOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGRlZmluZWQgb25cbiAgICogdGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgaXRzIHByb3RvdHlwZSAoc3RhdGljIG1ldGhvZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHN0YXRpY3M6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgcHJvcCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgcHJvcFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbnRleHRUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIHRoaXMgY29tcG9uZW50IHNldHMgZm9yIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjaGlsZENvbnRleHRUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvLyA9PT09IERlZmluaXRpb24gbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFZhbHVlcyBpbiB0aGUgbWFwcGluZyB3aWxsIGJlIHNldCBvblxuICAgKiBgdGhpcy5wcm9wc2AgaWYgdGhhdCBwcm9wIGlzIG5vdCBzcGVjaWZpZWQgKGkuZS4gdXNpbmcgYW4gYGluYCBjaGVjaykuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGBnZXRJbml0aWFsU3RhdGVgIGFuZCB0aGVyZWZvcmUgY2Fubm90IHJlbHlcbiAgICogb24gYHRoaXMuc3RhdGVgIG9yIHVzZSBgdGhpcy5zZXRTdGF0ZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxuICAgKlxuICAgKiAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAqICAgICByZXR1cm4ge1xuICAgKiAgICAgICBpc09uOiBmYWxzZSxcbiAgICogICAgICAgZm9vQmF6OiBuZXcgQmF6Rm9vKClcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRJbml0aWFsU3RhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0Q2hpbGRDb250ZXh0OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogVXNlcyBwcm9wcyBmcm9tIGB0aGlzLnByb3BzYCBhbmQgc3RhdGUgZnJvbSBgdGhpcy5zdGF0ZWAgdG8gcmVuZGVyIHRoZVxuICAgKiBzdHJ1Y3R1cmUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogTm8gZ3VhcmFudGVlcyBhcmUgbWFkZSBhYm91dCB3aGVuIG9yIGhvdyBvZnRlbiB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLCBzb1xuICAgKiBpdCBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAgICpcbiAgICogICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAqICAgICByZXR1cm4gPGRpdj5IZWxsbywge25hbWV9ITwvZGl2PjtcbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgKiBAbm9zaWRlZWZmZWN0c1xuICAgKiBAcmVxdWlyZWRcbiAgICovXG4gIHJlbmRlcjogU3BlY1BvbGljeS5ERUZJTkVfT05DRSxcblxuICAvLyA9PT09IERlbGVnYXRlIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCBhbmQgYWJvdXQgdG8gYmUgbW91bnRlZC5cbiAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcbiAgICogYnkgdGhpcyBtZXRob2QgbXVzdCBiZSBjbGVhbmVkIHVwIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGAuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIGFuZCBoYXMgYSBET00gcmVwcmVzZW50YXRpb24uXG4gICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcbiAgICogc3RhdGUgdXNpbmcgYHRoaXMuc2V0U3RhdGVgLiBDdXJyZW50IHByb3BzIGFyZSBhY2Nlc3NlZCB2aWEgYHRoaXMucHJvcHNgLlxuICAgKlxuICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgKiAgICAgICBsaWtlc0luY3JlYXNpbmc6IG5leHRQcm9wcy5saWtlQ291bnQgPiB0aGlzLnByb3BzLmxpa2VDb3VudFxuICAgKiAgICAgfSk7XG4gICAqICAgfVxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxuICAgKiB0cmFuc2l0aW9uIG1heSBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgYnV0IHRoZSBvcHBvc2l0ZSBpcyBub3QgdHJ1ZS4gSWYgeW91XG4gICAqIG5lZWQgaXQsIHlvdSBhcmUgcHJvYmFibHkgbG9va2luZyBmb3IgYGNvbXBvbmVudFdpbGxVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGlsZSBkZWNpZGluZyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIGFzIGEgcmVzdWx0IG9mXG4gICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBgcmV0dXJuIGZhbHNlYCB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgdGhlXG4gICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcbiAgICogdXBkYXRlLlxuICAgKlxuICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICByZXR1cm4gIWVxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgKiAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfT05DRSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxuICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXG4gICAqIGFuZCBgbmV4dENvbnRleHRgLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxuICAgKlxuICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQncyBET00gcmVwcmVzZW50YXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldlN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNvbnRleHRcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGFuZCBoYXZlXG4gICAqIGl0cyBET00gcmVwcmVzZW50YXRpb24gZGVzdHJveWVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBkZWFsbG9jYXRlIGFueSBleHRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxuICAgKiBkZXN0cm95ZWQgYnkgdGhhdCBwb2ludC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvLyA9PT09IEFkdmFuY2VkIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQncyBjdXJyZW50bHkgbW91bnRlZCBET00gcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IFNwZWNQb2xpY3kuT1ZFUlJJREVfQkFTRVxuXG59O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBjbGFzcyBzcGVjaWZpY2F0aW9uIGtleXMgdG8gc3BlY2lhbCBwcm9jZXNzaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBBbHRob3VnaCB0aGVzZSBhcmUgZGVjbGFyZWQgbGlrZSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGluIHRoZSBzcGVjaWZpY2F0aW9uXG4gKiB3aGVuIGRlZmluaW5nIGNsYXNzZXMgdXNpbmcgYFJlYWN0LmNyZWF0ZUNsYXNzYCwgdGhleSBhcmUgYWN0dWFsbHkgc3RhdGljXG4gKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxuICogYmVpbmcgc3RhdGljLCB0aGV5IG11c3QgYmUgZGVmaW5lZCBvdXRzaWRlIG9mIHRoZSBcInN0YXRpY3NcIiBrZXkgdW5kZXJcbiAqIHdoaWNoIGFsbCBvdGhlciBzdGF0aWMgbWV0aG9kcyBhcmUgZGVmaW5lZC5cbiAqL1xudmFyIFJFU0VSVkVEX1NQRUNfS0VZUyA9IHtcbiAgZGlzcGxheU5hbWU6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICB9LFxuICBtaXhpbnM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgbWl4aW5zKSB7XG4gICAgaWYgKG1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIG1peGluc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjaGlsZENvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNoaWxkQ29udGV4dCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dFR5cGVzKTtcbiAgfSxcbiAgY29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0KTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzLCBjb250ZXh0VHlwZXMpO1xuICB9LFxuICAvKipcbiAgICogU3BlY2lhbCBjYXNlIGdldERlZmF1bHRQcm9wcyB3aGljaCBzaG91bGQgbW92ZSBpbnRvIHN0YXRpY3MgYnV0IHJlcXVpcmVzXG4gICAqIGF1dG9tYXRpYyBtZXJnaW5nLlxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcywgZ2V0RGVmYXVsdFByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzO1xuICAgIH1cbiAgfSxcbiAgcHJvcFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHByb3BUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IucHJvcFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBwcm9wVHlwZXMpO1xuICB9LFxuICBzdGF0aWNzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcyk7XG4gIH0sXG4gIGF1dG9iaW5kOiBmdW5jdGlvbiAoKSB7fSB9O1xuXG4vLyBub29wXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHR5cGVEZWYsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcbiAgICBpZiAodHlwZURlZi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIC8vIHVzZSBhIHdhcm5pbmcgaW5zdGVhZCBvZiBhbiBpbnZhcmlhbnQgc28gY29tcG9uZW50c1xuICAgICAgLy8gZG9uJ3Qgc2hvdyB1cCBpbiBwcm9kIGJ1dCBvbmx5IGluIF9fREVWX19cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNZXRob2RPdmVycmlkZShpc0FscmVhZHlEZWZpbmVkLCBuYW1lKSB7XG4gIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV0gOiBudWxsO1xuXG4gIC8vIERpc2FsbG93IG92ZXJyaWRpbmcgb2YgYmFzZSBjbGFzcyBtZXRob2RzIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChSZWFjdENsYXNzTWl4aW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuT1ZFUlJJREVfQkFTRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIG92ZXJyaWRlIGAlc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzIGRvIG5vdCBvdmVybGFwIHdpdGggUmVhY3QgbWV0aG9kcy4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3MycsIG5hbWUpIDogdm9pZCAwO1xuICB9XG5cbiAgLy8gRGlzYWxsb3cgZGVmaW5pbmcgbWV0aG9kcyBtb3JlIHRoYW4gb25jZSB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICEoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSB8fCBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbi4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3NCcsIG5hbWUpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogTWl4aW4gaGVscGVyIHdoaWNoIGhhbmRsZXMgcG9saWN5IHZhbGlkYXRpb24gYW5kIHJlc2VydmVkXG4gKiBzcGVjaWZpY2F0aW9uIGtleXMgd2hlbiBidWlsZGluZyBSZWFjdCBjbGFzc2VzLlxuICovXG5mdW5jdGlvbiBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYykge1xuICBpZiAoIXNwZWMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHR5cGVvZlNwZWMgPSB0eXBlb2Ygc3BlYztcbiAgICAgIHZhciBpc01peGluVmFsaWQgPSB0eXBlb2ZTcGVjID09PSAnb2JqZWN0JyAmJiBzcGVjICE9PSBudWxsO1xuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpc01peGluVmFsaWQsICclczogWW91XFwncmUgYXR0ZW1wdGluZyB0byBpbmNsdWRlIGEgbWl4aW4gdGhhdCBpcyBlaXRoZXIgbnVsbCAnICsgJ29yIG5vdCBhbiBvYmplY3QuIENoZWNrIHRoZSBtaXhpbnMgaW5jbHVkZWQgYnkgdGhlIGNvbXBvbmVudCwgJyArICdhcyB3ZWxsIGFzIGFueSBtaXhpbnMgdGhleSBpbmNsdWRlIHRoZW1zZWx2ZXMuICcgKyAnRXhwZWN0ZWQgb2JqZWN0IGJ1dCBnb3QgJXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBzcGVjID09PSBudWxsID8gbnVsbCA6IHR5cGVvZlNwZWMpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gICEodHlwZW9mIHNwZWMgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdXNlIGEgY29tcG9uZW50IGNsYXNzIG9yIGZ1bmN0aW9uIGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBfcHJvZEludmFyaWFudCgnNzUnKSA6IHZvaWQgMDtcbiAgISFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3BlYykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byB1c2UgYSBjb21wb25lbnQgYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IF9wcm9kSW52YXJpYW50KCc3NicpIDogdm9pZCAwO1xuXG4gIHZhciBwcm90byA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgdmFyIGF1dG9CaW5kUGFpcnMgPSBwcm90by5fX3JlYWN0QXV0b0JpbmRQYWlycztcblxuICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgLy8gY2hhaW5pbmcgb3JkZXIgaXMgYXBwbGllZCB0byBtZXRob2RzIHdpdGggREVGSU5FX01BTlkgcG9saWN5LCB3aGV0aGVyXG4gIC8vIG1peGlucyBhcmUgbGlzdGVkIGJlZm9yZSBvciBhZnRlciB0aGVzZSBtZXRob2RzIGluIHRoZSBzcGVjLlxuICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xuICAgIFJFU0VSVkVEX1NQRUNfS0VZUy5taXhpbnMoQ29uc3RydWN0b3IsIHNwZWMubWl4aW5zKTtcbiAgfVxuXG4gIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgIGlmICghc3BlYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IE1JWElOU19LRVkpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIG1peGlucyBpbiBhIHNwZWNpYWwgY2FzZSBhYm92ZS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eSA9IHNwZWNbbmFtZV07XG4gICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpO1xuXG4gICAgaWYgKFJFU0VSVkVEX1NQRUNfS0VZUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgUkVTRVJWRURfU1BFQ19LRVlTW25hbWVdKENvbnN0cnVjdG9yLCBwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNldHVwIG1ldGhvZHMgb24gcHJvdG90eXBlOlxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBtZW1iZXIgbWV0aG9kcyBzaG91bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgYm91bmQ6XG4gICAgICAvLyAxLiBFeHBlY3RlZCBSZWFjdENsYXNzIG1ldGhvZHMgKGluIHRoZSBcImludGVyZmFjZVwiKS5cbiAgICAgIC8vIDIuIE92ZXJyaWRkZW4gbWV0aG9kcyAodGhhdCB3ZXJlIG1peGVkIGluKS5cbiAgICAgIHZhciBpc1JlYWN0Q2xhc3NNZXRob2QgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbic7XG4gICAgICB2YXIgc2hvdWxkQXV0b0JpbmQgPSBpc0Z1bmN0aW9uICYmICFpc1JlYWN0Q2xhc3NNZXRob2QgJiYgIWlzQWxyZWFkeURlZmluZWQgJiYgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XG5cbiAgICAgIGlmIChzaG91bGRBdXRvQmluZCkge1xuICAgICAgICBhdXRvQmluZFBhaXJzLnB1c2gobmFtZSwgcHJvcGVydHkpO1xuICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XG5cbiAgICAgICAgICAvLyBUaGVzZSBjYXNlcyBzaG91bGQgYWxyZWFkeSBiZSBjYXVnaHQgYnkgdmFsaWRhdGVNZXRob2RPdmVycmlkZS5cbiAgICAgICAgICAhKGlzUmVhY3RDbGFzc01ldGhvZCAmJiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQgfHwgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyB3aGVuIG1peGluZyBpbiBjb21wb25lbnQgc3BlY3MuJywgc3BlY1BvbGljeSwgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzcnLCBzcGVjUG9saWN5LCBuYW1lKSA6IHZvaWQgMDtcblxuICAgICAgICAgIC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xuICAgICAgICAgIC8vIG1ldGhvZHMgYmVmb3JlIGNhbGxpbmcgdGhlIG5ldyBwcm9wZXJ0eSwgbWVyZ2luZyBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICBpZiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQpIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkpIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEFkZCB2ZXJib3NlIGRpc3BsYXlOYW1lIHRvIHRoZSBmdW5jdGlvbiwgd2hpY2ggaGVscHMgd2hlbiBsb29raW5nXG4gICAgICAgICAgICAvLyBhdCBwcm9maWxpbmcgdG9vbHMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgcHJvdG9bbmFtZV0uZGlzcGxheU5hbWUgPSBzcGVjLmRpc3BsYXlOYW1lICsgJ18nICsgbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgaWYgKCFzdGF0aWNzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIG5hbWUgaW4gc3RhdGljcykge1xuICAgIHZhciBwcm9wZXJ0eSA9IHN0YXRpY3NbbmFtZV07XG4gICAgaWYgKCFzdGF0aWNzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNlcnZlZCA9IG5hbWUgaW4gUkVTRVJWRURfU1BFQ19LRVlTO1xuICAgICEhaXNSZXNlcnZlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGEgcmVzZXJ2ZWQgcHJvcGVydHksIGAlc2AsIHRoYXQgc2hvdWxkblxcJ3QgYmUgb24gdGhlIFwic3RhdGljc1wiIGtleS4gRGVmaW5lIGl0IGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IGluc3RlYWQ7IGl0IHdpbGwgc3RpbGwgYmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IuJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzgnLCBuYW1lKSA6IHZvaWQgMDtcblxuICAgIHZhciBpc0luaGVyaXRlZCA9IG5hbWUgaW4gQ29uc3RydWN0b3I7XG4gICAgISFpc0luaGVyaXRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGAlc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc5JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgQ29uc3RydWN0b3JbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvYmplY3RzLCBidXQgdGhyb3cgaWYgYm90aCBjb250YWluIHRoZSBzYW1lIGtleS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb25lIFRoZSBmaXJzdCBvYmplY3QsIHdoaWNoIGlzIG11dGF0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gdHdvIFRoZSBzZWNvbmQgb2JqZWN0XG4gKiBAcmV0dXJuIHtvYmplY3R9IG9uZSBhZnRlciBpdCBoYXMgYmVlbiBtdXRhdGVkIHRvIGNvbnRhaW4gZXZlcnl0aGluZyBpbiB0d28uXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMob25lLCB0d28pIHtcbiAgIShvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IENhbm5vdCBtZXJnZSBub24tb2JqZWN0cy4nKSA6IF9wcm9kSW52YXJpYW50KCc4MCcpIDogdm9pZCAwO1xuXG4gIGZvciAodmFyIGtleSBpbiB0d28pIHtcbiAgICBpZiAodHdvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICEob25lW2tleV0gPT09IHVuZGVmaW5lZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBUcmllZCB0byBtZXJnZSB0d28gb2JqZWN0cyB3aXRoIHRoZSBzYW1lIGtleTogYCVzYC4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlIHRvIGEgbWl4aW47IGluIHBhcnRpY3VsYXIsIHRoaXMgbWF5IGJlIGNhdXNlZCBieSB0d28gZ2V0SW5pdGlhbFN0YXRlKCkgb3IgZ2V0RGVmYXVsdFByb3BzKCkgbWV0aG9kcyByZXR1cm5pbmcgb2JqZWN0cyB3aXRoIGNsYXNoaW5nIGtleXMuJywga2V5KSA6IF9wcm9kSW52YXJpYW50KCc4MScsIGtleSkgOiB2b2lkIDA7XG4gICAgICBvbmVba2V5XSA9IHR3b1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb25lO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgbWVyZ2VzIHRoZWlyIHJldHVybiB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBtZXJnZWRSZXN1bHQoKSB7XG4gICAgdmFyIGEgPSBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgYiA9IHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgdmFyIGMgPSB7fTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGEpO1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYik7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBpZ25vcmVzIHRoZWlyIHJldHVybiB2YWxlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQmluZHMgYSBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWV0aG9kIHRvIGJlIGJvdW5kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBib3VuZCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCkge1xuICB2YXIgYm91bmRNZXRob2QgPSBtZXRob2QuYmluZChjb21wb25lbnQpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IG51bGw7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWU7XG4gICAgdmFyIF9iaW5kID0gYm91bmRNZXRob2QuYmluZDtcbiAgICBib3VuZE1ldGhvZC5iaW5kID0gZnVuY3Rpb24gKG5ld1RoaXMpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlciBpcyB0cnlpbmcgdG8gYmluZCgpIGFuIGF1dG9ib3VuZCBtZXRob2Q7IHdlIGVmZmVjdGl2ZWx5IHdpbGxcbiAgICAgIC8vIGlnbm9yZSB0aGUgdmFsdWUgb2YgXCJ0aGlzXCIgdGhhdCB0aGUgdXNlciBpcyB0cnlpbmcgdG8gdXNlLCBzb1xuICAgICAgLy8gbGV0J3Mgd2Fybi5cbiAgICAgIGlmIChuZXdUaGlzICE9PSBjb21wb25lbnQgJiYgbmV3VGhpcyAhPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogUmVhY3QgY29tcG9uZW50IG1ldGhvZHMgbWF5IG9ubHkgYmUgYm91bmQgdG8gdGhlICcgKyAnY29tcG9uZW50IGluc3RhbmNlLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBZb3UgYXJlIGJpbmRpbmcgYSBjb21wb25lbnQgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuICcgKyAnUmVhY3QgZG9lcyB0aGlzIGZvciB5b3UgYXV0b21hdGljYWxseSBpbiBhIGhpZ2gtcGVyZm9ybWFuY2UgJyArICd3YXksIHNvIHlvdSBjYW4gc2FmZWx5IHJlbW92ZSB0aGlzIGNhbGwuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gICAgICB9XG4gICAgICB2YXIgcmVib3VuZE1ldGhvZCA9IF9iaW5kLmFwcGx5KGJvdW5kTWV0aG9kLCBhcmd1bWVudHMpO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICByZXR1cm4gcmVib3VuZE1ldGhvZDtcbiAgICB9O1xuICB9XG4gIHJldHVybiBib3VuZE1ldGhvZDtcbn1cblxuLyoqXG4gKiBCaW5kcyBhbGwgYXV0by1ib3VuZCBtZXRob2RzIGluIGEgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kcyhjb21wb25lbnQpIHtcbiAgdmFyIHBhaXJzID0gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZFBhaXJzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGF1dG9CaW5kS2V5ID0gcGFpcnNbaV07XG4gICAgdmFyIG1ldGhvZCA9IHBhaXJzW2kgKyAxXTtcbiAgICBjb21wb25lbnRbYXV0b0JpbmRLZXldID0gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBtb3JlIHRvIHRoZSBSZWFjdENsYXNzIGJhc2UgY2xhc3MuIFRoZXNlIGFyZSBhbGwgbGVnYWN5IGZlYXR1cmVzIGFuZFxuICogdGhlcmVmb3JlIG5vdCBhbHJlYWR5IHBhcnQgb2YgdGhlIG1vZGVybiBSZWFjdENvbXBvbmVudC5cbiAqL1xudmFyIFJlYWN0Q2xhc3NNaXhpbiA9IHtcblxuICAvKipcbiAgICogVE9ETzogVGhpcyB3aWxsIGJlIGRlcHJlY2F0ZWQgYmVjYXVzZSBzdGF0ZSBzaG91bGQgYWx3YXlzIGtlZXAgYSBjb25zaXN0ZW50XG4gICAqIHR5cGUgc2lnbmF0dXJlIGFuZCB0aGUgb25seSB1c2UgY2FzZSBmb3IgdGhpcywgaXMgdG8gYXZvaWQgdGhhdC5cbiAgICovXG4gIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKG5ld1N0YXRlLCBjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKHRoaXMsIG5ld1N0YXRlKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdyZXBsYWNlU3RhdGUnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVyLmlzTW91bnRlZCh0aGlzKTtcbiAgfVxufTtcblxudmFyIFJlYWN0Q2xhc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7fTtcbl9hc3NpZ24oUmVhY3RDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDbGFzc01peGluKTtcblxuLyoqXG4gKiBNb2R1bGUgZm9yIGNyZWF0aW5nIGNvbXBvc2l0ZSBjb21wb25lbnRzLlxuICpcbiAqIEBjbGFzcyBSZWFjdENsYXNzXG4gKi9cbnZhciBSZWFjdENsYXNzID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGNvbXBvbmVudCBjbGFzcyBnaXZlbiBhIGNsYXNzIHNwZWNpZmljYXRpb24uXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyBDbGFzcyBzcGVjaWZpY2F0aW9uICh3aGljaCBtdXN0IGRlZmluZSBgcmVuZGVyYCkuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNyZWF0ZUNsYXNzOiBmdW5jdGlvbiAoc3BlYykge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgLy8gVGhpcyBjb25zdHJ1Y3RvciBnZXRzIG92ZXJyaWRkZW4gYnkgbW9ja3MuIFRoZSBhcmd1bWVudCBpcyB1c2VkXG4gICAgICAvLyBieSBtb2NrcyB0byBhc3NlcnQgb24gd2hhdCBnZXRzIG1vdW50ZWQuXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHRoaXMgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvciwgJ1NvbWV0aGluZyBpcyBjYWxsaW5nIGEgUmVhY3QgY29tcG9uZW50IGRpcmVjdGx5LiBVc2UgYSBmYWN0b3J5IG9yICcgKyAnSlNYIGluc3RlYWQuIFNlZTogaHR0cHM6Ly9mYi5tZS9yZWFjdC1sZWdhY3lmYWN0b3J5JykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFdpcmUgdXAgYXV0by1iaW5kaW5nXG4gICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRQYWlycy5sZW5ndGgpIHtcbiAgICAgICAgYmluZEF1dG9CaW5kTWV0aG9kcyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAgIC8vIFJlYWN0Q2xhc3NlcyBkb2Vzbid0IGhhdmUgY29uc3RydWN0b3JzLiBJbnN0ZWFkLCB0aGV5IHVzZSB0aGVcbiAgICAgIC8vIGdldEluaXRpYWxTdGF0ZSBhbmQgY29tcG9uZW50V2lsbE1vdW50IG1ldGhvZHMgZm9yIGluaXRpYWxpemF0aW9uLlxuXG4gICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQgJiYgdGhpcy5nZXRJbml0aWFsU3RhdGUuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0SW5pdGlhbFN0YXRlKCk6IG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnODInLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICB9O1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdENsYXNzQ29tcG9uZW50KCk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLl9fcmVhY3RBdXRvQmluZFBhaXJzID0gW107XG5cbiAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpKTtcblxuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGRlZmF1bHRQcm9wcyBwcm9wZXJ0eSBhZnRlciBhbGwgbWl4aW5zIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZGVmYXVsdFByb3BzID0gQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0YWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdXNlIG9mIHRoZXNlIG1ldGhvZCBuYW1lcyBpcyBvayxcbiAgICAgIC8vIHNpbmNlIGl0J3MgdXNlZCB3aXRoIGNyZWF0ZUNsYXNzLiBJZiBpdCdzIG5vdCwgdGhlbiBpdCdzIGxpa2VseSBhXG4gICAgICAvLyBtaXN0YWtlIHNvIHdlJ2xsIHdhcm4geW91IHRvIHVzZSB0aGUgc3RhdGljIHByb3BlcnR5LCBwcm9wZXJ0eVxuICAgICAgLy8gaW5pdGlhbGl6ZXIgb3IgY29uc3RydWN0b3IgcmVzcGVjdGl2ZWx5LlxuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLnJlbmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVDbGFzcyguLi4pOiBDbGFzcyBzcGVjaWZpY2F0aW9uIG11c3QgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLicpIDogX3Byb2RJbnZhcmlhbnQoJzgzJykgOiB2b2lkIDA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0TWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgICAgaW5qZWN0ZWRNaXhpbnMucHVzaChtaXhpbik7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDbGFzcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q2xhc3MuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZUxvY2F0aW9uc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IGtleU1pcnJvcih7XG4gIHByb3A6IG51bGwsXG4gIGNvbnRleHQ6IG51bGwsXG4gIGNoaWxkQ29udGV4dDogbnVsbFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9ucztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gZW51bWVyYXRpb24gd2l0aCBrZXlzIGVxdWFsIHRvIHRoZWlyIHZhbHVlLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgdmFyIENPTE9SUyA9IGtleU1pcnJvcih7Ymx1ZTogbnVsbCwgcmVkOiBudWxsfSk7XG4gKiAgIHZhciBteUNvbG9yID0gQ09MT1JTLmJsdWU7XG4gKiAgIHZhciBpc0NvbG9yVmFsaWQgPSAhIUNPTE9SU1tteUNvbG9yXTtcbiAqXG4gKiBUaGUgbGFzdCBsaW5lIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgaWYgdGhlIHZhbHVlcyBvZiB0aGUgZ2VuZXJhdGVkIGVudW0gd2VyZVxuICogbm90IGVxdWFsIHRvIHRoZWlyIGtleXMuXG4gKlxuICogICBJbnB1dDogIHtrZXkxOiB2YWwxLCBrZXkyOiB2YWwyfVxuICogICBPdXRwdXQ6IHtrZXkxOiBrZXkxLCBrZXkyOiBrZXkyfVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xudmFyIGtleU1pcnJvciA9IGZ1bmN0aW9uIGtleU1pcnJvcihvYmopIHtcbiAgdmFyIHJldCA9IHt9O1xuICB2YXIga2V5O1xuICAhKG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvYmopKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdrZXlNaXJyb3IoLi4uKTogQXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBrZXk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5TWlycm9yO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9rZXlNaXJyb3IuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qKlxuICogQWxsb3dzIGV4dHJhY3Rpb24gb2YgYSBtaW5pZmllZCBrZXkuIExldCdzIHRoZSBidWlsZCBzeXN0ZW0gbWluaWZ5IGtleXNcbiAqIHdpdGhvdXQgbG9zaW5nIHRoZSBhYmlsaXR5IHRvIGR5bmFtaWNhbGx5IHVzZSBrZXkgc3RyaW5ncyBhcyB2YWx1ZXNcbiAqIHRoZW1zZWx2ZXMuIFBhc3MgaW4gYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUga2V5L3ZhbCBwYWlyIGFuZCBpdCB3aWxsIHJldHVyblxuICogeW91IHRoZSBzdHJpbmcga2V5IG9mIHRoYXQgc2luZ2xlIHJlY29yZC4gU3VwcG9zZSB5b3Ugd2FudCB0byBncmFiIHRoZVxuICogdmFsdWUgZm9yIGEga2V5ICdjbGFzc05hbWUnIGluc2lkZSBvZiBhbiBvYmplY3QuIEtleS92YWwgbWluaWZpY2F0aW9uIG1heVxuICogaGF2ZSBhbGlhc2VkIHRoYXQga2V5IHRvIGJlICd4YTEyJy4ga2V5T2Yoe2NsYXNzTmFtZTogbnVsbH0pIHdpbGwgcmV0dXJuXG4gKiAneGExMicgaW4gdGhhdCBjYXNlLiBSZXNvbHZlIGtleXMgeW91IHdhbnQgdG8gdXNlIG9uY2UgYXQgc3RhcnR1cCB0aW1lLCB0aGVuXG4gKiByZXVzZSB0aG9zZSByZXNvbHV0aW9ucy5cbiAqL1xudmFyIGtleU9mID0gZnVuY3Rpb24ga2V5T2Yob25lS2V5T2JqKSB7XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIG9uZUtleU9iaikge1xuICAgIGlmICghb25lS2V5T2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlPZjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIva2V5T2YuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01GYWN0b3JpZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhY3RvcnkgdGhhdCBjcmVhdGVzIEhUTUwgdGFnIGVsZW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBjcmVhdGVET01GYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbiAgY3JlYXRlRE9NRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXBwaW5nIGZyb20gc3VwcG9ydGVkIEhUTUwgdGFncyB0byBgUmVhY3RET01Db21wb25lbnRgIGNsYXNzZXMuXG4gKiBUaGlzIGlzIGFsc28gYWNjZXNzaWJsZSB2aWEgYFJlYWN0LkRPTWAuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSB7XG4gIGE6IGNyZWF0ZURPTUZhY3RvcnkoJ2EnKSxcbiAgYWJicjogY3JlYXRlRE9NRmFjdG9yeSgnYWJicicpLFxuICBhZGRyZXNzOiBjcmVhdGVET01GYWN0b3J5KCdhZGRyZXNzJyksXG4gIGFyZWE6IGNyZWF0ZURPTUZhY3RvcnkoJ2FyZWEnKSxcbiAgYXJ0aWNsZTogY3JlYXRlRE9NRmFjdG9yeSgnYXJ0aWNsZScpLFxuICBhc2lkZTogY3JlYXRlRE9NRmFjdG9yeSgnYXNpZGUnKSxcbiAgYXVkaW86IGNyZWF0ZURPTUZhY3RvcnkoJ2F1ZGlvJyksXG4gIGI6IGNyZWF0ZURPTUZhY3RvcnkoJ2InKSxcbiAgYmFzZTogY3JlYXRlRE9NRmFjdG9yeSgnYmFzZScpLFxuICBiZGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2JkaScpLFxuICBiZG86IGNyZWF0ZURPTUZhY3RvcnkoJ2JkbycpLFxuICBiaWc6IGNyZWF0ZURPTUZhY3RvcnkoJ2JpZycpLFxuICBibG9ja3F1b3RlOiBjcmVhdGVET01GYWN0b3J5KCdibG9ja3F1b3RlJyksXG4gIGJvZHk6IGNyZWF0ZURPTUZhY3RvcnkoJ2JvZHknKSxcbiAgYnI6IGNyZWF0ZURPTUZhY3RvcnkoJ2JyJyksXG4gIGJ1dHRvbjogY3JlYXRlRE9NRmFjdG9yeSgnYnV0dG9uJyksXG4gIGNhbnZhczogY3JlYXRlRE9NRmFjdG9yeSgnY2FudmFzJyksXG4gIGNhcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ2NhcHRpb24nKSxcbiAgY2l0ZTogY3JlYXRlRE9NRmFjdG9yeSgnY2l0ZScpLFxuICBjb2RlOiBjcmVhdGVET01GYWN0b3J5KCdjb2RlJyksXG4gIGNvbDogY3JlYXRlRE9NRmFjdG9yeSgnY29sJyksXG4gIGNvbGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdjb2xncm91cCcpLFxuICBkYXRhOiBjcmVhdGVET01GYWN0b3J5KCdkYXRhJyksXG4gIGRhdGFsaXN0OiBjcmVhdGVET01GYWN0b3J5KCdkYXRhbGlzdCcpLFxuICBkZDogY3JlYXRlRE9NRmFjdG9yeSgnZGQnKSxcbiAgZGVsOiBjcmVhdGVET01GYWN0b3J5KCdkZWwnKSxcbiAgZGV0YWlsczogY3JlYXRlRE9NRmFjdG9yeSgnZGV0YWlscycpLFxuICBkZm46IGNyZWF0ZURPTUZhY3RvcnkoJ2RmbicpLFxuICBkaWFsb2c6IGNyZWF0ZURPTUZhY3RvcnkoJ2RpYWxvZycpLFxuICBkaXY6IGNyZWF0ZURPTUZhY3RvcnkoJ2RpdicpLFxuICBkbDogY3JlYXRlRE9NRmFjdG9yeSgnZGwnKSxcbiAgZHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2R0JyksXG4gIGVtOiBjcmVhdGVET01GYWN0b3J5KCdlbScpLFxuICBlbWJlZDogY3JlYXRlRE9NRmFjdG9yeSgnZW1iZWQnKSxcbiAgZmllbGRzZXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZWxkc2V0JyksXG4gIGZpZ2NhcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZ2NhcHRpb24nKSxcbiAgZmlndXJlOiBjcmVhdGVET01GYWN0b3J5KCdmaWd1cmUnKSxcbiAgZm9vdGVyOiBjcmVhdGVET01GYWN0b3J5KCdmb290ZXInKSxcbiAgZm9ybTogY3JlYXRlRE9NRmFjdG9yeSgnZm9ybScpLFxuICBoMTogY3JlYXRlRE9NRmFjdG9yeSgnaDEnKSxcbiAgaDI6IGNyZWF0ZURPTUZhY3RvcnkoJ2gyJyksXG4gIGgzOiBjcmVhdGVET01GYWN0b3J5KCdoMycpLFxuICBoNDogY3JlYXRlRE9NRmFjdG9yeSgnaDQnKSxcbiAgaDU6IGNyZWF0ZURPTUZhY3RvcnkoJ2g1JyksXG4gIGg2OiBjcmVhdGVET01GYWN0b3J5KCdoNicpLFxuICBoZWFkOiBjcmVhdGVET01GYWN0b3J5KCdoZWFkJyksXG4gIGhlYWRlcjogY3JlYXRlRE9NRmFjdG9yeSgnaGVhZGVyJyksXG4gIGhncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnaGdyb3VwJyksXG4gIGhyOiBjcmVhdGVET01GYWN0b3J5KCdocicpLFxuICBodG1sOiBjcmVhdGVET01GYWN0b3J5KCdodG1sJyksXG4gIGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2knKSxcbiAgaWZyYW1lOiBjcmVhdGVET01GYWN0b3J5KCdpZnJhbWUnKSxcbiAgaW1nOiBjcmVhdGVET01GYWN0b3J5KCdpbWcnKSxcbiAgaW5wdXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2lucHV0JyksXG4gIGluczogY3JlYXRlRE9NRmFjdG9yeSgnaW5zJyksXG4gIGtiZDogY3JlYXRlRE9NRmFjdG9yeSgna2JkJyksXG4gIGtleWdlbjogY3JlYXRlRE9NRmFjdG9yeSgna2V5Z2VuJyksXG4gIGxhYmVsOiBjcmVhdGVET01GYWN0b3J5KCdsYWJlbCcpLFxuICBsZWdlbmQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2xlZ2VuZCcpLFxuICBsaTogY3JlYXRlRE9NRmFjdG9yeSgnbGknKSxcbiAgbGluazogY3JlYXRlRE9NRmFjdG9yeSgnbGluaycpLFxuICBtYWluOiBjcmVhdGVET01GYWN0b3J5KCdtYWluJyksXG4gIG1hcDogY3JlYXRlRE9NRmFjdG9yeSgnbWFwJyksXG4gIG1hcms6IGNyZWF0ZURPTUZhY3RvcnkoJ21hcmsnKSxcbiAgbWVudTogY3JlYXRlRE9NRmFjdG9yeSgnbWVudScpLFxuICBtZW51aXRlbTogY3JlYXRlRE9NRmFjdG9yeSgnbWVudWl0ZW0nKSxcbiAgbWV0YTogY3JlYXRlRE9NRmFjdG9yeSgnbWV0YScpLFxuICBtZXRlcjogY3JlYXRlRE9NRmFjdG9yeSgnbWV0ZXInKSxcbiAgbmF2OiBjcmVhdGVET01GYWN0b3J5KCduYXYnKSxcbiAgbm9zY3JpcHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ25vc2NyaXB0JyksXG4gIG9iamVjdDogY3JlYXRlRE9NRmFjdG9yeSgnb2JqZWN0JyksXG4gIG9sOiBjcmVhdGVET01GYWN0b3J5KCdvbCcpLFxuICBvcHRncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnb3B0Z3JvdXAnKSxcbiAgb3B0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdvcHRpb24nKSxcbiAgb3V0cHV0OiBjcmVhdGVET01GYWN0b3J5KCdvdXRwdXQnKSxcbiAgcDogY3JlYXRlRE9NRmFjdG9yeSgncCcpLFxuICBwYXJhbTogY3JlYXRlRE9NRmFjdG9yeSgncGFyYW0nKSxcbiAgcGljdHVyZTogY3JlYXRlRE9NRmFjdG9yeSgncGljdHVyZScpLFxuICBwcmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3ByZScpLFxuICBwcm9ncmVzczogY3JlYXRlRE9NRmFjdG9yeSgncHJvZ3Jlc3MnKSxcbiAgcTogY3JlYXRlRE9NRmFjdG9yeSgncScpLFxuICBycDogY3JlYXRlRE9NRmFjdG9yeSgncnAnKSxcbiAgcnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3J0JyksXG4gIHJ1Ynk6IGNyZWF0ZURPTUZhY3RvcnkoJ3J1YnknKSxcbiAgczogY3JlYXRlRE9NRmFjdG9yeSgncycpLFxuICBzYW1wOiBjcmVhdGVET01GYWN0b3J5KCdzYW1wJyksXG4gIHNjcmlwdDogY3JlYXRlRE9NRmFjdG9yeSgnc2NyaXB0JyksXG4gIHNlY3Rpb246IGNyZWF0ZURPTUZhY3RvcnkoJ3NlY3Rpb24nKSxcbiAgc2VsZWN0OiBjcmVhdGVET01GYWN0b3J5KCdzZWxlY3QnKSxcbiAgc21hbGw6IGNyZWF0ZURPTUZhY3RvcnkoJ3NtYWxsJyksXG4gIHNvdXJjZTogY3JlYXRlRE9NRmFjdG9yeSgnc291cmNlJyksXG4gIHNwYW46IGNyZWF0ZURPTUZhY3RvcnkoJ3NwYW4nKSxcbiAgc3Ryb25nOiBjcmVhdGVET01GYWN0b3J5KCdzdHJvbmcnKSxcbiAgc3R5bGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0eWxlJyksXG4gIHN1YjogY3JlYXRlRE9NRmFjdG9yeSgnc3ViJyksXG4gIHN1bW1hcnk6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1bW1hcnknKSxcbiAgc3VwOiBjcmVhdGVET01GYWN0b3J5KCdzdXAnKSxcbiAgdGFibGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RhYmxlJyksXG4gIHRib2R5OiBjcmVhdGVET01GYWN0b3J5KCd0Ym9keScpLFxuICB0ZDogY3JlYXRlRE9NRmFjdG9yeSgndGQnKSxcbiAgdGV4dGFyZWE6IGNyZWF0ZURPTUZhY3RvcnkoJ3RleHRhcmVhJyksXG4gIHRmb290OiBjcmVhdGVET01GYWN0b3J5KCd0Zm9vdCcpLFxuICB0aDogY3JlYXRlRE9NRmFjdG9yeSgndGgnKSxcbiAgdGhlYWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RoZWFkJyksXG4gIHRpbWU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RpbWUnKSxcbiAgdGl0bGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RpdGxlJyksXG4gIHRyOiBjcmVhdGVET01GYWN0b3J5KCd0cicpLFxuICB0cmFjazogY3JlYXRlRE9NRmFjdG9yeSgndHJhY2snKSxcbiAgdTogY3JlYXRlRE9NRmFjdG9yeSgndScpLFxuICB1bDogY3JlYXRlRE9NRmFjdG9yeSgndWwnKSxcbiAgJ3Zhcic6IGNyZWF0ZURPTUZhY3RvcnkoJ3ZhcicpLFxuICB2aWRlbzogY3JlYXRlRE9NRmFjdG9yeSgndmlkZW8nKSxcbiAgd2JyOiBjcmVhdGVET01GYWN0b3J5KCd3YnInKSxcblxuICAvLyBTVkdcbiAgY2lyY2xlOiBjcmVhdGVET01GYWN0b3J5KCdjaXJjbGUnKSxcbiAgY2xpcFBhdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ2NsaXBQYXRoJyksXG4gIGRlZnM6IGNyZWF0ZURPTUZhY3RvcnkoJ2RlZnMnKSxcbiAgZWxsaXBzZTogY3JlYXRlRE9NRmFjdG9yeSgnZWxsaXBzZScpLFxuICBnOiBjcmVhdGVET01GYWN0b3J5KCdnJyksXG4gIGltYWdlOiBjcmVhdGVET01GYWN0b3J5KCdpbWFnZScpLFxuICBsaW5lOiBjcmVhdGVET01GYWN0b3J5KCdsaW5lJyksXG4gIGxpbmVhckdyYWRpZW50OiBjcmVhdGVET01GYWN0b3J5KCdsaW5lYXJHcmFkaWVudCcpLFxuICBtYXNrOiBjcmVhdGVET01GYWN0b3J5KCdtYXNrJyksXG4gIHBhdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ3BhdGgnKSxcbiAgcGF0dGVybjogY3JlYXRlRE9NRmFjdG9yeSgncGF0dGVybicpLFxuICBwb2x5Z29uOiBjcmVhdGVET01GYWN0b3J5KCdwb2x5Z29uJyksXG4gIHBvbHlsaW5lOiBjcmVhdGVET01GYWN0b3J5KCdwb2x5bGluZScpLFxuICByYWRpYWxHcmFkaWVudDogY3JlYXRlRE9NRmFjdG9yeSgncmFkaWFsR3JhZGllbnQnKSxcbiAgcmVjdDogY3JlYXRlRE9NRmFjdG9yeSgncmVjdCcpLFxuICBzdG9wOiBjcmVhdGVET01GYWN0b3J5KCdzdG9wJyksXG4gIHN2ZzogY3JlYXRlRE9NRmFjdG9yeSgnc3ZnJyksXG4gIHRleHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RleHQnKSxcbiAgdHNwYW46IGNyZWF0ZURPTUZhY3RvcnkoJ3RzcGFuJylcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GYWN0b3JpZXM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVsZW1lbnRWYWxpZGF0b3JcbiAqL1xuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG5cbnZhciBjaGVja1JlYWN0VHlwZVNwZWMgPSByZXF1aXJlKCcuL2NoZWNrUmVhY3RUeXBlU3BlYycpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJyBDaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBtZW1vaXplciA9IG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgfHwgKG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgPSB7fSk7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAobWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBlbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLic7XG4gIH1cblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJXMnLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpKSA6IHZvaWQgMDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICAvLyBFbnRyeSBpdGVyYXRvcnMgcHJvdmlkZSBpbXBsaWNpdCBrZXlzLlxuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIGlmIChjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMpIHtcbiAgICBjaGVja1JlYWN0VHlwZVNwZWMoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3AsIG5hbWUsIGVsZW1lbnQsIG51bGwpO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICB9XG59XG5cbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSB7XG5cbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbic7XG4gICAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgc2hvdWxkIG5vdCBiZSBudWxsLCB1bmRlZmluZWQsIGJvb2xlYW4sIG9yICcgKyAnbnVtYmVyLiBJdCBzaG91bGQgYmUgYSBzdHJpbmcgKGZvciBET00gZWxlbWVudHMpIG9yIGEgUmVhY3RDbGFzcyAnICsgJyhmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgY3JlYXRlRmFjdG9yeTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gICAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gICAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG4gIH0sXG5cbiAgY2xvbmVFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgICB9XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3I7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRUcmVlSG9va1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gaXNOYXRpdmUoZm4pIHtcbiAgLy8gQmFzZWQgb24gaXNOYXRpdmUoKSBmcm9tIExvZGFzaFxuICB2YXIgZnVuY1RvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgKyBmdW5jVG9TdHJpbmdcbiAgLy8gVGFrZSBhbiBleGFtcGxlIG5hdGl2ZSBmdW5jdGlvbiBzb3VyY2UgZm9yIGNvbXBhcmlzb25cbiAgLmNhbGwoaGFzT3duUHJvcGVydHkpXG4gIC8vIFN0cmlwIHJlZ2V4IGNoYXJhY3RlcnMgc28gd2UgY2FuIHVzZSBpdCBmb3IgcmVnZXhcbiAgLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLy8gUmVtb3ZlIGhhc093blByb3BlcnR5IGZyb20gdGhlIHRlbXBsYXRlIHRvIG1ha2UgaXQgZ2VuZXJpY1xuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCcpO1xuICB0cnkge1xuICAgIHZhciBzb3VyY2UgPSBmdW5jVG9TdHJpbmcuY2FsbChmbik7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChzb3VyY2UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxudmFyIGNhblVzZUNvbGxlY3Rpb25zID1cbi8vIEFycmF5LmZyb21cbnR5cGVvZiBBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nICYmXG4vLyBNYXBcbnR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoTWFwKSAmJlxuLy8gTWFwLnByb3RvdHlwZS5rZXlzXG5NYXAucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShNYXAucHJvdG90eXBlLmtleXMpICYmXG4vLyBTZXRcbnR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoU2V0KSAmJlxuLy8gU2V0LnByb3RvdHlwZS5rZXlzXG5TZXQucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShTZXQucHJvdG90eXBlLmtleXMpO1xuXG52YXIgaXRlbU1hcDtcbnZhciByb290SURTZXQ7XG5cbnZhciBpdGVtQnlLZXk7XG52YXIgcm9vdEJ5S2V5O1xuXG5pZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgaXRlbU1hcCA9IG5ldyBNYXAoKTtcbiAgcm9vdElEU2V0ID0gbmV3IFNldCgpO1xufSBlbHNlIHtcbiAgaXRlbUJ5S2V5ID0ge307XG4gIHJvb3RCeUtleSA9IHt9O1xufVxuXG52YXIgdW5tb3VudGVkSURzID0gW107XG5cbi8vIFVzZSBub24tbnVtZXJpYyBrZXlzIHRvIHByZXZlbnQgVjggcGVyZm9ybWFuY2UgaXNzdWVzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxuZnVuY3Rpb24gZ2V0S2V5RnJvbUlEKGlkKSB7XG4gIHJldHVybiAnLicgKyBpZDtcbn1cbmZ1bmN0aW9uIGdldElERnJvbUtleShrZXkpIHtcbiAgcmV0dXJuIHBhcnNlSW50KGtleS5zdWJzdHIoMSksIDEwKTtcbn1cblxuZnVuY3Rpb24gZ2V0KGlkKSB7XG4gIGlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICAgIHJldHVybiBpdGVtTWFwLmdldChpZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgcmV0dXJuIGl0ZW1CeUtleVtrZXldO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShpZCkge1xuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICBpdGVtTWFwWydkZWxldGUnXShpZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgZGVsZXRlIGl0ZW1CeUtleVtrZXldO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShpZCwgZWxlbWVudCwgcGFyZW50SUQpIHtcbiAgdmFyIGl0ZW0gPSB7XG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgdGV4dDogbnVsbCxcbiAgICBjaGlsZElEczogW10sXG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICB1cGRhdGVDb3VudDogMFxuICB9O1xuXG4gIGlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICAgIGl0ZW1NYXAuc2V0KGlkLCBpdGVtKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBpdGVtQnlLZXlba2V5XSA9IGl0ZW07XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUm9vdChpZCkge1xuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICByb290SURTZXQuYWRkKGlkKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICByb290QnlLZXlba2V5XSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlUm9vdChpZCkge1xuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICByb290SURTZXRbJ2RlbGV0ZSddKGlkKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBkZWxldGUgcm9vdEJ5S2V5W2tleV07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZElEcygpIHtcbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oaXRlbU1hcC5rZXlzKCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhpdGVtQnlLZXkpLm1hcChnZXRJREZyb21LZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJvb3RJRHMoKSB7XG4gIGlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHJvb3RJRFNldC5rZXlzKCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhyb290QnlLZXkpLm1hcChnZXRJREZyb21LZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1cmdlRGVlcChpZCkge1xuICB2YXIgaXRlbSA9IGdldChpZCk7XG4gIGlmIChpdGVtKSB7XG4gICAgdmFyIGNoaWxkSURzID0gaXRlbS5jaGlsZElEcztcblxuICAgIHJlbW92ZShpZCk7XG4gICAgY2hpbGRJRHMuZm9yRWFjaChwdXJnZURlZXApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIG5hbWUgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcjZW1wdHknO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gJyN0ZXh0JztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVJRChpZCkge1xuICB2YXIgbmFtZSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUoaWQpO1xuICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKGlkKTtcbiAgdmFyIG93bmVyTmFtZTtcbiAgaWYgKG93bmVySUQpIHtcbiAgICBvd25lck5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKG93bmVySUQpO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGVsZW1lbnQsICdSZWFjdENvbXBvbmVudFRyZWVIb29rOiBNaXNzaW5nIFJlYWN0IGVsZW1lbnQgZm9yIGRlYnVnSUQgJXMgd2hlbiAnICsgJ2J1aWxkaW5nIHN0YWNrJywgaWQpIDogdm9pZCAwO1xuICByZXR1cm4gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBlbGVtZW50ICYmIGVsZW1lbnQuX3NvdXJjZSwgb3duZXJOYW1lKTtcbn1cblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSB7XG4gIG9uU2V0Q2hpbGRyZW46IGZ1bmN0aW9uIChpZCwgbmV4dENoaWxkSURzKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIGl0ZW0uY2hpbGRJRHMgPSBuZXh0Q2hpbGRJRHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHRDaGlsZElEcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHRDaGlsZElEID0gbmV4dENoaWxkSURzW2ldO1xuICAgICAgdmFyIG5leHRDaGlsZCA9IGdldChuZXh0Q2hpbGRJRCk7XG4gICAgICAhbmV4dENoaWxkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGhvb2sgZXZlbnRzIHRvIGZpcmUgZm9yIHRoZSBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnMTQwJykgOiB2b2lkIDA7XG4gICAgICAhKG5leHRDaGlsZC5jaGlsZElEcyAhPSBudWxsIHx8IHR5cGVvZiBuZXh0Q2hpbGQuZWxlbWVudCAhPT0gJ29iamVjdCcgfHwgbmV4dENoaWxkLmVsZW1lbnQgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25TZXRDaGlsZHJlbigpIHRvIGZpcmUgZm9yIGEgY29udGFpbmVyIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxNDEnKSA6IHZvaWQgMDtcbiAgICAgICFuZXh0Q2hpbGQuaXNNb3VudGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uTW91bnRDb21wb25lbnQoKSB0byBmaXJlIGZvciB0aGUgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzcxJykgOiB2b2lkIDA7XG4gICAgICBpZiAobmV4dENoaWxkLnBhcmVudElEID09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkLnBhcmVudElEID0gaWQ7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSBidXQgbW91bnRpbmcgYSBuZXcgcm9vdCBkdXJpbmcgaW5cbiAgICAgICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGN1cnJlbnRseSBjYXVzZXMgbm90LXlldC1tb3VudGVkIGNvbXBvbmVudHMgdG9cbiAgICAgICAgLy8gYmUgcHVyZ2VkIGZyb20gb3VyIHRyZWUgZGF0YSBzbyB0aGVpciBwYXJlbnQgSUQgaXMgbWlzc2luZy5cbiAgICAgIH1cbiAgICAgICEobmV4dENoaWxkLnBhcmVudElEID09PSBpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25CZWZvcmVNb3VudENvbXBvbmVudCgpIHBhcmVudCBhbmQgb25TZXRDaGlsZHJlbigpIHRvIGJlIGNvbnNpc3RlbnQgKCVzIGhhcyBwYXJlbnRzICVzIGFuZCAlcykuJywgbmV4dENoaWxkSUQsIG5leHRDaGlsZC5wYXJlbnRJRCwgaWQpIDogX3Byb2RJbnZhcmlhbnQoJzE0MicsIG5leHRDaGlsZElELCBuZXh0Q2hpbGQucGFyZW50SUQsIGlkKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCwgZWxlbWVudCwgcGFyZW50SUQpIHtcbiAgICBjcmVhdGUoaWQsIGVsZW1lbnQsIHBhcmVudElEKTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCwgZWxlbWVudCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpZ25vcmUgdGhlIGVsZW1lbnQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW0uZWxlbWVudCA9IGVsZW1lbnQ7XG4gIH0sXG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICBpdGVtLmlzTW91bnRlZCA9IHRydWU7XG4gICAgdmFyIGlzUm9vdCA9IGl0ZW0ucGFyZW50SUQgPT09IDA7XG4gICAgaWYgKGlzUm9vdCkge1xuICAgICAgYWRkUm9vdChpZCk7XG4gICAgfVxuICB9LFxuICBvblVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIGlmICghaXRlbSB8fCAhaXRlbS5pc01vdW50ZWQpIHtcbiAgICAgIC8vIFdlIG1heSBlbmQgdXAgaGVyZSBhcyBhIHJlc3VsdCBvZiBzZXRTdGF0ZSgpIGluIGNvbXBvbmVudFdpbGxVbm1vdW50KCkuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGlnbm9yZSB0aGUgZWxlbWVudC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXRlbS51cGRhdGVDb3VudCsrO1xuICB9LFxuICBvblVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiBpdCBleGlzdHMuXG4gICAgICAvLyBgaXRlbWAgbWlnaHQgbm90IGV4aXN0IGlmIGl0IGlzIGluc2lkZSBhbiBlcnJvciBib3VuZGFyeSwgYW5kIGEgc2libGluZ1xuICAgICAgLy8gZXJyb3IgYm91bmRhcnkgY2hpbGQgdGhyZXcgd2hpbGUgbW91bnRpbmcuIFRoZW4gdGhpcyBpbnN0YW5jZSBuZXZlclxuICAgICAgLy8gZ290IGEgY2hhbmNlIHRvIG1vdW50LCBidXQgaXQgc3RpbGwgZ2V0cyBhbiB1bm1vdW50aW5nIGV2ZW50IGR1cmluZ1xuICAgICAgLy8gdGhlIGVycm9yIGJvdW5kYXJ5IGNsZWFudXAuXG4gICAgICBpdGVtLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgdmFyIGlzUm9vdCA9IGl0ZW0ucGFyZW50SUQgPT09IDA7XG4gICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgIHJlbW92ZVJvb3QoaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICB1bm1vdW50ZWRJRHMucHVzaChpZCk7XG4gIH0sXG4gIHB1cmdlVW5tb3VudGVkQ29tcG9uZW50czogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdENvbXBvbmVudFRyZWVIb29rLl9wcmV2ZW50UHVyZ2luZykge1xuICAgICAgLy8gU2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgdGVzdGluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVubW91bnRlZElEcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkID0gdW5tb3VudGVkSURzW2ldO1xuICAgICAgcHVyZ2VEZWVwKGlkKTtcbiAgICB9XG4gICAgdW5tb3VudGVkSURzLmxlbmd0aCA9IDA7XG4gIH0sXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5pc01vdW50ZWQgOiBmYWxzZTtcbiAgfSxcbiAgZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW06IGZ1bmN0aW9uICh0b3BFbGVtZW50KSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICBpZiAodG9wRWxlbWVudCkge1xuICAgICAgdmFyIHR5cGUgPSB0b3BFbGVtZW50LnR5cGU7XG4gICAgICB2YXIgbmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgOiB0eXBlO1xuICAgICAgdmFyIG93bmVyID0gdG9wRWxlbWVudC5fb3duZXI7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSB8fCAnVW5rbm93bicsIHRvcEVsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpKTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudE93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB2YXIgaWQgPSBjdXJyZW50T3duZXIgJiYgY3VycmVudE93bmVyLl9kZWJ1Z0lEO1xuXG4gICAgaW5mbyArPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGlkKTtcbiAgICByZXR1cm4gaW5mbztcbiAgfSxcbiAgZ2V0U3RhY2tBZGRlbmR1bUJ5SUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgd2hpbGUgKGlkKSB7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlSUQoaWQpO1xuICAgICAgaWQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm87XG4gIH0sXG4gIGdldENoaWxkSURzOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmNoaWxkSURzIDogW107XG4gIH0sXG4gIGdldERpc3BsYXlOYW1lOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGdldERpc3BsYXlOYW1lKGVsZW1lbnQpO1xuICB9LFxuICBnZXRFbGVtZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmVsZW1lbnQgOiBudWxsO1xuICB9LFxuICBnZXRPd25lcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50Ll9vd25lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50Ll9vd25lci5fZGVidWdJRDtcbiAgfSxcbiAgZ2V0UGFyZW50SUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0ucGFyZW50SUQgOiBudWxsO1xuICB9LFxuICBnZXRTb3VyY2U6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICB2YXIgZWxlbWVudCA9IGl0ZW0gPyBpdGVtLmVsZW1lbnQgOiBudWxsO1xuICAgIHZhciBzb3VyY2UgPSBlbGVtZW50ICE9IG51bGwgPyBlbGVtZW50Ll9zb3VyY2UgOiBudWxsO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH0sXG4gIGdldFRleHQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcnICsgZWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LFxuICBnZXRVcGRhdGVDb3VudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS51cGRhdGVDb3VudCA6IDA7XG4gIH0sXG5cblxuICBnZXRSZWdpc3RlcmVkSURzOiBnZXRSZWdpc3RlcmVkSURzLFxuXG4gIGdldFJvb3RJRHM6IGdldFJvb3RJRHNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2suanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2hlY2tSZWFjdFR5cGVTcGVjXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P29iamVjdH0gZWxlbWVudCBUaGUgUmVhY3QgZWxlbWVudCB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHs/bnVtYmVyfSBkZWJ1Z0lEIFRoZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUmVhY3RUeXBlU3BlYyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQsIGRlYnVnSUQpIHtcbiAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgdmFyIGVycm9yO1xuICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICEodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIFJlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc4NCcsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogdm9pZCAwO1xuICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKSA6IHZvaWQgMDtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBjb21wb25lbnRTdGFja0luZm8gPSAnJztcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVidWdJRCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0oZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBjb21wb25lbnRTdGFja0luZm8pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUmVhY3RUeXBlU3BlYztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2NoZWNrUmVhY3RUeXBlU3BlYy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlc1NlY3JldFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHByb3BUeXBlczoge1xuICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAqXG4gKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gKlxuICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gKiAgICAgfSxcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICogICB9KTtcbiAqXG4gKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gKlxuICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAqXG4gKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gKlxuICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAqICAgICAgICAgICk7XG4gKiAgICAgICAgfVxuICogICAgICB9XG4gKiAgICB9LFxuICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gKiAgfSk7XG4gKlxuICogQGludGVybmFsXG4gKi9cblxudmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxudmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyXG59O1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKHggPT09IHkpIHtcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cbi8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4vKipcbiAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIgd2UgZG9uJ3QgdXNlIHJlYWxcbiAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSAnJztcbn1cbi8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cblByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0ICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgIGlmICghbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICsgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICsgJ2FuZCB3aWxsIG5vdCB3b3JrIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uIFlvdSBtYXkgYmUgJyArICdzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyBsaWJyYXJ5LiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyBmb3IgZGV0YWlscy4nLCBwcm9wRnVsbE5hbWUsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdSZXF1aXJlZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHdhcyBub3Qgc3BlY2lmaWVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMobnVsbCkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICB9XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKCFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgIH1cbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAvLyBOYXRpdmUgU3ltYm9sLlxuICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG5mdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9XG4gIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgcmV0dXJuICdvYmplY3QnO1xuICB9XG4gIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgIHJldHVybiAnc3ltYm9sJztcbiAgfVxuICByZXR1cm4gcHJvcFR5cGU7XG59XG5cbi8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbi8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuICdkYXRlJztcbiAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcFR5cGU7XG59XG5cbi8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgIHJldHVybiBBTk9OWU1PVVM7XG4gIH1cbiAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RWZXJzaW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICcxNS4zLjEnO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG9ubHlDaGlsZFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJykgOiBfcHJvZEludmFyaWFudCgnMTQzJykgOiB2b2lkIDA7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbmx5Q2hpbGQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9vbmx5Q2hpbGQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0RE9NJyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QtZG9tL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NXG4gKi9cblxuLyogZ2xvYmFscyBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XG52YXIgZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUgPSByZXF1aXJlKCcuL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlJyk7XG52YXIgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIgPSByZXF1aXJlKCcuL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuUmVhY3REZWZhdWx0SW5qZWN0aW9uLmluamVjdCgpO1xuXG52YXIgUmVhY3RET00gPSB7XG4gIGZpbmRET01Ob2RlOiBmaW5kRE9NTm9kZSxcbiAgcmVuZGVyOiBSZWFjdE1vdW50LnJlbmRlcixcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMsXG4gIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclxufTtcblxuLy8gSW5qZWN0IHRoZSBydW50aW1lIGludG8gYSBkZXZ0b29scyBnbG9iYWwgaG9vayByZWdhcmRsZXNzIG9mIGJyb3dzZXIuXG4vLyBBbGxvd3MgZm9yIGRlYnVnZ2luZyB3aGVuIHRoZSBob29rIGlzIGluamVjdGVkIG9uIHRoZSBwYWdlLlxuLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbmlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0KHtcbiAgICBDb21wb25lbnRUcmVlOiB7XG4gICAgICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICAgICAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgLy8gaW5zdCBpcyBhbiBpbnRlcm5hbCBpbnN0YW5jZSAoYnV0IGNvdWxkIGJlIGEgY29tcG9zaXRlKVxuICAgICAgICBpZiAoaW5zdC5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgICAgICBpbnN0ID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIE1vdW50OiBSZWFjdE1vdW50LFxuICAgIFJlY29uY2lsZXI6IFJlYWN0UmVjb25jaWxlclxuICB9KTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgZGV2dG9vbHMgaXMgbm90IGluc3RhbGxlZFxuICAgIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggZG9lcyBub3QgaGF2ZSB0aGUgaXNzdWUgd2l0aCBkZXZ0b29scyBsb2FkZWQgb3ZlciBmaWxlOi8vXG4gICAgICAgIHZhciBzaG93RmlsZVVybE1lc3NhZ2UgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpID09PSAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyAnICsgKHNob3dGaWxlVXJsTWVzc2FnZSA/ICdhbmQgdXNlIGFuIEhUVFAgc2VydmVyIChpbnN0ZWFkIG9mIGEgZmlsZTogVVJMKSAnIDogJycpICsgJ2ZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGVzdEZ1bmMgPSBmdW5jdGlvbiB0ZXN0Rm4oKSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZygodGVzdEZ1bmMubmFtZSB8fCB0ZXN0RnVuYy50b1N0cmluZygpKS5pbmRleE9mKCd0ZXN0Rm4nKSAhPT0gLTEsICdJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGEgbWluaWZpZWQgY29weSBvZiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgJyArICdvZiBSZWFjdC4gV2hlbiBkZXBsb3lpbmcgUmVhY3QgYXBwcyB0byBwcm9kdWN0aW9uLCBtYWtlIHN1cmUgdG8gdXNlICcgKyAndGhlIHByb2R1Y3Rpb24gYnVpbGQgd2hpY2ggc2tpcHMgZGV2ZWxvcG1lbnQgd2FybmluZ3MgYW5kIGlzIGZhc3Rlci4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1taW5pZmljYXRpb24gZm9yIG1vcmUgZGV0YWlscy4nKSA6IHZvaWQgMDtcblxuICAgIC8vIElmIHdlJ3JlIGluIElFOCwgY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSBpbiBjb21wYXRpYmlsaXR5IG1vZGUgYW5kIHByb3ZpZGVcbiAgICAvLyBpbmZvcm1hdGlvbiBvbiBwcmV2ZW50aW5nIGNvbXBhdGliaWxpdHkgbW9kZVxuICAgIHZhciBpZUNvbXBhdGliaWxpdHlNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDg7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaWVDb21wYXRpYmlsaXR5TW9kZSwgJ0ludGVybmV0IEV4cGxvcmVyIGlzIHJ1bm5pbmcgaW4gY29tcGF0aWJpbGl0eSBtb2RlOyBwbGVhc2UgYWRkIHRoZSAnICsgJ2ZvbGxvd2luZyB0YWcgdG8geW91ciBIVE1MIHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZzogJyArICc8bWV0YSBodHRwLWVxdWl2PVwiWC1VQS1Db21wYXRpYmxlXCIgY29udGVudD1cIklFPWVkZ2VcIiAvPicpIDogdm9pZCAwO1xuXG4gICAgdmFyIGV4cGVjdGVkRmVhdHVyZXMgPSBbXG4gICAgLy8gc2hpbXNcbiAgICBBcnJheS5pc0FycmF5LCBBcnJheS5wcm90b3R5cGUuZXZlcnksIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiwgQXJyYXkucHJvdG90eXBlLm1hcCwgRGF0ZS5ub3csIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLCBPYmplY3Qua2V5cywgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgU3RyaW5nLnByb3RvdHlwZS50cmltXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRGZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFleHBlY3RlZEZlYXR1cmVzW2ldKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnT25lIG9yIG1vcmUgRVM1IHNoaW1zIGV4cGVjdGVkIGJ5IFJlYWN0IGFyZSBub3QgYXZhaWxhYmxlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1wb2x5ZmlsbHMnKSA6IHZvaWQgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbiAgdmFyIFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayA9IHJlcXVpcmUoJy4vUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rJyk7XG4gIHZhciBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2sgPSByZXF1aXJlKCcuL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vaycpO1xuXG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayk7XG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET007XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudFRyZWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIEZsYWdzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcblxudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEludGVybmFsSW5zdGFuY2UkJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4vKipcbiAqIERyaWxsIGRvd24gKHRocm91Z2ggY29tcG9zaXRlcyBhbmQgZW1wdHkgY29tcG9uZW50cykgdW50aWwgd2UgZ2V0IGEgaG9zdCBvclxuICogaG9zdCB0ZXh0IGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGlzIHByZXR0eSBwb2x5bW9ycGhpYyBidXQgdW5hdm9pZGFibGUgd2l0aCB0aGUgY3VycmVudCBzdHJ1Y3R1cmUgd2UgaGF2ZVxuICogZm9yIGBfcmVuZGVyZWRDaGlsZHJlbmAuXG4gKi9cbmZ1bmN0aW9uIGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoY29tcG9uZW50KSB7XG4gIHZhciByZW5kZXJlZDtcbiAgd2hpbGUgKHJlbmRlcmVkID0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudCA9IHJlbmRlcmVkO1xuICB9XG4gIHJldHVybiBjb21wb25lbnQ7XG59XG5cbi8qKlxuICogUG9wdWxhdGUgYF9ob3N0Tm9kZWAgb24gdGhlIHJlbmRlcmVkIGhvc3QvdGV4dCBjb21wb25lbnQgd2l0aCB0aGUgZ2l2ZW5cbiAqIERPTSBub2RlLiBUaGUgcGFzc2VkIGBpbnN0YCBjYW4gYmUgYSBjb21wb3NpdGUuXG4gKi9cbmZ1bmN0aW9uIHByZWNhY2hlTm9kZShpbnN0LCBub2RlKSB7XG4gIHZhciBob3N0SW5zdCA9IGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoaW5zdCk7XG4gIGhvc3RJbnN0Ll9ob3N0Tm9kZSA9IG5vZGU7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuZnVuY3Rpb24gdW5jYWNoZU5vZGUoaW5zdCkge1xuICB2YXIgbm9kZSA9IGluc3QuX2hvc3ROb2RlO1xuICBpZiAobm9kZSkge1xuICAgIGRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICAgIGluc3QuX2hvc3ROb2RlID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFBvcHVsYXRlIGBfaG9zdE5vZGVgIG9uIGVhY2ggY2hpbGQgb2YgYGluc3RgLCBhc3N1bWluZyB0aGF0IHRoZSBjaGlsZHJlblxuICogbWF0Y2ggdXAgd2l0aCB0aGUgRE9NIChlbGVtZW50KSBjaGlsZHJlbiBvZiBgbm9kZWAuXG4gKlxuICogV2UgY2FjaGUgZW50aXJlIGxldmVscyBhdCBvbmNlIHRvIGF2b2lkIGFuIG5eMiBwcm9ibGVtIHdoZXJlIHdlIGFjY2VzcyB0aGVcbiAqIGNoaWxkcmVuIG9mIGEgbm9kZSBzZXF1ZW50aWFsbHkgYW5kIGhhdmUgdG8gd2FsayBmcm9tIHRoZSBzdGFydCB0byBvdXIgdGFyZ2V0XG4gKiBub2RlIGV2ZXJ5IHRpbWUuXG4gKlxuICogU2luY2Ugd2UgdXBkYXRlIGBfcmVuZGVyZWRDaGlsZHJlbmAgYW5kIHRoZSBhY3R1YWwgRE9NIGF0IChzbGlnaHRseSlcbiAqIGRpZmZlcmVudCB0aW1lcywgd2UgY291bGQgcmFjZSBoZXJlIGFuZCBzZWUgYSBuZXdlciBgX3JlbmRlcmVkQ2hpbGRyZW5gIHRoYW5cbiAqIHRoZSBET00gbm9kZXMgd2Ugc2VlLiBUbyBhdm9pZCB0aGlzLCBSZWFjdE11bHRpQ2hpbGQgY2FsbHNcbiAqIGBwcmVwYXJlVG9NYW5hZ2VDaGlsZHJlbmAgYmVmb3JlIHdlIGNoYW5nZSBgX3JlbmRlcmVkQ2hpbGRyZW5gLCBhdCB3aGljaFxuICogdGltZSB0aGUgY29udGFpbmVyJ3MgY2hpbGQgbm9kZXMgYXJlIGFsd2F5cyBjYWNoZWQgKHVudGlsIGl0IHVubW91bnRzKS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpIHtcbiAgaWYgKGluc3QuX2ZsYWdzICYgRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRyZW4gPSBpbnN0Ll9yZW5kZXJlZENoaWxkcmVuO1xuICB2YXIgY2hpbGROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICBvdXRlcjogZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgIGlmICghY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0ID0gY2hpbGRyZW5bbmFtZV07XG4gICAgdmFyIGNoaWxkSUQgPSBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGNoaWxkSW5zdCkuX2RvbUlEO1xuICAgIGlmIChjaGlsZElEID09PSAwKSB7XG4gICAgICAvLyBXZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZyB0aGlzIGNoaWxkIGluIFJlYWN0TXVsdGlDaGlsZDsgc2tpcCBpdC5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBXZSBhc3N1bWUgdGhlIGNoaWxkIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY2hpbGQgaW5zdGFuY2VzLlxuICAgIGZvciAoOyBjaGlsZE5vZGUgIT09IG51bGw7IGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZykge1xuICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBjaGlsZE5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgPT09IFN0cmluZyhjaGlsZElEKSB8fCBjaGlsZE5vZGUubm9kZVR5cGUgPT09IDggJiYgY2hpbGROb2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC10ZXh0OiAnICsgY2hpbGRJRCArICcgJyB8fCBjaGlsZE5vZGUubm9kZVR5cGUgPT09IDggJiYgY2hpbGROb2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1lbXB0eTogJyArIGNoaWxkSUQgKyAnICcpIHtcbiAgICAgICAgcHJlY2FjaGVOb2RlKGNoaWxkSW5zdCwgY2hpbGROb2RlKTtcbiAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgRE9NIGNoaWxkcmVuIHdpdGhvdXQgZmluZGluZyBhbiBJRCBtYXRjaC5cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgZWxlbWVudCB3aXRoIElEICVzLicsIGNoaWxkSUQpIDogX3Byb2RJbnZhcmlhbnQoJzMyJywgY2hpbGRJRCkgOiB2b2lkIDA7XG4gIH1cbiAgaW5zdC5fZmxhZ3MgfD0gRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcztcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIGluc3RhbmNlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZXN0O1xuICB2YXIgaW5zdDtcbiAgZm9yICg7IG5vZGUgJiYgKGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKTsgbm9kZSA9IHBhcmVudHMucG9wKCkpIHtcbiAgICBjbG9zZXN0ID0gaW5zdDtcbiAgICBpZiAocGFyZW50cy5sZW5ndGgpIHtcbiAgICAgIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKTtcbiAgaWYgKGluc3QgIT0gbnVsbCAmJiBpbnN0Ll9ob3N0Tm9kZSA9PT0gbm9kZSkge1xuICAgIHJldHVybiBpbnN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkge1xuICAvLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbiAgLy8gaW52YXJpYW50IGZvciBhIG1pc3NpbmcgcGFyZW50LCB3aGljaCBpcyBzdXBlciBjb25mdXNpbmcuXG4gICEoaW5zdC5faG9zdE5vZGUgIT09IHVuZGVmaW5lZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuXG4gIGlmIChpbnN0Ll9ob3N0Tm9kZSkge1xuICAgIHJldHVybiBpbnN0Ll9ob3N0Tm9kZTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBhbmNlc3RvciB3aG9zZSBET00gbm9kZSB3ZSBoYXZlIGNhY2hlZC5cbiAgdmFyIHBhcmVudHMgPSBbXTtcbiAgd2hpbGUgKCFpbnN0Ll9ob3N0Tm9kZSkge1xuICAgIHBhcmVudHMucHVzaChpbnN0KTtcbiAgICAhaW5zdC5faG9zdFBhcmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBET00gdHJlZSByb290IHNob3VsZCBhbHdheXMgaGF2ZSBhIG5vZGUgcmVmZXJlbmNlLicpIDogX3Byb2RJbnZhcmlhbnQoJzM0JykgOiB2b2lkIDA7XG4gICAgaW5zdCA9IGluc3QuX2hvc3RQYXJlbnQ7XG4gIH1cblxuICAvLyBOb3cgcGFyZW50cyBjb250YWlucyBlYWNoIGFuY2VzdG9yIHRoYXQgZG9lcyAqbm90KiBoYXZlIGEgY2FjaGVkIG5hdGl2ZVxuICAvLyBub2RlLCBhbmQgYGluc3RgIGlzIHRoZSBkZWVwZXN0IGFuY2VzdG9yIHRoYXQgZG9lcy5cbiAgZm9yICg7IHBhcmVudHMubGVuZ3RoOyBpbnN0ID0gcGFyZW50cy5wb3AoKSkge1xuICAgIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBpbnN0Ll9ob3N0Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gaW5zdC5faG9zdE5vZGU7XG59XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSB7XG4gIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSxcbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZ2V0Tm9kZUZyb21JbnN0YW5jZSxcbiAgcHJlY2FjaGVDaGlsZE5vZGVzOiBwcmVjYWNoZUNoaWxkTm9kZXMsXG4gIHByZWNhY2hlTm9kZTogcHJlY2FjaGVOb2RlLFxuICB1bmNhY2hlTm9kZTogdW5jYWNoZU5vZGVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnRUcmVlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnRUcmVlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTVByb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiB0aGF0IGdpdmVuIGFuIGF0dHJpYnV0ZSBuYW1lIHdpbGwgcmV0dXJuIHRydWVcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAqIGF0dHJpYnV0ZSBuYW1lcyxcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMucHVzaChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSBcXCclc1xcJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSBpbmplY3RpbmcgdGhlIHNhbWUgRE9NIHByb3BlcnR5IGNvbmZpZyB0d2ljZSwgb3IgeW91IG1heSBiZSBpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsIHByb3BOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc0OCcsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSlcbiAgICAgIH07XG4gICAgICAhKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICsgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IFZhbHVlIGNhbiBiZSBvbmUgb2YgYm9vbGVhbiwgb3ZlcmxvYWRlZCBib29sZWFuLCBvciBudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzJywgcHJvcE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzUwJywgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkXSA9IHByb3BOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbYXR0cmlidXRlTmFtZV0gPSBwcm9wTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NUHJvcGVydHlOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZSA9IERPTVByb3BlcnR5TmFtZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHByb3BlcnR5SW5mbztcbiAgICB9XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gJzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkQnO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogRE9NUHJvcGVydHkgZXhwb3J0cyBsb29rdXAgb2JqZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGxpa2UgZnVuY3Rpb25zOlxuICpcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydpZCddXG4gKiAgIHRydWVcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydmb29iYXInXVxuICogICB1bmRlZmluZWRcbiAqXG4gKiBBbHRob3VnaCB0aGlzIG1heSBiZSBjb25mdXNpbmcsIGl0IHBlcmZvcm1zIGJldHRlciBpbiBnZW5lcmFsLlxuICpcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LWV4aXN0c1xuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktbWlzc2luZ1xuICovXG52YXIgRE9NUHJvcGVydHkgPSB7XG5cbiAgSURfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0aWQnLFxuICBST09UX0FUVFJJQlVURV9OQU1FOiAnZGF0YS1yZWFjdHJvb3QnLFxuXG4gIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIsXG4gIEFUVFJJQlVURV9OQU1FX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDAnLFxuXG4gIC8qKlxuICAgKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAgICogdGhlIHByb3BlcnR5IGluIHRoZSBET00uIEVhY2ggb2JqZWN0IGNvbnRhaW5zOlxuICAgKlxuICAgKiBhdHRyaWJ1dGVOYW1lOlxuICAgKiAgIFVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gICAqIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICAgKiBwcm9wZXJ0eU5hbWU6XG4gICAqICAgVXNlZCBvbiBET00gbm9kZSBpbnN0YW5jZXMuIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvXG4gICAqICAgZXh0ZXJuYWwgZmFjdG9ycy4pXG4gICAqIG11dGF0aW9uTWV0aG9kOlxuICAgKiAgIElmIG5vbi1udWxsLCB1c2VkIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAgYWZ0ZXJcbiAgICogICBpbml0aWFsIHJlbmRlci5cbiAgICogbXVzdFVzZVByb3BlcnR5OlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBoYXNCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc051bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljIGFuZCBzaG91bGQgYmVcbiAgICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICAgKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbiAgICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAgICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gICAqL1xuICBwcm9wZXJ0aWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbiwgdXNlZFxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy4gQXZhaWxhYmxlIG9ubHkgaW4gX19ERVZfXy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge30gOiBudWxsLFxuXG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlIGlzQ3VzdG9tQXR0cmlidXRlKCkgZnVuY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIGluamVjdGVkLlxuICAgKi9cbiAgX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zOiBbXSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgY3VzdG9tIGF0dHJpYnV0ZS5cbiAgICogQG1ldGhvZFxuICAgKi9cbiAgaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpc0N1c3RvbUF0dHJpYnV0ZUZuID0gRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zW2ldO1xuICAgICAgaWYgKGlzQ3VzdG9tQXR0cmlidXRlRm4oYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBpbmplY3Rpb246IERPTVByb3BlcnR5SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHkuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Db21wb25lbnRGbGFnc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3MgPSB7XG4gIGhhc0NhY2hlZENoaWxkTm9kZXM6IDEgPDwgMFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnRGbGFncy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRJbmplY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luJyk7XG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0NoYW5nZUV2ZW50UGx1Z2luJyk7XG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSByZXF1aXJlKCcuL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyJyk7XG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9FbnRlckxlYXZlRXZlbnRQbHVnaW4nKTtcbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL0hUTUxET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01FbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01FbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RE9NVHJlZVRyYXZlcnNhbCA9IHJlcXVpcmUoJy4vUmVhY3RET01UcmVlVHJhdmVyc2FsJyk7XG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRDb21wb25lbnQnKTtcbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5Jyk7XG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi9SZWFjdEV2ZW50TGlzdGVuZXInKTtcbnZhciBSZWFjdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbmplY3Rpb24nKTtcbnZhciBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uJyk7XG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL1NWR0RPTVByb3BlcnR5Q29uZmlnJyk7XG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NlbGVjdEV2ZW50UGx1Z2luJyk7XG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NpbXBsZUV2ZW50UGx1Z2luJyk7XG5cbnZhciBhbHJlYWR5SW5qZWN0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5qZWN0KCkge1xuICBpZiAoYWxyZWFkeUluamVjdGVkKSB7XG4gICAgLy8gVE9ETzogVGhpcyBpcyBjdXJyZW50bHkgdHJ1ZSBiZWNhdXNlIHRoZXNlIGluamVjdGlvbnMgYXJlIHNoYXJlZCBiZXR3ZWVuXG4gICAgLy8gdGhlIGNsaWVudCBhbmQgdGhlIHNlcnZlciBwYWNrYWdlLiBUaGV5IHNob3VsZCBiZSBidWlsdCBpbmRlcGVuZGVudGx5XG4gICAgLy8gYW5kIG5vdCBzaGFyZSBhbnkgaW5qZWN0aW9uIHN0YXRlLiBUaGVuIHRoaXMgcHJvYmxlbSB3aWxsIGJlIHNvbHZlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgYWxyZWFkeUluamVjdGVkID0gdHJ1ZTtcblxuICBSZWFjdEluamVjdGlvbi5FdmVudEVtaXR0ZXIuaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyKFJlYWN0RXZlbnRMaXN0ZW5lcik7XG5cbiAgLyoqXG4gICAqIEluamVjdCBtb2R1bGVzIGZvciByZXNvbHZpbmcgRE9NIGhpZXJhcmNoeSBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcik7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0Q29tcG9uZW50VHJlZShSZWFjdERPTUNvbXBvbmVudFRyZWUpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpblV0aWxzLmluamVjdFRyZWVUcmF2ZXJzYWwoUmVhY3RET01UcmVlVHJhdmVyc2FsKTtcblxuICAvKipcbiAgICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gICAqIHRoZW0pLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gICAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gICAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICAgIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkhvc3RDb21wb25lbnQuaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzKFJlYWN0RE9NQ29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5Ib3N0Q29tcG9uZW50LmluamVjdFRleHRDb21wb25lbnRDbGFzcyhSZWFjdERPTVRleHRDb21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKEhUTUxET01Qcm9wZXJ0eUNvbmZpZyk7XG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxuICBSZWFjdEluamVjdGlvbi5FbXB0eUNvbXBvbmVudC5pbmplY3RFbXB0eUNvbXBvbmVudEZhY3RvcnkoZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBSZWFjdERPTUVtcHR5Q29tcG9uZW50KGluc3RhbnRpYXRlKTtcbiAgfSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uVXBkYXRlcy5pbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbihSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgUmVhY3RJbmplY3Rpb24uVXBkYXRlcy5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkNvbXBvbmVudC5pbmplY3RFbnZpcm9ubWVudChSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbmplY3Q6IGluamVjdFxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSA9IHJlcXVpcmUoJy4vRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlJyk7XG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ29tcG9zaXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0lucHV0RXZlbnQnKTtcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkJlZm9yZUlucHV0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25CZWZvcmVJbnB1dENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQsIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wVGV4dElucHV0LCB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25FbmQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblN0YXJ0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uU3RhcnQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblVwZGF0ZTogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25VcGRhdGUsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uU3RhcnQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblVwZGF0ZTpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93biAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gZmFsbGJhY2sgb2JqZWN0LCBpZiBhbnkuXG52YXIgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcblxuLyoqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24gJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5nZXRQb29sZWQobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1c3RvbURhdGEgPSBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgZXZlbnQuZGF0YSA9IGN1c3RvbURhdGE7XG4gICAgfVxuICB9XG5cbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUZXh0SW5wdXQ6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQgfHwgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xuICAgICAgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnJlbGVhc2UoY3VycmVudENvbXBvc2l0aW9uKTtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGFzdGU6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAobmF0aXZlRXZlbnQud2hpY2ggJiYgIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPyBudWxsIDogbmF0aXZlRXZlbnQuZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgU3ludGhldGljSW5wdXRFdmVudCBmb3IgYGJlZm9yZUlucHV0YCwgYmFzZWQgb24gZWl0aGVyIG5hdGl2ZVxuICogYHRleHRJbnB1dGAgb3IgZmFsbGJhY2sgYmVoYXZpb3IuXG4gKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnM7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9XG5cbiAgLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cbiAgaWYgKCFjaGFycykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljSW5wdXRFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5iZWZvcmVJbnB1dCwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBldmVudC5kYXRhID0gY2hhcnM7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHJldHVybiBbZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpLCBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCldO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJlZm9yZUlucHV0RXZlbnRQbHVnaW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50Q29uc3RhbnRzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbnZhciBQcm9wYWdhdGlvblBoYXNlcyA9IGtleU1pcnJvcih7IGJ1YmJsZWQ6IG51bGwsIGNhcHR1cmVkOiBudWxsIH0pO1xuXG4vKipcbiAqIFR5cGVzIG9mIHJhdyBzaWduYWxzIGZyb20gdGhlIGJyb3dzZXIgY2F1Z2h0IGF0IHRoZSB0b3AgbGV2ZWwuXG4gKi9cbnZhciB0b3BMZXZlbFR5cGVzID0ga2V5TWlycm9yKHtcbiAgdG9wQWJvcnQ6IG51bGwsXG4gIHRvcEFuaW1hdGlvbkVuZDogbnVsbCxcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBudWxsLFxuICB0b3BBbmltYXRpb25TdGFydDogbnVsbCxcbiAgdG9wQmx1cjogbnVsbCxcbiAgdG9wQ2FuUGxheTogbnVsbCxcbiAgdG9wQ2FuUGxheVRocm91Z2g6IG51bGwsXG4gIHRvcENoYW5nZTogbnVsbCxcbiAgdG9wQ2xpY2s6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiBudWxsLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiBudWxsLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogbnVsbCxcbiAgdG9wQ29udGV4dE1lbnU6IG51bGwsXG4gIHRvcENvcHk6IG51bGwsXG4gIHRvcEN1dDogbnVsbCxcbiAgdG9wRG91YmxlQ2xpY2s6IG51bGwsXG4gIHRvcERyYWc6IG51bGwsXG4gIHRvcERyYWdFbmQ6IG51bGwsXG4gIHRvcERyYWdFbnRlcjogbnVsbCxcbiAgdG9wRHJhZ0V4aXQ6IG51bGwsXG4gIHRvcERyYWdMZWF2ZTogbnVsbCxcbiAgdG9wRHJhZ092ZXI6IG51bGwsXG4gIHRvcERyYWdTdGFydDogbnVsbCxcbiAgdG9wRHJvcDogbnVsbCxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6IG51bGwsXG4gIHRvcEVtcHRpZWQ6IG51bGwsXG4gIHRvcEVuY3J5cHRlZDogbnVsbCxcbiAgdG9wRW5kZWQ6IG51bGwsXG4gIHRvcEVycm9yOiBudWxsLFxuICB0b3BGb2N1czogbnVsbCxcbiAgdG9wSW5wdXQ6IG51bGwsXG4gIHRvcEludmFsaWQ6IG51bGwsXG4gIHRvcEtleURvd246IG51bGwsXG4gIHRvcEtleVByZXNzOiBudWxsLFxuICB0b3BLZXlVcDogbnVsbCxcbiAgdG9wTG9hZDogbnVsbCxcbiAgdG9wTG9hZGVkRGF0YTogbnVsbCxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6IG51bGwsXG4gIHRvcExvYWRTdGFydDogbnVsbCxcbiAgdG9wTW91c2VEb3duOiBudWxsLFxuICB0b3BNb3VzZU1vdmU6IG51bGwsXG4gIHRvcE1vdXNlT3V0OiBudWxsLFxuICB0b3BNb3VzZU92ZXI6IG51bGwsXG4gIHRvcE1vdXNlVXA6IG51bGwsXG4gIHRvcFBhc3RlOiBudWxsLFxuICB0b3BQYXVzZTogbnVsbCxcbiAgdG9wUGxheTogbnVsbCxcbiAgdG9wUGxheWluZzogbnVsbCxcbiAgdG9wUHJvZ3Jlc3M6IG51bGwsXG4gIHRvcFJhdGVDaGFuZ2U6IG51bGwsXG4gIHRvcFJlc2V0OiBudWxsLFxuICB0b3BTY3JvbGw6IG51bGwsXG4gIHRvcFNlZWtlZDogbnVsbCxcbiAgdG9wU2Vla2luZzogbnVsbCxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiBudWxsLFxuICB0b3BTdGFsbGVkOiBudWxsLFxuICB0b3BTdWJtaXQ6IG51bGwsXG4gIHRvcFN1c3BlbmQ6IG51bGwsXG4gIHRvcFRleHRJbnB1dDogbnVsbCxcbiAgdG9wVGltZVVwZGF0ZTogbnVsbCxcbiAgdG9wVG91Y2hDYW5jZWw6IG51bGwsXG4gIHRvcFRvdWNoRW5kOiBudWxsLFxuICB0b3BUb3VjaE1vdmU6IG51bGwsXG4gIHRvcFRvdWNoU3RhcnQ6IG51bGwsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IG51bGwsXG4gIHRvcFZvbHVtZUNoYW5nZTogbnVsbCxcbiAgdG9wV2FpdGluZzogbnVsbCxcbiAgdG9wV2hlZWw6IG51bGxcbn0pO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSB7XG4gIHRvcExldmVsVHlwZXM6IHRvcExldmVsVHlwZXMsXG4gIFByb3BhZ2F0aW9uUGhhc2VzOiBQcm9wYWdhdGlvblBoYXNlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudENvbnN0YW50cztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50Q29uc3RhbnRzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG5cbnZhciBhY2N1bXVsYXRlSW50byA9IHJlcXVpcmUoJy4vYWNjdW11bGF0ZUludG8nKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKCcuL2ZvckVhY2hBY2N1bXVsYXRlZCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBQcm9wYWdhdGlvblBoYXNlcyA9IEV2ZW50Q29uc3RhbnRzLlByb3BhZ2F0aW9uUGhhc2VzO1xudmFyIGdldExpc3RlbmVyID0gRXZlbnRQbHVnaW5IdWIuZ2V0TGlzdGVuZXI7XG5cbi8qKlxuICogU29tZSBldmVudCB0eXBlcyBoYXZlIGEgbm90aW9uIG9mIGRpZmZlcmVudCByZWdpc3RyYXRpb24gbmFtZXMgZm9yIGRpZmZlcmVudFxuICogXCJwaGFzZXNcIiBvZiBwcm9wYWdhdGlvbi4gVGhpcyBmaW5kcyBsaXN0ZW5lcnMgYnkgYSBnaXZlbiBwaGFzZS5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwcm9wYWdhdGlvblBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XG4gIHJldHVybiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbn1cblxuLyoqXG4gKiBUYWdzIGEgYFN5bnRoZXRpY0V2ZW50YCB3aXRoIGRpc3BhdGNoZWQgbGlzdGVuZXJzLiBDcmVhdGluZyB0aGlzIGZ1bmN0aW9uXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcbiAqIFwiZGlzcGF0Y2hcIiBvYmplY3QgdGhhdCBwYWlycyB0aGUgZXZlbnQgd2l0aCB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoaW5zdCwgdXB3YXJkcywgZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0LCAnRGlzcGF0Y2hpbmcgaW5zdCBtdXN0IG5vdCBiZSBudWxsJykgOiB2b2lkIDA7XG4gIH1cbiAgdmFyIHBoYXNlID0gdXB3YXJkcyA/IFByb3BhZ2F0aW9uUGhhc2VzLmJ1YmJsZWQgOiBQcm9wYWdhdGlvblBoYXNlcy5jYXB0dXJlZDtcbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwaGFzZSk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRpc3BhdGNoZXMgKG11c3QgYmUgZW50aXJlbHkgY29sbGVjdGVkIGJlZm9yZSBkaXNwYXRjaGluZyAtIHNlZSB1bml0XG4gKiB0ZXN0cykuIExhemlseSBhbGxvY2F0ZSB0aGUgYXJyYXkgdG8gY29uc2VydmUgbWVtb3J5LiAgV2UgbXVzdCBsb29wIHRocm91Z2hcbiAqIGVhY2ggZXZlbnQgYW5kIHBlcmZvcm0gdGhlIHRyYXZlcnNhbCBmb3IgZWFjaCBvbmUuIFdlIGNhbm5vdCBwZXJmb3JtIGFcbiAqIHNpbmdsZSB0cmF2ZXJzYWwgZm9yIHRoZSBlbnRpcmUgY29sbGVjdGlvbiBvZiBldmVudHMgYmVjYXVzZSBlYWNoIGV2ZW50IG1heVxuICogaGF2ZSBhIGRpZmZlcmVudCB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZVR3b1BoYXNlKGV2ZW50Ll90YXJnZXRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlYCwgYnV0IHNraXBzIG92ZXIgdGhlIHRhcmdldElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldChldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB2YXIgdGFyZ2V0SW5zdCA9IGV2ZW50Ll90YXJnZXRJbnN0O1xuICAgIHZhciBwYXJlbnRJbnN0ID0gdGFyZ2V0SW5zdCA/IEV2ZW50UGx1Z2luVXRpbHMuZ2V0UGFyZW50SW5zdGFuY2UodGFyZ2V0SW5zdCkgOiBudWxsO1xuICAgIEV2ZW50UGx1Z2luVXRpbHMudHJhdmVyc2VUd29QaGFzZShwYXJlbnRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpbnN0LCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcbiAqIGBkaXNwYXRjaE1hcmtlcmAuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50Ll90YXJnZXRJbnN0LCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKSB7XG4gIEV2ZW50UGx1Z2luVXRpbHMudHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBhY2N1bXVsYXRlRGlzcGF0Y2hlcywgbGVhdmUsIGVudGVyKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuLyoqXG4gKiBBIHNtYWxsIHNldCBvZiBwcm9wYWdhdGlvbiBwYXR0ZXJucywgZWFjaCBvZiB3aGljaCB3aWxsIGFjY2VwdCBhIHNtYWxsIGFtb3VudFxuICogb2YgaW5mb3JtYXRpb24sIGFuZCBnZW5lcmF0ZSBhIHNldCBvZiBcImRpc3BhdGNoIHJlYWR5IGV2ZW50IG9iamVjdHNcIiAtIHdoaWNoXG4gKiBhcmUgc2V0cyBvZiBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhbm5vdGF0ZWQgd2l0aCBhIHNldCBvZiBkaXNwYXRjaGVkXG4gKiBsaXN0ZW5lciBmdW5jdGlvbnMvaWRzLiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRoaXMgd2F5IHRvIGRpc2NvdXJhZ2UgdGhlc2VcbiAqIHByb3BhZ2F0aW9uIHN0cmF0ZWdpZXMgZnJvbSBhY3R1YWxseSBleGVjdXRpbmcgdGhlIGRpc3BhdGNoZXMsIHNpbmNlIHdlXG4gKiBhbHdheXMgd2FudCB0byBjb2xsZWN0IHRoZSBlbnRpcmUgc2V0IG9mIGRpc3BhdGNoZXMgYmVmb3JlIGV4ZWN1dGluZyBldmVudCBhXG4gKiBzaW5nbGUgb25lLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBFdmVudFByb3BhZ2F0b3JzXG4gKi9cbnZhciBFdmVudFByb3BhZ2F0b3JzID0ge1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldDogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQsXG4gIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQcm9wYWdhdG9ycztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50UHJvcGFnYXRvcnMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQbHVnaW5IdWJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5VdGlscycpO1xudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XG5cbnZhciBhY2N1bXVsYXRlSW50byA9IHJlcXVpcmUoJy4vYWNjdW11bGF0ZUludG8nKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKCcuL2ZvckVhY2hBY2N1bXVsYXRlZCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEludGVybmFsIHN0b3JlIGZvciBldmVudCBsaXN0ZW5lcnNcbiAqL1xudmFyIGxpc3RlbmVyQmFuayA9IHt9O1xuXG4vKipcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cbiAqL1xudmFyIGV2ZW50UXVldWUgPSBudWxsO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHByaXZhdGVcbiAqL1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSA9IGZ1bmN0aW9uIChldmVudCwgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudCkge1xuICAgIEV2ZW50UGx1Z2luVXRpbHMuZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG52YXIgZ2V0RGljdGlvbmFyeUtleSA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gIC8vIFByZXZlbnRzIFY4IHBlcmZvcm1hbmNlIGlzc3VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MjMyXG4gIHJldHVybiAnLicgKyBpbnN0Ll9yb290Tm9kZUlEO1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgRXZlbnRQbHVnaW5IdWIgPSB7XG5cbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBpbmplY3Rpb246IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG5cbiAgfSxcblxuICAvKipcbiAgICogU3RvcmVzIGBsaXN0ZW5lcmAgYXQgYGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtrZXldYC4gSXMgaWRlbXBvdGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgdG8gc3RvcmUuXG4gICAqL1xuICBwdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgISh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkICVzIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IHR5cGUgJXMnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogX3Byb2RJbnZhcmlhbnQoJzk0JywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IHZvaWQgMDtcblxuICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSB8fCAobGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdID0ge30pO1xuICAgIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV0gPSBsaXN0ZW5lcjtcblxuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKSB7XG4gICAgICBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gICAqL1xuICBnZXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgcmV0dXJuIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lICYmIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBsaXN0ZW5lciBmcm9tIHRoZSByZWdpc3RyYXRpb24gYmFuay5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKi9cbiAgZGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBuZXZlciBiZSBudWxsIC0tIHdoZW4gaXMgaXQ/XG4gICAgaWYgKGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICAgIGRlbGV0ZSBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtrZXldO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgRE9NIGVsZW1lbnQgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqL1xuICBkZWxldGVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiBsaXN0ZW5lckJhbmspIHtcbiAgICAgIGlmICghbGlzdGVuZXJCYW5rLmhhc093blByb3BlcnR5KHJlZ2lzdHJhdGlvbk5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtrZXldKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcikge1xuICAgICAgICBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuIG9wcG9ydHVuaXR5IHRvIGV4dHJhY3QgZXZlbnRzIGZyb20gdG9wLWxldmVsXG4gICAqIG5hdGl2ZSBicm93c2VyIGV2ZW50cy5cbiAgICpcbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cztcbiAgICB2YXIgcGx1Z2lucyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE5vdCBldmVyeSBwbHVnaW4gaW4gdGhlIG9yZGVyaW5nIG1heSBiZSBsb2FkZWQgYXQgcnVudGltZS5cbiAgICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgICAgdmFyIGV4dHJhY3RlZEV2ZW50cyA9IHBvc3NpYmxlUGx1Z2luLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc3ludGhldGljIGV2ZW50IHRoYXQgc2hvdWxkIGJlIGRpc3BhdGNoZWQgd2hlblxuICAgKiBgcHJvY2Vzc0V2ZW50UXVldWVgIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZXZlbnRzIEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVFdmVudHM6IGZ1bmN0aW9uIChldmVudHMpIHtcbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICBldmVudFF1ZXVlID0gYWNjdW11bGF0ZUludG8oZXZlbnRRdWV1ZSwgZXZlbnRzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYWxsIHN5bnRoZXRpYyBldmVudHMgb24gdGhlIGV2ZW50IHF1ZXVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NFdmVudFF1ZXVlOiBmdW5jdGlvbiAoc2ltdWxhdGVkKSB7XG4gICAgLy8gU2V0IGBldmVudFF1ZXVlYCB0byBudWxsIGJlZm9yZSBwcm9jZXNzaW5nIGl0IHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgbW9yZVxuICAgIC8vIGV2ZW50cyBnZXQgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZy5cbiAgICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICAgIGV2ZW50UXVldWUgPSBudWxsO1xuICAgIGlmIChzaW11bGF0ZWQpIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCk7XG4gICAgfVxuICAgICEhZXZlbnRRdWV1ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5NScpIDogdm9pZCAwO1xuICAgIC8vIFRoaXMgd291bGQgYmUgYSBnb29kIHRpbWUgdG8gcmV0aHJvdyBpZiBhbnkgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIHRocmV3LlxuICAgIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbiAgfSxcblxuICAvKipcbiAgICogVGhlc2UgYXJlIG5lZWRlZCBmb3IgdGVzdHMgb25seS4gRG8gbm90IHVzZSFcbiAgICovXG4gIF9fcHVyZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICBsaXN0ZW5lckJhbmsgPSB7fTtcbiAgfSxcblxuICBfX2dldExpc3RlbmVyQmFuazogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsaXN0ZW5lckJhbms7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpbkh1YjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luUmVnaXN0cnlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG9yZGVyaW5nIG9mIGV2ZW50IHBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpbk9yZGVyID0gbnVsbDtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG1hcHBpbmcgZnJvbSBuYW1lcyB0byBldmVudCBwbHVnaW4gbW9kdWxlcy5cbiAqL1xudmFyIG5hbWVzVG9QbHVnaW5zID0ge307XG5cbi8qKlxuICogUmVjb21wdXRlcyB0aGUgcGx1Z2luIGxpc3QgdXNpbmcgdGhlIGluamVjdGVkIHBsdWdpbnMgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpIHtcbiAgaWYgKCFFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgLy8gV2FpdCB1bnRpbCBhbiBgRXZlbnRQbHVnaW5PcmRlcmAgaXMgaW5qZWN0ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgdmFyIHBsdWdpbkluZGV4ID0gRXZlbnRQbHVnaW5PcmRlci5pbmRleE9mKHBsdWdpbk5hbWUpO1xuICAgICEocGx1Z2luSW5kZXggPiAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTYnLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFQbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudCBwbHVnaW5zIG11c3QgaW1wbGVtZW50IGFuIGBleHRyYWN0RXZlbnRzYCBtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsIHBsdWdpbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk3JywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSA9IFBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTgnLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIERpc3BhdGNoIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgZXZlbnQgbmFtZSwgYCVzYC4nLCBldmVudE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk5JywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXSA9IGRpc3BhdGNoQ29uZmlnO1xuXG4gIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xuICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBmb3IgKHZhciBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZU5hbWUpKSB7XG4gICAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lID0gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VOYW1lXTtcbiAgICAgICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocGhhc2VkUmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYSByZWdpc3RyYXRpb24gbmFtZSB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZGlzcGF0Y2hlZCBldmVudHMgYW5kXG4gKiBjYW4gYmUgdXNlZCB3aXRoIGBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcmAgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDAnLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IFBsdWdpbk1vZHVsZTtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSByZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0ge1xuXG4gIC8qKlxuICAgKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAgICovXG4gIHBsdWdpbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAgICovXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gICAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAgICogb25seSBpbiBfX0RFVl9fLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHt9IDogbnVsbCxcblxuICAvKipcbiAgICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICAgKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAgICogYWx3YXlzIGRldGVybWluaXN0aWMgcmVnYXJkbGVzcyBvZiBwYWNrYWdpbmcsIG9uLXRoZS1mbHkgaW5qZWN0aW9uLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBmdW5jdGlvbiAoSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgISFFdmVudFBsdWdpbk9yZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiBfcHJvZEludmFyaWFudCgnMTAxJykgOiB2b2lkIDA7XG4gICAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICAgKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICAgKlxuICAgKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBmdW5jdGlvbiAoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gUGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICEhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDInLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBQbHVnaW5Nb2R1bGU7XG4gICAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMb29rcyB1cCB0aGUgcGx1Z2luIGZvciB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBIHN5bnRoZXRpYyBldmVudC5cbiAgICogQHJldHVybiB7P29iamVjdH0gVGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWQgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFBsdWdpbk1vZHVsZUZvckV2ZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBldmVudC5kaXNwYXRjaENvbmZpZztcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZV0gfHwgbnVsbDtcbiAgICB9XG4gICAgZm9yICh2YXIgcGhhc2UgaW4gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmICghZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2UpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VdXTtcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbk1vZHVsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldEV2ZW50UGx1Z2luczogZnVuY3Rpb24gKCkge1xuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmIChuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBkZWxldGUgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MpIHtcbiAgICAgIGlmIChldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICBkZWxldGUgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcbiAgICAgIGZvciAodmFyIGxvd2VyQ2FzZWROYW1lIGluIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgICAgaWYgKHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICAgICAgZGVsZXRlIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5SZWdpc3RyeTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQbHVnaW5VdGlsc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEluamVjdGVkIGRlcGVuZGVuY2llczpcbiAqL1xuXG4vKipcbiAqIC0gYENvbXBvbmVudFRyZWVgOiBbcmVxdWlyZWRdIE1vZHVsZSB0aGF0IGNhbiBjb252ZXJ0IGJldHdlZW4gUmVhY3QgaW5zdGFuY2VzXG4gKiAgIGFuZCBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLlxuICovXG52YXIgQ29tcG9uZW50VHJlZTtcbnZhciBUcmVlVHJhdmVyc2FsO1xudmFyIGluamVjdGlvbiA9IHtcbiAgaW5qZWN0Q29tcG9uZW50VHJlZTogZnVuY3Rpb24gKEluamVjdGVkKSB7XG4gICAgQ29tcG9uZW50VHJlZSA9IEluamVjdGVkO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhJbmplY3RlZCAmJiBJbmplY3RlZC5nZXROb2RlRnJvbUluc3RhbmNlICYmIEluamVjdGVkLmdldEluc3RhbmNlRnJvbU5vZGUsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RDb21wb25lbnRUcmVlKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZUZyb21JbnN0YW5jZSBvciBnZXRJbnN0YW5jZUZyb21Ob2RlLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfSxcbiAgaW5qZWN0VHJlZVRyYXZlcnNhbDogZnVuY3Rpb24gKEluamVjdGVkKSB7XG4gICAgVHJlZVRyYXZlcnNhbCA9IEluamVjdGVkO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhJbmplY3RlZCAmJiBJbmplY3RlZC5pc0FuY2VzdG9yICYmIEluamVjdGVkLmdldExvd2VzdENvbW1vbkFuY2VzdG9yLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0VHJlZVRyYXZlcnNhbCguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGlzQW5jZXN0b3Igb3IgZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IuJykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbmZ1bmN0aW9uIGlzRW5kaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXAgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoRW5kIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbDtcbn1cblxuZnVuY3Rpb24gaXNNb3ZlaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlTW92ZSB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hNb3ZlO1xufVxuZnVuY3Rpb24gaXNTdGFydGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd24gfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQ7XG59XG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBsaXN0ZW5lcnNMZW4gPSBsaXN0ZW5lcnNJc0FyciA/IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCA6IGRpc3BhdGNoTGlzdGVuZXJzID8gMSA6IDA7XG5cbiAgICB2YXIgaW5zdGFuY2VzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgICB2YXIgaW5zdGFuY2VzTGVuID0gaW5zdGFuY2VzSXNBcnIgPyBkaXNwYXRjaEluc3RhbmNlcy5sZW5ndGggOiBkaXNwYXRjaEluc3RhbmNlcyA/IDEgOiAwO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW5zdGFuY2VzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIGluc3RhbmNlc0xlbiA9PT0gbGlzdGVuZXJzTGVuLCAnRXZlbnRQbHVnaW5VdGlsczogSW52YWxpZCBgZXZlbnRgLicpIDogdm9pZCAwO1xuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gaW5zdCBJbnRlcm5hbCBjb21wb25lbnQgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGxpc3RlbmVyLCBpbnN0KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBFdmVudFBsdWdpblV0aWxzLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gIGlmIChzaW11bGF0ZWQpIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoKHR5cGUsIGxpc3RlbmVyLCBldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayh0eXBlLCBsaXN0ZW5lciwgZXZlbnQpO1xuICB9XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVyc1tpXSwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVycywgZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICB9XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMsIGJ1dCBzdG9wc1xuICogYXQgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiByZXR1cm5pbmcgdHJ1ZSwgYW5kIHJldHVybnMgdGhhdCBpZC5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBpZCBvZiB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHdobydzIGxpc3RlbmVyIHJldHVybnNcbiAqIHRydWUsIG9yIG51bGwgaWYgbm8gbGlzdGVuZXIgcmV0dXJuZWQgdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnNbaV0oZXZlbnQsIGRpc3BhdGNoSW5zdGFuY2VzW2ldKSkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hJbnN0YW5jZXNbaV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKGV2ZW50LCBkaXNwYXRjaEluc3RhbmNlcykpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaEluc3RhbmNlcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQHNlZSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbFxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlKGV2ZW50KSB7XG4gIHZhciByZXQgPSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCk7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogRXhlY3V0aW9uIG9mIGEgXCJkaXJlY3RcIiBkaXNwYXRjaCAtIHRoZXJlIG11c3QgYmUgYXQgbW9zdCBvbmUgZGlzcGF0Y2hcbiAqIGFjY3VtdWxhdGVkIG9uIHRoZSBldmVudCBvciBpdCBpcyBjb25zaWRlcmVkIGFuIGVycm9yLiBJdCBkb2Vzbid0IHJlYWxseSBtYWtlXG4gKiBzZW5zZSBmb3IgYW4gZXZlbnQgd2l0aCBtdWx0aXBsZSBkaXNwYXRjaGVzIChidWJibGVkKSB0byBrZWVwIHRyYWNrIG9mIHRoZVxuICogcmV0dXJuIHZhbHVlcyBhdCBlYWNoIGRpc3BhdGNoIGV4ZWN1dGlvbiwgYnV0IGl0IGRvZXMgdGVuZCB0byBtYWtlIHNlbnNlIHdoZW5cbiAqIGRlYWxpbmcgd2l0aCBcImRpcmVjdFwiIGRpc3BhdGNoZXMuXG4gKlxuICogQHJldHVybiB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiBleGVjdXRpbmcgdGhlIHNpbmdsZSBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpcmVjdERpc3BhdGNoKGV2ZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIHZhciBkaXNwYXRjaExpc3RlbmVyID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZSA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAgISFBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2V4ZWN1dGVEaXJlY3REaXNwYXRjaCguLi4pOiBJbnZhbGlkIGBldmVudGAuJykgOiBfcHJvZEludmFyaWFudCgnMTAzJykgOiB2b2lkIDA7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBkaXNwYXRjaExpc3RlbmVyID8gRXZlbnRQbHVnaW5VdGlscy5nZXROb2RlRnJvbUluc3RhbmNlKGRpc3BhdGNoSW5zdGFuY2UpIDogbnVsbDtcbiAgdmFyIHJlcyA9IGRpc3BhdGNoTGlzdGVuZXIgPyBkaXNwYXRjaExpc3RlbmVyKGV2ZW50KSA6IG51bGw7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuZnVuY3Rpb24gaGFzRGlzcGF0Y2hlcyhldmVudCkge1xuICByZXR1cm4gISFldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG59XG5cbi8qKlxuICogR2VuZXJhbCB1dGlsaXRpZXMgdGhhdCBhcmUgdXNlZnVsIGluIGNyZWF0aW5nIGN1c3RvbSBFdmVudCBQbHVnaW5zLlxuICovXG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHtcbiAgaXNFbmRpc2g6IGlzRW5kaXNoLFxuICBpc01vdmVpc2g6IGlzTW92ZWlzaCxcbiAgaXNTdGFydGlzaDogaXNTdGFydGlzaCxcblxuICBleGVjdXRlRGlyZWN0RGlzcGF0Y2g6IGV4ZWN1dGVEaXJlY3REaXNwYXRjaCxcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIsXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWU6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUsXG4gIGhhc0Rpc3BhdGNoZXM6IGhhc0Rpc3BhdGNoZXMsXG5cbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpO1xuICB9LFxuICBnZXROb2RlRnJvbUluc3RhbmNlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBDb21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2Uobm9kZSk7XG4gIH0sXG4gIGlzQW5jZXN0b3I6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuaXNBbmNlc3RvcihhLCBiKTtcbiAgfSxcbiAgZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3I6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoYSwgYik7XG4gIH0sXG4gIGdldFBhcmVudEluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLmdldFBhcmVudEluc3RhbmNlKGluc3QpO1xuICB9LFxuICB0cmF2ZXJzZVR3b1BoYXNlOiBmdW5jdGlvbiAodGFyZ2V0LCBmbiwgYXJnKSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwudHJhdmVyc2VUd29QaGFzZSh0YXJnZXQsIGZuLCBhcmcpO1xuICB9LFxuICB0cmF2ZXJzZUVudGVyTGVhdmU6IGZ1bmN0aW9uIChmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwudHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pO1xuICB9LFxuXG4gIGluamVjdGlvbjogaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luVXRpbHM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpblV0aWxzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXJyb3JVdGlsc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhdWdodEVycm9yID0gbnVsbDtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqXG4gKiBAcGFyYW0gez9TdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBhIEZpcnN0IGFyZ3VtZW50XG4gKiBAcGFyYW0geyp9IGIgU2Vjb25kIGFyZ3VtZW50XG4gKi9cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBmdW5jLCBhLCBiKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZ1bmMoYSwgYik7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICBpZiAoY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgIGNhdWdodEVycm9yID0geDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcblxuICAvKipcbiAgICogSW52b2tlZCBieSBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZSBzbyB0aGF0IGFueSBlcnJvcnMgdGhyb3duIGJ5IHRoZSBldmVudFxuICAgKiBoYW5kbGVyIGFyZSBzdXJlIHRvIGJlIHJldGhyb3duIGJ5IHJldGhyb3dDYXVnaHRFcnJvci5cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaDogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAgICogd2Ugd2lsbCByZXRocm93IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHRvcCBsZXZlbCBlcnJvciBoYW5kbGVyLlxuICAgKi9cbiAgcmV0aHJvd0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhdWdodEVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSBjYXVnaHRFcnJvcjtcbiAgICAgIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLyoqXG4gICAqIFRvIGhlbHAgZGV2ZWxvcG1lbnQgd2UgY2FuIGdldCBiZXR0ZXIgZGV2dG9vbHMgaW50ZWdyYXRpb24gYnkgc2ltdWxhdGluZyBhXG4gICAqIHJlYWwgYnJvd3NlciBldmVudC5cbiAgICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgYSwgYikge1xuICAgICAgdmFyIGJvdW5kRnVuYyA9IGZ1bmMuYmluZChudWxsLCBhLCBiKTtcbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyBuYW1lO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXJyb3JVdGlscztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RXJyb3JVdGlscy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhY2N1bXVsYXRlSW50b1xuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXG4gKiBBUEkgY2xlYW5uZXNzLiBTaW5jZSBgY3VycmVudGAgY2FuIGJlIG51bGwgYmVmb3JlIGJlaW5nIHBhc3NlZCBpbiBhbmQgbm90XG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XG4gKlxuICogYGEgPSBhY2N1bXVsYXRlSW50byhhLCBiKTtgXG4gKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xuICAhKG5leHQgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiBfcHJvZEludmFyaWFudCgnMzAnKSA6IHZvaWQgMDtcblxuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAvLyBjZXJ0YWluIHRoYXQgeCBpcyBhbiBBcnJheSAoeCBjb3VsZCBiZSBhIHN0cmluZyB3aXRoIGNvbmNhdCBtZXRob2QpLlxuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgbmV4dCk7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAvLyBBIGJpdCB0b28gZGFuZ2Vyb3VzIHRvIG11dGF0ZSBgbmV4dGAuXG4gICAgcmV0dXJuIFtjdXJyZW50XS5jb25jYXQobmV4dCk7XG4gIH1cblxuICByZXR1cm4gW2N1cnJlbnQsIG5leHRdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFjY3VtdWxhdGVJbnRvO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvYWNjdW11bGF0ZUludG8uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZm9yRWFjaEFjY3VtdWxhdGVkXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYXJyIGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKi9cblxuZnVuY3Rpb24gZm9yRWFjaEFjY3VtdWxhdGVkKGFyciwgY2IsIHNjb3BlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIuZm9yRWFjaChjYiwgc2NvcGUpO1xuICB9IGVsc2UgaWYgKGFycikge1xuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoQWNjdW11bGF0ZWQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczogY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGNsYXNzIHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHJvb3RcbiAqL1xuZnVuY3Rpb24gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKHJvb3QpIHtcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gIHRoaXMuX3N0YXJ0VGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICB0aGlzLl9mYWxsYmFja1RleHQgPSBudWxsO1xufVxuXG5fYXNzaWduKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0VGV4dCA9IG51bGw7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGV4dCBvZiBpbnB1dC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGlmICgndmFsdWUnIGluIHRoaXMuX3Jvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGRpZmZlcmluZyBzdWJzdHJpbmcgYmV0d2VlbiB0aGUgaW5pdGlhbGx5IHN0b3JlZFxuICAgKiB0ZXh0IGNvbnRlbnQgYW5kIHRoZSBjdXJyZW50IGNvbnRlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmFsbGJhY2tUZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICAgIH1cblxuICAgIHZhciBzdGFydDtcbiAgICB2YXIgc3RhcnRWYWx1ZSA9IHRoaXMuX3N0YXJ0VGV4dDtcbiAgICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgICB2YXIgZW5kO1xuICAgIHZhciBlbmRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gICAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldFRleHRDb250ZW50QWNjZXNzb3JcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRleHRDb250ZW50QWNjZXNzb3I7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRUZXh0Q29udGVudEFjY2Vzc29yLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0V2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSBmYWxzZTtcbnZhciBpc1Byb3h5U3VwcG9ydGVkID0gdHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nO1xuXG52YXIgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMgPSBbJ2Rpc3BhdGNoQ29uZmlnJywgJ190YXJnZXRJbnN0JywgJ25hdGl2ZUV2ZW50JywgJ2lzRGVmYXVsdFByZXZlbnRlZCcsICdpc1Byb3BhZ2F0aW9uU3RvcHBlZCcsICdfZGlzcGF0Y2hMaXN0ZW5lcnMnLCAnX2Rpc3BhdGNoSW5zdGFuY2VzJ107XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgdHlwZTogbnVsbCxcbiAgdGFyZ2V0OiBudWxsLFxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXG4gIGN1cnJlbnRUYXJnZXQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLFxuICBldmVudFBoYXNlOiBudWxsLFxuICBidWJibGVzOiBudWxsLFxuICBjYW5jZWxhYmxlOiBudWxsLFxuICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgZGVmYXVsdFByZXZlbnRlZDogbnVsbCxcbiAgaXNUcnVzdGVkOiBudWxsXG59O1xuXG4vKipcbiAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gKlxuICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAqXG4gKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0SW5zdCBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IG5hdGl2ZUV2ZW50VGFyZ2V0IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW3Byb3BOYW1lXTsgLy8gdGhpcyBoYXMgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIHJldHVybiB0aGlzO1xufVxuXG5fYXNzaWduKFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZSwge1xuXG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICE9PSAndW5rbm93bicpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgdmFsaWQtdHlwZW9mXG4gICAgICAvLyBUaGUgQ2hhbmdlRXZlbnRQbHVnaW4gcmVnaXN0ZXJzIGEgXCJwcm9wZXJ0eWNoYW5nZVwiIGV2ZW50IGZvclxuICAgICAgLy8gSUUuIFRoaXMgZXZlbnQgZG9lcyBub3Qgc3VwcG9ydCBidWJibGluZyBvciBjYW5jZWxsaW5nLCBhbmRcbiAgICAgIC8vIGFueSByZWZlcmVuY2VzIHRvIGNhbmNlbEJ1YmJsZSB0aHJvdyBcIk1lbWJlciBub3QgZm91bmRcIi4gIEFcbiAgICAgIC8vIHR5cGVvZiBjaGVjayBvZiBcInVua25vd25cIiBjaXJjdW12ZW50cyB0aGlzIGlzc3VlIChhbmQgaXMgYWxzb1xuICAgICAgLy8gSUUgc3BlY2lmaWMpLlxuICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICovXG4gIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzUGVyc2lzdGVudCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNQZXJzaXN0ZW50OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UsXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIGBkZXN0cnVjdG9yYCBvbiBlYWNoIGluc3RhbmNlIGl0IHJlbGVhc2VzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW3Nob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzW2ldXSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hdGl2ZUV2ZW50JywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignbmF0aXZlRXZlbnQnLCBudWxsKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3ByZXZlbnREZWZhdWx0JywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbigncHJldmVudERlZmF1bHQnLCBlbXB0eUZ1bmN0aW9uKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0b3BQcm9wYWdhdGlvbicsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3N0b3BQcm9wYWdhdGlvbicsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICB9XG4gIH1cblxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBpZiAoaXNQcm94eVN1cHBvcnRlZCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgICBTeW50aGV0aWNFdmVudCA9IG5ldyBQcm94eShTeW50aGV0aWNFdmVudCwge1xuICAgICAgY29uc3RydWN0OiBmdW5jdGlvbiAodGFyZ2V0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5KHRhcmdldCwgT2JqZWN0LmNyZWF0ZSh0YXJnZXQucHJvdG90eXBlKSwgYXJncyk7XG4gICAgICB9LFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uIChjb25zdHJ1Y3RvciwgdGhhdCwgYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KGNvbnN0cnVjdG9yLmFwcGx5KHRoYXQsIGFyZ3MpLCB7XG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3AgIT09ICdpc1BlcnNpc3RlbnQnICYmICF0YXJnZXQuY29uc3RydWN0b3IuSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3ApICYmIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5IHx8IHRhcmdldC5pc1BlcnNpc3RlbnQoKSwgJ1RoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91XFwncmUgJyArICdzZWVpbmcgdGhpcywgeW91XFwncmUgYWRkaW5nIGEgbmV3IHByb3BlcnR5IGluIHRoZSBzeW50aGV0aWMgZXZlbnQgb2JqZWN0LiAnICsgJ1RoZSBwcm9wZXJ0eSBpcyBuZXZlciByZWxlYXNlZC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyplc2xpbnQtZW5hYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gIH1cbn1cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uIChDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIEUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRS5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XG4gIHZhciBwcm90b3R5cGUgPSBuZXcgRSgpO1xuXG4gIF9hc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IF9hc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuYXVnbWVudENsYXNzID0gU3VwZXIuYXVnbWVudENsYXNzO1xuXG4gIFBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDbGFzcywgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcbn07XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCwgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNFdmVudDtcblxuLyoqXG4gICogSGVscGVyIHRvIG51bGxpZnkgc3ludGhldGljRXZlbnQgaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGRlc3RydWN0aW5nXG4gICpcbiAgKiBAcGFyYW0ge29iamVjdH0gU3ludGhldGljRXZlbnRcbiAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAgKiBAcmV0dXJuIHtvYmplY3R9IGRlZmluZVByb3BlcnR5IG9iamVjdFxuICAqL1xuZnVuY3Rpb24gZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgZ2V0VmFsKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIGdldFZhbCA9PT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBzZXQsXG4gICAgZ2V0OiBnZXRcbiAgfTtcblxuICBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnc2V0dGluZyB0aGUgbWV0aG9kJyA6ICdzZXR0aW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgd2FybihhY3Rpb24sICdUaGlzIGlzIGVmZmVjdGl2ZWx5IGEgbm8tb3AnKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ2FjY2Vzc2luZyB0aGUgbWV0aG9kJyA6ICdhY2Nlc3NpbmcgdGhlIHByb3BlcnR5JztcbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbiA/ICdUaGlzIGlzIGEgbm8tb3AgZnVuY3Rpb24nIDogJ1RoaXMgaXMgc2V0IHRvIG51bGwnO1xuICAgIHdhcm4oYWN0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiBnZXRWYWw7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKGFjdGlvbiwgcmVzdWx0KSB7XG4gICAgdmFyIHdhcm5pbmdDb25kaXRpb24gPSBmYWxzZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh3YXJuaW5nQ29uZGl0aW9uLCAnVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcXCdyZSBzZWVpbmcgdGhpcywgJyArICd5b3VcXCdyZSAlcyBgJXNgIG9uIGEgcmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gJXMuICcgKyAnSWYgeW91IG11c3Qga2VlcCB0aGUgb3JpZ2luYWwgc3ludGhldGljIGV2ZW50IGFyb3VuZCwgdXNlIGV2ZW50LnBlcnNpc3QoKS4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGFjdGlvbiwgcHJvcE5hbWUsIHJlc3VsdCkgOiB2b2lkIDA7XG4gIH1cbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0V2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0lucHV0RXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi9cbnZhciBJbnB1dEV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0lucHV0RXZlbnQsIElucHV0RXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0lucHV0RXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENoYW5nZUV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2hhbmdlOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DaGFuZ2VDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ2hhbmdlLCB0b3BMZXZlbFR5cGVzLnRvcENsaWNrLCB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCB0b3BMZXZlbFR5cGVzLnRvcElucHV0LCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAnZmlsZSc7XG59XG5cbnZhciBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gU2VlIGBoYW5kbGVDaGFuZ2VgIGNvbW1lbnQgYmVsb3dcbiAgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gaXNFdmVudFN1cHBvcnRlZCgnY2hhbmdlJykgJiYgKCEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDgpO1xufVxuXG5mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmNoYW5nZSwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChldmVudCkge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50KTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbn1cblxuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2hhbmdlKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4KHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMpIHtcbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRhcmdldCwgdGFyZ2V0SW5zdCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHMuXG4gIC8vIElFMTArIGZpcmUgaW5wdXQgZXZlbnRzIHRvIG9mdGVuLCBzdWNoIHdoZW4gYSBwbGFjZWhvbGRlclxuICAvLyBjaGFuZ2VzIG9yIHdoZW4gYW4gaW5wdXQgd2l0aCBhIHBsYWNlaG9sZGVyIGlzIGZvY3VzZWQuXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKCEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDExKTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9MTEpIFJlcGxhY2VtZW50IGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgdmFsdWVgIHByb3BlcnR5IHRoYXQgZ2V0c1xuICogc2V0IG9uIHRoZSBhY3RpdmUgZWxlbWVudC5cbiAqL1xudmFyIG5ld1ZhbHVlUHJvcCA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AuZ2V0LmNhbGwodGhpcyk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgIC8vIENhc3QgdG8gYSBzdHJpbmcgc28gd2UgY2FuIGRvIGVxdWFsaXR5IGNoZWNrcy5cbiAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSAnJyArIHZhbDtcbiAgICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLnNldC5jYWxsKHRoaXMsIHZhbCk7XG4gIH1cbn07XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuY29uc3RydWN0b3IucHJvdG90eXBlLCAndmFsdWUnKTtcblxuICAvLyBOb3QgZ3VhcmRlZCBpbiBhIGNhbkRlZmluZVByb3BlcnR5IGNoZWNrOiBJRTggc3VwcG9ydHMgZGVmaW5lUHJvcGVydHkgb25seVxuICAvLyBvbiBET00gZWxlbWVudHNcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5ld1ZhbHVlUHJvcCk7XG4gIGlmIChhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UsIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZGVsZXRlIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gIGRlbGV0ZSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuXG4gIGlmIChhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UsIGZhbHNlKTtcbiAgfVxuXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUgIT09ICd2YWx1ZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHZhbHVlID0gbmF0aXZlRXZlbnQuc3JjRWxlbWVudC52YWx1ZTtcbiAgaWYgKHZhbHVlID09PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdmFsdWU7XG5cbiAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG59XG5cbi8qKlxuICogSWYgYSBgY2hhbmdlYCBldmVudCBzaG91bGQgYmUgZmlyZWQsIHJldHVybnMgdGhlIHRhcmdldCdzIElELlxuICovXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BJbnB1dCkge1xuICAgIC8vIEluIG1vZGVybiBicm93c2VycyAoaS5lLiwgbm90IElFOCBvciBJRTkpLCB0aGUgaW5wdXQgZXZlbnQgaXMgZXhhY3RseVxuICAgIC8vIHdoYXQgd2Ugd2FudCBzbyBmYWxsIHRocm91Z2ggaGVyZSBhbmQgdHJpZ2dlciBhbiBhYnN0cmFjdCBldmVudFxuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzKSB7XG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXG4gICAgLy8gZXF1YWwgdG8gJ3ZhbHVlJ1xuICAgIC8vIEluIElFOS0xMSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2UgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duKSB7XG4gICAgLy8gT24gdGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCwgdGhlIHRhcmdldCBpcyBqdXN0IGRvY3VtZW50IHdoaWNoIGlzbid0XG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyA5OSUgb2YgdGhlIHRpbWUsIGtleWRvd24gYW5kIGtleXVwIGFyZW4ndCBuZWNlc3NhcnkuIElFOCBmYWlscyB0byBmaXJlXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4gICAgLy8gZ2V0cyBpdCBhbmQgY2F0Y2hpbmcga2V5ZG93biBsZXRzIHVzIGZpcmUgYW4gZXZlbnQgZm9yIHRoZSBmaXJzdFxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4gICAgLy8gZmlyZSBzZWxlY3Rpb25jaGFuZ2Ugbm9ybWFsbHkuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC52YWx1ZSAhPT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRJbnN0O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2xpY2spIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50SUU7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGV2ZW50LnR5cGUgPSAnY2hhbmdlJztcbiAgICAgICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZUV2ZW50UGx1Z2luO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvQ2hhbmdlRXZlbnRQbHVnaW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RVcGRhdGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RGZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgZGlydHlDb21wb25lbnRzID0gW107XG52YXIgdXBkYXRlQmF0Y2hOdW1iZXIgPSAwO1xudmFyIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbnZhciBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcblxudmFyIGJhdGNoaW5nU3RyYXRlZ3kgPSBudWxsO1xuXG5mdW5jdGlvbiBlbnN1cmVJbmplY3RlZCgpIHtcbiAgIShSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiAmJiBiYXRjaGluZ1N0cmF0ZWd5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgaW5qZWN0IGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzIGFuZCBiYXRjaGluZyBzdHJhdGVneScpIDogX3Byb2RJbnZhcmlhbnQoJzEyMycpIDogdm9pZCAwO1xufVxuXG52YXIgTkVTVEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IGRpcnR5Q29tcG9uZW50cy5sZW5ndGg7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoICE9PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBBZGRpdGlvbmFsIHVwZGF0ZXMgd2VyZSBlbnF1ZXVlZCBieSBjb21wb25lbnREaWRVcGRhdGUgaGFuZGxlcnMgb3JcbiAgICAgIC8vIHNpbWlsYXI7IGJlZm9yZSBvdXIgb3duIFVQREFURV9RVUVVRUlORyB3cmFwcGVyIGNsb3Nlcywgd2Ugd2FudCB0byBydW5cbiAgICAgIC8vIHRoZXNlIG5ldyB1cGRhdGVzIHNvIHRoYXQgaWYgQSdzIGNvbXBvbmVudERpZFVwZGF0ZSBjYWxscyBzZXRTdGF0ZSBvblxuICAgICAgLy8gQiwgQiB3aWxsIHVwZGF0ZSBiZWZvcmUgdGhlIGNhbGxiYWNrIEEncyB1cGRhdGVyIHByb3ZpZGVkIHdoZW4gY2FsbGluZ1xuICAgICAgLy8gc2V0U3RhdGUuXG4gICAgICBkaXJ0eUNvbXBvbmVudHMuc3BsaWNlKDAsIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoKTtcbiAgICAgIGZsdXNoQmF0Y2hlZFVwZGF0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG59O1xuXG52YXIgVVBEQVRFX1FVRVVFSU5HID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLnJlc2V0KCk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbTkVTVEVEX1VQREFURVMsIFVQREFURV9RVUVVRUlOR107XG5cbmZ1bmN0aW9uIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKFxuICAvKiB1c2VDcmVhdGVFbGVtZW50ICovdHJ1ZSk7XG59XG5cbl9hc3NpZ24oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gbnVsbDtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5jYWxsYmFja1F1ZXVlKTtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUgPSBudWxsO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gICAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiA9IG51bGw7XG4gIH0sXG5cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEpIHtcbiAgICAvLyBFc3NlbnRpYWxseSBjYWxscyBgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtKG1ldGhvZCwgc2NvcGUsIGEpYFxuICAgIC8vIHdpdGggdGhpcyB0cmFuc2FjdGlvbidzIHdyYXBwZXJzIGFyb3VuZCBpdC5cbiAgICByZXR1cm4gVHJhbnNhY3Rpb24uTWl4aW4ucGVyZm9ybS5jYWxsKHRoaXMsIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybSwgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiwgbWV0aG9kLCBzY29wZSwgYSk7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbik7XG5cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XG4gIGVuc3VyZUluamVjdGVkKCk7XG4gIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpO1xufVxuXG4vKipcbiAqIEFycmF5IGNvbXBhcmF0b3IgZm9yIFJlYWN0Q29tcG9uZW50cyBieSBtb3VudCBvcmRlcmluZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMSBmaXJzdCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzIgc2Vjb25kIGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybiB2YWx1ZSB1c2FibGUgYnkgQXJyYXkucHJvdG90eXBlLnNvcnQoKS5cbiAqL1xuZnVuY3Rpb24gbW91bnRPcmRlckNvbXBhcmF0b3IoYzEsIGMyKSB7XG4gIHJldHVybiBjMS5fbW91bnRPcmRlciAtIGMyLl9tb3VudE9yZGVyO1xufVxuXG5mdW5jdGlvbiBydW5CYXRjaGVkVXBkYXRlcyh0cmFuc2FjdGlvbikge1xuICB2YXIgbGVuID0gdHJhbnNhY3Rpb24uZGlydHlDb21wb25lbnRzTGVuZ3RoO1xuICAhKGxlbiA9PT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgZmx1c2ggdHJhbnNhY3Rpb25cXCdzIHN0b3JlZCBkaXJ0eS1jb21wb25lbnRzIGxlbmd0aCAoJXMpIHRvIG1hdGNoIGRpcnR5LWNvbXBvbmVudHMgYXJyYXkgbGVuZ3RoICglcykuJywgbGVuLCBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA6IF9wcm9kSW52YXJpYW50KCcxMjQnLCBsZW4sIGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIDogdm9pZCAwO1xuXG4gIC8vIFNpbmNlIHJlY29uY2lsaW5nIGEgY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgb3duZXIgaGllcmFyY2h5IHVzdWFsbHkgKG5vdFxuICAvLyBhbHdheXMgLS0gc2VlIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpKSB3aWxsIHJlY29uY2lsZSBjaGlsZHJlbiwgcmVjb25jaWxlXG4gIC8vIHRoZW0gYmVmb3JlIHRoZWlyIGNoaWxkcmVuIGJ5IHNvcnRpbmcgdGhlIGFycmF5LlxuICBkaXJ0eUNvbXBvbmVudHMuc29ydChtb3VudE9yZGVyQ29tcGFyYXRvcik7XG5cbiAgLy8gQW55IHVwZGF0ZXMgZW5xdWV1ZWQgd2hpbGUgcmVjb25jaWxpbmcgbXVzdCBiZSBwZXJmb3JtZWQgYWZ0ZXIgdGhpcyBlbnRpcmVcbiAgLy8gYmF0Y2guIE90aGVyd2lzZSwgaWYgZGlydHlDb21wb25lbnRzIGlzIFtBLCBCXSB3aGVyZSBBIGhhcyBjaGlsZHJlbiBCIGFuZFxuICAvLyBDLCBCIGNvdWxkIHVwZGF0ZSB0d2ljZSBpbiBhIHNpbmdsZSBiYXRjaCBpZiBDJ3MgcmVuZGVyIGVucXVldWVzIGFuIHVwZGF0ZVxuICAvLyB0byBCIChzaW5jZSBCIHdvdWxkIGhhdmUgYWxyZWFkeSB1cGRhdGVkLCB3ZSBzaG91bGQgc2tpcCBpdCwgYW5kIHRoZSBvbmx5XG4gIC8vIHdheSB3ZSBjYW4ga25vdyB0byBkbyBzbyBpcyBieSBjaGVja2luZyB0aGUgYmF0Y2ggY291bnRlcikuXG4gIHVwZGF0ZUJhdGNoTnVtYmVyKys7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vIElmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgcGVuZGluZyBjaGFuZ2VzIGFwcGx5LCBpdCB3aWxsIHN0aWxsXG4gICAgLy8gYmUgaGVyZSwgYnV0IHdlIGFzc3VtZSB0aGF0IGl0IGhhcyBjbGVhcmVkIGl0cyBfcGVuZGluZ0NhbGxiYWNrcyBhbmRcbiAgICAvLyB0aGF0IHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBpcyBhIG5vb3AuXG4gICAgdmFyIGNvbXBvbmVudCA9IGRpcnR5Q29tcG9uZW50c1tpXTtcblxuICAgIC8vIElmIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBoYXBwZW5zIHRvIGVucXVldWUgYW55IG5ldyB1cGRhdGVzLCB3ZVxuICAgIC8vIHNob3VsZG4ndCBleGVjdXRlIHRoZSBjYWxsYmFja3MgdW50aWwgdGhlIG5leHQgcmVuZGVyIGhhcHBlbnMsIHNvXG4gICAgLy8gc3Rhc2ggdGhlIGNhbGxiYWNrcyBmaXJzdFxuICAgIHZhciBjYWxsYmFja3MgPSBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3M7XG4gICAgY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgIHZhciBtYXJrZXJOYW1lO1xuICAgIGlmIChSZWFjdEZlYXR1cmVGbGFncy5sb2dUb3BMZXZlbFJlbmRlcnMpIHtcbiAgICAgIHZhciBuYW1lZENvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgIC8vIER1Y2sgdHlwZSBUb3BMZXZlbFdyYXBwZXIuIFRoaXMgaXMgcHJvYmFibHkgYWx3YXlzIHRydWUuXG4gICAgICBpZiAoY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5wcm9wcyA9PT0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudC5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgbmFtZWRDb21wb25lbnQgPSBjb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgICAgfVxuICAgICAgbWFya2VyTmFtZSA9ICdSZWFjdCB1cGRhdGU6ICcgKyBuYW1lZENvbXBvbmVudC5nZXROYW1lKCk7XG4gICAgICBjb25zb2xlLnRpbWUobWFya2VyTmFtZSk7XG4gICAgfVxuXG4gICAgUmVhY3RSZWNvbmNpbGVyLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeShjb21wb25lbnQsIHRyYW5zYWN0aW9uLnJlY29uY2lsZVRyYW5zYWN0aW9uLCB1cGRhdGVCYXRjaE51bWJlcik7XG5cbiAgICBpZiAobWFya2VyTmFtZSkge1xuICAgICAgY29uc29sZS50aW1lRW5kKG1hcmtlck5hbWUpO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmNhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFja3Nbal0sIGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZsdXNoQmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ncyB3cmFwcGVycyB3aWxsIGNsZWFyIHRoZSBkaXJ0eUNvbXBvbmVudHNcbiAgLy8gYXJyYXkgYW5kIHBlcmZvcm0gYW55IHVwZGF0ZXMgZW5xdWV1ZWQgYnkgbW91bnQtcmVhZHkgaGFuZGxlcnMgKGkuZS4sXG4gIC8vIGNvbXBvbmVudERpZFVwZGF0ZSkgYnV0IHdlIG5lZWQgdG8gY2hlY2sgaGVyZSB0b28gaW4gb3JkZXIgdG8gY2F0Y2hcbiAgLy8gdXBkYXRlcyBlbnF1ZXVlZCBieSBzZXRTdGF0ZSBjYWxsYmFja3MgYW5kIGFzYXAgY2FsbHMuXG4gIHdoaWxlIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoIHx8IGFzYXBFbnF1ZXVlZCkge1xuICAgIGlmIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLmdldFBvb2xlZCgpO1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShydW5CYXRjaGVkVXBkYXRlcywgbnVsbCwgdHJhbnNhY3Rpb24pO1xuICAgICAgUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYXNhcEVucXVldWVkKSB7XG4gICAgICBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBxdWV1ZSA9IGFzYXBDYWxsYmFja1F1ZXVlO1xuICAgICAgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICAgICAgcXVldWUubm90aWZ5QWxsKCk7XG4gICAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UocXVldWUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNYXJrIGEgY29tcG9uZW50IGFzIG5lZWRpbmcgYSByZXJlbmRlciwgYWRkaW5nIGFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIGFcbiAqIGxpc3Qgb2YgZnVuY3Rpb25zIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgb25jZSB0aGUgcmVyZW5kZXIgb2NjdXJzLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGNvbXBvbmVudCkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuXG4gIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoVGhpcyBpcyBjYWxsZWQgYnkgZWFjaCB0b3AtbGV2ZWwgdXBkYXRlXG4gIC8vIGZ1bmN0aW9uLCBsaWtlIHNldFN0YXRlLCBmb3JjZVVwZGF0ZSwgZXRjLjsgY3JlYXRpb24gYW5kXG4gIC8vIGRlc3RydWN0aW9uIG9mIHRvcC1sZXZlbCBjb21wb25lbnRzIGlzIGd1YXJkZWQgaW4gUmVhY3RNb3VudC4pXG5cbiAgaWYgKCFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhlbnF1ZXVlVXBkYXRlLCBjb21wb25lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRpcnR5Q29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gIGlmIChjb21wb25lbnQuX3VwZGF0ZUJhdGNoTnVtYmVyID09IG51bGwpIHtcbiAgICBjb21wb25lbnQuX3VwZGF0ZUJhdGNoTnVtYmVyID0gdXBkYXRlQmF0Y2hOdW1iZXIgKyAxO1xuICB9XG59XG5cbi8qKlxuICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRvIGJlIHJ1biBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJhdGNoaW5nIGN5Y2xlLiBUaHJvd3NcbiAqIGlmIG5vIHVwZGF0ZXMgYXJlIGN1cnJlbnRseSBiZWluZyBwZXJmb3JtZWQuXG4gKi9cbmZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzLmFzYXA6IENhblxcJ3QgZW5xdWV1ZSBhbiBhc2FwIGNhbGxiYWNrIGluIGEgY29udGV4dCB3aGVyZXVwZGF0ZXMgYXJlIG5vdCBiZWluZyBiYXRjaGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzEyNScpIDogdm9pZCAwO1xuICBhc2FwQ2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgYXNhcEVucXVldWVkID0gdHJ1ZTtcbn1cblxudmFyIFJlYWN0VXBkYXRlc0luamVjdGlvbiA9IHtcbiAgaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IGZ1bmN0aW9uIChSZWNvbmNpbGVUcmFuc2FjdGlvbikge1xuICAgICFSZWNvbmNpbGVUcmFuc2FjdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIHJlY29uY2lsZSB0cmFuc2FjdGlvbiBjbGFzcycpIDogX3Byb2RJbnZhcmlhbnQoJzEyNicpIDogdm9pZCAwO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVjb25jaWxlVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgaW5qZWN0QmF0Y2hpbmdTdHJhdGVneTogZnVuY3Rpb24gKF9iYXRjaGluZ1N0cmF0ZWd5KSB7XG4gICAgIV9iYXRjaGluZ1N0cmF0ZWd5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hpbmcgc3RyYXRlZ3knKSA6IF9wcm9kSW52YXJpYW50KCcxMjcnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGVkVXBkYXRlcygpIGZ1bmN0aW9uJykgOiBfcHJvZEludmFyaWFudCgnMTI4JykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPT09ICdib29sZWFuJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYW4gaXNCYXRjaGluZ1VwZGF0ZXMgYm9vbGVhbiBhdHRyaWJ1dGUnKSA6IF9wcm9kSW52YXJpYW50KCcxMjknKSA6IHZvaWQgMDtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5ID0gX2JhdGNoaW5nU3RyYXRlZ3k7XG4gIH1cbn07XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSB7XG4gIC8qKlxuICAgKiBSZWFjdCByZWZlcmVuY2VzIGBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uYCB1c2luZyB0aGlzIHByb3BlcnR5IGluIG9yZGVyXG4gICAqIHRvIGFsbG93IGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IG51bGwsXG5cbiAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICBlbnF1ZXVlVXBkYXRlOiBlbnF1ZXVlVXBkYXRlLFxuICBmbHVzaEJhdGNoZWRVcGRhdGVzOiBmbHVzaEJhdGNoZWRVcGRhdGVzLFxuICBpbmplY3Rpb246IFJlYWN0VXBkYXRlc0luamVjdGlvbixcbiAgYXNhcDogYXNhcFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZXM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFVwZGF0ZXMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2FsbGJhY2tRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHBzZXVkby1ldmVudCBtb2R1bGUgdG8gaGVscCBrZWVwIHRyYWNrIG9mIGNvbXBvbmVudHMgd2FpdGluZyB0b1xuICogYmUgbm90aWZpZWQgd2hlbiB0aGVpciBET00gcmVwcmVzZW50YXRpb25zIGFyZSBhdmFpbGFibGUgZm9yIHVzZS5cbiAqXG4gKiBUaGlzIGltcGxlbWVudHMgYFBvb2xlZENsYXNzYCwgc28geW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBJbnN0ZWFkLCB1c2UgYENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKClgLlxuICpcbiAqIEBjbGFzcyBSZWFjdE1vdW50UmVhZHlcbiAqIEBpbXBsZW1lbnRzIFBvb2xlZENsYXNzXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gQ2FsbGJhY2tRdWV1ZSgpIHtcbiAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xufVxuXG5fYXNzaWduKENhbGxiYWNrUXVldWUucHJvdG90eXBlLCB7XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIEludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgQ29udGV4dCB0byBjYWxsIGBjYWxsYmFja2Agd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwgW107XG4gICAgdGhpcy5fY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cyB8fCBbXTtcbiAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgdGhpcy5fY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBhbGwgZW5xdWV1ZWQgY2FsbGJhY2tzIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGlzIGludm9rZWQgYWZ0ZXJcbiAgICogdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbXBvbmVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbm90aWZ5QWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgICB2YXIgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cztcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAhKGNhbGxiYWNrcy5sZW5ndGggPT09IGNvbnRleHRzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzbWF0Y2hlZCBsaXN0IG9mIGNvbnRleHRzIGluIGNhbGxiYWNrIHF1ZXVlJykgOiBfcHJvZEludmFyaWFudCgnMjQnKSA6IHZvaWQgMDtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0uY2FsbChjb250ZXh0c1tpXSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgIGNvbnRleHRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9LFxuXG4gIGNoZWNrcG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzID8gdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA6IDA7XG4gIH0sXG5cbiAgcm9sbGJhY2s6IGZ1bmN0aW9uIChsZW4pIHtcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3MubGVuZ3RoID0gbGVuO1xuICAgICAgdGhpcy5fY29udGV4dHMubGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENhbGxiYWNrUXVldWUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGxiYWNrUXVldWU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9DYWxsYmFja1F1ZXVlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RmVhdHVyZUZsYWdzXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHtcbiAgLy8gV2hlbiB0cnVlLCBjYWxsIGNvbnNvbGUudGltZSgpIGJlZm9yZSBhbmQgLnRpbWVFbmQoKSBhZnRlciBlYWNoIHRvcC1sZXZlbFxuICAvLyByZW5kZXIgKGJvdGggaW5pdGlhbCByZW5kZXJzIGFuZCB1cGRhdGVzKS4gVXNlZnVsIHdoZW4gbG9va2luZyBhdCBwcm9kLW1vZGVcbiAgLy8gdGltZWxpbmUgcHJvZmlsZXMgaW4gQ2hyb21lLCBmb3IgZXhhbXBsZS5cbiAgbG9nVG9wTGV2ZWxSZW5kZXJzOiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEZlYXR1cmVGbGFncztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RmVhdHVyZUZsYWdzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVjb25jaWxlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UmVmID0gcmVxdWlyZSgnLi9SZWFjdFJlZicpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gY2FsbCBSZWFjdFJlZi5hdHRhY2hSZWZzIHdpdGggdGhpcyBjb21wb3NpdGUgY29tcG9uZW50LCBzcGxpdCBvdXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpb25zIGluIHRoZSB0cmFuc2FjdGlvbiBtb3VudC1yZWFkeSBxdWV1ZS5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoUmVmcygpIHtcbiAgUmVhY3RSZWYuYXR0YWNoUmVmcyh0aGlzLCB0aGlzLl9jdXJyZW50RWxlbWVudCk7XG59XG5cbnZhciBSZWFjdFJlY29uY2lsZXIgPSB7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/b2JqZWN0fSB0aGUgY29udGFpbmluZyBob3N0IGNvbXBvbmVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IGluZm8gYWJvdXQgdGhlIGhvc3QgY29udGFpbmVyXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBwYXJlbnREZWJ1Z0lEIC8vIDAgaW4gcHJvZHVjdGlvbiBhbmQgZm9yIHJvb3RzXG4gICkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVNb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCwgcGFyZW50RGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBtYXJrdXAgPSBpbnRlcm5hbEluc3RhbmNlLm1vdW50Q29tcG9uZW50KHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgcGFyZW50RGVidWdJRCk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnJlZiAhPSBudWxsKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGF0dGFjaFJlZnMsIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2YWx1ZSB0aGF0IGNhbiBiZSBwYXNzZWQgdG9cbiAgICogUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXAuXG4gICAqL1xuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZS5nZXRIb3N0Tm9kZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgc2FmZWx5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVubW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICAgIFJlYWN0UmVmLmRldGFjaFJlZnMoaW50ZXJuYWxJbnN0YW5jZSwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQpO1xuICAgIGludGVybmFsSW5zdGFuY2UudW5tb3VudENvbXBvbmVudChzYWZlbHkpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Vbm1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGEgY29tcG9uZW50IHVzaW5nIGEgbmV3IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgbmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG5cbiAgICBpZiAobmV4dEVsZW1lbnQgPT09IHByZXZFbGVtZW50ICYmIGNvbnRleHQgPT09IGludGVybmFsSW5zdGFuY2UuX2NvbnRleHQpIHtcbiAgICAgIC8vIFNpbmNlIGVsZW1lbnRzIGFyZSBpbW11dGFibGUgYWZ0ZXIgdGhlIG93bmVyIGlzIHJlbmRlcmVkLFxuICAgICAgLy8gd2UgY2FuIGRvIGEgY2hlYXAgaWRlbnRpdHkgY29tcGFyZSBoZXJlIHRvIGRldGVybWluZSBpZiB0aGlzIGlzIGFcbiAgICAgIC8vIHN1cGVyZmx1b3VzIHJlY29uY2lsZS4gSXQncyBwb3NzaWJsZSBmb3Igc3RhdGUgdG8gYmUgbXV0YWJsZSBidXQgc3VjaFxuICAgICAgLy8gY2hhbmdlIHNob3VsZCB0cmlnZ2VyIGFuIHVwZGF0ZSBvZiB0aGUgb3duZXIgd2hpY2ggd291bGQgcmVjcmVhdGVcbiAgICAgIC8vIHRoZSBlbGVtZW50LiBXZSBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFuIG93bmVyIHNpbmNlXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciBhbiBlbGVtZW50IGNyZWF0ZWQgb3V0c2lkZSBhIGNvbXBvc2l0ZSB0byBiZVxuICAgICAgLy8gZGVlcGx5IG11dGF0ZWQgYW5kIHJldXNlZC5cblxuICAgICAgLy8gVE9ETzogQmFpbGluZyBvdXQgZWFybHkgaXMganVzdCBhIHBlcmYgb3B0aW1pemF0aW9uIHJpZ2h0P1xuICAgICAgLy8gVE9ETzogUmVtb3ZpbmcgdGhlIHJldHVybiBzdGF0ZW1lbnQgc2hvdWxkIGFmZmVjdCBjb3JyZWN0bmVzcz9cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsIG5leHRFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVmc0NoYW5nZWQgPSBSZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCk7XG5cbiAgICBpZiAocmVmc0NoYW5nZWQpIHtcbiAgICAgIFJlYWN0UmVmLmRldGFjaFJlZnMoaW50ZXJuYWxJbnN0YW5jZSwgcHJldkVsZW1lbnQpO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UucmVjZWl2ZUNvbXBvbmVudChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnJlZiAhPSBudWxsKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGF0dGFjaFJlZnMsIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25VcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBGbHVzaCBhbnkgZGlydHkgY2hhbmdlcyBpbiBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIHVwZGF0ZUJhdGNoTnVtYmVyKSB7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyICE9PSB1cGRhdGVCYXRjaE51bWJlcikge1xuICAgICAgLy8gVGhlIGNvbXBvbmVudCdzIGVucXVldWVkIGJhdGNoIG51bWJlciBzaG91bGQgYWx3YXlzIGJlIHRoZSBjdXJyZW50XG4gICAgICAvLyBiYXRjaCBvciB0aGUgZm9sbG93aW5nIG9uZS5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyID09IG51bGwgfHwgaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgPT09IHVwZGF0ZUJhdGNoTnVtYmVyICsgMSwgJ3BlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogVW5leHBlY3RlZCBiYXRjaCBudW1iZXIgKGN1cnJlbnQgJXMsICcgKyAncGVuZGluZyAlcyknLCB1cGRhdGVCYXRjaE51bWJlciwgaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkodHJhbnNhY3Rpb24pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25VcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVmXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RPd25lcicpO1xuXG52YXIgUmVhY3RSZWYgPSB7fTtcblxuZnVuY3Rpb24gYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIuYWRkQ29tcG9uZW50QXNSZWZUbyhjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYobnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIucmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuUmVhY3RSZWYuYXR0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChyZWYgIT0gbnVsbCkge1xuICAgIGF0dGFjaFJlZihyZWYsIGluc3RhbmNlLCBlbGVtZW50Ll9vd25lcik7XG4gIH1cbn07XG5cblJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMgPSBmdW5jdGlvbiAocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSB7XG4gIC8vIElmIGVpdGhlciB0aGUgb3duZXIgb3IgYSBgcmVmYCBoYXMgY2hhbmdlZCwgbWFrZSBzdXJlIHRoZSBuZXdlc3Qgb3duZXJcbiAgLy8gaGFzIHN0b3JlZCBhIHJlZmVyZW5jZSB0byBgdGhpc2AsIGFuZCB0aGUgcHJldmlvdXMgb3duZXIgKGlmIGRpZmZlcmVudClcbiAgLy8gaGFzIGZvcmdvdHRlbiB0aGUgcmVmZXJlbmNlIHRvIGB0aGlzYC4gV2UgdXNlIHRoZSBlbGVtZW50IGluc3RlYWRcbiAgLy8gb2YgdGhlIHB1YmxpYyB0aGlzLnByb3BzIGJlY2F1c2UgdGhlIHBvc3QgcHJvY2Vzc2luZyBjYW5ub3QgZGV0ZXJtaW5lXG4gIC8vIGEgcmVmLiBUaGUgcmVmIGNvbmNlcHR1YWxseSBsaXZlcyBvbiB0aGUgZWxlbWVudC5cblxuICAvLyBUT0RPOiBTaG91bGQgdGhpcyBldmVuIGJlIHBvc3NpYmxlPyBUaGUgb3duZXIgY2Fubm90IGNoYW5nZSBiZWNhdXNlXG4gIC8vIGl0J3MgZm9yYmlkZGVuIGJ5IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LiBUaGUgcmVmIGNhbiBjaGFuZ2VcbiAgLy8gaWYgeW91IHN3YXAgdGhlIGtleXMgb2YgYnV0IG5vdCB0aGUgcmVmcy4gUmVjb25zaWRlciB3aGVyZSB0aGlzIGNoZWNrXG4gIC8vIGlzIG1hZGUuIEl0IHByb2JhYmx5IGJlbG9uZ3Mgd2hlcmUgdGhlIGtleSBjaGVja2luZyBhbmRcbiAgLy8gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCBpcyBkb25lLlxuXG4gIHZhciBwcmV2RW1wdHkgPSBwcmV2RWxlbWVudCA9PT0gbnVsbCB8fCBwcmV2RWxlbWVudCA9PT0gZmFsc2U7XG4gIHZhciBuZXh0RW1wdHkgPSBuZXh0RWxlbWVudCA9PT0gbnVsbCB8fCBuZXh0RWxlbWVudCA9PT0gZmFsc2U7XG5cbiAgcmV0dXJuIChcbiAgICAvLyBUaGlzIGhhcyBhIGZldyBmYWxzZSBwb3NpdGl2ZXMgdy9yL3QgZW1wdHkgY29tcG9uZW50cy5cbiAgICBwcmV2RW1wdHkgfHwgbmV4dEVtcHR5IHx8IG5leHRFbGVtZW50LnJlZiAhPT0gcHJldkVsZW1lbnQucmVmIHx8XG4gICAgLy8gSWYgb3duZXIgY2hhbmdlcyBidXQgd2UgaGF2ZSBhbiB1bmNoYW5nZWQgZnVuY3Rpb24gcmVmLCBkb24ndCB1cGRhdGUgcmVmc1xuICAgIHR5cGVvZiBuZXh0RWxlbWVudC5yZWYgPT09ICdzdHJpbmcnICYmIG5leHRFbGVtZW50Ll9vd25lciAhPT0gcHJldkVsZW1lbnQuX293bmVyXG4gICk7XG59O1xuXG5SZWFjdFJlZi5kZXRhY2hSZWZzID0gZnVuY3Rpb24gKGluc3RhbmNlLCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgZGV0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlZjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UmVmLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0T3duZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBSZWFjdE93bmVycyBhcmUgY2FwYWJsZSBvZiBzdG9yaW5nIHJlZmVyZW5jZXMgdG8gb3duZWQgY29tcG9uZW50cy5cbiAqXG4gKiBBbGwgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL2JlaW5nLy8gcmVmZXJlbmNlZCBieSBvd25lciBjb21wb25lbnRzLCBidXRcbiAqIG9ubHkgUmVhY3RPd25lciBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vcmVmZXJlbmNpbmcvLyBvd25lZCBjb21wb25lbnRzLlxuICogVGhlIG5hbWVkIHJlZmVyZW5jZSBpcyBrbm93biBhcyBhIFwicmVmXCIuXG4gKlxuICogUmVmcyBhcmUgYXZhaWxhYmxlIHdoZW4gbW91bnRlZCBhbmQgdXBkYXRlZCBkdXJpbmcgcmVjb25jaWxpYXRpb24uXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiAoXG4gKiAgICAgICAgIDxkaXYgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja30+XG4gKiAgICAgICAgICAgPEN1c3RvbUNvbXBvbmVudCByZWY9XCJjdXN0b21cIiAvPlxuICogICAgICAgICA8L2Rpdj5cbiAqICAgICAgICk7XG4gKiAgICAgfSxcbiAqICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmhhbmRsZUNsaWNrKCk7XG4gKiAgICAgfSxcbiAqICAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmluaXRpYWxpemUoKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFJlZnMgc2hvdWxkIHJhcmVseSBiZSB1c2VkLiBXaGVuIHJlZnMgYXJlIHVzZWQsIHRoZXkgc2hvdWxkIG9ubHkgYmUgZG9uZSB0b1xuICogY29udHJvbCBkYXRhIHRoYXQgaXMgbm90IGhhbmRsZWQgYnkgUmVhY3QncyBkYXRhIGZsb3cuXG4gKlxuICogQGNsYXNzIFJlYWN0T3duZXJcbiAqL1xudmFyIFJlYWN0T3duZXIgPSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBvd25lci5cbiAgICogQGZpbmFsXG4gICAqL1xuICBpc1ZhbGlkT3duZXI6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gISEob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QuYXR0YWNoUmVmID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmplY3QuZGV0YWNoUmVmID09PSAnZnVuY3Rpb24nKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBhIGNvbXBvbmVudCBieSByZWYgdG8gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIGJ5IHdoaWNoIHRvIHJlZmVyIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRvIHJlY29yZCB0aGUgcmVmLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhZGRDb21wb25lbnRBc1JlZlRvOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgIVJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhZGRDb21wb25lbnRBc1JlZlRvKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyBgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicpIDogX3Byb2RJbnZhcmlhbnQoJzExOScpIDogdm9pZCAwO1xuICAgIG93bmVyLmF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjb21wb25lbnQgYnkgcmVmIGZyb20gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgb2YgdGhlIHJlZiB0byByZW1vdmUuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRoZSByZWYgaXMgcmVjb3JkZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbTogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFSZWFjdE93bmVyLmlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCBiZSByZW1vdmluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzIGByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBfcHJvZEludmFyaWFudCgnMTIwJykgOiB2b2lkIDA7XG4gICAgdmFyIG93bmVyUHVibGljSW5zdGFuY2UgPSBvd25lci5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIC8vIENoZWNrIHRoYXQgYGNvbXBvbmVudGAncyBvd25lciBpcyBzdGlsbCBhbGl2ZSBhbmQgdGhhdCBgY29tcG9uZW50YCBpcyBzdGlsbCB0aGUgY3VycmVudCByZWZcbiAgICAvLyBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvIGRldGFjaCB0aGUgcmVmIGlmIGFub3RoZXIgY29tcG9uZW50IHN0b2xlIGl0LlxuICAgIGlmIChvd25lclB1YmxpY0luc3RhbmNlICYmIG93bmVyUHVibGljSW5zdGFuY2UucmVmc1tyZWZdID09PSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSkge1xuICAgICAgb3duZXIuZGV0YWNoUmVmKHJlZik7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RPd25lcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0T3duZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnN0cnVtZW50YXRpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWJ1Z1Rvb2wgPSBudWxsO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3REZWJ1Z1Rvb2wgPSByZXF1aXJlKCcuL1JlYWN0RGVidWdUb29sJyk7XG4gIGRlYnVnVG9vbCA9IFJlYWN0RGVidWdUb29sO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVidWdUb29sOiBkZWJ1Z1Rvb2wgfTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SW5zdHJ1bWVudGF0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVidWdUb29sXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vaycpO1xudmFyIFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rID0gcmVxdWlyZSgnLi9SZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vaycpO1xudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbnZhciBSZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2snKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdyA9IHJlcXVpcmUoJ2ZianMvbGliL3BlcmZvcm1hbmNlTm93Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhvb2tzID0gW107XG52YXIgZGlkSG9va1Rocm93Rm9yRXZlbnQgPSB7fTtcblxuZnVuY3Rpb24gY2FsbEhvb2soZXZlbnQsIGZuLCBjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIHRyeSB7XG4gICAgZm4uY2FsbChjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZEhvb2tUaHJvd0ZvckV2ZW50W2V2ZW50XSwgJ0V4Y2VwdGlvbiB0aHJvd24gYnkgaG9vayB3aGlsZSBoYW5kbGluZyAlczogJXMnLCBldmVudCwgZSArICdcXG4nICsgZS5zdGFjaykgOiB2b2lkIDA7XG4gICAgZGlkSG9va1Rocm93Rm9yRXZlbnRbZXZlbnRdID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXZlbnQoZXZlbnQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBob29rID0gaG9va3NbaV07XG4gICAgdmFyIGZuID0gaG9va1tldmVudF07XG4gICAgaWYgKGZuKSB7XG4gICAgICBjYWxsSG9vayhldmVudCwgZm4sIGhvb2ssIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaXNQcm9maWxpbmcgPSBmYWxzZTtcbnZhciBmbHVzaEhpc3RvcnkgPSBbXTtcbnZhciBsaWZlQ3ljbGVUaW1lclN0YWNrID0gW107XG52YXIgY3VycmVudEZsdXNoTmVzdGluZyA9IDA7XG52YXIgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gbnVsbDtcbnZhciBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSBudWxsO1xudmFyIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xudmFyIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IG51bGw7XG52YXIgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IG51bGw7XG52YXIgY3VycmVudFRpbWVyVHlwZSA9IG51bGw7XG5cbnZhciBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjbGVhckhpc3RvcnkoKSB7XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sucHVyZ2VVbm1vdW50ZWRDb21wb25lbnRzKCk7XG4gIFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmNsZWFySGlzdG9yeSgpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmVlU25hcHNob3QocmVnaXN0ZXJlZElEcykge1xuICByZXR1cm4gcmVnaXN0ZXJlZElEcy5yZWR1Y2UoZnVuY3Rpb24gKHRyZWUsIGlkKSB7XG4gICAgdmFyIG93bmVySUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldE93bmVySUQoaWQpO1xuICAgIHZhciBwYXJlbnRJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UGFyZW50SUQoaWQpO1xuICAgIHRyZWVbaWRdID0ge1xuICAgICAgZGlzcGxheU5hbWU6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUoaWQpLFxuICAgICAgdGV4dDogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRUZXh0KGlkKSxcbiAgICAgIHVwZGF0ZUNvdW50OiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFVwZGF0ZUNvdW50KGlkKSxcbiAgICAgIGNoaWxkSURzOiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldENoaWxkSURzKGlkKSxcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBvd25lcnMgYnV0IHRoaXMgaXMgY2xvc2UgZW5vdWdoLlxuICAgICAgb3duZXJJRDogb3duZXJJRCB8fCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldE93bmVySUQocGFyZW50SUQpLFxuICAgICAgcGFyZW50SUQ6IHBhcmVudElEXG4gICAgfTtcbiAgICByZXR1cm4gdHJlZTtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiByZXNldE1lYXN1cmVtZW50cygpIHtcbiAgdmFyIHByZXZpb3VzU3RhcnRUaW1lID0gY3VycmVudEZsdXNoU3RhcnRUaW1lO1xuICB2YXIgcHJldmlvdXNNZWFzdXJlbWVudHMgPSBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgfHwgW107XG4gIHZhciBwcmV2aW91c09wZXJhdGlvbnMgPSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5nZXRIaXN0b3J5KCk7XG5cbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSBudWxsO1xuICAgIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IG51bGw7XG4gICAgY2xlYXJIaXN0b3J5KCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByZXZpb3VzTWVhc3VyZW1lbnRzLmxlbmd0aCB8fCBwcmV2aW91c09wZXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgdmFyIHJlZ2lzdGVyZWRJRHMgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFJlZ2lzdGVyZWRJRHMoKTtcbiAgICBmbHVzaEhpc3RvcnkucHVzaCh7XG4gICAgICBkdXJhdGlvbjogcGVyZm9ybWFuY2VOb3coKSAtIHByZXZpb3VzU3RhcnRUaW1lLFxuICAgICAgbWVhc3VyZW1lbnRzOiBwcmV2aW91c01lYXN1cmVtZW50cyB8fCBbXSxcbiAgICAgIG9wZXJhdGlvbnM6IHByZXZpb3VzT3BlcmF0aW9ucyB8fCBbXSxcbiAgICAgIHRyZWVTbmFwc2hvdDogZ2V0VHJlZVNuYXBzaG90KHJlZ2lzdGVyZWRJRHMpXG4gICAgfSk7XG4gIH1cblxuICBjbGVhckhpc3RvcnkoKTtcbiAgY3VycmVudEZsdXNoU3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gW107XG59XG5cbmZ1bmN0aW9uIGNoZWNrRGVidWdJRChkZWJ1Z0lEKSB7XG4gIHZhciBhbGxvd1Jvb3QgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcblxuICBpZiAoYWxsb3dSb290ICYmIGRlYnVnSUQgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFkZWJ1Z0lEKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERlYnVnVG9vbDogZGVidWdJRCBtYXkgbm90IGJlIGVtcHR5LicpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJlZ2luTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gIGlmIChjdXJyZW50Rmx1c2hOZXN0aW5nID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjdXJyZW50VGltZXJUeXBlICYmICFsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IgaW4gdGhlIFJlYWN0IHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGNvZGUuICcgKyAnRGlkIG5vdCBleHBlY3QgJXMgdGltZXIgdG8gc3RhcnQgd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuJywgdGltZXJUeXBlLCBjdXJyZW50VGltZXJUeXBlIHx8ICdubycsIGRlYnVnSUQgPT09IGN1cnJlbnRUaW1lckRlYnVnSUQgPyAndGhlIHNhbWUnIDogJ2Fub3RoZXInKSA6IHZvaWQgMDtcbiAgICBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IHRydWU7XG4gIH1cbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBkZWJ1Z0lEO1xuICBjdXJyZW50VGltZXJUeXBlID0gdGltZXJUeXBlO1xufVxuXG5mdW5jdGlvbiBlbmRMaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGN1cnJlbnRUaW1lclR5cGUgIT09IHRpbWVyVHlwZSAmJiAhbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZXJlIGlzIGFuIGludGVybmFsIGVycm9yIGluIHRoZSBSZWFjdCBwZXJmb3JtYW5jZSBtZWFzdXJlbWVudCBjb2RlLiAnICsgJ1dlIGRpZCBub3QgZXhwZWN0ICVzIHRpbWVyIHRvIHN0b3Agd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuIFBsZWFzZSByZXBvcnQgdGhpcyBhcyBhIGJ1ZyBpbiBSZWFjdC4nLCB0aW1lclR5cGUsIGN1cnJlbnRUaW1lclR5cGUgfHwgJ25vJywgZGVidWdJRCA9PT0gY3VycmVudFRpbWVyRGVidWdJRCA/ICd0aGUgc2FtZScgOiAnYW5vdGhlcicpIDogdm9pZCAwO1xuICAgIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMucHVzaCh7XG4gICAgICB0aW1lclR5cGU6IHRpbWVyVHlwZSxcbiAgICAgIGluc3RhbmNlSUQ6IGRlYnVnSUQsXG4gICAgICBkdXJhdGlvbjogcGVyZm9ybWFuY2VOb3coKSAtIGN1cnJlbnRUaW1lclN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb25cbiAgICB9KTtcbiAgfVxuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBudWxsO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gbnVsbDtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpIHtcbiAgdmFyIGN1cnJlbnRUaW1lciA9IHtcbiAgICBzdGFydFRpbWU6IGN1cnJlbnRUaW1lclN0YXJ0VGltZSxcbiAgICBuZXN0ZWRGbHVzaFN0YXJ0VGltZTogcGVyZm9ybWFuY2VOb3coKSxcbiAgICBkZWJ1Z0lEOiBjdXJyZW50VGltZXJEZWJ1Z0lELFxuICAgIHRpbWVyVHlwZTogY3VycmVudFRpbWVyVHlwZVxuICB9O1xuICBsaWZlQ3ljbGVUaW1lclN0YWNrLnB1c2goY3VycmVudFRpbWVyKTtcbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gbnVsbDtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IG51bGw7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xuICBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzdW1lQ3VycmVudExpZmVDeWNsZVRpbWVyKCkge1xuICB2YXIgX2xpZmVDeWNsZVRpbWVyU3RhY2skID0gbGlmZUN5Y2xlVGltZXJTdGFjay5wb3AoKTtcblxuICB2YXIgc3RhcnRUaW1lID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLnN0YXJ0VGltZTtcbiAgdmFyIG5lc3RlZEZsdXNoU3RhcnRUaW1lID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLm5lc3RlZEZsdXNoU3RhcnRUaW1lO1xuICB2YXIgZGVidWdJRCA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5kZWJ1Z0lEO1xuICB2YXIgdGltZXJUeXBlID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLnRpbWVyVHlwZTtcblxuICB2YXIgbmVzdGVkRmx1c2hEdXJhdGlvbiA9IHBlcmZvcm1hbmNlTm93KCkgLSBuZXN0ZWRGbHVzaFN0YXJ0VGltZTtcbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uICs9IG5lc3RlZEZsdXNoRHVyYXRpb247XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBkZWJ1Z0lEO1xuICBjdXJyZW50VGltZXJUeXBlID0gdGltZXJUeXBlO1xufVxuXG52YXIgUmVhY3REZWJ1Z1Rvb2wgPSB7XG4gIGFkZEhvb2s6IGZ1bmN0aW9uIChob29rKSB7XG4gICAgaG9va3MucHVzaChob29rKTtcbiAgfSxcbiAgcmVtb3ZlSG9vazogZnVuY3Rpb24gKGhvb2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaG9va3NbaV0gPT09IGhvb2spIHtcbiAgICAgICAgaG9va3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBpc1Byb2ZpbGluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc1Byb2ZpbGluZztcbiAgfSxcbiAgYmVnaW5Qcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpc1Byb2ZpbGluZyA9IHRydWU7XG4gICAgZmx1c2hIaXN0b3J5Lmxlbmd0aCA9IDA7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBSZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rKTtcbiAgfSxcbiAgZW5kUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc1Byb2ZpbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlzUHJvZmlsaW5nID0gZmFsc2U7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBSZWFjdERlYnVnVG9vbC5yZW1vdmVIb29rKFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rKTtcbiAgfSxcbiAgZ2V0Rmx1c2hIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZsdXNoSGlzdG9yeTtcbiAgfSxcbiAgb25CZWdpbkZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgY3VycmVudEZsdXNoTmVzdGluZysrO1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgcGF1c2VDdXJyZW50TGlmZUN5Y2xlVGltZXIoKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5GbHVzaCcpO1xuICB9LFxuICBvbkVuZEZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBjdXJyZW50Rmx1c2hOZXN0aW5nLS07XG4gICAgcmVzdW1lQ3VycmVudExpZmVDeWNsZVRpbWVyKCk7XG4gICAgZW1pdEV2ZW50KCdvbkVuZEZsdXNoJyk7XG4gIH0sXG4gIG9uQmVnaW5MaWZlQ3ljbGVUaW1lcjogZnVuY3Rpb24gKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5MaWZlQ3ljbGVUaW1lcicsIGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gICAgYmVnaW5MaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICB9LFxuICBvbkVuZExpZmVDeWNsZVRpbWVyOiBmdW5jdGlvbiAoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVuZExpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gICAgZW1pdEV2ZW50KCdvbkVuZExpZmVDeWNsZVRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgfSxcbiAgb25FcnJvcjogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBpZiAoY3VycmVudFRpbWVyRGVidWdJRCAhPSBudWxsKSB7XG4gICAgICBlbmRMaWZlQ3ljbGVUaW1lcihjdXJyZW50VGltZXJEZWJ1Z0lELCBjdXJyZW50VGltZXJUeXBlKTtcbiAgICB9XG4gICAgZW1pdEV2ZW50KCdvbkVycm9yJywgZGVidWdJRCk7XG4gIH0sXG4gIG9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCcpO1xuICB9LFxuICBvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCcpO1xuICB9LFxuICBvbkhvc3RPcGVyYXRpb246IGZ1bmN0aW9uIChkZWJ1Z0lELCB0eXBlLCBwYXlsb2FkKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25Ib3N0T3BlcmF0aW9uJywgZGVidWdJRCwgdHlwZSwgcGF5bG9hZCk7XG4gIH0sXG4gIG9uU2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uU2V0U3RhdGUnKTtcbiAgfSxcbiAgb25TZXRDaGlsZHJlbjogZnVuY3Rpb24gKGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgY2hpbGREZWJ1Z0lEcy5mb3JFYWNoKGNoZWNrRGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvblNldENoaWxkcmVuJywgZGVidWdJRCwgY2hpbGREZWJ1Z0lEcyk7XG4gIH0sXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50LCBwYXJlbnREZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGNoZWNrRGVidWdJRChwYXJlbnREZWJ1Z0lELCB0cnVlKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlTW91bnRDb21wb25lbnQnLCBkZWJ1Z0lELCBlbGVtZW50LCBwYXJlbnREZWJ1Z0lEKTtcbiAgfSxcbiAgb25Nb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbk1vdW50Q29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlVXBkYXRlQ29tcG9uZW50JywgZGVidWdJRCwgZWxlbWVudCk7XG4gIH0sXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uVXBkYXRlQ29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uQmVmb3JlVW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZm9yZVVubW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uVW5tb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvblRlc3RFdmVudDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25UZXN0RXZlbnQnKTtcbiAgfVxufTtcblxuLy8gVE9ETyByZW1vdmUgdGhlc2Ugd2hlbiBSTi93d3cgZ2V0cyB1cGRhdGVkXG5SZWFjdERlYnVnVG9vbC5hZGREZXZ0b29sID0gUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vaztcblJlYWN0RGVidWdUb29sLnJlbW92ZURldnRvb2wgPSBSZWFjdERlYnVnVG9vbC5yZW1vdmVIb29rO1xuXG5SZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2spO1xuUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdENvbXBvbmVudFRyZWVIb29rKTtcblJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2spO1xudmFyIHVybCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cubG9jYXRpb24uaHJlZiB8fCAnJztcbmlmICgvWz8mXXJlYWN0X3BlcmZcXGIvLnRlc3QodXJsKSkge1xuICBSZWFjdERlYnVnVG9vbC5iZWdpblByb2ZpbGluZygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVidWdUb29sO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3REZWJ1Z1Rvb2wuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9va1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5JbnZhbGlkU2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIXByb2Nlc3NpbmdDaGlsZENvbnRleHQsICdzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKScpIDogdm9pZCAwO1xuICB9O1xufVxuXG52YXIgUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayA9IHtcbiAgb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgfSxcbiAgb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IGZhbHNlO1xuICB9LFxuICBvblNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgd2FybkludmFsaWRTZXRTdGF0ZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2s7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGlzdG9yeSA9IFtdO1xuXG52YXIgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2sgPSB7XG4gIG9uSG9zdE9wZXJhdGlvbjogZnVuY3Rpb24gKGRlYnVnSUQsIHR5cGUsIHBheWxvYWQpIHtcbiAgICBoaXN0b3J5LnB1c2goe1xuICAgICAgaW5zdGFuY2VJRDogZGVidWdJRCxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgfSk7XG4gIH0sXG4gIGNsZWFySGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5fcHJldmVudENsZWFyaW5nKSB7XG4gICAgICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0cy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoaXN0b3J5ID0gW107XG4gIH0sXG4gIGdldEhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vaztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2hpbGRyZW5NdXRhdGlvbldhcm5pbmdIb29rXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuID09PSBlbGVtZW50LnByb3BzLmNoaWxkcmVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpc011dGF0ZWQgPSBmYWxzZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4pKSB7XG4gICAgaWYgKGVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuLmxlbmd0aCA9PT0gZWxlbWVudC5wcm9wcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuW2ldICE9PSBlbGVtZW50LnByb3BzLmNoaWxkcmVuW2ldKSB7XG4gICAgICAgICAgaXNNdXRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpc011dGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4pIHx8IGlzTXV0YXRlZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnQ29tcG9uZW50XFwncyBjaGlsZHJlbiBzaG91bGQgbm90IGJlIG11dGF0ZWQuJXMnLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfVxufVxuXG52YXIgUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2sgPSB7XG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoZGVidWdJRCkpO1xuICB9LFxuICBvblVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChkZWJ1Z0lEKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2s7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vay5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIHBlcmZvcm1hbmNlID0gcmVxdWlyZSgnLi9wZXJmb3JtYW5jZScpO1xuXG52YXIgcGVyZm9ybWFuY2VOb3c7XG5cbi8qKlxuICogRGV0ZWN0IGlmIHdlIGNhbiB1c2UgYHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKWAgYW5kIGdyYWNlZnVsbHkgZmFsbGJhY2sgdG9cbiAqIGBEYXRlLm5vdygpYCBpZiBpdCBkb2Vzbid0IGV4aXN0LiBXZSBuZWVkIHRvIHN1cHBvcnQgRmlyZWZveCA8IDE1IGZvciBub3dcbiAqIGJlY2F1c2Ugb2YgRmFjZWJvb2sncyB0ZXN0aW5nIGluZnJhc3RydWN0dXJlLlxuICovXG5pZiAocGVyZm9ybWFuY2Uubm93KSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgcGVyZm9ybWFuY2VOb3cgPSBmdW5jdGlvbiBwZXJmb3JtYW5jZU5vdygpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZU5vdztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHBlcmZvcm1hbmNlO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlIHx8IHdpbmRvdy5tc1BlcmZvcm1hbmNlIHx8IHdpbmRvdy53ZWJraXRQZXJmb3JtYW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZSB8fCB7fTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgVHJhbnNhY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBgVHJhbnNhY3Rpb25gIGNyZWF0ZXMgYSBibGFjayBib3ggdGhhdCBpcyBhYmxlIHRvIHdyYXAgYW55IG1ldGhvZCBzdWNoIHRoYXRcbiAqIGNlcnRhaW4gaW52YXJpYW50cyBhcmUgbWFpbnRhaW5lZCBiZWZvcmUgYW5kIGFmdGVyIHRoZSBtZXRob2QgaXMgaW52b2tlZFxuICogKEV2ZW4gaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGlsZSBpbnZva2luZyB0aGUgd3JhcHBlZCBtZXRob2QpLiBXaG9ldmVyXG4gKiBpbnN0YW50aWF0ZXMgYSB0cmFuc2FjdGlvbiBjYW4gcHJvdmlkZSBlbmZvcmNlcnMgb2YgdGhlIGludmFyaWFudHMgYXRcbiAqIGNyZWF0aW9uIHRpbWUuIFRoZSBgVHJhbnNhY3Rpb25gIGNsYXNzIGl0c2VsZiB3aWxsIHN1cHBseSBvbmUgYWRkaXRpb25hbFxuICogYXV0b21hdGljIGludmFyaWFudCBmb3IgeW91IC0gdGhlIGludmFyaWFudCB0aGF0IGFueSB0cmFuc2FjdGlvbiBpbnN0YW5jZVxuICogc2hvdWxkIG5vdCBiZSBydW4gd2hpbGUgaXQgaXMgYWxyZWFkeSBiZWluZyBydW4uIFlvdSB3b3VsZCB0eXBpY2FsbHkgY3JlYXRlIGFcbiAqIHNpbmdsZSBpbnN0YW5jZSBvZiBhIGBUcmFuc2FjdGlvbmAgZm9yIHJldXNlIG11bHRpcGxlIHRpbWVzLCB0aGF0IHBvdGVudGlhbGx5XG4gKiBpcyB1c2VkIHRvIHdyYXAgc2V2ZXJhbCBkaWZmZXJlbnQgbWV0aG9kcy4gV3JhcHBlcnMgYXJlIGV4dHJlbWVseSBzaW1wbGUgLVxuICogdGhleSBvbmx5IHJlcXVpcmUgaW1wbGVtZW50aW5nIHR3byBtZXRob2RzLlxuICpcbiAqIDxwcmU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlcnMgKGluamVjdGVkIGF0IGNyZWF0aW9uIHRpbWUpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAgICAgICAgK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS18LS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgdiAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICAgICArLS0tLS0tLS0tLS0tLS0tKyAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgKy0tfCAgICB3cmFwcGVyMSAgIHwtLS18LS0tLSsgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICstLS0tLS0tLS0tLS0tLS0rICAgdiAgICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICAgICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgKy0tLS18ICAgd3JhcHBlcjIgIHwtLS0tLS0tLSsgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgdiAgICAgdiAgICAgICAgICAgICAgICAgICAgIHYgICAgIHYgICB8IHdyYXBwZXJcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8IGludmFyaWFudHNcbiAqIHBlcmZvcm0oYW55TWV0aG9kKSB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8IG1haW50YWluZWRcbiAqICstLS0tLS0tLS0tLS0tLS0tLT58LXwtLS18LXwtLS18LS0+fGFueU1ldGhvZHwtLS18LS0tfC18LS0tfC18LS0tLS0tLS0+XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfFxuICogICAgICAgICAgICAgICAgICAgIHwgIGluaXRpYWxpemUgICAgICAgICAgICAgICAgICAgIGNsb3NlICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gKiA8L3ByZT5cbiAqXG4gKiBVc2UgY2FzZXM6XG4gKiAtIFByZXNlcnZpbmcgdGhlIGlucHV0IHNlbGVjdGlvbiByYW5nZXMgYmVmb3JlL2FmdGVyIHJlY29uY2lsaWF0aW9uLlxuICogICBSZXN0b3Jpbmcgc2VsZWN0aW9uIGV2ZW4gaW4gdGhlIGV2ZW50IG9mIGFuIHVuZXhwZWN0ZWQgZXJyb3IuXG4gKiAtIERlYWN0aXZhdGluZyBldmVudHMgd2hpbGUgcmVhcnJhbmdpbmcgdGhlIERPTSwgcHJldmVudGluZyBibHVycy9mb2N1c2VzLFxuICogICB3aGlsZSBndWFyYW50ZWVpbmcgdGhhdCBhZnRlcndhcmRzLCB0aGUgZXZlbnQgc3lzdGVtIGlzIHJlYWN0aXZhdGVkLlxuICogLSBGbHVzaGluZyBhIHF1ZXVlIG9mIGNvbGxlY3RlZCBET00gbXV0YXRpb25zIHRvIHRoZSBtYWluIFVJIHRocmVhZCBhZnRlciBhXG4gKiAgIHJlY29uY2lsaWF0aW9uIHRha2VzIHBsYWNlIGluIGEgd29ya2VyIHRocmVhZC5cbiAqIC0gSW52b2tpbmcgYW55IGNvbGxlY3RlZCBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgYWZ0ZXIgcmVuZGVyaW5nIG5ld1xuICogICBjb250ZW50LlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogV3JhcHBpbmcgcGFydGljdWxhciBmbHVzaGVzIG9mIHRoZSBgUmVhY3RXb3JrZXJgIHF1ZXVlXG4gKiAgIHRvIHByZXNlcnZlIHRoZSBgc2Nyb2xsVG9wYCAoYW4gYXV0b21hdGljIHNjcm9sbCBhd2FyZSBET00pLlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogTGF5b3V0IGNhbGN1bGF0aW9ucyBiZWZvcmUgYW5kIGFmdGVyIERPTSB1cGRhdGVzLlxuICpcbiAqIFRyYW5zYWN0aW9uYWwgcGx1Z2luIEFQSTpcbiAqIC0gQSBtb2R1bGUgdGhhdCBoYXMgYW4gYGluaXRpYWxpemVgIG1ldGhvZCB0aGF0IHJldHVybnMgYW55IHByZWNvbXB1dGF0aW9uLlxuICogLSBhbmQgYSBgY2xvc2VgIG1ldGhvZCB0aGF0IGFjY2VwdHMgdGhlIHByZWNvbXB1dGF0aW9uLiBgY2xvc2VgIGlzIGludm9rZWRcbiAqICAgd2hlbiB0aGUgd3JhcHBlZCBwcm9jZXNzIGlzIGNvbXBsZXRlZCwgb3IgaGFzIGZhaWxlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFRyYW5zYWN0aW9uYWxXcmFwcGVyPn0gdHJhbnNhY3Rpb25XcmFwcGVyIFdyYXBwZXIgbW9kdWxlc1xuICogdGhhdCBpbXBsZW1lbnQgYGluaXRpYWxpemVgIGFuZCBgY2xvc2VgLlxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IFNpbmdsZSB0cmFuc2FjdGlvbiBmb3IgcmV1c2UgaW4gdGhyZWFkLlxuICpcbiAqIEBjbGFzcyBUcmFuc2FjdGlvblxuICovXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoaXMgaW5zdGFuY2Ugc28gdGhhdCBpdCBpcyBwcmVwYXJlZCBmb3IgY29sbGVjdGluZyBtZXRyaWNzLiBEb2VzXG4gICAqIHNvIHN1Y2ggdGhhdCB0aGlzIHNldHVwIG1ldGhvZCBtYXkgYmUgdXNlZCBvbiBhbiBpbnN0YW5jZSB0aGF0IGlzIGFscmVhZHlcbiAgICogaW5pdGlhbGl6ZWQsIGluIGEgd2F5IHRoYXQgZG9lcyBub3QgY29uc3VtZSBhZGRpdGlvbmFsIG1lbW9yeSB1cG9uIHJldXNlLlxuICAgKiBUaGF0IGNhbiBiZSB1c2VmdWwgaWYgeW91IGRlY2lkZSB0byBtYWtlIHlvdXIgc3ViY2xhc3Mgb2YgdGhpcyBtaXhpbiBhXG4gICAqIFwiUG9vbGVkQ2xhc3NcIi5cbiAgICovXG4gIHJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy5nZXRUcmFuc2FjdGlvbldyYXBwZXJzKCk7XG4gICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhKSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgfSxcblxuICBfaXNJblRyYW5zYWN0aW9uOiBmYWxzZSxcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj59IEFycmF5IG9mIHRyYW5zYWN0aW9uIHdyYXBwZXJzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogbnVsbCxcblxuICBpc0luVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9pc0luVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiB3aXRoaW4gYSBzYWZldHkgd2luZG93LiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbFxuICAgKiBtZXRob2RzIHRoYXQgcmVzdWx0IGluIGxhcmdlIGFtb3VudHMgb2YgY29tcHV0YXRpb24vbXV0YXRpb25zIHRoYXQgd291bGRcbiAgICogbmVlZCB0byBiZSBzYWZldHkgY2hlY2tlZC4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBoZWxwcyBwcmV2ZW50IHRoZSBuZWVkXG4gICAqIHRvIGJpbmQgaW4gbWFueSBjYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1lbWJlciBvZiBzY29wZSB0byBjYWxsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgU2NvcGUgdG8gaW52b2tlIGZyb20uXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGEgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBiIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYyBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGQgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBlIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqXG4gICAqIEByZXR1cm4geyp9IFJldHVybiB2YWx1ZSBmcm9tIGBtZXRob2RgLlxuICAgKi9cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAhIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24ucGVyZm9ybSguLi4pOiBDYW5ub3QgaW5pdGlhbGl6ZSBhIHRyYW5zYWN0aW9uIHdoZW4gdGhlcmUgaXMgYWxyZWFkeSBhbiBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbi4nKSA6IF9wcm9kSW52YXJpYW50KCcyNycpIDogdm9pZCAwO1xuICAgIHZhciBlcnJvclRocm93bjtcbiAgICB2YXIgcmV0O1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgIC8vIG9uZSBvZiB0aGVzZSBjYWxscyB0aHJldy5cbiAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbCgwKTtcbiAgICAgIHJldCA9IG1ldGhvZC5jYWxsKHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIElmIGBtZXRob2RgIHRocm93cywgcHJlZmVyIHRvIHNob3cgdGhhdCBzdGFjayB0cmFjZSBvdmVyIGFueSB0aHJvd25cbiAgICAgICAgICAvLyBieSBpbnZva2luZyBgY2xvc2VBbGxgLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTaW5jZSBgbWV0aG9kYCBkaWRuJ3QgdGhyb3csIHdlIGRvbid0IHdhbnQgdG8gc2lsZW5jZSB0aGUgZXhjZXB0aW9uXG4gICAgICAgICAgLy8gaGVyZS5cbiAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBpbml0aWFsaXplQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aCB0aGVcbiAgICAgICAgLy8gT0JTRVJWRURfRVJST1Igc3RhdGUgYmVmb3JlIG92ZXJ3cml0aW5nIGl0IHdpdGggdGhlIHJlYWwgcmV0dXJuIHZhbHVlXG4gICAgICAgIC8vIG9mIGluaXRpYWxpemUgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gT0JTRVJWRURfRVJST1IgaW4gdGhlIGZpbmFsbHlcbiAgICAgICAgLy8gYmxvY2ssIGl0IG1lYW5zIHdyYXBwZXIuaW5pdGlhbGl6ZSB0aHJldy5cbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUjtcbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSB3cmFwcGVyLmluaXRpYWxpemUgPyB3cmFwcGVyLmluaXRpYWxpemUuY2FsbCh0aGlzKSA6IG51bGw7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGhpcy53cmFwcGVySW5pdERhdGFbaV0gPT09IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SKSB7XG4gICAgICAgICAgLy8gVGhlIGluaXRpYWxpemVyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGluaXRpYWxpemUgdGhlXG4gICAgICAgICAgLy8gcmVtYWluaW5nIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmVcbiAgICAgICAgICAvLyB0aGF0IHRoZSBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZXMgZWFjaCBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmNsb3NlW2ldYCBmdW5jdGlvbnMsIHBhc3NpbmcgaW50b1xuICAgKiB0aGVtIHRoZSByZXNwZWN0aXZlIHJldHVybiB2YWx1ZXMgb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5pbml0W2ldYFxuICAgKiAoYGNsb3NlYHJzIHRoYXQgY29ycmVzcG9uZCB0byBpbml0aWFsaXplcnMgdGhhdCBmYWlsZWQgd2lsbCBub3QgYmVcbiAgICogaW52b2tlZCkuXG4gICAqL1xuICBjbG9zZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICAhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5jbG9zZUFsbCgpOiBDYW5ub3QgY2xvc2UgdHJhbnNhY3Rpb24gd2hlbiBub25lIGFyZSBvcGVuLicpIDogX3Byb2RJbnZhcmlhbnQoJzI4JykgOiB2b2lkIDA7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLndyYXBwZXJJbml0RGF0YVtpXTtcbiAgICAgIHZhciBlcnJvclRocm93bjtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgICAvLyB3cmFwcGVyLmNsb3NlIHRocmV3LlxuICAgICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICAgIGlmIChpbml0RGF0YSAhPT0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1IgJiYgd3JhcHBlci5jbG9zZSkge1xuICAgICAgICAgIHdyYXBwZXIuY2xvc2UuY2FsbCh0aGlzLCBpbml0RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIFRoZSBjbG9zZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgY2xvc2UgdGhlIHJlbWFpbmluZ1xuICAgICAgICAgIC8vIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmUgdGhhdCB0aGVcbiAgICAgICAgICAvLyBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICB9XG59O1xuXG52YXIgVHJhbnNhY3Rpb24gPSB7XG5cbiAgTWl4aW46IE1peGluLFxuXG4gIC8qKlxuICAgKiBUb2tlbiB0byBsb29rIGZvciB0byBkZXRlcm1pbmUgaWYgYW4gZXJyb3Igb2NjdXJyZWQuXG4gICAqL1xuICBPQlNFUlZFRF9FUlJPUjoge31cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2FjdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1RyYW5zYWN0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50VGFyZ2V0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQgfHwgbmF0aXZlRXZlbnQuc3JjRWxlbWVudCB8fCB3aW5kb3c7XG5cbiAgLy8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuICBpZiAodGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xuICB9XG5cbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gMyA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50VGFyZ2V0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0RXZlbnRUYXJnZXQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNFdmVudFN1cHBvcnRlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudFN1cHBvcnRlZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2lzRXZlbnRTdXBwb3J0ZWQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNUZXh0SW5wdXRFbGVtZW50XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cblxudmFyIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XG4gICdjb2xvcic6IHRydWUsXG4gICdkYXRlJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZSxcbiAgJ2VtYWlsJzogdHJ1ZSxcbiAgJ21vbnRoJzogdHJ1ZSxcbiAgJ251bWJlcic6IHRydWUsXG4gICdwYXNzd29yZCc6IHRydWUsXG4gICdyYW5nZSc6IHRydWUsXG4gICdzZWFyY2gnOiB0cnVlLFxuICAndGVsJzogdHJ1ZSxcbiAgJ3RleHQnOiB0cnVlLFxuICAndGltZSc6IHRydWUsXG4gICd1cmwnOiB0cnVlLFxuICAnd2Vlayc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0SW5wdXRFbGVtZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvaXNUZXh0SW5wdXRFbGVtZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG4vKipcbiAqIE1vZHVsZSB0aGF0IGlzIGluamVjdGFibGUgaW50byBgRXZlbnRQbHVnaW5IdWJgLCB0aGF0IHNwZWNpZmllcyBhXG4gKiBkZXRlcm1pbmlzdGljIG9yZGVyaW5nIG9mIGBFdmVudFBsdWdpbmBzLiBBIGNvbnZlbmllbnQgd2F5IHRvIHJlYXNvbiBhYm91dFxuICogcGx1Z2lucywgd2l0aG91dCBoYXZpbmcgdG8gcGFja2FnZSBldmVyeSBvbmUgb2YgdGhlbS4gVGhpcyBpcyBiZXR0ZXIgdGhhblxuICogaGF2aW5nIHBsdWdpbnMgYmUgb3JkZXJlZCBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgYXJlIGluamVjdGVkIGJlY2F1c2VcbiAqIHRoYXQgb3JkZXJpbmcgd291bGQgYmUgaW5mbHVlbmNlZCBieSB0aGUgcGFja2FnaW5nIG9yZGVyLlxuICogYFJlc3BvbmRlckV2ZW50UGx1Z2luYCBtdXN0IG9jY3VyIGJlZm9yZSBgU2ltcGxlRXZlbnRQbHVnaW5gIHNvIHRoYXRcbiAqIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBldmVudHMgaXMgY29udmVuaWVudCBpbiBgU2ltcGxlRXZlbnRQbHVnaW5gIGhhbmRsZXJzLlxuICovXG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSBba2V5T2YoeyBSZXNwb25kZXJFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBTaW1wbGVFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBUYXBFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBFbnRlckxlYXZlRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgQ2hhbmdlRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgU2VsZWN0RXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogbnVsbCB9KV07XG5cbm1vZHVsZS5leHBvcnRzID0gRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFbnRlckxlYXZlRXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIG1vdXNlRW50ZXI6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiBrZXlPZih7IG9uTW91c2VFbnRlcjogbnVsbCB9KSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0LCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3Zlcl1cbiAgfSxcbiAgbW91c2VMZWF2ZToge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHsgb25Nb3VzZUxlYXZlOiBudWxsIH0pLFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wTW91c2VPdXQsIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXVxuICB9XG59O1xuXG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gICAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcbiAgICogd2UgZG8gbm90IGV4dHJhY3QgZHVwbGljYXRlIGV2ZW50cy4gSG93ZXZlciwgbW92aW5nIHRoZSBtb3VzZSBpbnRvIHRoZVxuICAgKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAgICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyICYmIChuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LmZyb21FbGVtZW50KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0b3BMZXZlbFR5cGUgIT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQgJiYgdG9wTGV2ZWxUeXBlICE9PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3Zlcikge1xuICAgICAgLy8gTXVzdCBub3QgYmUgYSBtb3VzZSBpbiBvciBtb3VzZSBvdXQgLSBpZ25vcmluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3aW47XG4gICAgaWYgKG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICAgIC8vIGBuYXRpdmVFdmVudFRhcmdldGAgaXMgcHJvYmFibHkgYSB3aW5kb3cgb2JqZWN0LlxuICAgICAgd2luID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbiA9IHdpbmRvdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJvbTtcbiAgICB2YXIgdG87XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCkge1xuICAgICAgZnJvbSA9IHRhcmdldEluc3Q7XG4gICAgICB2YXIgcmVsYXRlZCA9IG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQudG9FbGVtZW50O1xuICAgICAgdG8gPSByZWxhdGVkID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICAgIGZyb20gPSBudWxsO1xuICAgICAgdG8gPSB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZyb21Ob2RlID0gZnJvbSA9PSBudWxsID8gd2luIDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoZnJvbSk7XG4gICAgdmFyIHRvTm9kZSA9IHRvID09IG51bGwgPyB3aW4gOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0byk7XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlTGVhdmUsIGZyb20sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgbGVhdmUudHlwZSA9ICdtb3VzZWxlYXZlJztcbiAgICBsZWF2ZS50YXJnZXQgPSBmcm9tTm9kZTtcbiAgICBsZWF2ZS5yZWxhdGVkVGFyZ2V0ID0gdG9Ob2RlO1xuXG4gICAgdmFyIGVudGVyID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUVudGVyLCB0bywgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBlbnRlci50eXBlID0gJ21vdXNlZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvTm9kZTtcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XG5cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKTtcblxuICAgIHJldHVybiBbbGVhdmUsIGVudGVyXTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVudGVyTGVhdmVFdmVudFBsdWdpbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNNb3VzZUV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gV2Via2l0LCBGaXJlZm94LCBJRTkrXG4gICAgLy8gd2hpY2g6ICAxIDIgM1xuICAgIC8vIGJ1dHRvbjogMCAxIDIgKHN0YW5kYXJkKVxuICAgIHZhciBidXR0b24gPSBldmVudC5idXR0b247XG4gICAgaWYgKCd3aGljaCcgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuICAgIC8vIElFPDlcbiAgICAvLyB3aGljaDogIHVuZGVmaW5lZFxuICAgIC8vIGJ1dHRvbjogMCAwIDBcbiAgICAvLyBidXR0b246IDEgNCAyIChvbm1vdXNldXApXG4gICAgcmV0dXJuIGJ1dHRvbiA9PT0gMiA/IDIgOiBidXR0b24gPT09IDQgPyAxIDogMDtcbiAgfSxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9LFxuICAvLyBcIlByb3ByaWV0YXJ5XCIgSW50ZXJmYWNlLlxuICBwYWdlWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWCcgaW4gZXZlbnQgPyBldmVudC5wYWdlWCA6IGV2ZW50LmNsaWVudFggKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQ7XG4gIH0sXG4gIHBhZ2VZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VZJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VZIDogZXZlbnQuY2xpZW50WSArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljTW91c2VFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNVSUV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFVJRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgVUlFdmVudEludGVyZmFjZSA9IHtcbiAgdmlldzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnZpZXcpIHtcbiAgICAgIHJldHVybiBldmVudC52aWV3O1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgaWYgKHRhcmdldC53aW5kb3cgPT09IHRhcmdldCkge1xuICAgICAgLy8gdGFyZ2V0IGlzIGEgd2luZG93IG9iamVjdFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICB2YXIgZG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgIGlmIChkb2MpIHtcbiAgICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gIH0sXG4gIGRldGFpbDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmRldGFpbCB8fCAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVUlFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNVSUV2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljVUlFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBWaWV3cG9ydE1ldHJpY3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBWaWV3cG9ydE1ldHJpY3MgPSB7XG5cbiAgY3VycmVudFNjcm9sbExlZnQ6IDAsXG5cbiAgY3VycmVudFNjcm9sbFRvcDogMCxcblxuICByZWZyZXNoU2Nyb2xsVmFsdWVzOiBmdW5jdGlvbiAoc2Nyb2xsUG9zaXRpb24pIHtcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQgPSBzY3JvbGxQb3NpdGlvbi54O1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wID0gc2Nyb2xsUG9zaXRpb24ueTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXdwb3J0TWV0cmljcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1ZpZXdwb3J0TWV0cmljcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICAnQWx0JzogJ2FsdEtleScsXG4gICdDb250cm9sJzogJ2N0cmxLZXknLFxuICAnTWV0YSc6ICdtZXRhS2V5JyxcbiAgJ1NoaWZ0JzogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudE1vZGlmaWVyU3RhdGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgSFRNTERPTVByb3BlcnR5Q29uZmlnXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG5cbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG5cbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZChuZXcgUmVnRXhwKCdeKGRhdGF8YXJpYSktWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpKSxcbiAgUHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhY2NlcHQ6IDAsXG4gICAgYWNjZXB0Q2hhcnNldDogMCxcbiAgICBhY2Nlc3NLZXk6IDAsXG4gICAgYWN0aW9uOiAwLFxuICAgIGFsbG93RnVsbFNjcmVlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYWxsb3dUcmFuc3BhcmVuY3k6IDAsXG4gICAgYWx0OiAwLFxuICAgIGFzeW5jOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvQ29tcGxldGU6IDAsXG4gICAgLy8gYXV0b0ZvY3VzIGlzIHBvbHlmaWxsZWQvbm9ybWFsaXplZCBieSBBdXRvRm9jdXNVdGlsc1xuICAgIC8vIGF1dG9Gb2N1czogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b1BsYXk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNhcHR1cmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNlbGxQYWRkaW5nOiAwLFxuICAgIGNlbGxTcGFjaW5nOiAwLFxuICAgIGNoYXJTZXQ6IDAsXG4gICAgY2hhbGxlbmdlOiAwLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2l0ZTogMCxcbiAgICBjbGFzc0lEOiAwLFxuICAgIGNsYXNzTmFtZTogMCxcbiAgICBjb2xzOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBjb2xTcGFuOiAwLFxuICAgIGNvbnRlbnQ6IDAsXG4gICAgY29udGVudEVkaXRhYmxlOiAwLFxuICAgIGNvbnRleHRNZW51OiAwLFxuICAgIGNvbnRyb2xzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjb29yZHM6IDAsXG4gICAgY3Jvc3NPcmlnaW46IDAsXG4gICAgZGF0YTogMCwgLy8gRm9yIGA8b2JqZWN0IC8+YCBhY3RzIGFzIGBzcmNgLlxuICAgIGRhdGVUaW1lOiAwLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpcjogMCxcbiAgICBkaXNhYmxlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZG93bmxvYWQ6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgZHJhZ2dhYmxlOiAwLFxuICAgIGVuY1R5cGU6IDAsXG4gICAgZm9ybTogMCxcbiAgICBmb3JtQWN0aW9uOiAwLFxuICAgIGZvcm1FbmNUeXBlOiAwLFxuICAgIGZvcm1NZXRob2Q6IDAsXG4gICAgZm9ybU5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGZvcm1UYXJnZXQ6IDAsXG4gICAgZnJhbWVCb3JkZXI6IDAsXG4gICAgaGVhZGVyczogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgaGlkZGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBoaWdoOiAwLFxuICAgIGhyZWY6IDAsXG4gICAgaHJlZkxhbmc6IDAsXG4gICAgaHRtbEZvcjogMCxcbiAgICBodHRwRXF1aXY6IDAsXG4gICAgaWNvbjogMCxcbiAgICBpZDogMCxcbiAgICBpbnB1dE1vZGU6IDAsXG4gICAgaW50ZWdyaXR5OiAwLFxuICAgIGlzOiAwLFxuICAgIGtleVBhcmFtczogMCxcbiAgICBrZXlUeXBlOiAwLFxuICAgIGtpbmQ6IDAsXG4gICAgbGFiZWw6IDAsXG4gICAgbGFuZzogMCxcbiAgICBsaXN0OiAwLFxuICAgIGxvb3A6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGxvdzogMCxcbiAgICBtYW5pZmVzdDogMCxcbiAgICBtYXJnaW5IZWlnaHQ6IDAsXG4gICAgbWFyZ2luV2lkdGg6IDAsXG4gICAgbWF4OiAwLFxuICAgIG1heExlbmd0aDogMCxcbiAgICBtZWRpYTogMCxcbiAgICBtZWRpYUdyb3VwOiAwLFxuICAgIG1ldGhvZDogMCxcbiAgICBtaW46IDAsXG4gICAgbWluTGVuZ3RoOiAwLFxuICAgIC8vIENhdXRpb247IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4gICAgLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC5cbiAgICBtdWx0aXBsZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBuYW1lOiAwLFxuICAgIG5vbmNlOiAwLFxuICAgIG5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wdGltdW06IDAsXG4gICAgcGF0dGVybjogMCxcbiAgICBwbGFjZWhvbGRlcjogMCxcbiAgICBwb3N0ZXI6IDAsXG4gICAgcHJlbG9hZDogMCxcbiAgICBwcm9maWxlOiAwLFxuICAgIHJhZGlvR3JvdXA6IDAsXG4gICAgcmVhZE9ubHk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlZmVycmVyUG9saWN5OiAwLFxuICAgIHJlbDogMCxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvbGU6IDAsXG4gICAgcm93czogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgcm93U3BhbjogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc2FuZGJveDogMCxcbiAgICBzY29wZTogMCxcbiAgICBzY29wZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNjcm9sbGluZzogMCxcbiAgICBzZWFtbGVzczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2hhcGU6IDAsXG4gICAgc2l6ZTogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc2l6ZXM6IDAsXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogMCxcbiAgICBzcmM6IDAsXG4gICAgc3JjRG9jOiAwLFxuICAgIHNyY0xhbmc6IDAsXG4gICAgc3JjU2V0OiAwLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzdGVwOiAwLFxuICAgIHN0eWxlOiAwLFxuICAgIHN1bW1hcnk6IDAsXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgdGFyZ2V0OiAwLFxuICAgIHRpdGxlOiAwLFxuICAgIC8vIFNldHRpbmcgLnR5cGUgdGhyb3dzIG9uIG5vbi08aW5wdXQ+IHRhZ3NcbiAgICB0eXBlOiAwLFxuICAgIHVzZU1hcDogMCxcbiAgICB2YWx1ZTogMCxcbiAgICB3aWR0aDogMCxcbiAgICB3bW9kZTogMCxcbiAgICB3cmFwOiAwLFxuXG4gICAgLyoqXG4gICAgICogUkRGYSBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgYWJvdXQ6IDAsXG4gICAgZGF0YXR5cGU6IDAsXG4gICAgaW5saXN0OiAwLFxuICAgIHByZWZpeDogMCxcbiAgICAvLyBwcm9wZXJ0eSBpcyBhbHNvIHN1cHBvcnRlZCBmb3IgT3BlbkdyYXBoIGluIG1ldGEgdGFncy5cbiAgICBwcm9wZXJ0eTogMCxcbiAgICByZXNvdXJjZTogMCxcbiAgICAndHlwZW9mJzogMCxcbiAgICB2b2NhYjogMCxcblxuICAgIC8qKlxuICAgICAqIE5vbi1zdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgLy8gYXV0b0NhcGl0YWxpemUgYW5kIGF1dG9Db3JyZWN0IGFyZSBzdXBwb3J0ZWQgaW4gTW9iaWxlIFNhZmFyaSBmb3JcbiAgICAvLyBrZXlib2FyZCBoaW50cy5cbiAgICBhdXRvQ2FwaXRhbGl6ZTogMCxcbiAgICBhdXRvQ29ycmVjdDogMCxcbiAgICAvLyBhdXRvU2F2ZSBhbGxvd3MgV2ViS2l0L0JsaW5rIHRvIHBlcnNpc3QgdmFsdWVzIG9mIGlucHV0IGZpZWxkcyBvbiBwYWdlIHJlbG9hZHNcbiAgICBhdXRvU2F2ZTogMCxcbiAgICAvLyBjb2xvciBpcyBmb3IgU2FmYXJpIG1hc2staWNvbiBsaW5rXG4gICAgY29sb3I6IDAsXG4gICAgLy8gaXRlbVByb3AsIGl0ZW1TY29wZSwgaXRlbVR5cGUgYXJlIGZvclxuICAgIC8vIE1pY3JvZGF0YSBzdXBwb3J0LiBTZWUgaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgaXRlbVByb3A6IDAsXG4gICAgaXRlbVNjb3BlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBpdGVtVHlwZTogMCxcbiAgICAvLyBpdGVtSUQgYW5kIGl0ZW1SZWYgYXJlIGZvciBNaWNyb2RhdGEgc3VwcG9ydCBhcyB3ZWxsIGJ1dFxuICAgIC8vIG9ubHkgc3BlY2lmaWVkIGluIHRoZSBXSEFUV0cgc3BlYyBkb2N1bWVudC4gU2VlXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvbWljcm9kYXRhLmh0bWwjbWljcm9kYXRhLWRvbS1hcGlcbiAgICBpdGVtSUQ6IDAsXG4gICAgaXRlbVJlZjogMCxcbiAgICAvLyByZXN1bHRzIHNob3cgbG9va2luZyBnbGFzcyBpY29uIGFuZCByZWNlbnQgc2VhcmNoZXMgb24gaW5wdXRcbiAgICAvLyBzZWFyY2ggZmllbGRzIGluIFdlYktpdC9CbGlua1xuICAgIHJlc3VsdHM6IDAsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgc2VjdXJpdHkgcmVzdHJpY3Rpb25zIG9uIGFuIGlmcmFtZVxuICAgIC8vIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBzYW5kYm94IGF0dHJpYnV0ZSBvbiBJRTwxMFxuICAgIHNlY3VyaXR5OiAwLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgY29udHJvbHMgZm9jdXMgYmVoYXZpb3JcbiAgICB1bnNlbGVjdGFibGU6IDBcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xuICB9LFxuICBET01Qcm9wZXJ0eU5hbWVzOiB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIVE1MRE9NUHJvcGVydHlDb25maWc7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdERPTUlET3BlcmF0aW9ucycpO1xuXG4vKipcbiAqIEFic3RyYWN0cyBhd2F5IGFsbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSByZWNvbmNpbGVyIHRoYXQgcmVxdWlyZXMga25vd2xlZGdlIG9mXG4gKiB0aGUgYnJvd3NlciBjb250ZXh0LiBUT0RPOiBUaGVzZSBjYWxsZXJzIHNob3VsZCBiZSByZWZhY3RvcmVkIHRvIGF2b2lkIHRoZVxuICogbmVlZCBmb3IgdGhpcyBpbmplY3Rpb24uXG4gKi9cbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHtcblxuICBwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBSZWFjdERPTUlET3BlcmF0aW9ucy5kYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMsXG5cbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBET01DaGlsZHJlbk9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTUNoaWxkcmVuT3BlcmF0aW9uc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERhbmdlciA9IHJlcXVpcmUoJy4vRGFuZ2VyJyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xuXG5mdW5jdGlvbiBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgbm9kZSkge1xuICAvLyBTcGVjaWFsIGNhc2UgZm9yIHRleHQgY29tcG9uZW50cywgd2hpY2ggcmV0dXJuIFtvcGVuLCBjbG9zZV0gY29tbWVudHNcbiAgLy8gZnJvbSBnZXRIb3N0Tm9kZS5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBub2RlID0gbm9kZVsxXTtcbiAgfVxuICByZXR1cm4gbm9kZSA/IG5vZGUubmV4dFNpYmxpbmcgOiBwYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG59XG5cbi8qKlxuICogSW5zZXJ0cyBgY2hpbGROb2RlYCBhcyBhIGNoaWxkIG9mIGBwYXJlbnROb2RlYCBhdCB0aGUgYGluZGV4YC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHBhcmVudE5vZGUgUGFyZW50IG5vZGUgaW4gd2hpY2ggdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjaGlsZE5vZGUgQ2hpbGQgbm9kZSB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAqIEBpbnRlcm5hbFxuICovXG52YXIgaW5zZXJ0Q2hpbGRBdCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAvLyBXZSByZWx5IGV4Y2x1c2l2ZWx5IG9uIGBpbnNlcnRCZWZvcmUobm9kZSwgbnVsbClgIGluc3RlYWQgb2YgYWxzbyB1c2luZ1xuICAvLyBgYXBwZW5kQ2hpbGQobm9kZSlgLiAoVXNpbmcgYHVuZGVmaW5lZGAgaXMgbm90IGFsbG93ZWQgYnkgYWxsIGJyb3dzZXJzIHNvXG4gIC8vIHdlIGFyZSBjYXJlZnVsIHRvIHVzZSBgbnVsbGAuKVxuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xufSk7XG5cbmZ1bmN0aW9uIGluc2VydExhenlUcmVlQ2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZFRyZWUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShwYXJlbnROb2RlLCBjaGlsZFRyZWUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiBtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkTm9kZSkpIHtcbiAgICBtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBjaGlsZE5vZGVbMF0sIGNoaWxkTm9kZVsxXSwgcmVmZXJlbmNlTm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudE5vZGUsIGNoaWxkTm9kZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZE5vZGUpKSB7XG4gICAgdmFyIGNsb3NpbmdDb21tZW50ID0gY2hpbGROb2RlWzFdO1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZVswXTtcbiAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvc2luZ0NvbW1lbnQpO1xuICB9XG4gIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGROb2RlKTtcbn1cblxuZnVuY3Rpb24gbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgb3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCByZWZlcmVuY2VOb2RlKSB7XG4gIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIG5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgIGlmIChub2RlID09PSBjbG9zaW5nQ29tbWVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIHN0YXJ0Tm9kZSwgY2xvc2luZ0NvbW1lbnQpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZS5uZXh0U2libGluZztcbiAgICBpZiAobm9kZSA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAgIC8vIFRoZSBjbG9zaW5nIGNvbW1lbnQgaXMgcmVtb3ZlZCBieSBSZWFjdE11bHRpQ2hpbGQuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZURlbGltaXRlZFRleHQob3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCBzdHJpbmdUZXh0KSB7XG4gIHZhciBwYXJlbnROb2RlID0gb3BlbmluZ0NvbW1lbnQucGFyZW50Tm9kZTtcbiAgdmFyIG5vZGVBZnRlckNvbW1lbnQgPSBvcGVuaW5nQ29tbWVudC5uZXh0U2libGluZztcbiAgaWYgKG5vZGVBZnRlckNvbW1lbnQgPT09IGNsb3NpbmdDb21tZW50KSB7XG4gICAgLy8gVGhlcmUgYXJlIG5vIHRleHQgbm9kZXMgYmV0d2VlbiB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyBjb21tZW50czsgaW5zZXJ0XG4gICAgLy8gYSBuZXcgb25lIGlmIHN0cmluZ1RleHQgaXNuJ3QgZW1wdHkuXG4gICAgaWYgKHN0cmluZ1RleHQpIHtcbiAgICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyaW5nVGV4dCksIG5vZGVBZnRlckNvbW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RyaW5nVGV4dCkge1xuICAgICAgLy8gU2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIGZpcnN0IG5vZGUgYWZ0ZXIgdGhlIG9wZW5pbmcgY29tbWVudCwgYW5kXG4gICAgICAvLyByZW1vdmUgYWxsIGZvbGxvd2luZyBub2RlcyB1cCB1bnRpbCB0aGUgY2xvc2luZyBjb21tZW50LlxuICAgICAgc2V0VGV4dENvbnRlbnQobm9kZUFmdGVyQ29tbWVudCwgc3RyaW5nVGV4dCk7XG4gICAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG5vZGVBZnRlckNvbW1lbnQsIGNsb3NpbmdDb21tZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShvcGVuaW5nQ29tbWVudCkuX2RlYnVnSUQsICdyZXBsYWNlIHRleHQnLCBzdHJpbmdUZXh0KTtcbiAgfVxufVxuXG52YXIgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAgPSBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IGZ1bmN0aW9uIChvbGRDaGlsZCwgbWFya3VwLCBwcmV2SW5zdGFuY2UpIHtcbiAgICBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkQ2hpbGQsIG1hcmt1cCk7XG4gICAgaWYgKHByZXZJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihwcmV2SW5zdGFuY2UuX2RlYnVnSUQsICdyZXBsYWNlIHdpdGgnLCBtYXJrdXAudG9TdHJpbmcoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0SW5zdGFuY2UgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShtYXJrdXAubm9kZSk7XG4gICAgICBpZiAobmV4dEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24obmV4dEluc3RhbmNlLl9kZWJ1Z0lELCAnbW91bnQnLCBtYXJrdXAudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIHVwZGF0aW5nIHdpdGggRE9NIGNoaWxkcmVuLlxuICovXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0ge1xuXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCxcblxuICByZXBsYWNlRGVsaW1pdGVkVGV4dDogcmVwbGFjZURlbGltaXRlZFRleHQsXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuIFRoZVxuICAgKiB1cGRhdGUgY29uZmlndXJhdGlvbnMgYXJlIGVhY2ggZXhwZWN0ZWQgdG8gaGF2ZSBhIGBwYXJlbnROb2RlYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NVcGRhdGVzOiBmdW5jdGlvbiAocGFyZW50Tm9kZSwgdXBkYXRlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGFyZW50Tm9kZURlYnVnSUQgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShwYXJlbnROb2RlKS5fZGVidWdJRDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHVwZGF0ZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciB1cGRhdGUgPSB1cGRhdGVzW2tdO1xuICAgICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVA6XG4gICAgICAgICAgaW5zZXJ0TGF6eVRyZWVDaGlsZEF0KHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50LCBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgdXBkYXRlLmFmdGVyTm9kZSkpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHBhcmVudE5vZGVEZWJ1Z0lELCAnaW5zZXJ0IGNoaWxkJywgeyB0b0luZGV4OiB1cGRhdGUudG9JbmRleCwgY29udGVudDogdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuTU9WRV9FWElTVElORzpcbiAgICAgICAgICBtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgdXBkYXRlLmZyb21Ob2RlLCBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgdXBkYXRlLmFmdGVyTm9kZSkpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHBhcmVudE5vZGVEZWJ1Z0lELCAnbW92ZSBjaGlsZCcsIHsgZnJvbUluZGV4OiB1cGRhdGUuZnJvbUluZGV4LCB0b0luZGV4OiB1cGRhdGUudG9JbmRleCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuU0VUX01BUktVUDpcbiAgICAgICAgICBzZXRJbm5lckhUTUwocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHBhcmVudE5vZGVEZWJ1Z0lELCAncmVwbGFjZSBjaGlsZHJlbicsIHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5URVhUX0NPTlRFTlQ6XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHBhcmVudE5vZGVEZWJ1Z0lELCAncmVwbGFjZSB0ZXh0JywgdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFOlxuICAgICAgICAgIHJlbW92ZUNoaWxkKHBhcmVudE5vZGUsIHVwZGF0ZS5mcm9tTm9kZSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdyZW1vdmUgY2hpbGQnLCB7IGZyb21JbmRleDogdXBkYXRlLmZyb21JbmRleCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NQ2hpbGRyZW5PcGVyYXRpb25zO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTUxhenlUcmVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NTmFtZXNwYWNlcyA9IHJlcXVpcmUoJy4vRE9NTmFtZXNwYWNlcycpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uJyk7XG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XG5cbi8qKlxuICogSW4gSUUgKDgtMTEpIGFuZCBFZGdlLCBhcHBlbmRpbmcgbm9kZXMgd2l0aCBubyBjaGlsZHJlbiBpcyBkcmFtYXRpY2FsbHlcbiAqIGZhc3RlciB0aGFuIGFwcGVuZGluZyBhIGZ1bGwgc3VidHJlZSwgc28gd2UgZXNzZW50aWFsbHkgcXVldWUgdXAgdGhlXG4gKiAuYXBwZW5kQ2hpbGQgY2FsbHMgaGVyZSBhbmQgYXBwbHkgdGhlbSBzbyBlYWNoIG5vZGUgaXMgYWRkZWQgdG8gaXRzIHBhcmVudFxuICogYmVmb3JlIGFueSBjaGlsZHJlbiBhcmUgYWRkZWQuXG4gKlxuICogSW4gb3RoZXIgYnJvd3NlcnMsIGRvaW5nIHNvIGlzIHNsb3dlciBvciBuZXV0cmFsIGNvbXBhcmVkIHRvIHRoZSBvdGhlciBvcmRlclxuICogKGluIEZpcmVmb3gsIHR3aWNlIGFzIHNsb3cpIHNvIHdlIG9ubHkgZG8gdGhpcyBpbnZlcnNpb24gaW4gSUUuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zcGljeWovaW5uZXJodG1sLXZzLWNyZWF0ZWVsZW1lbnQtdnMtY2xvbmVub2RlLlxuICovXG52YXIgZW5hYmxlTGF6eSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmRvY3VtZW50TW9kZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQgPT09ICdzdHJpbmcnICYmIC9cXGJFZGdlXFwvXFxkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5mdW5jdGlvbiBpbnNlcnRUcmVlQ2hpbGRyZW4odHJlZSkge1xuICBpZiAoIWVuYWJsZUxhenkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5vZGUgPSB0cmVlLm5vZGU7XG4gIHZhciBjaGlsZHJlbiA9IHRyZWUuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnNlcnRUcmVlQmVmb3JlKG5vZGUsIGNoaWxkcmVuW2ldLCBudWxsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHJlZS5odG1sICE9IG51bGwpIHtcbiAgICBzZXRJbm5lckhUTUwobm9kZSwgdHJlZS5odG1sKTtcbiAgfSBlbHNlIGlmICh0cmVlLnRleHQgIT0gbnVsbCkge1xuICAgIHNldFRleHRDb250ZW50KG5vZGUsIHRyZWUudGV4dCk7XG4gIH1cbn1cblxudmFyIGluc2VydFRyZWVCZWZvcmUgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChwYXJlbnROb2RlLCB0cmVlLCByZWZlcmVuY2VOb2RlKSB7XG4gIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZW4ndCBhY3R1YWxseSBwYXJ0IG9mIHRoZSBET00gYWZ0ZXIgaW5zZXJ0aW9uIHNvXG4gIC8vIGFwcGVuZGluZyBjaGlsZHJlbiB3b24ndCB1cGRhdGUgdGhlIERPTS4gV2UgbmVlZCB0byBlbnN1cmUgdGhlIGZyYWdtZW50XG4gIC8vIGlzIHByb3Blcmx5IHBvcHVsYXRlZCBmaXJzdCwgYnJlYWtpbmcgb3V0IG9mIG91ciBsYXp5IGFwcHJvYWNoIGZvciBqdXN0XG4gIC8vIHRoaXMgbGV2ZWwuIEFsc28sIHNvbWUgPG9iamVjdD4gcGx1Z2lucyAobGlrZSBGbGFzaCBQbGF5ZXIpIHdpbGwgcmVhZFxuICAvLyA8cGFyYW0+IG5vZGVzIGltbWVkaWF0ZWx5IHVwb24gaW5zZXJ0aW9uIGludG8gdGhlIERPTSwgc28gPG9iamVjdD5cbiAgLy8gbXVzdCBhbHNvIGJlIHBvcHVsYXRlZCBwcmlvciB0byBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICBpZiAodHJlZS5ub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgfHwgdHJlZS5ub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSAmJiB0cmVlLm5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdCcgJiYgKHRyZWUubm9kZS5uYW1lc3BhY2VVUkkgPT0gbnVsbCB8fCB0cmVlLm5vZGUubmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpKSB7XG4gICAgaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpO1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRyZWUubm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodHJlZS5ub2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgICBpbnNlcnRUcmVlQ2hpbGRyZW4odHJlZSk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiByZXBsYWNlQ2hpbGRXaXRoVHJlZShvbGROb2RlLCBuZXdUcmVlKSB7XG4gIG9sZE5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3VHJlZS5ub2RlLCBvbGROb2RlKTtcbiAgaW5zZXJ0VHJlZUNoaWxkcmVuKG5ld1RyZWUpO1xufVxuXG5mdW5jdGlvbiBxdWV1ZUNoaWxkKHBhcmVudFRyZWUsIGNoaWxkVHJlZSkge1xuICBpZiAoZW5hYmxlTGF6eSkge1xuICAgIHBhcmVudFRyZWUuY2hpbGRyZW4ucHVzaChjaGlsZFRyZWUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudFRyZWUubm9kZS5hcHBlbmRDaGlsZChjaGlsZFRyZWUubm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVldWVIVE1MKHRyZWUsIGh0bWwpIHtcbiAgaWYgKGVuYWJsZUxhenkpIHtcbiAgICB0cmVlLmh0bWwgPSBodG1sO1xuICB9IGVsc2Uge1xuICAgIHNldElubmVySFRNTCh0cmVlLm5vZGUsIGh0bWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHF1ZXVlVGV4dCh0cmVlLCB0ZXh0KSB7XG4gIGlmIChlbmFibGVMYXp5KSB7XG4gICAgdHJlZS50ZXh0ID0gdGV4dDtcbiAgfSBlbHNlIHtcbiAgICBzZXRUZXh0Q29udGVudCh0cmVlLm5vZGUsIHRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy5ub2RlLm5vZGVOYW1lO1xufVxuXG5mdW5jdGlvbiBET01MYXp5VHJlZShub2RlKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogbm9kZSxcbiAgICBjaGlsZHJlbjogW10sXG4gICAgaHRtbDogbnVsbCxcbiAgICB0ZXh0OiBudWxsLFxuICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICB9O1xufVxuXG5ET01MYXp5VHJlZS5pbnNlcnRUcmVlQmVmb3JlID0gaW5zZXJ0VHJlZUJlZm9yZTtcbkRPTUxhenlUcmVlLnJlcGxhY2VDaGlsZFdpdGhUcmVlID0gcmVwbGFjZUNoaWxkV2l0aFRyZWU7XG5ET01MYXp5VHJlZS5xdWV1ZUNoaWxkID0gcXVldWVDaGlsZDtcbkRPTUxhenlUcmVlLnF1ZXVlSFRNTCA9IHF1ZXVlSFRNTDtcbkRPTUxhenlUcmVlLnF1ZXVlVGV4dCA9IHF1ZXVlVGV4dDtcblxubW9kdWxlLmV4cG9ydHMgPSBET01MYXp5VHJlZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0RPTUxhenlUcmVlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTU5hbWVzcGFjZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01OYW1lc3BhY2VzID0ge1xuICBodG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsXG4gIG1hdGhtbDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnLFxuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zydcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NTmFtZXNwYWNlcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0RPTU5hbWVzcGFjZXMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2V0SW5uZXJIVE1MXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcblxudmFyIFdISVRFU1BBQ0VfVEVTVCA9IC9eWyBcXHJcXG5cXHRcXGZdLztcbnZhciBOT05WSVNJQkxFX1RFU1QgPSAvPCghLS18bGlua3xub3NjcmlwdHxtZXRhfHNjcmlwdHxzdHlsZSlbIFxcclxcblxcdFxcZlxcLz5dLztcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcblxuLy8gU1ZHIHRlbXAgY29udGFpbmVyIGZvciBJRSBsYWNraW5nIGlubmVySFRNTFxudmFyIHJldXNhYmxlU1ZHQ29udGFpbmVyO1xuXG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuc3ZnICYmICEoJ2lubmVySFRNTCcgaW4gbm9kZSkpIHtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHJldXNhYmxlU1ZHQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyLmlubmVySFRNTCA9ICc8c3ZnPicgKyBodG1sICsgJzwvc3ZnPic7XG4gICAgdmFyIG5ld05vZGVzID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZC5jaGlsZE5vZGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobmV3Tm9kZXNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gIH1cbn0pO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFODogV2hlbiB1cGRhdGluZyBhIGp1c3QgY3JlYXRlZCBub2RlIHdpdGggaW5uZXJIVE1MIG9ubHkgbGVhZGluZ1xuICAvLyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQuIFdoZW4gdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZSB3aXRoIGlubmVySFRNTFxuICAvLyB3aGl0ZXNwYWNlIGluIHJvb3QgVGV4dE5vZGVzIGlzIGFsc28gY29sbGFwc2VkLlxuICAvLyBAc2VlIHF1aXJrc21vZGUub3JnL2J1Z3JlcG9ydHMvYXJjaGl2ZXMvMjAwNC8xMS9pbm5lcmh0bWxfYW5kX3QuaHRtbFxuXG4gIC8vIEZlYXR1cmUgZGV0ZWN0aW9uOyBvbmx5IElFOCBpcyBrbm93biB0byBiZWhhdmUgaW1wcm9wZXJseSBsaWtlIHRoaXMuXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSAnICc7XG4gIGlmICh0ZXN0RWxlbWVudC5pbm5lckhUTUwgPT09ICcnKSB7XG4gICAgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgICAgIC8vIE1hZ2ljIHRoZW9yeTogSUU4IHN1cHBvc2VkbHkgZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiBhZGRlZCBhbmQgdXBkYXRlZFxuICAgICAgLy8gbm9kZXMgd2hlbiBwcm9jZXNzaW5nIGlubmVySFRNTCwgaW5uZXJIVE1MIG9uIHVwZGF0ZWQgbm9kZXMgc3VmZmVyc1xuICAgICAgLy8gZnJvbSB3b3JzZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLiBSZS1hZGRpbmcgYSBub2RlIGxpa2UgdGhpcyB0cmlnZ2Vyc1xuICAgICAgLy8gdGhlIGluaXRpYWwgYW5kIG1vcmUgZmF2b3JhYmxlIHdoaXRlc3BhY2UgYmVoYXZpb3IuXG4gICAgICAvLyBUT0RPOiBXaGF0IHRvIGRvIG9uIGEgZGV0YWNoZWQgbm9kZT9cbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYWxzbyBpbXBsZW1lbnQgYSB3b3JrYXJvdW5kIGZvciBub24tdmlzaWJsZSB0YWdzIGRpc2FwcGVhcmluZyBpbnRvXG4gICAgICAvLyB0aGluIGFpciBvbiBJRTgsIHRoaXMgb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHZpc2libGUgdGV4dFxuICAgICAgLy8gaW4tZnJvbnQgb2YgdGhlIG5vbi12aXNpYmxlIHRhZ3MuIFBpZ2d5YmFjayBvbiB0aGUgd2hpdGVzcGFjZSBmaXhcbiAgICAgIC8vIGFuZCBzaW1wbHkgY2hlY2sgaWYgYW55IG5vbi12aXNpYmxlIHRhZ3MgYXBwZWFyIGluIHRoZSBzb3VyY2UuXG4gICAgICBpZiAoV0hJVEVTUEFDRV9URVNULnRlc3QoaHRtbCkgfHwgaHRtbFswXSA9PT0gJzwnICYmIE5PTlZJU0lCTEVfVEVTVC50ZXN0KGh0bWwpKSB7XG4gICAgICAgIC8vIFJlY292ZXIgbGVhZGluZyB3aGl0ZXNwYWNlIGJ5IHRlbXBvcmFyaWx5IHByZXBlbmRpbmcgYW55IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gXFx1RkVGRiBoYXMgdGhlIHBvdGVudGlhbCBhZHZhbnRhZ2Ugb2YgYmVpbmcgemVyby13aWR0aC9pbnZpc2libGUuXG4gICAgICAgIC8vIFVnbGlmeUpTIGRyb3BzIFUrRkVGRiBjaGFycyB3aGVuIHBhcnNpbmcsIHNvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICAgICAgIC8vIGluIGhvcGVzIHRoYXQgdGhpcyBpcyBwcmVzZXJ2ZWQgZXZlbiBpZiBcIlxcdUZFRkZcIiBpcyB0cmFuc2Zvcm1lZCB0b1xuICAgICAgICAvLyB0aGUgYWN0dWFsIFVuaWNvZGUgY2hhcmFjdGVyIChieSBCYWJlbCwgZm9yIGV4YW1wbGUpLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9ibG9iL3YyLjQuMjAvbGliL3BhcnNlLmpzI0wyMTZcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkVGRikgKyBodG1sO1xuXG4gICAgICAgIC8vIGRlbGV0ZURhdGEgbGVhdmVzIGFuIGVtcHR5IGBUZXh0Tm9kZWAgd2hpY2ggb2Zmc2V0cyB0aGUgaW5kZXggb2YgYWxsXG4gICAgICAgIC8vIGNoaWxkcmVuLiBEZWZpbml0ZWx5IHdhbnQgdG8gYXZvaWQgdGhpcy5cbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUuZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZS5kZWxldGVEYXRhKDAsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0ZXN0RWxlbWVudCA9IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0SW5uZXJIVE1MO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvc2V0SW5uZXJIVE1MLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb25cbiAqL1xuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCBoYXMgJ3Vuc2FmZScgcHJpdmlsZWdlcyAocmVxdWlyZWQgYnkgd2luZG93czggYXBwcylcbiAqL1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIGlmICh0eXBlb2YgTVNBcHAgIT09ICd1bmRlZmluZWQnICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzZXRUZXh0Q29udGVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn07XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgaWYgKCEoJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICAgICAgc2V0SW5uZXJIVE1MKG5vZGUsIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRleHRDb250ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvc2V0VGV4dENvbnRlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBCYXNlZCBvbiB0aGUgZXNjYXBlLWh0bWwgbGlicmFyeSwgd2hpY2ggaXMgdXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgYmVsb3c6XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTMgVEogSG9sb3dheWNodWtcbiAqIENvcHlyaWdodCAoYykgMjAxNSBBbmRyZWFzIEx1YmJlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgVGlhbmNoZW5nIFwiVGltb3RoeVwiIEd1XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG4gKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAqICdTb2Z0d2FyZScpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbiAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG4gKiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXG4gKiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWVxuICogQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcbiAqIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXG4gKiBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgbWF0Y2hIdG1sUmVnRXhwID0gL1tcIicmPD5dLztcblxuLyoqXG4gKiBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIHRoZSBnaXZlbiBzdHJpbmcgb2YgaHRtbC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGVzY2FwZSBmb3IgaW5zZXJ0aW5nIGludG8gSFRNTFxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIHZhciBzdHIgPSAnJyArIHN0cmluZztcbiAgdmFyIG1hdGNoID0gbWF0Y2hIdG1sUmVnRXhwLmV4ZWMoc3RyKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBlc2NhcGU7XG4gIHZhciBodG1sID0gJyc7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0SW5kZXggPSAwO1xuXG4gIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgIGNhc2UgMzQ6XG4gICAgICAgIC8vIFwiXG4gICAgICAgIGVzY2FwZSA9ICcmcXVvdDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIC8vICZcbiAgICAgICAgZXNjYXBlID0gJyZhbXA7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICAvLyAnXG4gICAgICAgIGVzY2FwZSA9ICcmI3gyNzsnOyAvLyBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sOyB1c2VkIHRvIGJlICcmIzM5J1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIC8vIDxcbiAgICAgICAgZXNjYXBlID0gJyZsdDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIC8vID5cbiAgICAgICAgZXNjYXBlID0gJyZndDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XG4gICAgICBodG1sICs9IHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCk7XG4gICAgfVxuXG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlO1xuICB9XG5cbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59XG4vLyBlbmQgY29kZSBjb3BpZWQgYW5kIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWxcblxuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSB7XG4gIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB0ZXh0ID09PSAnbnVtYmVyJykge1xuICAgIC8vIHRoaXMgc2hvcnRjaXJjdWl0IGhlbHBzIHBlcmYgZm9yIHR5cGVzIHRoYXQgd2Uga25vdyB3aWxsIG5ldmVyIGhhdmVcbiAgICAvLyBzcGVjaWFsIGNoYXJhY3RlcnMsIGVzcGVjaWFsbHkgZ2l2ZW4gdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgb2Z0ZW5cbiAgICAvLyBmb3IgbnVtZXJpYyBkb20gaWRzLlxuICAgIHJldHVybiAnJyArIHRleHQ7XG4gIH1cbiAgcmV0dXJuIGVzY2FwZUh0bWwodGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERhbmdlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cCA9IHJlcXVpcmUoJ2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCcpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBEYW5nZXIgPSB7XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGEgbm9kZSB3aXRoIGEgc3RyaW5nIG9mIG1hcmt1cCBhdCBpdHMgY3VycmVudCBwb3NpdGlvbiB3aXRoaW4gaXRzXG4gICAqIHBhcmVudC4gVGhlIG1hcmt1cCBtdXN0IHJlbmRlciBpbnRvIGEgc2luZ2xlIHJvb3Qgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBvbGRDaGlsZCBDaGlsZCBub2RlIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRvIHJlbmRlciBpbiBwbGFjZSBvZiB0aGUgY2hpbGQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXApIHtcbiAgICAhRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZW5kZXIgbWFya3VwIGluIGEgd29ya2VyIHRocmVhZC4gTWFrZSBzdXJlIGB3aW5kb3dgIGFuZCBgZG9jdW1lbnRgIGFyZSBhdmFpbGFibGUgZ2xvYmFsbHkgYmVmb3JlIHJlcXVpcmluZyBSZWFjdCB3aGVuIHVuaXQgdGVzdGluZyBvciB1c2UgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IF9wcm9kSW52YXJpYW50KCc1NicpIDogdm9pZCAwO1xuICAgICFtYXJrdXAgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogTWlzc2luZyBtYXJrdXAuJykgOiBfcHJvZEludmFyaWFudCgnNTcnKSA6IHZvaWQgMDtcbiAgICAhKG9sZENoaWxkLm5vZGVOYW1lICE9PSAnSFRNTCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZXBsYWNlIG1hcmt1cCBvZiB0aGUgPGh0bWw+IG5vZGUuIFRoaXMgaXMgYmVjYXVzZSBicm93c2VyIHF1aXJrcyBtYWtlIHRoaXMgdW5yZWxpYWJsZSBhbmQvb3Igc2xvdy4gSWYgeW91IHdhbnQgdG8gcmVuZGVyIHRvIHRoZSByb290IHlvdSBtdXN0IHVzZSBzZXJ2ZXIgcmVuZGVyaW5nLiBTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKS4nKSA6IF9wcm9kSW52YXJpYW50KCc1OCcpIDogdm9pZCAwO1xuXG4gICAgaWYgKHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBlbXB0eUZ1bmN0aW9uKVswXTtcbiAgICAgIG9sZENoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0NoaWxkLCBvbGRDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIERPTUxhenlUcmVlLnJlcGxhY2VDaGlsZFdpdGhUcmVlKG9sZENoaWxkLCBtYXJrdXApO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhbmdlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0Rhbmdlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwqL1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJy4vY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZSgnLi9nZXRNYXJrdXBXcmFwJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byByZW5kZXIgYWxsIG1hcmt1cC5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBQYXR0ZXJuIHVzZWQgYnkgYGdldE5vZGVOYW1lYC5cbiAqL1xudmFyIG5vZGVOYW1lUGF0dGVybiA9IC9eXFxzKjwoXFx3KykvO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBgbm9kZU5hbWVgIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobWFya3VwKSB7XG4gIHZhciBub2RlTmFtZU1hdGNoID0gbWFya3VwLm1hdGNoKG5vZGVOYW1lUGF0dGVybik7XG4gIHJldHVybiBub2RlTmFtZU1hdGNoICYmIG5vZGVOYW1lTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5vZGVzIHJlbmRlcmVkIGZyb20gdGhlIHN1cHBsaWVkIG1hcmt1cC4gVGhlXG4gKiBvcHRpb25hbGx5IHN1cHBsaWVkIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbmNlIGZvciBlYWNoXG4gKiA8c2NyaXB0PiBlbGVtZW50IHRoYXQgaXMgcmVuZGVyZWQuIElmIG5vIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIGlzIHN1cHBsaWVkLFxuICogYW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiBhbnkgPHNjcmlwdD4gZWxlbWVudHMgYXJlIHJlbmRlcmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgQSBzdHJpbmcgb2YgdmFsaWQgSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gaGFuZGxlU2NyaXB0IEludm9rZWQgb25jZSBmb3IgZWFjaCByZW5kZXJlZCA8c2NyaXB0Pi5cbiAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnR8RE9NVGV4dE5vZGU+fSBBbiBhcnJheSBvZiByZW5kZXJlZCBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgaGFuZGxlU2NyaXB0KSB7XG4gIHZhciBub2RlID0gZHVtbXlOb2RlO1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwIGR1bW15IG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIG5vZGVOYW1lID0gZ2V0Tm9kZU5hbWUobWFya3VwKTtcblxuICB2YXIgd3JhcCA9IG5vZGVOYW1lICYmIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpO1xuICBpZiAod3JhcCkge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gd3JhcFsxXSArIG1hcmt1cCArIHdyYXBbMl07XG5cbiAgICB2YXIgd3JhcERlcHRoID0gd3JhcFswXTtcbiAgICB3aGlsZSAod3JhcERlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBtYXJrdXA7XG4gIH1cblxuICB2YXIgc2NyaXB0cyA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICBpZiAoc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAhaGFuZGxlU2NyaXB0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCguLi4pOiBVbmV4cGVjdGVkIDxzY3JpcHQ+IGVsZW1lbnQgcmVuZGVyZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNyZWF0ZUFycmF5RnJvbU1peGVkKHNjcmlwdHMpLmZvckVhY2goaGFuZGxlU2NyaXB0KTtcbiAgfVxuXG4gIHZhciBub2RlcyA9IEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKTtcbiAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byBhcnJheXMuXG4gKlxuICogVGhpcyBBUEkgYXNzdW1lcyB0aGUgY2FsbGVyIGtub3dzIHRoZSBjb250ZW50cyBvZiB0aGUgZGF0YSB0eXBlLiBGb3IgbGVzc1xuICogd2VsbCBkZWZpbmVkIGlucHV0cyB1c2UgY3JlYXRlQXJyYXlGcm9tTWl4ZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb258ZmlsZWxpc3R9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHZhciBsZW5ndGggPSBvYmoubGVuZ3RoO1xuXG4gIC8vIFNvbWUgYnJvd3NlcnMgYnVpbHRpbiBvYmplY3RzIGNhbiByZXBvcnQgdHlwZW9mICdmdW5jdGlvbicgKGUuZy4gTm9kZUxpc3RcbiAgLy8gaW4gb2xkIHZlcnNpb25zIG9mIFNhZmFyaSkuXG4gICEoIUFycmF5LmlzQXJyYXkob2JqKSAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IEFycmF5LWxpa2Ugb2JqZWN0IGV4cGVjdGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEodHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBuZWVkcyBhIGxlbmd0aCBwcm9wZXJ0eScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKGxlbmd0aCA9PT0gMCB8fCBsZW5ndGggLSAxIGluIG9iaikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IHNob3VsZCBoYXZlIGtleXMgZm9yIGluZGljZXMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgISh0eXBlb2Ygb2JqLmNhbGxlZSAhPT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IGNhblxcJ3QgYmUgYGFyZ3VtZW50c2AuIFVzZSByZXN0IHBhcmFtcyAnICsgJyhmdW5jdGlvbiguLi5hcmdzKSB7fSkgb3IgQXJyYXkuZnJvbSgpIGluc3RlYWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIC8vIE9sZCBJRSBkb2Vzbid0IGdpdmUgY29sbGVjdGlvbnMgYWNjZXNzIHRvIGhhc093blByb3BlcnR5LiBBc3N1bWUgaW5wdXRzXG4gIC8vIHdpdGhvdXQgbWV0aG9kIHdpbGwgdGhyb3cgZHVyaW5nIHRoZSBzbGljZSBjYWxsIGFuZCBza2lwIHN0cmFpZ2h0IHRvIHRoZVxuICAvLyBmYWxsYmFjay5cbiAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRSA8IDkgZG9lcyBub3Qgc3VwcG9ydCBBcnJheSNzbGljZSBvbiBjb2xsZWN0aW9ucyBvYmplY3RzXG4gICAgfVxuICB9XG5cbiAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcga2V5IGJ5IGtleS4gVGhpcyBhc3N1bWVzIGFsbCBrZXlzIGhhdmUgYSB2YWx1ZSxcbiAgLy8gc28gd2lsbCBub3QgcHJlc2VydmUgc3BhcnNlbHkgcG9wdWxhdGVkIGlucHV0cy5cbiAgdmFyIHJldCA9IEFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW5ndGg7IGlpKyspIHtcbiAgICByZXRbaWldID0gb2JqW2lpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFBlcmZvcm0gYSBoZXVyaXN0aWMgdGVzdCB0byBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIFwiYXJyYXktbGlrZVwiLlxuICpcbiAqICAgQSBtb25rIGFza2VkIEpvc2h1LCBhIFplbiBtYXN0ZXIsIFwiSGFzIGEgZG9nIEJ1ZGRoYSBuYXR1cmU/XCJcbiAqICAgSm9zaHUgcmVwbGllZDogXCJNdS5cIlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiBpdHMgYXJndW1lbnQgaGFzIFwiYXJyYXkgbmF0dXJlXCI6IGl0IHJldHVybnNcbiAqIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFjdHVhbCBhcnJheSwgYW4gYGFyZ3VtZW50cycgb2JqZWN0LCBvciBhblxuICogSFRNTENvbGxlY3Rpb24gKGUuZy4gbm9kZS5jaGlsZE5vZGVzIG9yIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSkuXG4gKlxuICogSXQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIG90aGVyIGFycmF5LWxpa2Ugb2JqZWN0cyBsaWtlIEZpbGVsaXN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNBcnJheU5hdHVyZShvYmopIHtcbiAgcmV0dXJuIChcbiAgICAvLyBub3QgbnVsbC9mYWxzZVxuICAgICEhb2JqICYmIChcbiAgICAvLyBhcnJheXMgYXJlIG9iamVjdHMsIE5vZGVMaXN0cyBhcmUgZnVuY3Rpb25zIGluIFNhZmFyaVxuICAgIHR5cGVvZiBvYmogPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nKSAmJlxuICAgIC8vIHF1YWNrcyBsaWtlIGFuIGFycmF5XG4gICAgJ2xlbmd0aCcgaW4gb2JqICYmXG4gICAgLy8gbm90IHdpbmRvd1xuICAgICEoJ3NldEludGVydmFsJyBpbiBvYmopICYmXG4gICAgLy8gbm8gRE9NIG5vZGUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYW4gYXJyYXktbGlrZVxuICAgIC8vIGEgJ3NlbGVjdCcgZWxlbWVudCBoYXMgJ2xlbmd0aCcgYW5kICdpdGVtJyBwcm9wZXJ0aWVzIG9uIElFOFxuICAgIHR5cGVvZiBvYmoubm9kZVR5cGUgIT0gJ251bWJlcicgJiYgKFxuICAgIC8vIGEgcmVhbCBhcnJheVxuICAgIEFycmF5LmlzQXJyYXkob2JqKSB8fFxuICAgIC8vIGFyZ3VtZW50c1xuICAgICdjYWxsZWUnIGluIG9iaiB8fFxuICAgIC8vIEhUTUxDb2xsZWN0aW9uL05vZGVMaXN0XG4gICAgJ2l0ZW0nIGluIG9iailcbiAgKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXkgYnkgd3JhcHBpbmcgaXQgaW4gYW4gYXJyYXkgaWYgaXQgaXMgbm90LlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50IGlmIGl0IGlzIGFscmVhZHkgYW4gYXJyYXkuXG4gKlxuICogVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGlkaW9tYXRpY2FsbHk6XG4gKlxuICogICB2YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKCdjcmVhdGVBcnJheUZyb21NaXhlZCcpO1xuICpcbiAqICAgZnVuY3Rpb24gdGFrZXNPbmVPck1vcmVUaGluZ3ModGhpbmdzKSB7XG4gKiAgICAgdGhpbmdzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQodGhpbmdzKTtcbiAqICAgICAuLi5cbiAqICAgfVxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmVhdCBgdGhpbmdzJyBhcyBhbiBhcnJheSwgYnV0IGFjY2VwdCBzY2FsYXJzIGluIHRoZSBBUEkuXG4gKlxuICogSWYgeW91IG5lZWQgdG8gY29udmVydCBhbiBhcnJheS1saWtlIG9iamVjdCwgbGlrZSBgYXJndW1lbnRzYCwgaW50byBhbiBhcnJheVxuICogdXNlIHRvQXJyYXkgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RnJvbU1peGVkKG9iaikge1xuICBpZiAoIWhhc0FycmF5TmF0dXJlKG9iaikpIHtcbiAgICByZXR1cm4gW29ial07XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b0FycmF5KG9iaik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBcnJheUZyb21NaXhlZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvY3JlYXRlQXJyYXlGcm9tTWl4ZWQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwgKi9cblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byBkZXRlY3Qgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeS5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBTb21lIGJyb3dzZXJzIGNhbm5vdCB1c2UgYGlubmVySFRNTGAgdG8gcmVuZGVyIGNlcnRhaW4gZWxlbWVudHMgc3RhbmRhbG9uZSxcbiAqIHNvIHdlIHdyYXAgdGhlbSwgcmVuZGVyIHRoZSB3cmFwcGVkIG5vZGVzLCB0aGVuIGV4dHJhY3QgdGhlIGRlc2lyZWQgbm9kZS5cbiAqXG4gKiBJbiBJRTgsIGNlcnRhaW4gZWxlbWVudHMgY2Fubm90IHJlbmRlciBhbG9uZSwgc28gd3JhcCBhbGwgZWxlbWVudHMgKCcqJykuXG4gKi9cblxudmFyIHNob3VsZFdyYXAgPSB7fTtcblxudmFyIHNlbGVjdFdyYXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJ0cnVlXCI+JywgJzwvc2VsZWN0PiddO1xudmFyIHRhYmxlV3JhcCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xudmFyIHRyV3JhcCA9IFszLCAnPHRhYmxlPjx0Ym9keT48dHI+JywgJzwvdHI+PC90Ym9keT48L3RhYmxlPiddO1xuXG52YXIgc3ZnV3JhcCA9IFsxLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JywgJzwvc3ZnPiddO1xuXG52YXIgbWFya3VwV3JhcCA9IHtcbiAgJyonOiBbMSwgJz88ZGl2PicsICc8L2Rpdj4nXSxcblxuICAnYXJlYSc6IFsxLCAnPG1hcD4nLCAnPC9tYXA+J10sXG4gICdjb2wnOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcbiAgJ2xlZ2VuZCc6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICAncGFyYW0nOiBbMSwgJzxvYmplY3Q+JywgJzwvb2JqZWN0PiddLFxuICAndHInOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcblxuICAnb3B0Z3JvdXAnOiBzZWxlY3RXcmFwLFxuICAnb3B0aW9uJzogc2VsZWN0V3JhcCxcblxuICAnY2FwdGlvbic6IHRhYmxlV3JhcCxcbiAgJ2NvbGdyb3VwJzogdGFibGVXcmFwLFxuICAndGJvZHknOiB0YWJsZVdyYXAsXG4gICd0Zm9vdCc6IHRhYmxlV3JhcCxcbiAgJ3RoZWFkJzogdGFibGVXcmFwLFxuXG4gICd0ZCc6IHRyV3JhcCxcbiAgJ3RoJzogdHJXcmFwXG59O1xuXG4vLyBJbml0aWFsaXplIHRoZSBTVkcgZWxlbWVudHMgc2luY2Ugd2Uga25vdyB0aGV5J2xsIGFsd2F5cyBuZWVkIHRvIGJlIHdyYXBwZWRcbi8vIGNvbnNpc3RlbnRseS4gSWYgdGhleSBhcmUgY3JlYXRlZCBpbnNpZGUgYSA8ZGl2PiB0aGV5IHdpbGwgYmUgaW5pdGlhbGl6ZWQgaW5cbi8vIHRoZSB3cm9uZyBuYW1lc3BhY2UgKGFuZCB3aWxsIG5vdCBkaXNwbGF5KS5cbnZhciBzdmdFbGVtZW50cyA9IFsnY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2RlZnMnLCAnZWxsaXBzZScsICdnJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyR3JhZGllbnQnLCAnbWFzaycsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JywgJ3N0b3AnLCAndGV4dCcsICd0c3BhbiddO1xuc3ZnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobm9kZU5hbWUpIHtcbiAgbWFya3VwV3JhcFtub2RlTmFtZV0gPSBzdmdXcmFwO1xuICBzaG91bGRXcmFwW25vZGVOYW1lXSA9IHRydWU7XG59KTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uIGZvciB0aGUgc3VwcGxpZWQgYG5vZGVOYW1lYC5cbiAqXG4gKiBOT1RFOiBUaGlzIGxhemlseSBkZXRlY3RzIHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIExvd2VyY2FzZSBgbm9kZU5hbWVgLlxuICogQHJldHVybiB7P2FycmF5fSBNYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uLCBpZiBhcHBsaWNhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSB7XG4gICEhIWR1bW15Tm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNYXJrdXAgd3JhcHBpbmcgbm9kZSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGlmICghbWFya3VwV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBub2RlTmFtZSA9ICcqJztcbiAgfVxuICBpZiAoIXNob3VsZFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnKicpIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPGxpbmsgLz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzwnICsgbm9kZU5hbWUgKyAnPjwvJyArIG5vZGVOYW1lICsgJz4nO1xuICAgIH1cbiAgICBzaG91bGRXcmFwW25vZGVOYW1lXSA9ICFkdW1teU5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gc2hvdWxkV3JhcFtub2RlTmFtZV0gPyBtYXJrdXBXcmFwW25vZGVOYW1lXSA6IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFya3VwV3JhcDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvZ2V0TWFya3VwV3JhcC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG4vKipcbiAqIFdoZW4gYSBjb21wb25lbnQncyBjaGlsZHJlbiBhcmUgdXBkYXRlZCwgYSBzZXJpZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdHMgYXJlIGNyZWF0ZWQgaW4gb3JkZXIgdG8gYmF0Y2ggYW5kIHNlcmlhbGl6ZSB0aGUgcmVxdWlyZWQgY2hhbmdlcy5cbiAqXG4gKiBFbnVtZXJhdGVzIGFsbCB0aGUgcG9zc2libGUgdHlwZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICBJTlNFUlRfTUFSS1VQOiBudWxsLFxuICBNT1ZFX0VYSVNUSU5HOiBudWxsLFxuICBSRU1PVkVfTk9ERTogbnVsbCxcbiAgU0VUX01BUktVUDogbnVsbCxcbiAgVEVYVF9DT05URU5UOiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSURPcGVyYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgdXNlZCB0byBwcm9jZXNzIHVwZGF0ZXMgdG8gRE9NIG5vZGVzLlxuICovXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IGZ1bmN0aW9uIChwYXJlbnRJbnN0LCB1cGRhdGVzKSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShwYXJlbnRJbnN0KTtcbiAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMucHJvY2Vzc1VwZGF0ZXMobm9kZSwgdXBkYXRlcyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JRE9wZXJhdGlvbnM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudFxuICovXG5cbi8qIGdsb2JhbCBoYXNPd25Qcm9wZXJ0eTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSByZXF1aXJlKCcuL0F1dG9Gb2N1c1V0aWxzJyk7XG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdERPTUJ1dHRvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01CdXR0b24nKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTUlucHV0ID0gcmVxdWlyZSgnLi9SZWFjdERPTUlucHV0Jyk7XG52YXIgUmVhY3RET01PcHRpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NT3B0aW9uJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0YXJlYScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkJyk7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgRmxhZ3MgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzO1xudmFyIGRlbGV0ZUxpc3RlbmVyID0gRXZlbnRQbHVnaW5IdWIuZGVsZXRlTGlzdGVuZXI7XG52YXIgZ2V0Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlO1xudmFyIGxpc3RlblRvID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvO1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcblxuLy8gRm9yIHF1aWNrbHkgbWF0Y2hpbmcgY2hpbGRyZW4gdHlwZSwgdG8gdGVzdCBpZiBjYW4gYmUgdHJlYXRlZCBhcyBjb250ZW50LlxudmFyIENPTlRFTlRfVFlQRVMgPSB7ICdzdHJpbmcnOiB0cnVlLCAnbnVtYmVyJzogdHJ1ZSB9O1xuXG52YXIgU1RZTEUgPSBrZXlPZih7IHN0eWxlOiBudWxsIH0pO1xudmFyIEhUTUwgPSBrZXlPZih7IF9faHRtbDogbnVsbCB9KTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBudWxsLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IG51bGxcbn07XG5cbi8vIE5vZGUgdHlwZSBmb3IgZG9jdW1lbnQgZnJhZ21lbnRzIChOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpLlxudmFyIERPQ19GUkFHTUVOVF9UWVBFID0gMTE7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShpbnRlcm5hbEluc3RhbmNlKSB7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgdmFyIG93bmVyID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyIHx8IG51bGw7XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnIFRoaXMgRE9NIG5vZGUgd2FzIHJlbmRlcmVkIGJ5IGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZnJpZW5kbHlTdHJpbmdpZnkob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiAnWycgKyBvYmoubWFwKGZyaWVuZGx5U3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICB2YXIga2V5RXNjYXBlZCA9IC9eW2EteiRfXVtcXHckX10qJC9pLnRlc3Qoa2V5KSA/IGtleSA6IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICAgICAgcGFpcnMucHVzaChrZXlFc2NhcGVkICsgJzogJyArIGZyaWVuZGx5U3RyaW5naWZ5KG9ialtrZXldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAneycgKyBwYWlycy5qb2luKCcsICcpICsgJ30nO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gJ1tmdW5jdGlvbiBvYmplY3RdJztcbiAgfVxuICAvLyBEaWZmZXJzIGZyb20gSlNPTi5zdHJpbmdpZnkgaW4gdGhhdCB1bmRlZmluZWQgYmVjYXVzZSB1bmRlZmluZWQgYW5kIHRoYXRcbiAgLy8gaW5mIGFuZCBuYW4gZG9uJ3QgYmVjb21lIG51bGxcbiAgcmV0dXJuIFN0cmluZyhvYmopO1xufVxuXG52YXIgc3R5bGVNdXRhdGlvbldhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHN0eWxlMSwgc3R5bGUyLCBjb21wb25lbnQpIHtcbiAgaWYgKHN0eWxlMSA9PSBudWxsIHx8IHN0eWxlMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzaGFsbG93RXF1YWwoc3R5bGUxLCBzdHlsZTIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuX3RhZztcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcikge1xuICAgIG93bmVyTmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgfVxuXG4gIHZhciBoYXNoID0gb3duZXJOYW1lICsgJ3wnICsgY29tcG9uZW50TmFtZTtcblxuICBpZiAoc3R5bGVNdXRhdGlvbldhcm5pbmcuaGFzT3duUHJvcGVydHkoaGFzaCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdHlsZU11dGF0aW9uV2FybmluZ1toYXNoXSA9IHRydWU7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgJXNgIHdhcyBwYXNzZWQgYSBzdHlsZSBvYmplY3QgdGhhdCBoYXMgcHJldmlvdXNseSBiZWVuIG11dGF0ZWQuICcgKyAnTXV0YXRpbmcgYHN0eWxlYCBpcyBkZXByZWNhdGVkLiBDb25zaWRlciBjbG9uaW5nIGl0IGJlZm9yZWhhbmQuIENoZWNrICcgKyAndGhlIGByZW5kZXJgICVzLiBQcmV2aW91cyBzdHlsZTogJXMuIE11dGF0ZWQgc3R5bGU6ICVzLicsIGNvbXBvbmVudE5hbWUsIG93bmVyID8gJ29mIGAnICsgb3duZXJOYW1lICsgJ2AnIDogJ3VzaW5nIDwnICsgY29tcG9uZW50TmFtZSArICc+JywgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUxKSwgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUyKSkgOiB2b2lkIDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBwcm9wc1xuICovXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW2NvbXBvbmVudC5fdGFnXSkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgY29tcG9uZW50Ll90YWcsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyID8gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAnICsgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzEzNycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiBfcHJvZEludmFyaWFudCgnNjAnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogX3Byb2RJbnZhcmlhbnQoJzYxJykgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5pbm5lckhUTUwgPT0gbnVsbCwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLm9uRm9jdXNJbiA9PSBudWxsICYmIHByb3BzLm9uRm9jdXNPdXQgPT0gbnVsbCwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJykgOiB2b2lkIDA7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArIFxcJ2VtXFwnfX0gd2hlbiB1c2luZyBKU1guJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiBfcHJvZEludmFyaWFudCgnNjInLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lciwgdHJhbnNhY3Rpb24pIHtcbiAgaWYgKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIElFOCBoYXMgbm8gQVBJIGZvciBldmVudCBjYXB0dXJpbmcgYW5kIHRoZSBgb25TY3JvbGxgIGV2ZW50IGRvZXNuJ3RcbiAgICAvLyBidWJibGUuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocmVnaXN0cmF0aW9uTmFtZSAhPT0gJ29uU2Nyb2xsJyB8fCBpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSwgJ1RoaXMgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCB0aGUgYG9uU2Nyb2xsYCBldmVudCcpIDogdm9pZCAwO1xuICB9XG4gIHZhciBjb250YWluZXJJbmZvID0gaW5zdC5faG9zdENvbnRhaW5lckluZm87XG4gIHZhciBpc0RvY3VtZW50RnJhZ21lbnQgPSBjb250YWluZXJJbmZvLl9ub2RlICYmIGNvbnRhaW5lckluZm8uX25vZGUubm9kZVR5cGUgPT09IERPQ19GUkFHTUVOVF9UWVBFO1xuICB2YXIgZG9jID0gaXNEb2N1bWVudEZyYWdtZW50ID8gY29udGFpbmVySW5mby5fbm9kZSA6IGNvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG4gIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocHV0TGlzdGVuZXIsIHtcbiAgICBpbnN0OiBpbnN0LFxuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IHJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwdXRMaXN0ZW5lcigpIHtcbiAgdmFyIGxpc3RlbmVyVG9QdXQgPSB0aGlzO1xuICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcihsaXN0ZW5lclRvUHV0Lmluc3QsIGxpc3RlbmVyVG9QdXQucmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXJUb1B1dC5saXN0ZW5lcik7XG59XG5cbmZ1bmN0aW9uIGlucHV0UG9zdE1vdW50KCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIFJlYWN0RE9NSW5wdXQucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxuZnVuY3Rpb24gdGV4dGFyZWFQb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01UZXh0YXJlYS5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xufVxuXG5mdW5jdGlvbiBvcHRpb25Qb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01PcHRpb24ucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxudmFyIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbiA9IGVtcHR5RnVuY3Rpb247XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24gPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIHZhciBoYXNFeGlzdGluZ0NvbnRlbnQgPSB0aGlzLl9jb250ZW50RGVidWdJRCAhPSBudWxsO1xuICAgIHZhciBkZWJ1Z0lEID0gdGhpcy5fZGVidWdJRDtcbiAgICAvLyBUaGlzIElEIHJlcHJlc2VudHMgdGhlIGlubGluZWQgY2hpbGQgdGhhdCBoYXMgbm8gYmFja2luZyBpbnN0YW5jZTpcbiAgICB2YXIgY29udGVudERlYnVnSUQgPSAtZGVidWdJRDtcblxuICAgIGlmIChjb250ZW50ID09IG51bGwpIHtcbiAgICAgIGlmIChoYXNFeGlzdGluZ0NvbnRlbnQpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVW5tb3VudENvbXBvbmVudCh0aGlzLl9jb250ZW50RGVidWdJRCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb250ZW50RGVidWdJRCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY29udGVudERlYnVnSUQgPSBjb250ZW50RGVidWdJRDtcbiAgICBpZiAoaGFzRXhpc3RpbmdDb250ZW50KSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGNvbnRlbnREZWJ1Z0lEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQsIGRlYnVnSUQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgW2NvbnRlbnREZWJ1Z0lEXSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGUgYSBgdHJhcEJ1YmJsZWRFdmVudGAgZm9yIGVhY2hcbnZhciBtZWRpYUV2ZW50cyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJ1xufTtcblxuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudHNMb2NhbCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICAvLyBJZiBhIGNvbXBvbmVudCByZW5kZXJzIHRvIG51bGwgb3IgaWYgYW5vdGhlciBjb21wb25lbnQgZmF0YWxzIGFuZCBjYXVzZXNcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSB0cmVlIHRvIGJlIGNvcnJ1cHRlZCwgYG5vZGVgIGhlcmUgY2FuIGJlIG51bGwuXG4gICFpbnN0Ll9yb290Tm9kZUlEID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ011c3QgYmUgbW91bnRlZCB0byB0cmFwIGV2ZW50cycpIDogX3Byb2RJbnZhcmlhbnQoJzYzJykgOiB2b2lkIDA7XG4gIHZhciBub2RlID0gZ2V0Tm9kZShpbnN0KTtcbiAgIW5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhcEJ1YmJsZWRFdmVudCguLi4pOiBSZXF1aXJlcyBub2RlIHRvIGJlIHJlbmRlcmVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzY0JykgOiB2b2lkIDA7XG5cbiAgc3dpdGNoIChpbnN0Ll90YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wTG9hZCwgJ2xvYWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW107XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzLnB1c2goUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlc1tldmVudF0sIG1lZGlhRXZlbnRzW2V2ZW50XSwgbm9kZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcEVycm9yLCAnZXJyb3InLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcEVycm9yLCAnZXJyb3InLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BMb2FkLCAnbG9hZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFJlc2V0LCAncmVzZXQnLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BTdWJtaXQsICdzdWJtaXQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wSW52YWxpZCwgJ2ludmFsaWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0VXBkYXRlU2VsZWN0V3JhcHBlcigpIHtcbiAgUmVhY3RET01TZWxlY3QucG9zdFVwZGF0ZVdyYXBwZXIodGhpcyk7XG59XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3Mgc2hvdWxkIG9taXQgdGhlaXIgY2xvc2UgdGFnLiBXZSBrZWVwIGEgd2hpdGVsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICAnYXJlYSc6IHRydWUsXG4gICdiYXNlJzogdHJ1ZSxcbiAgJ2JyJzogdHJ1ZSxcbiAgJ2NvbCc6IHRydWUsXG4gICdlbWJlZCc6IHRydWUsXG4gICdocic6IHRydWUsXG4gICdpbWcnOiB0cnVlLFxuICAnaW5wdXQnOiB0cnVlLFxuICAna2V5Z2VuJzogdHJ1ZSxcbiAgJ2xpbmsnOiB0cnVlLFxuICAnbWV0YSc6IHRydWUsXG4gICdwYXJhbSc6IHRydWUsXG4gICdzb3VyY2UnOiB0cnVlLFxuICAndHJhY2snOiB0cnVlLFxuICAnd2JyJzogdHJ1ZVxufTtcblxuLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcbiAgJ2xpc3RpbmcnOiB0cnVlLFxuICAncHJlJzogdHJ1ZSxcbiAgJ3RleHRhcmVhJzogdHJ1ZVxufTtcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gICdtZW51aXRlbSc6IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG4vLyBXZSBhY2NlcHQgYW55IHRhZyB0byBiZSByZW5kZXJlZCBidXQgc2luY2UgdGhpcyBnZXRzIGluamVjdGVkIGludG8gYXJiaXRyYXJ5XG4vLyBIVE1MLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgYSBzYWZlIHRhZy5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVcblxudmFyIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvOyAvLyBTaW1wbGlmaWVkIHN1YnNldFxudmFyIHZhbGlkYXRlZFRhZ0NhY2hlID0ge307XG52YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKSB7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRUYWdDYWNoZSwgdGFnKSkge1xuICAgICFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdGFnOiAlcycsIHRhZykgOiBfcHJvZEludmFyaWFudCgnNjUnLCB0YWcpIDogdm9pZCAwO1xuICAgIHZhbGlkYXRlZFRhZ0NhY2hlW3RhZ10gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIHJldHVybiB0YWdOYW1lLmluZGV4T2YoJy0nKSA+PSAwIHx8IHByb3BzLmlzICE9IG51bGw7XG59XG5cbnZhciBnbG9iYWxJZENvdW50ZXIgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUmVhY3QgY2xhc3MgdGhhdCBpcyBpZGVtcG90ZW50IGFuZCBjYXBhYmxlIG9mIGNvbnRhaW5pbmcgb3RoZXJcbiAqIFJlYWN0IGNvbXBvbmVudHMuIEl0IGFjY2VwdHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBET00gcHJvcGVydGllcyB0aGF0IGFyZVxuICogdmFsaWQgYWNjb3JkaW5nIHRvIGBET01Qcm9wZXJ0eWAuXG4gKlxuICogIC0gRXZlbnQgbGlzdGVuZXJzOiBgb25DbGlja2AsIGBvbk1vdXNlRG93bmAsIGV0Yy5cbiAqICAtIERPTSBwcm9wZXJ0aWVzOiBgY2xhc3NOYW1lYCwgYG5hbWVgLCBgdGl0bGVgLCBldGMuXG4gKlxuICogVGhlIGBzdHlsZWAgcHJvcGVydHkgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZyb20gdGhlIERPTSBBUEkuIEl0IGFjY2VwdHMgYW5cbiAqIG9iamVjdCBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBSZWFjdERPTUNvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RNdWx0aUNoaWxkXG4gKi9cbmZ1bmN0aW9uIFJlYWN0RE9NQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgdmFyIHRhZyA9IGVsZW1lbnQudHlwZTtcbiAgdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKTtcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLl90YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgdGhpcy5fbmFtZXNwYWNlVVJJID0gbnVsbDtcbiAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICB0aGlzLl9kb21JRCA9IDA7XG4gIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gbnVsbDtcbiAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcbiAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcbiAgdGhpcy5fZmxhZ3MgPSAwO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRoaXMuX2FuY2VzdG9ySW5mbyA9IG51bGw7XG4gICAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgbnVsbCk7XG4gIH1cbn1cblxuUmVhY3RET01Db21wb25lbnQuZGlzcGxheU5hbWUgPSAnUmVhY3RET01Db21wb25lbnQnO1xuXG5SZWFjdERPTUNvbXBvbmVudC5NaXhpbiA9IHtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIHJvb3QgdGFnIG1hcmt1cCB0aGVuIHJlY3Vyc2VzLiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGFuZFxuICAgKiBpcyBub3QgaWRlbXBvdGVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9SZWFjdERPTUNvbXBvbmVudH0gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBpbmZvIGFib3V0IHRoZSBob3N0IGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb21wdXRlZCBtYXJrdXAuXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBnbG9iYWxJZENvdW50ZXIrKztcbiAgICB0aGlzLl9kb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IGhvc3RDb250YWluZXJJbmZvO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgICAgICBsaXN0ZW5lcnM6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NQnV0dG9uLmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUlucHV0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01JbnB1dC5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIFJlYWN0RE9NT3B0aW9uLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBSZWFjdERPTVNlbGVjdC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIHByb3BzKTtcblxuICAgIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgICAvLyB0YWdzIGdldCBubyBuYW1lc3BhY2UuXG4gICAgdmFyIG5hbWVzcGFjZVVSSTtcbiAgICB2YXIgcGFyZW50VGFnO1xuICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgIG5hbWVzcGFjZVVSSSA9IGhvc3RQYXJlbnQuX25hbWVzcGFjZVVSSTtcbiAgICAgIHBhcmVudFRhZyA9IGhvc3RQYXJlbnQuX3RhZztcbiAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvLl90YWcpIHtcbiAgICAgIG5hbWVzcGFjZVVSSSA9IGhvc3RDb250YWluZXJJbmZvLl9uYW1lc3BhY2VVUkk7XG4gICAgICBwYXJlbnRUYWcgPSBob3N0Q29udGFpbmVySW5mby5fdGFnO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlVVJJID09IG51bGwgfHwgbmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLnN2ZyAmJiBwYXJlbnRUYWcgPT09ICdmb3JlaWdub2JqZWN0Jykge1xuICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5odG1sO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgIGlmICh0aGlzLl90YWcgPT09ICdzdmcnKSB7XG4gICAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMuc3ZnO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl90YWcgPT09ICdtYXRoJykge1xuICAgICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLm1hdGhtbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbmFtZXNwYWNlVVJJID0gbmFtZXNwYWNlVVJJO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnRJbmZvO1xuICAgICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdFBhcmVudC5fYW5jZXN0b3JJbmZvO1xuICAgICAgfSBlbHNlIGlmIChob3N0Q29udGFpbmVySW5mby5fdGFnKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0Q29udGFpbmVySW5mby5fYW5jZXN0b3JJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudEluZm8pIHtcbiAgICAgICAgLy8gcGFyZW50SW5mbyBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgZXhjZXB0IGZvciB0aGUgdG9wLWxldmVsXG4gICAgICAgIC8vIGNvbXBvbmVudCB3aGVuIHNlcnZlciByZW5kZXJpbmdcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKHRoaXMuX3RhZywgdGhpcywgcGFyZW50SW5mbyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hbmNlc3RvckluZm8gPSB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhwYXJlbnRJbmZvLCB0aGlzLl90YWcsIHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBtb3VudEltYWdlO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICAgICAgdmFyIGVsO1xuICAgICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5odG1sKSB7XG4gICAgICAgIGlmICh0aGlzLl90YWcgPT09ICdzY3JpcHQnKSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIHRoZSBzY3JpcHQgdmlhIC5pbm5lckhUTUwgc28gaXRzIFwicGFyc2VyLWluc2VydGVkXCIgZmxhZyBpc1xuICAgICAgICAgIC8vIHNldCB0byB0cnVlIGFuZCBpdCBkb2VzIG5vdCBleGVjdXRlXG4gICAgICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSAnPCcgKyB0eXBlICsgJz48LycgKyB0eXBlICsgJz4nO1xuICAgICAgICAgIGVsID0gZGl2LnJlbW92ZUNoaWxkKGRpdi5maXJzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5pcykge1xuICAgICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUsIHByb3BzLmlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY3Vhc2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC82ODk2XG4gICAgICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICB9XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKHRoaXMsIGVsKTtcbiAgICAgIHRoaXMuX2ZsYWdzIHw9IEZsYWdzLmhhc0NhY2hlZENoaWxkTm9kZXM7XG4gICAgICBpZiAoIXRoaXMuX2hvc3RQYXJlbnQpIHtcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldEF0dHJpYnV0ZUZvclJvb3QoZWwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhudWxsLCBwcm9wcywgdHJhbnNhY3Rpb24pO1xuICAgICAgdmFyIGxhenlUcmVlID0gRE9NTGF6eVRyZWUoZWwpO1xuICAgICAgdGhpcy5fY3JlYXRlSW5pdGlhbENoaWxkcmVuKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgbGF6eVRyZWUpO1xuICAgICAgbW91bnRJbWFnZSA9IGxhenlUcmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFnT3BlbiA9IHRoaXMuX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnModHJhbnNhY3Rpb24sIHByb3BzKTtcbiAgICAgIHZhciB0YWdDb250ZW50ID0gdGhpcy5fY3JlYXRlQ29udGVudE1hcmt1cCh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgaWYgKCF0YWdDb250ZW50ICYmIG9taXR0ZWRDbG9zZVRhZ3NbdGhpcy5fdGFnXSkge1xuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICcvPic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICc+JyArIHRhZ0NvbnRlbnQgKyAnPC8nICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSArICc+JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGlucHV0UG9zdE1vdW50LCB0aGlzKTtcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRleHRhcmVhUG9zdE1vdW50LCB0aGlzKTtcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShvcHRpb25Qb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbW91bnRJbWFnZTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBvcGVuIHRhZyBhbmQgYWxsIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYmVjYXVzZSBldmVudHMgZ2V0IHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIEl0ZXJhdGluZyBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzIGlzIGZhc3RlciB0aGFuIGl0ZXJhdGluZyBvdmVyIGFycmF5cy5cbiAgICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9vYmotdnMtYXJyLWl0ZXJhdGlvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIG9mIG9wZW5pbmcgdGFnLlxuICAgKi9cbiAgX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnM6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMpIHtcbiAgICB2YXIgcmV0ID0gJzwnICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLCBwcm9wS2V5LCBwcm9wVmFsdWUsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gU2VlIGBfdXBkYXRlRE9NUHJvcGVydGllc2AuIHN0eWxlIGJsb2NrXG4gICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wVmFsdWUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IF9hc3NpZ24oe30sIHByb3BzLnN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvcFZhbHVlID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhwcm9wVmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrdXAgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdGFnICE9IG51bGwgJiYgaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBwcm9wcykpIHtcbiAgICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgICBtYXJrdXAgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlKHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrdXApIHtcbiAgICAgICAgICByZXQgKz0gJyAnICsgbWFya3VwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIHN0YXRpYyBwYWdlcywgbm8gbmVlZCB0byBwdXQgUmVhY3QgSUQgYW5kIGNoZWNrc3VtLiBTYXZlcyBsb3RzIG9mXG4gICAgLy8gYnl0ZXMuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5faG9zdFBhcmVudCkge1xuICAgICAgcmV0ICs9ICcgJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JSb290KCk7XG4gICAgfVxuICAgIHJldCArPSAnICcgKyBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9ySUQodGhpcy5fZG9tSUQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSB0YWdzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udGVudCBtYXJrdXAuXG4gICAqL1xuICBfY3JlYXRlQ29udGVudE1hcmt1cDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCkge1xuICAgIHZhciByZXQgPSAnJztcblxuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgcmV0ID0gaW5uZXJIVE1MLl9faHRtbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgcmV0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKGNvbnRlbnRUb1VzZSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgY29udGVudFRvVXNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgcmV0ID0gbW91bnRJbWFnZXMuam9pbignJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdsaW5lRWF0aW5nVGFnc1t0aGlzLl90YWddICYmIHJldC5jaGFyQXQoMCkgPT09ICdcXG4nKSB7XG4gICAgICAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgICAgIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAgICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgICAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gICAgICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAgIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAgICAgcmV0dXJuICdcXG4nICsgcmV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSxcblxuICBfY3JlYXRlSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBsYXp5VHJlZSkge1xuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVIVE1MKGxhenlUcmVlLCBpbm5lckhUTUwuX19odG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBjb250ZW50VG9Vc2UpO1xuICAgICAgICB9XG4gICAgICAgIERPTUxhenlUcmVlLnF1ZXVlVGV4dChsYXp5VHJlZSwgY29udGVudFRvVXNlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW91bnRJbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBtb3VudEltYWdlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY2VpdmVzIGEgbmV4dCBlbGVtZW50IGFuZCB1cGRhdGVzIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQ7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBjb21wb25lbnQgYWZ0ZXIgaXQgaGFzIGFscmVhZHkgYmVlbiBhbGxvY2F0ZWQgYW5kXG4gICAqIGF0dGFjaGVkIHRvIHRoZSBET00uIFJlY29uY2lsZXMgdGhlIHJvb3QgRE9NIG5vZGUsIHRoZW4gcmVjdXJzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RQcm9wcyA9IHByZXZFbGVtZW50LnByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01CdXR0b24uZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pO1xuICAgIHRoaXMuX3VwZGF0ZURPTUNoaWxkcmVuKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgICAvLyBoYXBwZW4gYWZ0ZXIgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgICAvLyByZWNvbmNpbGlhdGlvblxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBwcm9wZXJ0aWVzIGJ5IGRldGVjdGluZyBkaWZmZXJlbmNlcyBpbiBwcm9wZXJ0eSB2YWx1ZXMgYW5kXG4gICAqIHVwZGF0aW5nIHRoZSBET00gYXMgbmVjZXNzYXJ5LiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JhYmx5IHRoZSBzaW5nbGUgbW9zdFxuICAgKiBjcml0aWNhbCBwYXRoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIFRPRE86IEJlbmNobWFyayB3aGV0aGVyIGNoZWNraW5nIGZvciBjaGFuZ2VkIHZhbHVlcyBpbiBtZW1vcnkgYWN0dWFsbHlcbiAgICogICAgICAgaW1wcm92ZXMgcGVyZm9ybWFuY2UgKGVzcGVjaWFsbHkgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnRzKS5cbiAgICogVE9ETzogQmVuY2htYXJrIHRoZSBlZmZlY3RzIG9mIHB1dHRpbmcgdGhpcyBhdCB0aGUgdG9wIHNpbmNlIDk5JSBvZiBwcm9wc1xuICAgKiAgICAgICBkbyBub3QgY2hhbmdlIGZvciBhIGdpdmVuIHJlY29uY2lsaWF0aW9uLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgYXJlYXMgdGhhdCBjYW4gYmUgaW1wcm92ZWQgd2l0aCBjYWNoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgX3VwZGF0ZURPTVByb3BlcnRpZXM6IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgcHJvcEtleTtcbiAgICB2YXIgc3R5bGVOYW1lO1xuICAgIHZhciBzdHlsZVVwZGF0ZXM7XG4gICAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCAhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IGxhc3RQcm9wc1twcm9wS2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIHZhciBsYXN0U3R5bGUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weTtcbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKSB7XG4gICAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChsYXN0UHJvcHNbcHJvcEtleV0pIHtcbiAgICAgICAgICAvLyBPbmx5IGNhbGwgZGVsZXRlTGlzdGVuZXIgaWYgdGhlcmUgd2FzIGEgbGlzdGVuZXIgcHJldmlvdXNseSBvclxuICAgICAgICAgIC8vIGVsc2Ugd2lsbERlbGV0ZUxpc3RlbmVyIGdldHMgY2FsbGVkIHdoZW4gdGhlcmUgd2Fzbid0IGFjdHVhbGx5IGFcbiAgICAgICAgICAvLyBsaXN0ZW5lciAoZS5nLiwgb25DbGljaz17bnVsbH0pXG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcywgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBsYXN0UHJvcHMpKSB7XG4gICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wS2V5XSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShnZXROb2RlKHRoaXMpLCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgICAgdmFyIGxhc3RQcm9wID0gcHJvcEtleSA9PT0gU1RZTEUgPyB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA6IGxhc3RQcm9wcyAhPSBudWxsID8gbGFzdFByb3BzW3Byb3BLZXldIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5LCB0aGlzLl9wcmV2aW91c1N0eWxlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBuZXh0UHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFByb3AgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IF9hc3NpZ24oe30sIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLCBwcm9wS2V5LCBuZXh0UHJvcCwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcywgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBuZXh0UHJvcHMpKSB7XG4gICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBnZXROb2RlKHRoaXMpO1xuICAgICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgICBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JTdHlsZXMoZ2V0Tm9kZSh0aGlzKSwgc3R5bGVVcGRhdGVzLCB0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHZhcmlvdXMgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGVcbiAgICogY2hpbGRyZW4gY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIF91cGRhdGVET01DaGlsZHJlbjogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBsYXN0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIGxhc3RQcm9wcy5jaGlsZHJlbl0gPyBsYXN0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgIHZhciBuZXh0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIG5leHRQcm9wcy5jaGlsZHJlbl0gPyBuZXh0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuXG4gICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG4gICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG5cbiAgICAvLyBOb3RlIHRoZSB1c2Ugb2YgYCE9YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgIHZhciBsYXN0Q2hpbGRyZW4gPSBsYXN0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IGxhc3RQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBjaGlsZHJlbiB0byBjb250ZW50L2h0bWwgb3IgdmljZSB2ZXJzYSwgcmVtb3ZlXG4gICAgLy8gdGhlIG9sZCBjb250ZW50XG4gICAgdmFyIGxhc3RIYXNDb250ZW50T3JIdG1sID0gbGFzdENvbnRlbnQgIT0gbnVsbCB8fCBsYXN0SHRtbCAhPSBudWxsO1xuICAgIHZhciBuZXh0SGFzQ29udGVudE9ySHRtbCA9IG5leHRDb250ZW50ICE9IG51bGwgfHwgbmV4dEh0bWwgIT0gbnVsbDtcbiAgICBpZiAobGFzdENoaWxkcmVuICE9IG51bGwgJiYgbmV4dENoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obnVsbCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAobGFzdEhhc0NvbnRlbnRPckh0bWwgJiYgIW5leHRIYXNDb250ZW50T3JIdG1sKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmV4dENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RDb250ZW50ICE9PSBuZXh0Q29udGVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnICsgbmV4dENvbnRlbnQpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIG5leHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICB0aGlzLnVwZGF0ZU1hcmt1cCgnJyArIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0Tm9kZSh0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVzdHJveXMgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuIERvZXMgbm90IHJlbW92ZSBmcm9tXG4gICAqIHRoZSBET00uIFRoYXQgbXVzdCBiZSBkb25lIGJ5IHRoZSBwYXJlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHNhZmVseSkge1xuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnbGluayc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnM7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBvbmVudHMgbGlrZSA8aHRtbD4gPGhlYWQ+IGFuZCA8Ym9keT4gY2FuJ3QgYmUgcmVtb3ZlZCBvciBhZGRlZFxuICAgICAgICAgKiBlYXNpbHkgaW4gYSBjcm9zcy1icm93c2VyIHdheSwgaG93ZXZlciBpdCdzIHZhbHVhYmxlIHRvIGJlIGFibGUgdG9cbiAgICAgICAgICogdGFrZSBhZHZhbnRhZ2Ugb2YgUmVhY3QncyByZWNvbmNpbGlhdGlvbiBmb3Igc3R5bGluZyBhbmQgPHRpdGxlPlxuICAgICAgICAgKiBtYW5hZ2VtZW50LiBTbyB3ZSBqdXN0IGRvY3VtZW50IGl0IGFuZCB0aHJvdyBpbiBkYW5nZXJvdXMgY2FzZXMuXG4gICAgICAgICAqL1xuICAgICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnPCVzPiB0cmllZCB0byB1bm1vdW50LiBCZWNhdXNlIG9mIGNyb3NzLWJyb3dzZXIgcXVpcmtzIGl0IGlzIGltcG9zc2libGUgdG8gdW5tb3VudCBzb21lIHRvcC1sZXZlbCBjb21wb25lbnRzIChlZyA8aHRtbD4sIDxoZWFkPiwgYW5kIDxib2R5PikgcmVsaWFibHkgYW5kIGVmZmljaWVudGx5LiBUbyBmaXggdGhpcywgaGF2ZSBhIHNpbmdsZSB0b3AtbGV2ZWwgY29tcG9uZW50IHRoYXQgbmV2ZXIgdW5tb3VudHMgcmVuZGVyIHRoZXNlIGVsZW1lbnRzLicsIHRoaXMuX3RhZykgOiBfcHJvZEludmFyaWFudCgnNjYnLCB0aGlzLl90YWcpIDogdm9pZCAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLnVubW91bnRDaGlsZHJlbihzYWZlbHkpO1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgICBFdmVudFBsdWdpbkh1Yi5kZWxldGVBbGxMaXN0ZW5lcnModGhpcyk7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gICAgdGhpcy5fZG9tSUQgPSAwO1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IG51bGw7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgbnVsbCk7XG4gICAgfVxuICB9LFxuXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldE5vZGUodGhpcyk7XG4gIH1cblxufTtcblxuX2Fzc2lnbihSZWFjdERPTUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0RE9NQ29tcG9uZW50Lk1peGluLCBSZWFjdE11bHRpQ2hpbGQuTWl4aW4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQXV0b0ZvY3VzVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XG5cbnZhciBBdXRvRm9jdXNVdGlscyA9IHtcbiAgZm9jdXNET01Db21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBmb2N1c05vZGUoUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcykpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dG9Gb2N1c1V0aWxzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvQXV0b0ZvY3VzVXRpbHMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9mb2N1c05vZGUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTUHJvcGVydHlPcGVyYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZScpO1xudmFyIGRhbmdlcm91c1N0eWxlVmFsdWUgPSByZXF1aXJlKCcuL2Rhbmdlcm91c1N0eWxlVmFsdWUnKTtcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUnKTtcbnZhciBtZW1vaXplU3RyaW5nT25seSA9IHJlcXVpcmUoJ2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHByb2Nlc3NTdHlsZU5hbWUgPSBtZW1vaXplU3RyaW5nT25seShmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG4gIHJldHVybiBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKTtcbn0pO1xuXG52YXIgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSBmYWxzZTtcbnZhciBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnY3NzRmxvYXQnO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB2YXIgdGVtcFN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHRyeSB7XG4gICAgLy8gSUU4IHRocm93cyBcIkludmFsaWQgYXJndW1lbnQuXCIgaWYgcmVzZXR0aW5nIHNob3J0aGFuZCBzdHlsZSBwcm9wZXJ0aWVzLlxuICAgIHRlbXBTdHlsZS5mb250ID0gJyc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IHRydWU7XG4gIH1cbiAgLy8gSUU4IG9ubHkgc3VwcG9ydHMgYWNjZXNzaW5nIGNzc0Zsb2F0IChzdGFuZGFyZCkgYXMgc3R5bGVGbG9hdFxuICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmNzc0Zsb2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnc3R5bGVGbG9hdCc7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuXG4gIC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG5cbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBjYW1lbGl6ZVN0eWxlTmFtZShuYW1lKSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG5cXCd0IGNvbnRhaW4gYSBzZW1pY29sb24uJXMgJyArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lciksIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4lcycsIG5hbWUsIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciBjaGVja1JlbmRlck1lc3NhZ2UgPSBmdW5jdGlvbiAob3duZXIpIHtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICAgKi9cbiAgdmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBjb21wb25lbnQpIHtcbiAgICB2YXIgb3duZXI7XG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICB9XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUsIG93bmVyKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSwgb3duZXIpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUsIG93bmVyKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUsIG93bmVyKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIGZvciB1c2UgYXMgaW5saW5lIHN0eWxlczpcbiAgICpcbiAgICogICA+IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyh7d2lkdGg6ICcyMDBweCcsIGhlaWdodDogMH0pXG4gICAqICAgXCJ3aWR0aDoyMDBweDtoZWlnaHQ6MDtcIlxuICAgKlxuICAgKiBVbmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkIHNvIHRoYXQgZGVjbGFyYXRpdmUgcHJvZ3JhbW1pbmcgaXMgZWFzaWVyLlxuICAgKiBUaGUgcmVzdWx0IHNob3VsZCBiZSBIVE1MLWVzY2FwZWQgYmVmb3JlIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JTdHlsZXM6IGZ1bmN0aW9uIChzdHlsZXMsIGNvbXBvbmVudCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQpICsgJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gICAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG4gIHNldFZhbHVlRm9yU3R5bGVzOiBmdW5jdGlvbiAobm9kZSwgc3R5bGVzLCBjb21wb25lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihjb21wb25lbnQuX2RlYnVnSUQsICd1cGRhdGUgc3R5bGVzJywgc3R5bGVzKTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGNvbXBvbmVudCk7XG4gICAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnIHx8IHN0eWxlTmFtZSA9PT0gJ2Nzc0Zsb2F0Jykge1xuICAgICAgICBzdHlsZU5hbWUgPSBzdHlsZUZsb2F0QWNjZXNzb3I7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyAmJiBDU1NQcm9wZXJ0eS5zaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbikge1xuICAgICAgICAgIC8vIFNob3J0aGFuZCBwcm9wZXJ0eSB0aGF0IElFOCB3b24ndCBsaWtlIHVuc2V0dGluZywgc28gdW5zZXQgZWFjaFxuICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBwbGFjYXRlIGl0XG4gICAgICAgICAgZm9yICh2YXIgaW5kaXZpZHVhbFN0eWxlTmFtZSBpbiBleHBhbnNpb24pIHtcbiAgICAgICAgICAgIHN0eWxlW2luZGl2aWR1YWxTdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBNb3N0IHN0eWxlIHByb3BlcnRpZXMgY2FuIGJlIHVuc2V0IGJ5IGRvaW5nIC5zdHlsZVtwcm9wXSA9ICcnIGJ1dCBJRThcbiAqIGRvZXNuJ3QgbGlrZSBkb2luZyB0aGF0IHdpdGggc2hvcnRoYW5kIHByb3BlcnRpZXMgc28gZm9yIHRoZSBwcm9wZXJ0aWVzIHRoYXRcbiAqIElFOCBicmVha3Mgb24sIHdoaWNoIGFyZSBsaXN0ZWQgaGVyZSwgd2UgaW5zdGVhZCB1bnNldCBlYWNoIG9mIHRoZVxuICogaW5kaXZpZHVhbCBwcm9wZXJ0aWVzLiBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzODUuXG4gKiBUaGUgNC12YWx1ZSAnY2xvY2snIHByb3BlcnRpZXMgbGlrZSBtYXJnaW4sIHBhZGRpbmcsIGJvcmRlci13aWR0aCBzZWVtIHRvXG4gKiBiZWhhdmUgd2l0aG91dCBhbnkgcHJvYmxlbXMuIEN1cmlvdXNseSwgbGlzdC1zdHlsZSB3b3JrcyB0b28gd2l0aG91dCBhbnlcbiAqIHNwZWNpYWwgcHJvZGRpbmcuXG4gKi9cbnZhciBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnMgPSB7XG4gIGJhY2tncm91bmQ6IHtcbiAgICBiYWNrZ3JvdW5kQXR0YWNobWVudDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXG4gICAgYmFja2dyb3VuZEltYWdlOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiB0cnVlXG4gIH0sXG4gIGJhY2tncm91bmRQb3NpdGlvbjoge1xuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZVxuICB9LFxuICBib3JkZXI6IHtcbiAgICBib3JkZXJXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJCb3R0b206IHtcbiAgICBib3JkZXJCb3R0b21XaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21TdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21Db2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJMZWZ0OiB7XG4gICAgYm9yZGVyTGVmdFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckxlZnRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyUmlnaHQ6IHtcbiAgICBib3JkZXJSaWdodFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJUb3A6IHtcbiAgICBib3JkZXJUb3BXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJUb3BTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJUb3BDb2xvcjogdHJ1ZVxuICB9LFxuICBmb250OiB7XG4gICAgZm9udFN0eWxlOiB0cnVlLFxuICAgIGZvbnRWYXJpYW50OiB0cnVlLFxuICAgIGZvbnRXZWlnaHQ6IHRydWUsXG4gICAgZm9udFNpemU6IHRydWUsXG4gICAgbGluZUhlaWdodDogdHJ1ZSxcbiAgICBmb250RmFtaWx5OiB0cnVlXG4gIH0sXG4gIG91dGxpbmU6IHtcbiAgICBvdXRsaW5lV2lkdGg6IHRydWUsXG4gICAgb3V0bGluZVN0eWxlOiB0cnVlLFxuICAgIG91dGxpbmVDb2xvcjogdHJ1ZVxuICB9XG59O1xuXG52YXIgQ1NTUHJvcGVydHkgPSB7XG4gIGlzVW5pdGxlc3NOdW1iZXI6IGlzVW5pdGxlc3NOdW1iZXIsXG4gIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uczogc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHkuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoJy4vY2FtZWxpemUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbW96LXRyYW5zaXRpb24nKVxuICogICA8IFwiTW96VHJhbnNpdGlvblwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcbiAqICAgPCBcIm1zVHJhbnNpdGlvblwiXG4gKlxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICogKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemVTdHlsZU5hbWU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9jYW1lbGl6ZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBkYW5nZXJvdXNTdHlsZVZhbHVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyO1xudmFyIHN0eWxlV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBjb21wb25lbnQpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBpc05vbk51bWVyaWMgPSBpc05hTih2YWx1ZSk7XG4gIGlmIChpc05vbk51bWVyaWMgfHwgdmFsdWUgPT09IDAgfHwgaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7IC8vIGNhc3QgdG8gc3RyaW5nXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBBbGxvdyAnMCcgdG8gcGFzcyB0aHJvdWdoIHdpdGhvdXQgd2FybmluZy4gMCBpcyBhbHJlYWR5IHNwZWNpYWwgYW5kXG4gICAgICAvLyBkb2Vzbid0IHJlcXVpcmUgdW5pdHMsIHNvIHdlIGRvbid0IG5lZWQgdG8gd2FybiBhYm91dCBpdC5cbiAgICAgIGlmIChjb21wb25lbnQgJiYgdmFsdWUgIT09ICcwJykge1xuICAgICAgICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gb3duZXIuZ2V0TmFtZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKG93bmVyTmFtZSAmJiAhc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdKSB7XG4gICAgICAgICAgc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgdmFyIHdhcm5pbmdzID0gc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdO1xuICAgICAgICAgIHdhcm5lZCA9IHdhcm5pbmdzW25hbWVdO1xuICAgICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICB3YXJuaW5nc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdhIGAlc2AgdGFnIChvd25lcjogYCVzYCkgd2FzIHBhc3NlZCBhIG51bWVyaWMgc3RyaW5nIHZhbHVlICcgKyAnZm9yIENTUyBwcm9wZXJ0eSBgJXNgICh2YWx1ZTogYCVzYCkgd2hpY2ggd2lsbCBiZSB0cmVhdGVkICcgKyAnYXMgYSB1bml0bGVzcyBudW1iZXIgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdC4nLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnR5cGUsIG93bmVyTmFtZSB8fCAndW5rbm93bicsIG5hbWUsIHZhbHVlKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgKyAncHgnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhbmdlcm91c1N0eWxlVmFsdWU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2h5cGhlbmF0ZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1lbW9pemVzIHRoZSByZXR1cm4gdmFsdWUgb2YgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIHN0cmluZyBhcmd1bWVudC5cbiAqL1xuXG5mdW5jdGlvbiBtZW1vaXplU3RyaW5nT25seShjYWxsYmFjaykge1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICBpZiAoIWNhY2hlLmhhc093blByb3BlcnR5KHN0cmluZykpIHtcbiAgICAgIGNhY2hlW3N0cmluZ10gPSBjYWxsYmFjay5jYWxsKHRoaXMsIHN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZVtzdHJpbmddO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVTdHJpbmdPbmx5O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01Qcm9wZXJ0eU9wZXJhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIgPSByZXF1aXJlKCcuL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmICh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpIDogdm9pZCAwO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSAmJiAhdmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSAmJiBpc05hTih2YWx1ZSkgfHwgcHJvcGVydHlJbmZvLmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlICYmIHZhbHVlIDwgMSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gZmFsc2U7XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERPTSBwcm9wZXJ0aWVzLlxuICovXG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIElEIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5lc2NhcGVkIElELlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIoaWQpO1xuICB9LFxuXG4gIHNldEF0dHJpYnV0ZUZvcklEOiBmdW5jdGlvbiAobm9kZSwgaWQpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSwgaWQpO1xuICB9LFxuXG4gIGNyZWF0ZU1hcmt1cEZvclJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRSArICc9XCJcIic7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9yUm9vdDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FLCAnJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIG51bGwgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9XCJcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIGN1c3RvbSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIGVtcHR5IHN0cmluZyBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBzZXRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgICBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgICBwYXlsb2FkW25hbWVdID0gdmFsdWU7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAndXBkYXRlIGF0dHJpYnV0ZScsIHBheWxvYWQpO1xuICAgIH1cbiAgfSxcblxuICBzZXRWYWx1ZUZvckF0dHJpYnV0ZTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgICBwYXlsb2FkW25hbWVdID0gdmFsdWU7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAndXBkYXRlIGF0dHJpYnV0ZScsIHBheWxvYWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAncmVtb3ZlIGF0dHJpYnV0ZScsIG5hbWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdW5kZWZpbmVkKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAncmVtb3ZlIGF0dHJpYnV0ZScsIG5hbWUpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0RPTVByb3BlcnR5T3BlcmF0aW9ucy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG5cbi8qKlxuICogRXNjYXBlcyBhdHRyaWJ1dGUgdmFsdWUgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKSB7XG4gIHJldHVybiAnXCInICsgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHZhbHVlKSArICdcIic7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4nKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUgPSByZXF1aXJlKCcuL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lJyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RFdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0IHBsdWdnYWJsZVxuICogICAgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGhhc0V2ZW50UGFnZVhZO1xudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gZmFsc2U7XG52YXIgcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyID0gMDtcblxuLy8gRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIHdoaWNoIGRvbid0IGNvbnNpc3RlbnRseSBidWJibGUgKHdoaWNoIHdlIHRyYXAgYXQgYVxuLy8gbG93ZXIgbm9kZSB0aGFuIGBkb2N1bWVudGApLCBiaW5kaW5nIGF0IGBkb2N1bWVudGAgd291bGQgY2F1c2UgZHVwbGljYXRlXG4vLyBldmVudHMgc28gd2UgZG9uJ3QgaW5jbHVkZSB0aGVtIGhlcmVcbnZhciB0b3BFdmVudE1hcHBpbmcgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BBbmltYXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25lbmQnKSB8fCAnYW5pbWF0aW9uZW5kJyxcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJykgfHwgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gIHRvcEFuaW1hdGlvblN0YXJ0OiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uc3RhcnQnKSB8fCAnYW5pbWF0aW9uc3RhcnQnLFxuICB0b3BCbHVyOiAnYmx1cicsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcENoYW5nZTogJ2NoYW5nZScsXG4gIHRvcENsaWNrOiAnY2xpY2snLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3BNb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxuICB0b3BQYXN0ZTogJ3Bhc3RlJyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTY3JvbGw6ICdzY3JvbGwnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogJ3NlbGVjdGlvbmNoYW5nZScsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUZXh0SW5wdXQ6ICd0ZXh0SW5wdXQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFRvdWNoQ2FuY2VsOiAndG91Y2hjYW5jZWwnLFxuICB0b3BUb3VjaEVuZDogJ3RvdWNoZW5kJyxcbiAgdG9wVG91Y2hNb3ZlOiAndG91Y2htb3ZlJyxcbiAgdG9wVG91Y2hTdGFydDogJ3RvdWNoc3RhcnQnLFxuICB0b3BUcmFuc2l0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpIHx8ICd0cmFuc2l0aW9uZW5kJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnLFxuICB0b3BXaGVlbDogJ3doZWVsJ1xufTtcblxuLyoqXG4gKiBUbyBlbnN1cmUgbm8gY29uZmxpY3RzIHdpdGggb3RoZXIgcG90ZW50aWFsIFJlYWN0IGluc3RhbmNlcyBvbiB0aGUgcGFnZVxuICovXG52YXIgdG9wTGlzdGVuZXJzSURLZXkgPSAnX3JlYWN0TGlzdGVuZXJzSUQnICsgU3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBpcyB1c2VkIHRvIGF0dGFjaCB0b3AtbGV2ZWwgZXZlbnQgbGlzdGVuZXJzLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcignbXlJRCcsICdvbkNsaWNrJywgbXlGdW5jdGlvbik7XG4gKlxuICogVGhpcyB3b3VsZCBhbGxvY2F0ZSBhIFwicmVnaXN0cmF0aW9uXCIgb2YgYCgnb25DbGljaycsIG15RnVuY3Rpb24pYCBvbiAnbXlJRCcuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSBfYXNzaWduKHt9LCBSZWFjdEV2ZW50RW1pdHRlck1peGluLCB7XG5cbiAgLyoqXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxuICAgKi9cbiAgUmVhY3RFdmVudExpc3RlbmVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChSZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5zZXRIYW5kbGVUb3BMZXZlbChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWwpO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciBvciBub3QgYW55IGNyZWF0ZWQgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBpZiBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIGlmIChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnNldEVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGNhbGxiYWNrcyBhcmUgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIShSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyICYmIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuaXNFbmFibGVkKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICAgIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgICB2YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICAgIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcFdoZWVsKSB7XG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ3doZWVsJykpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnd2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ21vdXNld2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wV2hlZWwsICdtb3VzZXdoZWVsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggbmVlZHMgdG8gY2FwdHVyZSBhIGRpZmZlcmVudCBtb3VzZSBzY3JvbGwgZXZlbnQuXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy90ZXN0cy9zY3JvbGwuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wV2hlZWwsICdET01Nb3VzZVNjcm9sbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCkge1xuXG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ3Njcm9sbCcsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wU2Nyb2xsLCAnc2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCwgJ3Njcm9sbCcsIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuV0lORE9XX0hBTkRMRSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMgfHwgZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXMnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCAnZm9jdXMnLCBtb3VudEF0KTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BCbHVyLCAnYmx1cicsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXNpbicpKSB7XG4gICAgICAgICAgICAvLyBJRSBoYXMgYGZvY3VzaW5gIGFuZCBgZm9jdXNvdXRgIGV2ZW50cyB3aGljaCBidWJibGUuXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDA4LzA0L2RlbGVnYXRpbmdfdGhlLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCAnZm9jdXNpbicsIG1vdW50QXQpO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wQmx1ciwgJ2ZvY3Vzb3V0JywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXG4gICAgICAgICAgaXNMaXN0ZW5pbmdbdG9wTGV2ZWxUeXBlcy50b3BCbHVyXSA9IHRydWU7XG4gICAgICAgICAgaXNMaXN0ZW5pbmdbdG9wTGV2ZWxUeXBlcy50b3BGb2N1c10gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRvcEV2ZW50TWFwcGluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xuICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudChkZXBlbmRlbmN5LCB0b3BFdmVudE1hcHBpbmdbZGVwZW5kZW5jeV0sIG1vdW50QXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSk7XG4gIH0sXG5cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbnMgdG8gd2luZG93IHNjcm9sbCBhbmQgcmVzaXplIGV2ZW50cy4gV2UgY2FjaGUgc2Nyb2xsIHZhbHVlcyBzbyB0aGF0XG4gICAqIGFwcGxpY2F0aW9uIGNvZGUgY2FuIGFjY2VzcyB0aGVtIHdpdGhvdXQgdHJpZ2dlcmluZyByZWZsb3dzLlxuICAgKlxuICAgKiBWaWV3cG9ydE1ldHJpY3MgaXMgb25seSB1c2VkIGJ5IFN5bnRoZXRpY01vdXNlL1RvdWNoRXZlbnQgYW5kIG9ubHkgd2hlblxuICAgKiBwYWdlWC9wYWdlWSBpc24ndCBzdXBwb3J0ZWQgKGxlZ2FjeSBicm93c2VycykuXG4gICAqXG4gICAqIE5PVEU6IFNjcm9sbCBldmVudHMgZG8gbm90IGJ1YmJsZS5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvc2Nyb2xsLmh0bWxcbiAgICovXG4gIGVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmIChoYXNFdmVudFBhZ2VYWSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBoYXNFdmVudFBhZ2VYWSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50ICYmICdwYWdlWCcgaW4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnQnKTtcbiAgICB9XG4gICAgaWYgKCFoYXNFdmVudFBhZ2VYWSAmJiAhaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUpIHtcbiAgICAgIHZhciByZWZyZXNoID0gVmlld3BvcnRNZXRyaWNzLnJlZnJlc2hTY3JvbGxWYWx1ZXM7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLm1vbml0b3JTY3JvbGxWYWx1ZShyZWZyZXNoKTtcbiAgICAgIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHtcblxuICAvKipcbiAgICogU3RyZWFtcyBhIGZpcmVkIHRvcC1sZXZlbCBldmVudCB0byBgRXZlbnRQbHVnaW5IdWJgIHdoZXJlIHBsdWdpbnMgaGF2ZSB0aGVcbiAgICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICovXG4gIGhhbmRsZVRvcExldmVsOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzID0gRXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50RW1pdHRlck1peGluO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFdmVudEVtaXR0ZXJNaXhpbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1ha2VQcmVmaXhNYXAoc3R5bGVQcm9wLCBldmVudE5hbWUpIHtcbiAgdmFyIHByZWZpeGVzID0ge307XG5cbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ21zJyArIHN0eWxlUHJvcF0gPSAnTVMnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTycgKyBzdHlsZVByb3BdID0gJ28nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHZlbmRvclByZWZpeGVzID0ge1xuICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25FbmQnKSxcbiAgYW5pbWF0aW9uaXRlcmF0aW9uOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uSXRlcmF0aW9uJyksXG4gIGFuaW1hdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uU3RhcnQnKSxcbiAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsICdUcmFuc2l0aW9uRW5kJylcbn07XG5cbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG52YXIgcHJlZml4ZWRFdmVudE5hbWVzID0ge307XG5cbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cbnZhciBzdHlsZSA9IHt9O1xuXG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb247XG4gIH1cblxuICAvLyBTYW1lIGFzIGFib3ZlXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NQnV0dG9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGlzYWJsZWRJbnB1dFV0aWxzID0gcmVxdWlyZSgnLi9EaXNhYmxlZElucHV0VXRpbHMnKTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPGJ1dHRvbj4gaG9zdCBjb21wb25lbnQgdGhhdCBkb2VzIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50c1xuICogd2hlbiBgZGlzYWJsZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NQnV0dG9uID0ge1xuICBnZXRIb3N0UHJvcHM6IERpc2FibGVkSW5wdXRVdGlscy5nZXRIb3N0UHJvcHNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01CdXR0b247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUJ1dHRvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEaXNhYmxlZElucHV0VXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkaXNhYmxlYWJsZU1vdXNlTGlzdGVuZXJOYW1lcyA9IHtcbiAgb25DbGljazogdHJ1ZSxcbiAgb25Eb3VibGVDbGljazogdHJ1ZSxcbiAgb25Nb3VzZURvd246IHRydWUsXG4gIG9uTW91c2VNb3ZlOiB0cnVlLFxuICBvbk1vdXNlVXA6IHRydWUsXG5cbiAgb25DbGlja0NhcHR1cmU6IHRydWUsXG4gIG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlRG93bkNhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VNb3ZlQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZVVwQ2FwdHVyZTogdHJ1ZVxufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgaG9zdCBjb21wb25lbnQgdGhhdCBkb2VzIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50c1xuICogd2hlbiBgZGlzYWJsZWRgIGlzIHNldC5cbiAqL1xudmFyIERpc2FibGVkSW5wdXRVdGlscyA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuXG4gICAgLy8gQ29weSB0aGUgcHJvcHMsIGV4Y2VwdCB0aGUgbW91c2UgbGlzdGVuZXJzXG4gICAgdmFyIGhvc3RQcm9wcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFkaXNhYmxlYWJsZU1vdXNlTGlzdGVuZXJOYW1lc1trZXldICYmIHByb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaG9zdFByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzYWJsZWRJbnB1dFV0aWxzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRGlzYWJsZWRJbnB1dFV0aWxzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSW5wdXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERpc2FibGVkSW5wdXRVdGlscyA9IHJlcXVpcmUoJy4vRGlzYWJsZWRJbnB1dFV0aWxzJyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZUxpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ2hlY2tlZExpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gZm9yY2VVcGRhdGVJZk1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgICBSZWFjdERPTUlucHV0LnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb250cm9sbGVkKHByb3BzKSB7XG4gIHZhciB1c2VzQ2hlY2tlZCA9IHByb3BzLnR5cGUgPT09ICdjaGVja2JveCcgfHwgcHJvcHMudHlwZSA9PT0gJ3JhZGlvJztcbiAgcmV0dXJuIHVzZXNDaGVja2VkID8gcHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkIDogcHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELWh0bWw1LTIwMTIxMDI1L3RoZS1pbnB1dC1lbGVtZW50Lmh0bWxcbiAqL1xudmFyIFJlYWN0RE9NSW5wdXQgPSB7XG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgdmFyIGNoZWNrZWQgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldENoZWNrZWQocHJvcHMpO1xuXG4gICAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe1xuICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCAudHlwZSBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMgKHNldHRpbmcgLnZhbHVlXG4gICAgICAvLyBiZWZvcmUgLnR5cGUgbWVhbnMgLnZhbHVlIGlzIGxvc3QgaW4gSUUxMSBhbmQgYmVsb3cpXG4gICAgICB0eXBlOiB1bmRlZmluZWQsXG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5zdGVwIGJlZm9yZSAudmFsdWUgKHNldHRpbmcgLnZhbHVlIGJlZm9yZSAuc3RlcFxuICAgICAgLy8gbWVhbnMgLnZhbHVlIGlzIHJvdW5kZWQgb24gbW91bnQsIGJhc2VkIHVwb24gc3RlcCBwcmVjaXNpb24pXG4gICAgICBzdGVwOiB1bmRlZmluZWQsXG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5taW4gJiAubWF4IGJlZm9yZSAudmFsdWUgKHRvIGVuc3VyZSBwcm9wZXIgb3JkZXJcbiAgICAgIC8vIGluIGNvcm5lciBjYXNlcyBzdWNoIGFzIG1pbiBvciBtYXggZGVyaXZpbmcgZnJvbSB2YWx1ZSwgZS5nLiBJc3N1ZSAjNzE3MClcbiAgICAgIG1pbjogdW5kZWZpbmVkLFxuICAgICAgbWF4OiB1bmRlZmluZWRcbiAgICB9LCBEaXNhYmxlZElucHV0VXRpbHMuZ2V0SG9zdFByb3BzKGluc3QsIHByb3BzKSwge1xuICAgICAgZGVmYXVsdENoZWNrZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgdmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkLFxuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdpbnB1dCcsIHByb3BzLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuXG4gICAgICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZUxpbmtgIHByb3Agb24gYGlucHV0YCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVmFsdWVMaW5rID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5jaGVja2VkTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuQ2hlY2tlZExpbmspIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgY2hlY2tlZExpbmtgIHByb3Agb24gYGlucHV0YCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ2hlY2tlZExpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgICAgaW5pdGlhbFZhbHVlOiBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWUsXG4gICAgICBsaXN0ZW5lcnM6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpXG4gICAgfTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUuY29udHJvbGxlZCA9IGlzQ29udHJvbGxlZChwcm9wcyk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuICAgICAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICBpZiAoIWluc3QuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmIGNvbnRyb2xsZWQgJiYgIWRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSBjb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIWNvbnRyb2xsZWQgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBTaG91bGRuJ3QgdGhpcyBiZSBnZXRDaGVja2VkKHByb3BzKT9cbiAgICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gICAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkoUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCksICdjaGVja2VkJywgY2hlY2tlZCB8fCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuXG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgICAgLy8gVG8gYXZvaWQgc2lkZSBlZmZlY3RzIChzdWNoIGFzIGxvc2luZyB0ZXh0IHNlbGVjdGlvbiksIG9ubHkgc2V0IHZhbHVlIGlmIGNoYW5nZWRcbiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gbm9kZS52YWx1ZSkge1xuICAgICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wcy52YWx1ZSA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gJycgKyBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhcHJvcHMuZGVmYXVsdENoZWNrZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XG4gICAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcblxuICAgIC8vIERldGFjaCB2YWx1ZSBmcm9tIGRlZmF1bHRWYWx1ZS4gV2Ugd29uJ3QgZG8gYW55dGhpbmcgaWYgd2UncmUgd29ya2luZyBvblxuICAgIC8vIHN1Ym1pdCBvciByZXNldCBpbnB1dHMgYXMgdGhvc2UgdmFsdWVzICYgZGVmYXVsdFZhbHVlcyBhcmUgbGlua2VkLiBUaGV5XG4gICAgLy8gYXJlIG5vdCByZXNldGFibGUgbm9kZXMgc28gdGhpcyBvcGVyYXRpb24gZG9lc24ndCBtYXR0ZXIgYW5kIGFjdHVhbGx5XG4gICAgLy8gcmVtb3ZlcyBicm93c2VyLWRlZmF1bHQgdmFsdWVzIChlZyBcIlN1Ym1pdCBRdWVyeVwiKSB3aGVuIG5vIHZhbHVlIGlzXG4gICAgLy8gcHJvdmlkZWQuXG5cbiAgICBzd2l0Y2ggKHByb3BzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3N1Ym1pdCc6XG4gICAgICBjYXNlICdyZXNldCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdkYXRldGltZSc6XG4gICAgICBjYXNlICdkYXRldGltZS1sb2NhbCc6XG4gICAgICBjYXNlICdtb250aCc6XG4gICAgICBjYXNlICd0aW1lJzpcbiAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAvLyBUaGlzIGZpeGVzIHRoZSBuby1zaG93IGlzc3VlIG9uIGlPUyBTYWZhcmkgYW5kIEFuZHJvaWQgQ2hyb21lOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyMzNcbiAgICAgICAgbm9kZS52YWx1ZSA9ICcnO1xuICAgICAgICBub2RlLnZhbHVlID0gbm9kZS5kZWZhdWx0VmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gICAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgICAvLyB3aWxsIHNvbWV0aW1lcyBpbmZsdWVuY2UgdGhlIHZhbHVlIG9mIGNoZWNrZWQgKGV2ZW4gYWZ0ZXIgZGV0YWNobWVudCkuXG4gICAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICAgIGlmIChuYW1lICE9PSAnJykge1xuICAgICAgbm9kZS5uYW1lID0gJyc7XG4gICAgfVxuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gICAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuXG4gIC8vIEhlcmUgd2UgdXNlIGFzYXAgdG8gd2FpdCB1bnRpbCBhbGwgdXBkYXRlcyBoYXZlIHByb3BhZ2F0ZWQsIHdoaWNoXG4gIC8vIGlzIGltcG9ydGFudCB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuXG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHJvb3ROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLCBsZXQncyBqdXN0IHVzZSB0aGUgZ2xvYmFsXG4gICAgLy8gYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndCBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVySW5zdGFuY2UgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShvdGhlck5vZGUpO1xuICAgICAgIW90aGVySW5zdGFuY2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiBfcHJvZEludmFyaWFudCgnOTAnKSA6IHZvaWQgMDtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIG90aGVySW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlucHV0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01JbnB1dC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBMaW5rZWRWYWx1ZVV0aWxzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICdidXR0b24nOiB0cnVlLFxuICAnY2hlY2tib3gnOiB0cnVlLFxuICAnaW1hZ2UnOiB0cnVlLFxuICAnaGlkZGVuJzogdHJ1ZSxcbiAgJ3JhZGlvJzogdHJ1ZSxcbiAgJ3Jlc2V0JzogdHJ1ZSxcbiAgJ3N1Ym1pdCc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpIHtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWRMaW5rID09IG51bGwgfHwgaW5wdXRQcm9wcy52YWx1ZUxpbmsgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSB2YWx1ZUxpbmsuIElmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkTGluaywgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rIGFuZCB2aWNlIHZlcnNhLicpIDogX3Byb2RJbnZhcmlhbnQoJzg3JykgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy52YWx1ZSA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSB2YWx1ZUxpbmsgYW5kIGEgdmFsdWUgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50IHRvIHVzZSB2YWx1ZSBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rLicpIDogX3Byb2RJbnZhcmlhbnQoJzg4JykgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSBjaGVja2VkIHByb3BlcnR5IG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZCBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgY2hlY2tlZExpbmsnKSA6IF9wcm9kSW52YXJpYW50KCc4OScpIDogdm9pZCAwO1xufVxuXG52YXIgcHJvcFR5cGVzID0ge1xuICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgb25DaGFuZ2U6IFJlYWN0UHJvcFR5cGVzLmZ1bmNcbn07XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFByb3ZpZGUgYSBsaW5rZWQgYHZhbHVlYCBhdHRyaWJ1dGUgZm9yIGNvbnRyb2xsZWQgZm9ybXMuIFlvdSBzaG91bGQgbm90IHVzZVxuICogdGhpcyBvdXRzaWRlIG9mIHRoZSBSZWFjdERPTSBjb250cm9sbGVkIGZvcm0gY29tcG9uZW50cy5cbiAqL1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSB7XG4gIGNoZWNrUHJvcFR5cGVzOiBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcHMsIG93bmVyKSB7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcFR5cGVzKSB7XG4gICAgICBpZiAocHJvcFR5cGVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgdGFnTmFtZSwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgYWRkZW5kdW0gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCBmb3JtIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIHZhbHVlIHByb3Agb3IgbGluay5cbiAgICovXG4gIGdldFZhbHVlOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IGNoZWNrZWQgc3RhdHVzIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSBjaGVja2VkIHByb3BcbiAgICogICAgICAgICAgICAgb3IgbGluay5cbiAgICovXG4gIGdldENoZWNrZWQ6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XG4gICAgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgY2hhbmdlIGV2ZW50IHRvIGhhbmRsZVxuICAgKi9cbiAgZXhlY3V0ZU9uQ2hhbmdlOiBmdW5jdGlvbiAoaW5wdXRQcm9wcywgZXZlbnQpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZUxpbmsucmVxdWVzdENoYW5nZShldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZExpbmsucmVxdWVzdENoYW5nZShldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgfSBlbHNlIGlmIChpbnB1dFByb3BzLm9uQ2hhbmdlKSB7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5vbkNoYW5nZS5jYWxsKHVuZGVmaW5lZCwgZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rZWRWYWx1ZVV0aWxzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvTGlua2VkVmFsdWVVdGlscy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTU9wdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3QnKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgUmVhY3RDaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgIH0gZWxzZSBpZiAoIWRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4pIHtcbiAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdPbmx5IHN0cmluZ3MgYW5kIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBhcyA8b3B0aW9uPiBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb250ZW50O1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gaG9zdCBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01PcHRpb24gPSB7XG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBob3N0UGFyZW50KSB7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLnNlbGVjdGVkID09IG51bGwsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBMb29rIHVwIHdoZXRoZXIgdGhpcyBvcHRpb24gaXMgJ3NlbGVjdGVkJ1xuICAgIHZhciBzZWxlY3RWYWx1ZSA9IG51bGw7XG4gICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgdmFyIHNlbGVjdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG5cbiAgICAgIGlmIChzZWxlY3RQYXJlbnQuX3RhZyA9PT0gJ29wdGdyb3VwJykge1xuICAgICAgICBzZWxlY3RQYXJlbnQgPSBzZWxlY3RQYXJlbnQuX2hvc3RQYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RQYXJlbnQgIT0gbnVsbCAmJiBzZWxlY3RQYXJlbnQuX3RhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgc2VsZWN0VmFsdWUgPSBSZWFjdERPTVNlbGVjdC5nZXRTZWxlY3RWYWx1ZUNvbnRleHQoc2VsZWN0UGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgaXMgbnVsbCAoZS5nLiwgbm8gc3BlY2lmaWVkIHZhbHVlIG9yIGFmdGVyIGluaXRpYWwgbW91bnQpXG4gICAgLy8gb3IgbWlzc2luZyAoZS5nLiwgZm9yIDxkYXRhbGlzdD4pLCB3ZSBkb24ndCBjaGFuZ2UgcHJvcHMuc2VsZWN0ZWRcbiAgICB2YXIgc2VsZWN0ZWQgPSBudWxsO1xuICAgIGlmIChzZWxlY3RWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YWx1ZSA9IHByb3BzLnZhbHVlICsgJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgICBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gICAgICAgIC8vIG11bHRpcGxlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoJycgKyBzZWxlY3RWYWx1ZVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWQgPSAnJyArIHNlbGVjdFZhbHVlID09PSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7IHNlbGVjdGVkOiBzZWxlY3RlZCB9O1xuICB9LFxuXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgLy8gdmFsdWU9XCJcIiBzaG91bGQgbWFrZSBhIHZhbHVlIGF0dHJpYnV0ZSAoIzYyMTkpXG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBwcm9wcy52YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBzZWxlY3RlZDogdW5kZWZpbmVkLCBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcblxuICAgIC8vIFJlYWQgc3RhdGUgb25seSBmcm9tIGluaXRpYWwgbW91bnQgYmVjYXVzZSA8c2VsZWN0PiB1cGRhdGVzIHZhbHVlXG4gICAgLy8gbWFudWFsbHk7IHdlIG5lZWQgdGhlIGluaXRpYWwgc3RhdGUgb25seSBmb3Igc2VydmVyIHJlbmRlcmluZ1xuICAgIGlmIChpbnN0Ll93cmFwcGVyU3RhdGUuc2VsZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgaG9zdFByb3BzLnNlbGVjdGVkID0gaW5zdC5fd3JhcHBlclN0YXRlLnNlbGVjdGVkO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50ID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcblxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICAgIH1cblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTU9wdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NT3B0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NU2VsZWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERpc2FibGVkSW5wdXRVdGlscyA9IHJlcXVpcmUoJy4vRGlzYWJsZWRJbnB1dFV0aWxzJyk7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCAmJiB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSkge1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKHRoaXMsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpIHtcbiAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcywgb3duZXIpO1xuXG4gIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgc2VsZWN0YCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB2b2lkIDA7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGluc3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbGVcbiAqIEBwYXJhbSB7Kn0gcHJvcFZhbHVlIEEgc3RyaW5nYWJsZSAod2l0aCBgbXVsdGlwbGVgLCBhIGxpc3Qgb2Ygc3RyaW5nYWJsZXMpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhpbnN0LCBtdWx0aXBsZSwgcHJvcFZhbHVlKSB7XG4gIHZhciBzZWxlY3RlZFZhbHVlLCBpO1xuICB2YXIgb3B0aW9ucyA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpLm9wdGlvbnM7XG5cbiAgaWYgKG11bHRpcGxlKSB7XG4gICAgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGVjdGVkVmFsdWVbJycgKyBwcm9wVmFsdWVbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkob3B0aW9uc1tpXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tpXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXG4gICAgc2VsZWN0ZWRWYWx1ZSA9ICcnICsgcHJvcFZhbHVlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob3B0aW9uc1tpXS52YWx1ZSA9PT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xudmFyIFJlYWN0RE9NU2VsZWN0ID0ge1xuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIHJldHVybiBfYXNzaWduKHt9LCBEaXNhYmxlZElucHV0VXRpbHMuZ2V0SG9zdFByb3BzKGluc3QsIHByb3BzKSwge1xuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZSxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgcGVuZGluZ1VwZGF0ZTogZmFsc2UsXG4gICAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdCksXG4gICAgICB3YXNNdWx0aXBsZTogQm9vbGVhbihwcm9wcy5tdWx0aXBsZSlcbiAgICB9O1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpIDogdm9pZCAwO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0U2VsZWN0VmFsdWVDb250ZXh0OiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIFJlYWN0RE9NT3B0aW9uIGxvb2tzIGF0IHRoaXMgaW5pdGlhbCB2YWx1ZSBzbyB0aGUgaW5pdGlhbCBnZW5lcmF0ZWRcbiAgICAvLyBtYXJrdXAgaGFzIGNvcnJlY3QgYHNlbGVjdGVkYCBhdHRyaWJ1dGVzXG4gICAgcmV0dXJuIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU7XG4gIH0sXG5cbiAgcG9zdFVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgICAvLyB0aGlzIHZhbHVlIGRvd25cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIHdhc011bHRpcGxlID0gaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpO1xuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG4gICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSkpIHtcbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcblxuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICBSZWFjdFVwZGF0ZXMuYXNhcCh1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVGV4dGFyZWFcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERpc2FibGVkSW5wdXRVdGlscyA9IHJlcXVpcmUoJy4vRGlzYWJsZWRJbnB1dFV0aWxzJyk7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FyblZhbERlZmF1bHRWYWwgPSBmYWxzZTtcblxuZnVuY3Rpb24gZm9yY2VVcGRhdGVJZk1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgICBSZWFjdERPTVRleHRhcmVhLnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cbnZhciBSZWFjdERPTVRleHRhcmVhID0ge1xuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJykgOiBfcHJvZEludmFyaWFudCgnOTEnKSA6IHZvaWQgMDtcblxuICAgIC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXG4gICAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC4gIFdlIGNvdWxkIGFkZCBhIGNoZWNrIGluIHNldFRleHRDb250ZW50XG4gICAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgICAvLyBjb21wbGV0ZWx5IHNvbHZlIHRoaXMgSUU5IGJ1ZyksIGJ1dCBTZWJhc3RpYW4rQmVuIHNlZW1lZCB0byBsaWtlIHRoaXMgc29sdXRpb24uXG4gICAgLy8gVGhlIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQncyBmb3JjZWQgdG8gYmUgYSBzdHJpbmcuXG4gICAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIERpc2FibGVkSW5wdXRVdGlscy5nZXRIb3N0UHJvcHMoaW5zdCwgcHJvcHMpLCB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBjaGlsZHJlbjogJycgKyBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCd0ZXh0YXJlYScsIHByb3BzLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgICAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgdGV4dGFyZWFgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWxEZWZhdWx0VmFsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgdmFyIGluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuXG4gICAgLy8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJykgOiBfcHJvZEludmFyaWFudCgnOTInKSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgIShjaGlsZHJlbi5sZW5ndGggPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpIDogX3Byb2RJbnZhcmlhbnQoJzkzJykgOiB2b2lkIDA7XG4gICAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnICsgY2hpbGRyZW47XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgICB9XG4gICAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgaW5pdGlhbFZhbHVlOiAnJyArIGluaXRpYWxWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgICAgLy8gVG8gYXZvaWQgc2lkZSBlZmZlY3RzIChzdWNoIGFzIGxvc2luZyB0ZXh0IHNlbGVjdGlvbiksIG9ubHkgc2V0IHZhbHVlIGlmIGNoYW5nZWRcbiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gbm9kZS52YWx1ZSkge1xuICAgICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XG4gICAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcblxuICAgIC8vIFdhcm5pbmc6IG5vZGUudmFsdWUgbWF5IGJlIHRoZSBlbXB0eSBzdHJpbmcgYXQgdGhpcyBwb2ludCAoSUUxMSkgaWYgcGxhY2Vob2xkZXIgaXMgc2V0LlxuICAgIG5vZGUudmFsdWUgPSBub2RlLnRleHRDb250ZW50OyAvLyBEZXRhY2ggdmFsdWUgZnJvbSBkZWZhdWx0VmFsdWVcbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0YXJlYTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dGFyZWEuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNdWx0aUNoaWxkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRSZWNvbmNpbGVyJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGZsYXR0ZW5DaGlsZHJlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbkNoaWxkcmVuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1hcmt1cCB0byBiZSByZW5kZXJlZCBhbmQgaW5zZXJ0ZWQgYXQgYSBzdXBwbGllZCBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlSW5zZXJ0TWFya3VwKG1hcmt1cCwgYWZ0ZXJOb2RlLCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5JTlNFUlRfTUFSS1VQLFxuICAgIGNvbnRlbnQ6IG1hcmt1cCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgZnJvbU5vZGU6IG51bGwsXG4gICAgdG9JbmRleDogdG9JbmRleCxcbiAgICBhZnRlck5vZGU6IGFmdGVyTm9kZVxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBtb3ZpbmcgYW4gZXhpc3RpbmcgZWxlbWVudCB0byBhbm90aGVyIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggU291cmNlIGluZGV4IG9mIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlTW92ZShjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBjaGlsZC5fbW91bnRJbmRleCxcbiAgICBmcm9tTm9kZTogUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKGNoaWxkKSxcbiAgICB0b0luZGV4OiB0b0luZGV4LFxuICAgIGFmdGVyTm9kZTogYWZ0ZXJOb2RlXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHJlbW92aW5nIGFuIGVsZW1lbnQgYXQgYW4gaW5kZXguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBJbmRleCBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlUmVtb3ZlKGNoaWxkLCBub2RlKSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERSxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXG4gICAgZnJvbU5vZGU6IG5vZGUsXG4gICAgdG9JbmRleDogbnVsbCxcbiAgICBhZnRlck5vZGU6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3Igc2V0dGluZyB0aGUgbWFya3VwIG9mIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVNldE1hcmt1cChtYXJrdXApIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlNFVF9NQVJLVVAsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsLFxuICAgIGFmdGVyTm9kZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBzZXR0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlVGV4dENvbnRlbnQodGV4dENvbnRlbnQpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVCxcbiAgICBjb250ZW50OiB0ZXh0Q29udGVudCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgZnJvbU5vZGU6IG51bGwsXG4gICAgdG9JbmRleDogbnVsbCxcbiAgICBhZnRlck5vZGU6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBQdXNoIGFuIHVwZGF0ZSwgaWYgYW55LCBvbnRvIHRoZSBxdWV1ZS4gQ3JlYXRlcyBhIG5ldyBxdWV1ZSBpZiBub25lIGlzXG4gKiBwYXNzZWQgYW5kIGFsd2F5cyByZXR1cm5zIHRoZSBxdWV1ZS4gTXV0YXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGVucXVldWUocXVldWUsIHVwZGF0ZSkge1xuICBpZiAodXBkYXRlKSB7XG4gICAgcXVldWUgPSBxdWV1ZSB8fCBbXTtcbiAgICBxdWV1ZS5wdXNoKHVwZGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG4vKipcbiAqIFByb2Nlc3NlcyBhbnkgZW5xdWV1ZWQgdXBkYXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwcm9jZXNzUXVldWUoaW5zdCwgdXBkYXRlUXVldWUpIHtcbiAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzKGluc3QsIHVwZGF0ZVF1ZXVlKTtcbn1cblxudmFyIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uID0gZW1wdHlGdW5jdGlvbjtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBnZXREZWJ1Z0lEID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgICBpZiAoIWluc3QuX2RlYnVnSUQpIHtcbiAgICAgIC8vIENoZWNrIGZvciBBUlQtbGlrZSBpbnN0YW5jZXMuIFRPRE86IFRoaXMgaXMgc2lsbHkvZ3Jvc3MuXG4gICAgICB2YXIgaW50ZXJuYWw7XG4gICAgICBpZiAoaW50ZXJuYWwgPSBSZWFjdEluc3RhbmNlTWFwLmdldChpbnN0KSkge1xuICAgICAgICBpbnN0ID0gaW50ZXJuYWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnN0Ll9kZWJ1Z0lEO1xuICB9O1xuICBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbiA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgIHZhciBkZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAvLyBUT0RPOiBSZWFjdCBOYXRpdmUgZW1wdHkgY29tcG9uZW50cyBhcmUgYWxzbyBtdWx0aWNoaWxkLlxuICAgIC8vIFRoaXMgbWVhbnMgdGhleSBzdGlsbCBnZXQgaW50byB0aGlzIG1ldGhvZCBidXQgZG9uJ3QgaGF2ZSBfZGVidWdJRC5cbiAgICBpZiAoZGVidWdJRCAhPT0gMCkge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgY2hpbGRyZW4gPyBPYmplY3Qua2V5cyhjaGlsZHJlbikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2tleV0uX2RlYnVnSUQ7XG4gICAgICB9KSA6IFtdKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogUmVhY3RNdWx0aUNoaWxkIGFyZSBjYXBhYmxlIG9mIHJlY29uY2lsaW5nIG11bHRpcGxlIGNoaWxkcmVuLlxuICpcbiAqIEBjbGFzcyBSZWFjdE11bHRpQ2hpbGRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkID0ge1xuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBjb21tb24gZnVuY3Rpb25hbGl0eSBmb3IgY29tcG9uZW50cyB0aGF0IG11c3QgcmVjb25jaWxlIG11bHRpcGxlXG4gICAqIGNoaWxkcmVuLiBUaGlzIGlzIHVzZWQgYnkgYFJlYWN0RE9NQ29tcG9uZW50YCB0byBtb3VudCwgdXBkYXRlLCBhbmRcbiAgICogdW5tb3VudCBjaGlsZCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAbGVuZHMge1JlYWN0TXVsdGlDaGlsZC5wcm90b3R5cGV9XG4gICAqL1xuICBNaXhpbjoge1xuXG4gICAgX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgc2VsZkRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci5pbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci5pbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIF9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIG5leHRDaGlsZHJlbjtcbiAgICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51cGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIHRoaXMsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgcmV0dXJuIG5leHRDaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBzZWxmRGVidWdJRCk7XG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51cGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIHRoaXMsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICByZXR1cm4gbmV4dENoaWxkcmVuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgbW91bnRlZCByZXByZXNlbnRhdGlvbnMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAgdmFyIG1vdW50SW1hZ2VzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltuYW1lXTtcbiAgICAgICAgICB2YXIgc2VsZkRlYnVnSUQgPSAwO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4Kys7XG4gICAgICAgICAgbW91bnRJbWFnZXMucHVzaChtb3VudEltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIGNoaWxkcmVuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1vdW50SW1hZ2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIHRleHQgY29udGVudCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dENvbnRlbnQgU3RyaW5nIG9mIGNvbnRlbnQuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlVGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChuZXh0Q29udGVudCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAvLyBSZW1vdmUgYW55IHJlbmRlcmVkIGNoaWxkcmVuLlxuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgZmFsc2UpO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGVUZXh0Q29udGVudCBjYWxsZWQgb24gbm9uLWVtcHR5IGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTgnKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IG5ldyB0ZXh0IGNvbnRlbnQuXG4gICAgICB2YXIgdXBkYXRlcyA9IFttYWtlVGV4dENvbnRlbnQobmV4dENvbnRlbnQpXTtcbiAgICAgIHByb2Nlc3NRdWV1ZSh0aGlzLCB1cGRhdGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBtYXJrdXAgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRNYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVNYXJrdXA6IGZ1bmN0aW9uIChuZXh0TWFya3VwKSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBmYWxzZSk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVRleHRDb250ZW50IGNhbGxlZCBvbiBub24tZW1wdHkgY29tcG9uZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzExOCcpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdXBkYXRlcyA9IFttYWtlU2V0TWFya3VwKG5leHRNYXJrdXApXTtcbiAgICAgIHByb2Nlc3NRdWV1ZSh0aGlzLCB1cGRhdGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBuZXcgY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIE5lc3RlZCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAvLyBIb29rIHVzZWQgYnkgUmVhY3QgQVJUXG4gICAgICB0aGlzLl91cGRhdGVDaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIE5lc3RlZCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgdmFyIHJlbW92ZWROb2RlcyA9IHt9O1xuICAgICAgdmFyIG1vdW50SW1hZ2VzID0gW107XG4gICAgICB2YXIgbmV4dENoaWxkcmVuID0gdGhpcy5fcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHVwZGF0ZXMgPSBudWxsO1xuICAgICAgdmFyIG5hbWU7XG4gICAgICAvLyBgbmV4dEluZGV4YCB3aWxsIGluY3JlbWVudCBmb3IgZWFjaCBjaGlsZCBpbiBgbmV4dENoaWxkcmVuYCwgYnV0XG4gICAgICAvLyBgbGFzdEluZGV4YCB3aWxsIGJlIHRoZSBsYXN0IGluZGV4IHZpc2l0ZWQgaW4gYHByZXZDaGlsZHJlbmAuXG4gICAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgICAgLy8gYG5leHRNb3VudEluZGV4YCB3aWxsIGluY3JlbWVudCBmb3IgZWFjaCBuZXdseSBtb3VudGVkIGNoaWxkLlxuICAgICAgdmFyIG5leHRNb3VudEluZGV4ID0gMDtcbiAgICAgIHZhciBsYXN0UGxhY2VkTm9kZSA9IG51bGw7XG4gICAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIGlmIChwcmV2Q2hpbGQgPT09IG5leHRDaGlsZCkge1xuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMubW92ZUNoaWxkKHByZXZDaGlsZCwgbGFzdFBsYWNlZE5vZGUsIG5leHRJbmRleCwgbGFzdEluZGV4KSk7XG4gICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgIHByZXZDaGlsZC5fbW91bnRJbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYGxhc3RJbmRleGAgYmVmb3JlIGBfbW91bnRJbmRleGAgZ2V0cyB1bnNldCBieSB1bm1vdW50aW5nLlxuICAgICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgICAgLy8gVGhlIGByZW1vdmVkTm9kZXNgIGxvb3AgYmVsb3cgd2lsbCBhY3R1YWxseSByZW1vdmUgdGhlIGNoaWxkLlxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLl9tb3VudENoaWxkQXRJbmRleChuZXh0Q2hpbGQsIG1vdW50SW1hZ2VzW25leHRNb3VudEluZGV4XSwgbGFzdFBsYWNlZE5vZGUsIG5leHRJbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpKTtcbiAgICAgICAgICBuZXh0TW91bnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICBsYXN0UGxhY2VkTm9kZSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShuZXh0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgICAgZm9yIChuYW1lIGluIHJlbW92ZWROb2Rlcykge1xuICAgICAgICBpZiAocmVtb3ZlZE5vZGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdXBkYXRlcyA9IGVucXVldWUodXBkYXRlcywgdGhpcy5fdW5tb3VudENoaWxkKHByZXZDaGlsZHJlbltuYW1lXSwgcmVtb3ZlZE5vZGVzW25hbWVdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1cGRhdGVzKSB7XG4gICAgICAgIHByb2Nlc3NRdWV1ZSh0aGlzLCB1cGRhdGVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBuZXh0Q2hpbGRyZW47XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgbmV4dENoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXG4gICAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuIEl0IGRvZXMgbm90IGFjdHVhbGx5IHBlcmZvcm0gYW55XG4gICAgICogYmFja2VuZCBvcGVyYXRpb25zLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAoc2FmZWx5KSB7XG4gICAgICB2YXIgcmVuZGVyZWRDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocmVuZGVyZWRDaGlsZHJlbiwgc2FmZWx5KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIGNoaWxkIGNvbXBvbmVudCB0byB0aGUgc3VwcGxpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW92ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFzdEluZGV4IExhc3QgaW5kZXggdmlzaXRlZCBvZiB0aGUgc2libGluZ3Mgb2YgYGNoaWxkYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIGFmdGVyTm9kZSwgdG9JbmRleCwgbGFzdEluZGV4KSB7XG4gICAgICAvLyBJZiB0aGUgaW5kZXggb2YgYGNoaWxkYCBpcyBsZXNzIHRoYW4gYGxhc3RJbmRleGAsIHRoZW4gaXQgbmVlZHMgdG9cbiAgICAgIC8vIGJlIG1vdmVkLiBPdGhlcndpc2UsIHdlIGRvIG5vdCBuZWVkIHRvIG1vdmUgaXQgYmVjYXVzZSBhIGNoaWxkIHdpbGwgYmVcbiAgICAgIC8vIGluc2VydGVkIG9yIG1vdmVkIGJlZm9yZSBgY2hpbGRgLlxuICAgICAgaWYgKGNoaWxkLl9tb3VudEluZGV4IDwgbGFzdEluZGV4KSB7XG4gICAgICAgIHJldHVybiBtYWtlTW92ZShjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vdW50SW1hZ2UgTWFya3VwIHRvIGluc2VydC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgYWZ0ZXJOb2RlLCBtb3VudEltYWdlKSB7XG4gICAgICByZXR1cm4gbWFrZUluc2VydE1hcmt1cChtb3VudEltYWdlLCBhZnRlck5vZGUsIGNoaWxkLl9tb3VudEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENoaWxkIHRvIHJlbW92ZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbm9kZSkge1xuICAgICAgcmV0dXJuIG1ha2VSZW1vdmUoY2hpbGQsIG5vZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3VudHMgYSBjaGlsZCB3aXRoIHRoZSBzdXBwbGllZCBuYW1lLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3VudENoaWxkQXRJbmRleDogZnVuY3Rpb24gKGNoaWxkLCBtb3VudEltYWdlLCBhZnRlck5vZGUsIGluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleDtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNoaWxkKGNoaWxkLCBhZnRlck5vZGUsIG1vdW50SW1hZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhIHJlbmRlcmVkIGNoaWxkLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIHVubW91bnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdW5tb3VudENoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIG5vZGUpIHtcbiAgICAgIHZhciB1cGRhdGUgPSB0aGlzLnJlbW92ZUNoaWxkKGNoaWxkLCBub2RlKTtcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gbnVsbDtcbiAgICAgIHJldHVybiB1cGRhdGU7XG4gICAgfVxuXG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgaW5qZWN0ZWQgPSBmYWxzZTtcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSB7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBob29rIGZvciBzd2FwcGluZyBvdXQgbW91bnQgaW1hZ2VzIGluIHRoZSBtaWRkbGUgb2ZcbiAgICogdGhlIHRyZWUuXG4gICAqL1xuICByZXBsYWNlTm9kZVdpdGhNYXJrdXA6IG51bGwsXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBob29rIGZvciBwcm9jZXNzaW5nIGEgcXVldWUgb2YgY2hpbGQgdXBkYXRlcy4gV2lsbFxuICAgKiBsYXRlciBtb3ZlIGludG8gTXVsdGlDaGlsZENvbXBvbmVudHMuXG4gICAqL1xuICBwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVudmlyb25tZW50OiBmdW5jdGlvbiAoZW52aXJvbm1lbnQpIHtcbiAgICAgICEhaW5qZWN0ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQ6IGluamVjdEVudmlyb25tZW50KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuJykgOiBfcHJvZEludmFyaWFudCgnMTA0JykgOiB2b2lkIDA7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IGVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyA9IGVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXM7XG4gICAgICBpbmplY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnN0YW5jZU1hcFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcbiAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cbiAqL1xuXG4vLyBUT0RPOiBSZXBsYWNlIHRoaXMgd2l0aCBFUzY6IHZhciBSZWFjdEluc3RhbmNlTWFwID0gbmV3IE1hcCgpO1xuXG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHtcblxuICAvKipcbiAgICogVGhpcyBBUEkgc2hvdWxkIGJlIGNhbGxlZCBgZGVsZXRlYCBidXQgd2UnZCBoYXZlIHRvIG1ha2Ugc3VyZSB0byBhbHdheXNcbiAgICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcbiAgICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgfSxcblxuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2U7XG4gIH0sXG5cbiAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdmFsdWU7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluc3RhbmNlTWFwO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZU1hcC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENoaWxkUmVjb25jaWxlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG5cbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG59XG5cbmZ1bmN0aW9uIGluc3RhbnRpYXRlQ2hpbGQoY2hpbGRJbnN0YW5jZXMsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgdmFyIGtleVVuaXF1ZSA9IGNoaWxkSW5zdGFuY2VzW25hbWVdID09PSB1bmRlZmluZWQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XG4gICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgfVxuICAgIGlmICgha2V5VW5pcXVlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLiVzJywgS2V5RXNjYXBlVXRpbHMudW5lc2NhcGUobmFtZSksIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoc2VsZkRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNoaWxkICE9IG51bGwgJiYga2V5VW5pcXVlKSB7XG4gICAgY2hpbGRJbnN0YW5jZXNbbmFtZV0gPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNoaWxkLCB0cnVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlYWN0Q2hpbGRSZWNvbmNpbGVyIHByb3ZpZGVzIGhlbHBlcnMgZm9yIGluaXRpYWxpemluZyBvciB1cGRhdGluZyBhIHNldCBvZlxuICogY2hpbGRyZW4uIEl0cyBvdXRwdXQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgaXQgb250byBSZWFjdE11bHRpQ2hpbGQgd2hpY2hcbiAqIGRvZXMgZGlmZmVkIHJlb3JkZXJpbmcgYW5kIGluc2VydGlvbi5cbiAqL1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0ge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGROb2RlcyBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICogQHJldHVybiB7P29iamVjdH0gQSBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCwgc2VsZkRlYnVnSUQgLy8gMCBpbiBwcm9kdWN0aW9uIGFuZCBmb3Igcm9vdHNcbiAgKSB7XG4gICAgaWYgKG5lc3RlZENoaWxkTm9kZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZEluc3RhbmNlcyA9IHt9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgZnVuY3Rpb24gKGNoaWxkSW5zdHMsIGNoaWxkLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdHMsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCk7XG4gICAgICB9LCBjaGlsZEluc3RhbmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgaW5zdGFudGlhdGVDaGlsZCwgY2hpbGRJbnN0YW5jZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRJbnN0YW5jZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIGFuZCByZXR1cm5zIGEgbmV3IHNldCBvZiBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENoaWxkcmVuIEZsYXQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgbmV3IHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICApIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgZG9uJ3QgaGF2ZSBhIHdheSB0byB0cmFjayBtb3ZlcyBoZXJlIGJ1dCBpZiB3ZSB1c2UgaXRlcmF0b3JzXG4gICAgLy8gaW5zdGVhZCBvZiBmb3IuLmluIHdlIGNhbiB6aXAgdGhlIGl0ZXJhdG9ycyBhbmQgY2hlY2sgaWYgYW4gaXRlbSBoYXNcbiAgICAvLyBtb3ZlZC5cbiAgICAvLyBUT0RPOiBJZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCByZXR1cm4gdGhlIHByZXZDaGlsZHJlbiBvYmplY3Qgc28gdGhhdCB3ZVxuICAgIC8vIGNhbiBxdWlja2x5IGJhaWxvdXQgaWYgbm90aGluZyBoYXMgY2hhbmdlZC5cbiAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuYW1lO1xuICAgIHZhciBwcmV2Q2hpbGQ7XG4gICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldkNoaWxkICYmIHByZXZDaGlsZC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICBpZiAocHJldkNoaWxkICE9IG51bGwgJiYgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q2hpbGQsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IHByZXZDaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICByZW1vdmVkTm9kZXNbbmFtZV0gPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUocHJldkNoaWxkKTtcbiAgICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgdmFyIG5leHRDaGlsZEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IG5leHRDaGlsZEluc3RhbmNlO1xuICAgICAgICAvLyBDcmVhdGluZyBtb3VudCBpbWFnZSBub3cgZW5zdXJlcyByZWZzIGFyZSByZXNvbHZlZCBpbiByaWdodCBvcmRlclxuICAgICAgICAvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxMDEgZm9yIGV4cGxhbmF0aW9uKS5cbiAgICAgICAgdmFyIG5leHRDaGlsZE1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQobmV4dENoaWxkSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICBtb3VudEltYWdlcy5wdXNoKG5leHRDaGlsZE1vdW50SW1hZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBVbm1vdW50IGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgIGZvciAobmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIShuZXh0Q2hpbGRyZW4gJiYgbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSkge1xuICAgICAgICBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIHJlbW92ZWROb2Rlc1tuYW1lXSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q2hpbGQpO1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSByZW5kZXJlZENoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHJlbmRlcmVkQ2hpbGRyZW4sIHNhZmVseSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gcmVuZGVyZWRDaGlsZHJlbikge1xuICAgICAgaWYgKHJlbmRlcmVkQ2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkQ2hpbGQgPSByZW5kZXJlZENoaWxkcmVuW25hbWVdO1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChyZW5kZXJlZENoaWxkLCBzYWZlbHkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRSZWNvbmNpbGVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0SG9zdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0Q29tcG9uZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vLyBUbyBhdm9pZCBhIGN5Y2xpYyBkZXBlbmRlbmN5LCB3ZSBjcmVhdGUgdGhlIGZpbmFsIGNsYXNzIGluIHRoaXMgbW9kdWxlXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdGhpcy5jb25zdHJ1Y3QoZWxlbWVudCk7XG59O1xuX2Fzc2lnbihSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLCBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5NaXhpbiwge1xuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFxufSk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB0eXBlIHJlZmVyZW5jZSBpcyBhIGtub3duIGludGVybmFsIHR5cGUuIEkuZS4gbm90IGEgdXNlclxuICogcHJvdmlkZWQgY29tcG9zaXRlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHlwZVxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSB2YWxpZCBpbnRlcm5hbCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc0ludGVybmFsQ29tcG9uZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIG5leHREZWJ1Z0lEID0gMTtcblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0Tm9kZSwgY3JlYXRlIGFuIGluc3RhbmNlIHRoYXQgd2lsbCBhY3R1YWxseSBiZSBtb3VudGVkLlxuICpcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZEhhdmVEZWJ1Z0lEXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgbmV3IGluc3RhbmNlIG9mIHRoZSBlbGVtZW50J3MgY29uc3RydWN0b3IuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobm9kZSwgc2hvdWxkSGF2ZURlYnVnSUQpIHtcbiAgdmFyIGluc3RhbmNlO1xuXG4gIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IGZhbHNlKSB7XG4gICAgaW5zdGFuY2UgPSBSZWFjdEVtcHR5Q29tcG9uZW50LmNyZWF0ZShpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgZWxlbWVudCA9IG5vZGU7XG4gICAgIShlbGVtZW50ICYmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIGVsZW1lbnQudHlwZSA9PSBudWxsID8gZWxlbWVudC50eXBlIDogdHlwZW9mIGVsZW1lbnQudHlwZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKSkgOiBfcHJvZEludmFyaWFudCgnMTMwJywgZWxlbWVudC50eXBlID09IG51bGwgPyBlbGVtZW50LnR5cGUgOiB0eXBlb2YgZWxlbWVudC50eXBlLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oZWxlbWVudC5fb3duZXIpKSA6IHZvaWQgMDtcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBzdHJpbmcgdmFsdWVzXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnN0YW5jZSA9IFJlYWN0SG9zdENvbXBvbmVudC5jcmVhdGVJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKGlzSW50ZXJuYWxDb21wb25lbnRUeXBlKGVsZW1lbnQudHlwZSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGVtcG9yYXJpbHkgYXZhaWxhYmxlIGZvciBjdXN0b20gY29tcG9uZW50cyB0aGF0IGFyZSBub3Qgc3RyaW5nXG4gICAgICAvLyByZXByZXNlbnRhdGlvbnMuIEkuZS4gQVJULiBPbmNlIHRob3NlIGFyZSB1cGRhdGVkIHRvIHVzZSB0aGUgc3RyaW5nXG4gICAgICAvLyByZXByZXNlbnRhdGlvbiwgd2UgY2FuIGRyb3AgdGhpcyBjb2RlIHBhdGguXG4gICAgICBpbnN0YW5jZSA9IG5ldyBlbGVtZW50LnR5cGUoZWxlbWVudCk7XG5cbiAgICAgIC8vIFdlIHJlbmFtZWQgdGhpcy4gQWxsb3cgdGhlIG9sZCBuYW1lIGZvciBjb21wYXQuIDooXG4gICAgICBpZiAoIWluc3RhbmNlLmdldEhvc3ROb2RlKSB7XG4gICAgICAgIGluc3RhbmNlLmdldEhvc3ROb2RlID0gaW5zdGFuY2UuZ2V0TmF0aXZlTm9kZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UgPSBuZXcgUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyKGVsZW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5vZGUgPT09ICdudW1iZXInKSB7XG4gICAgaW5zdGFuY2UgPSBSZWFjdEhvc3RDb21wb25lbnQuY3JlYXRlSW5zdGFuY2VGb3JUZXh0KG5vZGUpO1xuICB9IGVsc2Uge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbmNvdW50ZXJlZCBpbnZhbGlkIFJlYWN0IG5vZGUgb2YgdHlwZSAlcycsIHR5cGVvZiBub2RlKSA6IF9wcm9kSW52YXJpYW50KCcxMzEnLCB0eXBlb2Ygbm9kZSkgOiB2b2lkIDA7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0YW5jZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0SG9zdE5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnVubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicsICdPbmx5IFJlYWN0IENvbXBvbmVudHMgY2FuIGJlIG1vdW50ZWQuJykgOiB2b2lkIDA7XG4gIH1cblxuICAvLyBUaGVzZSB0d28gZmllbGRzIGFyZSB1c2VkIGJ5IHRoZSBET00gYW5kIEFSVCBkaWZmaW5nIGFsZ29yaXRobXNcbiAgLy8gcmVzcGVjdGl2ZWx5LiBJbnN0ZWFkIG9mIHVzaW5nIGV4cGFuZG9zIG9uIGNvbXBvbmVudHMsIHdlIHNob3VsZCBiZVxuICAvLyBzdG9yaW5nIHRoZSBzdGF0ZSBuZWVkZWQgYnkgdGhlIGRpZmZpbmcgYWxnb3JpdGhtcyBlbHNld2hlcmUuXG4gIGluc3RhbmNlLl9tb3VudEluZGV4ID0gMDtcbiAgaW5zdGFuY2UuX21vdW50SW1hZ2UgPSBudWxsO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuX2RlYnVnSUQgPSBzaG91bGRIYXZlRGVidWdJRCA/IG5leHREZWJ1Z0lEKysgOiAwO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgaW5zdGFuY2VzIHNob3VsZCBmdWxseSBjb25zdHJ1Y3RlZCBhdCB0aGlzIHBvaW50LCBzbyB0aGV5IHNob3VsZFxuICAvLyBub3QgZ2V0IGFueSBuZXcgZmllbGRzIGFkZGVkIHRvIHRoZW0gYXQgdGhpcyBwb2ludC5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3ROb2RlVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0Tm9kZVR5cGVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG5cbnZhciBjaGVja1JlYWN0VHlwZVNwZWMgPSByZXF1aXJlKCcuL2NoZWNrUmVhY3RUeXBlU3BlYycpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgQ29tcG9zaXRlVHlwZXMgPSB7XG4gIEltcHVyZUNsYXNzOiAwLFxuICBQdXJlQ2xhc3M6IDEsXG4gIFN0YXRlbGVzc0Z1bmN0aW9uYWw6IDJcbn07XG5cbmZ1bmN0aW9uIFN0YXRlbGVzc0NvbXBvbmVudChDb21wb25lbnQpIHt9XG5TdGF0ZWxlc3NDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENvbXBvbmVudCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHRoaXMpLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICB2YXIgZWxlbWVudCA9IENvbXBvbmVudCh0aGlzLnByb3BzLCB0aGlzLmNvbnRleHQsIHRoaXMudXBkYXRlcik7XG4gIHdhcm5JZkludmFsaWRFbGVtZW50KENvbXBvbmVudCwgZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuZnVuY3Rpb24gd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCBlbGVtZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCksICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSAnICsgJ3JldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlQ29tcG9uZW50RGlkTW91bnRXaXRoVGltZXIoKSB7XG4gIHZhciBwdWJsaWNJbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudERpZE1vdW50Jyk7XG4gIH1cbiAgcHVibGljSW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50RGlkTW91bnQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VDb21wb25lbnREaWRVcGRhdGVXaXRoVGltZXIocHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSB7XG4gIHZhciBwdWJsaWNJbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICB9XG4gIHB1YmxpY0luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpO1xuICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhIShDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGlzUHVyZUNvbXBvbmVudChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCk7XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tIFRoZSBMaWZlLUN5Y2xlIG9mIGEgQ29tcG9zaXRlIENvbXBvbmVudCAtLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAtIGNvbnN0cnVjdG9yOiBJbml0aWFsaXphdGlvbiBvZiBzdGF0ZS4gVGhlIGluc3RhbmNlIGlzIG5vdyByZXRhaW5lZC5cbiAqICAgLSBjb21wb25lbnRXaWxsTW91bnRcbiAqICAgLSByZW5kZXJcbiAqICAgLSBbY2hpbGRyZW4ncyBjb25zdHJ1Y3RvcnNdXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlcl1cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudERpZE1vdW50XVxuICogICAgIC0gY29tcG9uZW50RGlkTW91bnRcbiAqXG4gKiAgICAgICBVcGRhdGUgUGhhc2VzOlxuICogICAgICAgLSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChvbmx5IGNhbGxlZCBpZiBwYXJlbnQgdXBkYXRlZClcbiAqICAgICAgIC0gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gKiAgICAgICAgIC0gY29tcG9uZW50V2lsbFVwZGF0ZVxuICogICAgICAgICAgIC0gcmVuZGVyXG4gKiAgICAgICAgICAgLSBbY2hpbGRyZW4ncyBjb25zdHJ1Y3RvcnMgb3IgcmVjZWl2ZSBwcm9wcyBwaGFzZXNdXG4gKiAgICAgICAgIC0gY29tcG9uZW50RGlkVXBkYXRlXG4gKlxuICogICAgIC0gY29tcG9uZW50V2lsbFVubW91bnRcbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxVbm1vdW50XVxuICogICAtIFtjaGlsZHJlbiBkZXN0cm95ZWRdXG4gKiAtIChkZXN0cm95ZWQpOiBUaGUgaW5zdGFuY2UgaXMgbm93IGJsYW5rLCByZWxlYXNlZCBieSBSZWFjdCBhbmQgcmVhZHkgZm9yIEdDLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBBbiBpbmNyZW1lbnRpbmcgSUQgYXNzaWduZWQgdG8gZWFjaCBjb21wb25lbnQgd2hlbiBpdCBpcyBtb3VudGVkLiBUaGlzIGlzXG4gKiB1c2VkIHRvIGVuZm9yY2UgdGhlIG9yZGVyIGluIHdoaWNoIGBSZWFjdFVwZGF0ZXNgIHVwZGF0ZXMgZGlydHkgY29tcG9uZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbmV4dE1vdW50SUQgPSAxO1xuXG4vKipcbiAqIEBsZW5kcyB7UmVhY3RDb21wb3NpdGVDb21wb25lbnQucHJvdG90eXBlfVxuICovXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpbiA9IHtcblxuICAvKipcbiAgICogQmFzZSBjb25zdHJ1Y3RvciBmb3IgYWxsIGNvbXBvc2l0ZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IG51bGw7XG4gICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZVF1ZXVlXG4gICAgdGhpcy5fdXBkYXRlQmF0Y2hOdW1iZXIgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX21vdW50T3JkZXIgPSAwO1xuICAgIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG5cbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVzIGFuZCBSZWFjdFVwZGF0ZVF1ZXVlLlxuICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuXG4gICAgLy8gQ29tcG9uZW50V2lsbFVubW91bnQgc2hhbGwgb25seSBiZSBjYWxsZWQgb25jZVxuICAgIHRoaXMuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50ID0gZmFsc2U7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhpcy5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaG9zdFBhcmVudFxuICAgKiBAcGFyYW0gez9vYmplY3R9IGhvc3RDb250YWluZXJJbmZvXG4gICAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX21vdW50T3JkZXIgPSBuZXh0TW91bnRJRCsrO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgcHVibGljUHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgcHVibGljQ29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICB2YXIgdXBkYXRlUXVldWUgPSB0cmFuc2FjdGlvbi5nZXRVcGRhdGVRdWV1ZSgpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcHVibGljIGNsYXNzXG4gICAgdmFyIGRvQ29uc3RydWN0ID0gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCk7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnQoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcblxuICAgIC8vIFN1cHBvcnQgZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gICAgaWYgKCFkb0NvbnN0cnVjdCAmJiAoaW5zdCA9PSBudWxsIHx8IGluc3QucmVuZGVyID09IG51bGwpKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSBpbnN0O1xuICAgICAgd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCByZW5kZXJlZEVsZW1lbnQpO1xuICAgICAgIShpbnN0ID09PSBudWxsIHx8IGluc3QgPT09IGZhbHNlIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChpbnN0KSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogQSB2YWxpZCBSZWFjdCBlbGVtZW50IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA1JywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIGluc3QgPSBuZXcgU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCk7XG4gICAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gQ29tcG9zaXRlVHlwZXMuU3RhdGVsZXNzRnVuY3Rpb25hbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzUHVyZUNvbXBvbmVudChDb21wb25lbnQpKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5QdXJlQ2xhc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gQ29tcG9zaXRlVHlwZXMuSW1wdXJlQ2xhc3M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBsYXRlciBpbiBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50LCBidXQgYWRkIGFuIGVhcmx5XG4gICAgICAvLyB3YXJuaW5nIG5vdyB0byBoZWxwIGRlYnVnZ2luZ1xuICAgICAgaWYgKGluc3QucmVuZGVyID09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcHNNdXRhdGVkID0gaW5zdC5wcm9wcyAhPT0gcHVibGljUHJvcHM7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW5zdC5wcm9wcyA9PT0gdW5kZWZpbmVkIHx8ICFwcm9wc011dGF0ZWQsICclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgJ3VwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnRcXCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gVGhlc2Ugc2hvdWxkIGJlIHNldCB1cCBpbiB0aGUgY29uc3RydWN0b3IsIGJ1dCBhcyBhIGNvbnZlbmllbmNlIGZvclxuICAgIC8vIHNpbXBsZXIgY2xhc3MgYWJzdHJhY3Rpb25zLCB3ZSBzZXQgdGhlbSB1cCBhZnRlciB0aGUgZmFjdC5cbiAgICBpbnN0LnByb3BzID0gcHVibGljUHJvcHM7XG4gICAgaW5zdC5jb250ZXh0ID0gcHVibGljQ29udGV4dDtcbiAgICBpbnN0LnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICBpbnN0LnVwZGF0ZXIgPSB1cGRhdGVRdWV1ZTtcblxuICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdDtcblxuICAgIC8vIFN0b3JlIGEgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIGJhY2sgdG8gdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5zZXQoaW5zdCwgdGhpcyk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gU2luY2UgcGxhaW4gSlMgY2xhc3NlcyBhcmUgZGVmaW5lZCB3aXRob3V0IGFueSBzcGVjaWFsIGluaXRpYWxpemF0aW9uXG4gICAgICAvLyBsb2dpYywgd2UgY2FuIG5vdCBjYXRjaCBjb21tb24gZXJyb3JzIGVhcmx5LiBUaGVyZWZvcmUsIHdlIGhhdmUgdG9cbiAgICAgIC8vIGNhdGNoIHRoZW0gaGVyZSwgYXQgaW5pdGlhbGl6YXRpb24gdGltZSwgaW5zdGVhZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0LmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldERlZmF1bHRQcm9wcyB8fCBpbnN0LmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QucHJvcFR5cGVzLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5jb250ZXh0VHlwZXMsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhICcgKyAnc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5zdC5zdGF0ZTtcbiAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3Quc3RhdGUgPSBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwNicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciBtYXJrdXA7XG4gICAgaWYgKGluc3QudW5zdGFibGVfaGFuZGxlRXJyb3IpIHtcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudFdpdGhFcnJvckhhbmRsaW5nKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnREaWRNb3VudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnZva2VDb21wb25lbnREaWRNb3VudFdpdGhUaW1lciwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGluc3QuY29tcG9uZW50RGlkTW91bnQsIGluc3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgX2NvbnN0cnVjdENvbXBvbmVudDogZnVuY3Rpb24gKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXIoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXI6IGZ1bmN0aW9uIChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGluc3RhbmNlT3JFbGVtZW50O1xuICAgIGlmIChkb0NvbnN0cnVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3RhbmNlT3JFbGVtZW50ID0gbmV3IENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY3RvcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgY2FuIHN0aWxsIGJlIGFuIGluc3RhbmNlIGluIGNhc2Ugb2YgZmFjdG9yeSBjb21wb25lbnRzXG4gICAgICAvLyBidXQgd2UnbGwgY291bnQgdGhpcyBhcyB0aW1lIHNwZW50IHJlbmRlcmluZyBhcyB0aGUgbW9yZSBjb21tb24gY2FzZS5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAncmVuZGVyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3RhbmNlT3JFbGVtZW50ID0gQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdyZW5kZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2VPckVsZW1lbnQ7XG4gIH0sXG5cbiAgcGVyZm9ybUluaXRpYWxNb3VudFdpdGhFcnJvckhhbmRsaW5nOiBmdW5jdGlvbiAocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbWFya3VwO1xuICAgIHZhciBjaGVja3BvaW50ID0gdHJhbnNhY3Rpb24uY2hlY2twb2ludCgpO1xuICAgIHRyeSB7XG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUm9sbCBiYWNrIHRvIGNoZWNrcG9pbnQsIGhhbmRsZSBlcnJvciAod2hpY2ggbWF5IGFkZCBpdGVtcyB0byB0aGUgdHJhbnNhY3Rpb24pLCBhbmQgdGFrZSBhIG5ldyBjaGVja3BvaW50XG4gICAgICB0cmFuc2FjdGlvbi5yb2xsYmFjayhjaGVja3BvaW50KTtcbiAgICAgIHRoaXMuX2luc3RhbmNlLnVuc3RhYmxlX2hhbmRsZUVycm9yKGUpO1xuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlLnN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZSh0aGlzLl9pbnN0YW5jZS5wcm9wcywgdGhpcy5faW5zdGFuY2UuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBjaGVja3BvaW50ID0gdHJhbnNhY3Rpb24uY2hlY2twb2ludCgpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudC51bm1vdW50Q29tcG9uZW50KHRydWUpO1xuICAgICAgdHJhbnNhY3Rpb24ucm9sbGJhY2soY2hlY2twb2ludCk7XG5cbiAgICAgIC8vIFRyeSBhZ2FpbiAtIHdlJ3ZlIGluZm9ybWVkIHRoZSBjb21wb25lbnQgYWJvdXQgdGhlIGVycm9yLCBzbyB0aGV5IGNhbiByZW5kZXIgYW4gZXJyb3IgbWVzc2FnZSB0aGlzIHRpbWUuXG4gICAgICAvLyBJZiB0aGlzIHRocm93cyBhZ2FpbiwgdGhlIGVycm9yIHdpbGwgYnViYmxlIHVwIChhbmQgY2FuIGJlIGNhdWdodCBieSBhIGhpZ2hlciBlcnJvciBib3VuZGFyeSkuXG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIHBlcmZvcm1Jbml0aWFsTW91bnQ6IGZ1bmN0aW9uIChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbE1vdW50KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdoZW4gbW91bnRpbmcsIGNhbGxzIHRvIGBzZXRTdGF0ZWAgYnkgYGNvbXBvbmVudFdpbGxNb3VudGAgd2lsbCBzZXRcbiAgICAgIC8vIGB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZWAgd2l0aG91dCB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyLlxuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XG4gICAgICAgIGluc3Quc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKGluc3QucHJvcHMsIGluc3QuY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm90IGEgc3RhdGVsZXNzIGNvbXBvbmVudCwgd2Ugbm93IHJlbmRlclxuICAgIGlmIChyZW5kZXJlZEVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVUeXBlID0gUmVhY3ROb2RlVHlwZXMuZ2V0VHlwZShyZW5kZXJlZEVsZW1lbnQpO1xuICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBub2RlVHlwZTtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KHJlbmRlcmVkRWxlbWVudCwgbm9kZVR5cGUgIT09IFJlYWN0Tm9kZVR5cGVzLkVNUFRZIC8qIHNob3VsZEhhdmVEZWJ1Z0lEICovXG4gICAgKTtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGNoaWxkO1xuXG4gICAgdmFyIHNlbGZEZWJ1Z0lEID0gMDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2VsZkRlYnVnSUQgPSB0aGlzLl9kZWJ1Z0lEO1xuICAgIH1cbiAgICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCksIHNlbGZEZWJ1Z0lEKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbih0aGlzLl9kZWJ1Z0lELCBjaGlsZC5fZGVidWdJRCAhPT0gMCA/IFtjaGlsZC5fZGVidWdJRF0gOiBbXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoc2FmZWx5KSB7XG4gICAgaWYgKCF0aGlzLl9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVubW91bnQgJiYgIWluc3QuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50KSB7XG4gICAgICBpbnN0Ll9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCA9IHRydWU7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzYWZlbHkpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmdldE5hbWUoKSArICcuY29tcG9uZW50V2lsbFVubW91bnQoKSc7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudC5iaW5kKGluc3QpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LCBzYWZlbHkpO1xuICAgICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG51bGw7XG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgcGVuZGluZyBmaWVsZHNcbiAgICAvLyBFdmVuIGlmIHRoaXMgY29tcG9uZW50IGlzIHNjaGVkdWxlZCBmb3IgYW5vdGhlciB1cGRhdGUgaW4gUmVhY3RVcGRhdGVzLFxuICAgIC8vIGl0IHdvdWxkIHN0aWxsIGJlIGlnbm9yZWQgYmVjYXVzZSB0aGVzZSBmaWVsZHMgYXJlIHJlc2V0LlxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgLy8gVGhlc2UgZmllbGRzIGRvIG5vdCByZWFsbHkgbmVlZCB0byBiZSByZXNldCBzaW5jZSB0aGlzIG9iamVjdCBpcyBub1xuICAgIC8vIGxvbmdlciBhY2Nlc3NpYmxlLlxuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICAgIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG5cbiAgICAvLyBEZWxldGUgdGhlIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSB0byB0aGlzIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgLy8gd2hpY2ggYWxsb3cgdGhlIGludGVybmFscyB0byBiZSBwcm9wZXJseSBjbGVhbmVkIHVwIGV2ZW4gaWYgdGhlIHVzZXJcbiAgICAvLyBsZWFrcyBhIHJlZmVyZW5jZSB0byB0aGUgcHVibGljIGluc3RhbmNlLlxuICAgIFJlYWN0SW5zdGFuY2VNYXAucmVtb3ZlKGluc3QpO1xuXG4gICAgLy8gU29tZSBleGlzdGluZyBjb21wb25lbnRzIHJlbHkgb24gaW5zdC5wcm9wcyBldmVuIGFmdGVyIHRoZXkndmUgYmVlblxuICAgIC8vIGRlc3Ryb3llZCAoaW4gZXZlbnQgaGFuZGxlcnMpLlxuICAgIC8vIFRPRE86IGluc3QucHJvcHMgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3Quc3RhdGUgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3QuY29udGV4dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21hc2tDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBDb21wb25lbnQuY29udGV4dFR5cGVzO1xuICAgIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gICAgfVxuICAgIHZhciBtYXNrZWRDb250ZXh0ID0ge307XG4gICAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBtYXNrZWRDb250ZXh0W2NvbnRleHROYW1lXSA9IGNvbnRleHRbY29udGV4dE5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgLCBhbmQgYXNzZXJ0cyB0aGF0IHRoZXkgYXJlIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gdGhpcy5fbWFza0NvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgaWYgKENvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tDb250ZXh0VHlwZXMoQ29tcG9uZW50LmNvbnRleHRUeXBlcywgbWFza2VkQ29udGV4dCwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjdXJyZW50Q29udGV4dFxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0KCk7XG4gICAgfVxuICAgIHZhciBjaGlsZENvbnRleHQgPSBpbnN0LmdldENoaWxkQ29udGV4dCAmJiBpbnN0LmdldENoaWxkQ29udGV4dCgpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0KCk7XG4gICAgfVxuICAgIGlmIChjaGlsZENvbnRleHQpIHtcbiAgICAgICEodHlwZW9mIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gdXNlIGdldENoaWxkQ29udGV4dCgpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwNycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tDb250ZXh0VHlwZXMoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY2hpbGRDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICAgICEobmFtZSBpbiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzEwOCcsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9hc3NpZ24oe30sIGN1cnJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IHRoZSBjb250ZXh0IHR5cGVzIGFyZSB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBjb250ZXh0IGZpZWxkIHRvIGEgUmVhY3RQcm9wVHlwZVxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrQ29udGV4dFR5cGVzOiBmdW5jdGlvbiAodHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uKSB7XG4gICAgY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgdGhpcy5nZXROYW1lKCksIG51bGwsIHRoaXMuX2RlYnVnSUQpO1xuICB9LFxuXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIG5leHRDb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIHByZXZDb250ZXh0ID0gdGhpcy5fY29udGV4dDtcblxuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcblxuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIHByZXZDb250ZXh0LCBuZXh0Q29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIGFueSBvZiBgX3BlbmRpbmdFbGVtZW50YCwgYF9wZW5kaW5nU3RhdGVRdWV1ZWAsIG9yIGBfcGVuZGluZ0ZvcmNlVXBkYXRlYFxuICAgKiBpcyBzZXQsIHVwZGF0ZSB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodGhpcy5fcGVuZGluZ0VsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQodGhpcywgdGhpcy5fcGVuZGluZ0VsZW1lbnQsIHRyYW5zYWN0aW9uLCB0aGlzLl9jb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlICE9PSBudWxsIHx8IHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY29udGV4dCwgdGhpcy5fY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYW4gdXBkYXRlIHRvIGEgbW91bnRlZCBjb21wb25lbnQuIFRoZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGFuZFxuICAgKiBzaG91bGRDb21wb25lbnRVcGRhdGUgbWV0aG9kcyBhcmUgY2FsbGVkLCB0aGVuIChhc3N1bWluZyB0aGUgdXBkYXRlIGlzbid0XG4gICAqIHNraXBwZWQpIHRoZSByZW1haW5pbmcgdXBkYXRlIGxpZmVjeWNsZSBtZXRob2RzIGFyZSBjYWxsZWQgYW5kIHRoZSBET01cbiAgICogcmVwcmVzZW50YXRpb24gaXMgdXBkYXRlZC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBwcmV2UGFyZW50RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dFBhcmVudEVsZW1lbnRcbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByZXZQYXJlbnRFbGVtZW50LCBuZXh0UGFyZW50RWxlbWVudCwgcHJldlVubWFza2VkQ29udGV4dCwgbmV4dFVubWFza2VkQ29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgIShpbnN0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0F0dGVtcHRlZCB0byB1cGRhdGUgY29tcG9uZW50IGAlc2AgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHVubW91bnRlZCAob3IgZmFpbGVkIHRvIG1vdW50KS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMzYnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgIHZhciB3aWxsUmVjZWl2ZSA9IGZhbHNlO1xuICAgIHZhciBuZXh0Q29udGV4dDtcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgY29udGV4dCBoYXMgY2hhbmdlZCBvciBub3RcbiAgICBpZiAodGhpcy5fY29udGV4dCA9PT0gbmV4dFVubWFza2VkQ29udGV4dCkge1xuICAgICAgbmV4dENvbnRleHQgPSBpbnN0LmNvbnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQobmV4dFVubWFza2VkQ29udGV4dCk7XG4gICAgICB3aWxsUmVjZWl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHByZXZQcm9wcyA9IHByZXZQYXJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSBuZXh0UGFyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIE5vdCBhIHNpbXBsZSBzdGF0ZSB1cGRhdGUgYnV0IGEgcHJvcHMgdXBkYXRlXG4gICAgaWYgKHByZXZQYXJlbnRFbGVtZW50ICE9PSBuZXh0UGFyZW50RWxlbWVudCkge1xuICAgICAgd2lsbFJlY2VpdmUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEFuIHVwZGF0ZSBoZXJlIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIGJ1dCBpbW1lZGlhdGVseSBzZXRcbiAgICAvLyBfcGVuZGluZ1N0YXRlUXVldWUgd2hpY2ggd2lsbCBlbnN1cmUgdGhhdCBhbnkgc3RhdGUgdXBkYXRlcyBnZXRzXG4gICAgLy8gaW1tZWRpYXRlbHkgcmVjb25jaWxlZCBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIHRoZSBuZXh0IGJhdGNoLlxuICAgIGlmICh3aWxsUmVjZWl2ZSAmJiBpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcblxuICAgIGlmICghdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XG4gICAgICBpZiAoaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNob3VsZFVwZGF0ZSA9IGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdzaG91bGRDb21wb25lbnRVcGRhdGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21wb3NpdGVUeXBlID09PSBDb21wb3NpdGVUeXBlcy5QdXJlQ2xhc3MpIHtcbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSAhc2hhbGxvd0VxdWFsKHByZXZQcm9wcywgbmV4dFByb3BzKSB8fCAhc2hhbGxvd0VxdWFsKGluc3Quc3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgICAvLyBXaWxsIHNldCBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAuXG4gICAgICB0aGlzLl9wZXJmb3JtQ29tcG9uZW50VXBkYXRlKG5leHRQYXJlbnRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCBuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgaXQncyBkZXRlcm1pbmVkIHRoYXQgYSBjb21wb25lbnQgc2hvdWxkIG5vdCB1cGRhdGUsIHdlIHN0aWxsIHdhbnRcbiAgICAgIC8vIHRvIHNldCBwcm9wcyBhbmQgc3RhdGUgYnV0IHdlIHNob3J0Y3V0IHRoZSByZXN0IG9mIHRoZSB1cGRhdGUuXG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRQYXJlbnRFbGVtZW50O1xuICAgICAgdGhpcy5fY29udGV4dCA9IG5leHRVbm1hc2tlZENvbnRleHQ7XG4gICAgICBpbnN0LnByb3BzID0gbmV4dFByb3BzO1xuICAgICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICAgIH1cbiAgfSxcblxuICBfcHJvY2Vzc1BlbmRpbmdTdGF0ZTogZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZTtcbiAgICB2YXIgcmVwbGFjZSA9IHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGU7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgIGlmICghcXVldWUpIHtcbiAgICAgIHJldHVybiBpbnN0LnN0YXRlO1xuICAgIH1cblxuICAgIGlmIChyZXBsYWNlICYmIHF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHF1ZXVlWzBdO1xuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSBfYXNzaWduKHt9LCByZXBsYWNlID8gcXVldWVbMF0gOiBpbnN0LnN0YXRlKTtcbiAgICBmb3IgKHZhciBpID0gcmVwbGFjZSA/IDEgOiAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0aWFsID0gcXVldWVbaV07XG4gICAgICBfYXNzaWduKG5leHRTdGF0ZSwgdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBwcm9wcywgY29udGV4dCkgOiBwYXJ0aWFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNZXJnZXMgbmV3IHByb3BzIGFuZCBzdGF0ZSwgbm90aWZpZXMgZGVsZWdhdGUgbWV0aG9kcyBvZiB1cGRhdGUgYW5kXG4gICAqIHBlcmZvcm1zIHVwZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IE5leHQgZWxlbWVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzIE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGUgTmV4dCBvYmplY3QgdG8gc2V0IGFzIHN0YXRlLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0IE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgY29udGV4dC5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHVubWFza2VkQ29udGV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BlcmZvcm1Db21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIHZhciBoYXNDb21wb25lbnREaWRVcGRhdGUgPSBCb29sZWFuKGluc3QuY29tcG9uZW50RGlkVXBkYXRlKTtcbiAgICB2YXIgcHJldlByb3BzO1xuICAgIHZhciBwcmV2U3RhdGU7XG4gICAgdmFyIHByZXZDb250ZXh0O1xuICAgIGlmIChoYXNDb21wb25lbnREaWRVcGRhdGUpIHtcbiAgICAgIHByZXZQcm9wcyA9IGluc3QucHJvcHM7XG4gICAgICBwcmV2U3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgICAgcHJldkNvbnRleHQgPSBpbnN0LmNvbnRleHQ7XG4gICAgfVxuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLl9jb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcblxuICAgIHRoaXMuX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnZva2VDb21wb25lbnREaWRVcGRhdGVXaXRoVGltZXIuYmluZCh0aGlzLCBwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRVcGRhdGUuYmluZChpbnN0LCBwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpLCBpbnN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIGNvbXBvbmVudCdzIGByZW5kZXJgIG1ldGhvZCBhbmQgdXBkYXRlIHRoZSBET00gYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBfdXBkYXRlUmVuZGVyZWRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2Q29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICB2YXIgcHJldlJlbmRlcmVkRWxlbWVudCA9IHByZXZDb21wb25lbnRJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIG5leHRSZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcbiAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldlJlbmRlcmVkRWxlbWVudCwgbmV4dFJlbmRlcmVkRWxlbWVudCkpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHByZXZDb21wb25lbnRJbnN0YW5jZSwgbmV4dFJlbmRlcmVkRWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb2xkSG9zdE5vZGUgPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUocHJldkNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDb21wb25lbnRJbnN0YW5jZSwgZmFsc2UpO1xuXG4gICAgICB2YXIgbm9kZVR5cGUgPSBSZWFjdE5vZGVUeXBlcy5nZXRUeXBlKG5leHRSZW5kZXJlZEVsZW1lbnQpO1xuICAgICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG5vZGVUeXBlO1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5faW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0UmVuZGVyZWRFbGVtZW50LCBub2RlVHlwZSAhPT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkgLyogc2hvdWxkSGF2ZURlYnVnSUQgKi9cbiAgICAgICk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGNoaWxkO1xuXG4gICAgICB2YXIgc2VsZkRlYnVnSUQgPSAwO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2VsZkRlYnVnSUQgPSB0aGlzLl9kZWJ1Z0lEO1xuICAgICAgfVxuICAgICAgdmFyIG5leHRNYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCB0aGlzLl9ob3N0UGFyZW50LCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSwgc2VsZkRlYnVnSUQpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIGNoaWxkLl9kZWJ1Z0lEICE9PSAwID8gW2NoaWxkLl9kZWJ1Z0lEXSA6IFtdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZDb21wb25lbnRJbnN0YW5jZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZGVuIGluIHNoYWxsb3cgcmVuZGVyaW5nLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZJbnN0YW5jZSkge1xuICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwKG9sZEhvc3ROb2RlLCBuZXh0TWFya3VwLCBwcmV2SW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdyZW5kZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlbmRlcmVkQ29tcG9uZW50ID0gaW5zdC5yZW5kZXIoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgIGlmIChyZW5kZXJlZENvbXBvbmVudCA9PT0gdW5kZWZpbmVkICYmIGluc3QucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICByZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlcmVkQ29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByZW5kZXJlZENvbXBvbmVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyB8fCB0aGlzLl9jb21wb3NpdGVUeXBlICE9PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsKSB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlbmRlcmVkQ29tcG9uZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0KCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICB9XG4gICAgIShcbiAgICAvLyBUT0RPOiBBbiBgaXNWYWxpZE5vZGVgIGZ1bmN0aW9uIHdvdWxkIHByb2JhYmx5IGJlIG1vcmUgYXBwcm9wcmlhdGVcbiAgICByZW5kZXJlZENvbXBvbmVudCA9PT0gbnVsbCB8fCByZW5kZXJlZENvbXBvbmVudCA9PT0gZmFsc2UgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHJlbmRlcmVkQ29tcG9uZW50KSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMucmVuZGVyKCk6IEEgdmFsaWQgUmVhY3QgZWxlbWVudCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDknLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgIHJldHVybiByZW5kZXJlZENvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogTGF6aWx5IGFsbG9jYXRlcyB0aGUgcmVmcyBvYmplY3QgYW5kIHN0b3JlcyBgY29tcG9uZW50YCBhcyBgcmVmYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBSZWZlcmVuY2UgbmFtZS5cbiAgICogQHBhcmFtIHtjb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gc3RvcmUgYXMgYHJlZmAuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXR0YWNoUmVmOiBmdW5jdGlvbiAocmVmLCBjb21wb25lbnQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTAnKSA6IHZvaWQgMDtcbiAgICB2YXIgcHVibGljQ29tcG9uZW50SW5zdGFuY2UgPSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQgJiYgY29tcG9uZW50LmdldE5hbWUgPyBjb21wb25lbnQuZ2V0TmFtZSgpIDogJ2EgY29tcG9uZW50JztcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHB1YmxpY0NvbXBvbmVudEluc3RhbmNlICE9IG51bGwsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcyAnICsgJyhTZWUgcmVmIFwiJXNcIiBpbiAlcyBjcmVhdGVkIGJ5ICVzKS4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLicsIHJlZiwgY29tcG9uZW50TmFtZSwgdGhpcy5nZXROYW1lKCkpIDogdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICByZWZzW3JlZl0gPSBwdWJsaWNDb21wb25lbnRJbnN0YW5jZTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0YWNoZXMgYSByZWZlcmVuY2UgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAZmluYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGFjaFJlZjogZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciByZWZzID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlZnM7XG4gICAgZGVsZXRlIHJlZnNbcmVmXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgaXRcbiAgICogaW4gZXJyb3IgbWVzc2FnZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5hbWUgb3IgbnVsbC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5uYW1lIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljbHkgYWNjZXNzaWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudCAtIGkuZS4gd2hhdFxuICAgKiBpcyBleHBvc2VkIGJ5IHJlZnMgYW5kIHJldHVybmVkIGJ5IHJlbmRlci4gQ2FuIGJlIG51bGwgZm9yIHN0YXRlbGVzc1xuICAgKiBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gdGhlIHB1YmxpYyBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIGlmICh0aGlzLl9jb21wb3NpdGVUeXBlID09PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0sXG5cbiAgLy8gU3R1YlxuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogbnVsbFxuXG59O1xuXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSB7XG5cbiAgTWl4aW46IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Tm9kZVR5cGVzXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdE5vZGVUeXBlcyA9IHtcbiAgSE9TVDogMCxcbiAgQ09NUE9TSVRFOiAxLFxuICBFTVBUWTogMixcblxuICBnZXRUeXBlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuRU1QVFk7XG4gICAgfSBlbHNlIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZS50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5DT01QT1NJVEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuSE9TVDtcbiAgICAgIH1cbiAgICB9XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1VuZXhwZWN0ZWQgbm9kZTogJXMnLCBub2RlKSA6IF9wcm9kSW52YXJpYW50KCcyNicsIG5vZGUpIDogdm9pZCAwO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9kZVR5cGVzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3ROb2RlVHlwZXMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhIGBwcmV2RWxlbWVudGAgYW5kIGBuZXh0RWxlbWVudGAsIGRldGVybWluZXMgaWYgdGhlIGV4aXN0aW5nXG4gKiBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZCBhcyBvcHBvc2VkIHRvIGJlaW5nIGRlc3Ryb3llZCBvciByZXBsYWNlZCBieSBhIG5ld1xuICogaW5zdGFuY2UuIEJvdGggYXJndW1lbnRzIGFyZSBlbGVtZW50cy4gVGhpcyBlbnN1cmVzIHRoYXQgdGhpcyBsb2dpYyBjYW5cbiAqIG9wZXJhdGUgb24gc3RhdGVsZXNzIHRyZWVzIHdpdGhvdXQgYW55IGJhY2tpbmcgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2RWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0RWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXhpc3RpbmcgaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSB7XG4gIHZhciBwcmV2RW1wdHkgPSBwcmV2RWxlbWVudCA9PT0gbnVsbCB8fCBwcmV2RWxlbWVudCA9PT0gZmFsc2U7XG4gIHZhciBuZXh0RW1wdHkgPSBuZXh0RWxlbWVudCA9PT0gbnVsbCB8fCBuZXh0RWxlbWVudCA9PT0gZmFsc2U7XG4gIGlmIChwcmV2RW1wdHkgfHwgbmV4dEVtcHR5KSB7XG4gICAgcmV0dXJuIHByZXZFbXB0eSA9PT0gbmV4dEVtcHR5O1xuICB9XG5cbiAgdmFyIHByZXZUeXBlID0gdHlwZW9mIHByZXZFbGVtZW50O1xuICB2YXIgbmV4dFR5cGUgPSB0eXBlb2YgbmV4dEVsZW1lbnQ7XG4gIGlmIChwcmV2VHlwZSA9PT0gJ3N0cmluZycgfHwgcHJldlR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5leHRUeXBlID09PSAnc3RyaW5nJyB8fCBuZXh0VHlwZSA9PT0gJ251bWJlcic7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5leHRUeXBlID09PSAnb2JqZWN0JyAmJiBwcmV2RWxlbWVudC50eXBlID09PSBuZXh0RWxlbWVudC50eXBlICYmIHByZXZFbGVtZW50LmtleSA9PT0gbmV4dEVsZW1lbnQua2V5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVtcHR5Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlDb21wb25lbnRGYWN0b3J5O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RW1wdHlDb21wb25lbnRGYWN0b3J5OiBmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGVtcHR5Q29tcG9uZW50RmFjdG9yeSA9IGZhY3Rvcnk7XG4gIH1cbn07XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAgIHJldHVybiBlbXB0eUNvbXBvbmVudEZhY3RvcnkoaW5zdGFudGlhdGUpO1xuICB9XG59O1xuXG5SZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbiA9IFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbXB0eUNvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RW1wdHlDb21wb25lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RIb3N0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IG51bGw7XG4vLyBUaGlzIHJlZ2lzdHJ5IGtlZXBzIHRyYWNrIG9mIHdyYXBwZXIgY2xhc3NlcyBhcm91bmQgaG9zdCB0YWdzLlxudmFyIHRhZ1RvQ29tcG9uZW50Q2xhc3MgPSB7fTtcbnZhciB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBudWxsO1xuXG52YXIgUmVhY3RIb3N0Q29tcG9uZW50SW5qZWN0aW9uID0ge1xuICAvLyBUaGlzIGFjY2VwdHMgYSBjbGFzcyB0aGF0IHJlY2VpdmVzIHRoZSB0YWcgc3RyaW5nLiBUaGlzIGlzIGEgY2F0Y2ggYWxsXG4gIC8vIHRoYXQgY2FuIHJlbmRlciBhbnkga2luZCBvZiB0YWcuXG4gIGluamVjdEdlbmVyaWNDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgZ2VuZXJpY0NvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XG4gIH0sXG4gIC8vIFRoaXMgYWNjZXB0cyBhIHRleHQgY29tcG9uZW50IGNsYXNzIHRoYXQgdGFrZXMgdGhlIHRleHQgc3RyaW5nIHRvIGJlXG4gIC8vIHJlbmRlcmVkIGFzIHByb3BzLlxuICBpbmplY3RUZXh0Q29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgIHRleHRDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSBrZXllZCBvYmplY3Qgd2l0aCBjbGFzc2VzIGFzIHZhbHVlcy4gRWFjaCBrZXkgcmVwcmVzZW50cyBhXG4gIC8vIHRhZy4gVGhhdCBwYXJ0aWN1bGFyIHRhZyB3aWxsIHVzZSB0aGlzIGNsYXNzIGluc3RlYWQgb2YgdGhlIGdlbmVyaWMgb25lLlxuICBpbmplY3RDb21wb25lbnRDbGFzc2VzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3Nlcykge1xuICAgIF9hc3NpZ24odGFnVG9Db21wb25lbnRDbGFzcywgY29tcG9uZW50Q2xhc3Nlcyk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGEgaG9zdCBpbnRlcm5hbCBjb21wb25lbnQgY2xhc3MgZm9yIGEgc3BlY2lmaWMgdGFnLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGNyZWF0ZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgaW50ZXJuYWwgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgIWdlbmVyaWNDb21wb25lbnRDbGFzcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBpcyBubyByZWdpc3RlcmVkIGNvbXBvbmVudCBmb3IgdGhlIHRhZyAlcycsIGVsZW1lbnQudHlwZSkgOiBfcHJvZEludmFyaWFudCgnMTExJywgZWxlbWVudC50eXBlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIG5ldyBnZW5lcmljQ29tcG9uZW50Q2xhc3MoZWxlbWVudCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdFRleHR9IHRleHRcbiAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUZvclRleHQodGV4dCkge1xuICByZXR1cm4gbmV3IHRleHRDb21wb25lbnRDbGFzcyh0ZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVGV4dENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIGNvbXBvbmVudCBpbnN0YW5jZW9mIHRleHRDb21wb25lbnRDbGFzcztcbn1cblxudmFyIFJlYWN0SG9zdENvbXBvbmVudCA9IHtcbiAgY3JlYXRlSW50ZXJuYWxDb21wb25lbnQ6IGNyZWF0ZUludGVybmFsQ29tcG9uZW50LFxuICBjcmVhdGVJbnN0YW5jZUZvclRleHQ6IGNyZWF0ZUluc3RhbmNlRm9yVGV4dCxcbiAgaXNUZXh0Q29tcG9uZW50OiBpc1RleHRDb21wb25lbnQsXG4gIGluamVjdGlvbjogUmVhY3RIb3N0Q29tcG9uZW50SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SG9zdENvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SG9zdENvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmbGF0dGVuQ2hpbGRyZW5cbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IHBhc3NlZCB0aHJvdWdoIHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7P1JlYWN0Q29tcG9uZW50fSBjaGlsZCBSZWFjdCBjaGlsZCBjb21wb25lbnQuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWUgU3RyaW5nIG5hbWUgb2Yga2V5IHBhdGggdG8gY2hpbGQuXG4gKiBAcGFyYW0ge251bWJlcj19IHNlbGZEZWJ1Z0lEIE9wdGlvbmFsIGRlYnVnSUQgb2YgdGhlIGN1cnJlbnQgaW50ZXJuYWwgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKSB7XG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICBpZiAodHJhdmVyc2VDb250ZXh0ICYmIHR5cGVvZiB0cmF2ZXJzZUNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyYXZlcnNlQ29udGV4dDtcbiAgICB2YXIga2V5VW5pcXVlID0gcmVzdWx0W25hbWVdID09PSB1bmRlZmluZWQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWtleVVuaXF1ZSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLiVzJywgS2V5RXNjYXBlVXRpbHMudW5lc2NhcGUobmFtZSksIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoc2VsZkRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleVVuaXF1ZSAmJiBjaGlsZCAhPSBudWxsKSB7XG4gICAgICByZXN1bHRbbmFtZV0gPSBjaGlsZDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBGbGF0dGVucyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuIEFueSBudWxsXG4gKiBjaGlsZHJlbiB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIEByZXR1cm4geyFvYmplY3R9IGZsYXR0ZW5lZCBjaGlsZHJlbiBrZXllZCBieSBuYW1lLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4sIHNlbGZEZWJ1Z0lEKSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gICAgICByZXR1cm4gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpO1xuICAgIH0sIHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuQ2hpbGRyZW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9mbGF0dGVuQ2hpbGRyZW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlJyk7XG5cbi8qKlxuICogRXhlY3V0ZWQgd2l0aGluIHRoZSBzY29wZSBvZiB0aGUgYFRyYW5zYWN0aW9uYCBpbnN0YW5jZS4gQ29uc2lkZXIgdGhlc2UgYXNcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cbiAqIGVhY2ggb3RoZXIuXG4gKi9cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtdO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBUUkFOU0FDVElPTl9XUkFQUEVSUy5wdXNoKHtcbiAgICBpbml0aWFsaXplOiBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkZsdXNoLFxuICAgIGNsb3NlOiBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRGbHVzaFxuICB9KTtcbn1cblxudmFyIG5vb3BDYWxsYmFja1F1ZXVlID0ge1xuICBlbnF1ZXVlOiBmdW5jdGlvbiAoKSB7fVxufTtcblxuLyoqXG4gKiBAY2xhc3MgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSByZW5kZXJUb1N0YXRpY01hcmt1cFxuICovXG5mdW5jdGlvbiBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKHJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IHJlbmRlclRvU3RhdGljTWFya3VwO1xuICB0aGlzLnVzZUNyZWF0ZUVsZW1lbnQgPSBmYWxzZTtcbiAgdGhpcy51cGRhdGVRdWV1ZSA9IG5ldyBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlKHRoaXMpO1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXl9IEVtcHR5IGxpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5vb3BDYWxsYmFja1F1ZXVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IFJlYWN0IGFzeW5jIGV2ZW50cy5cbiAgICovXG4gIGdldFVwZGF0ZVF1ZXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMsIGFuZCB3aWxsIGludm9rZSB0aGlzIGJlZm9yZSBhbGxvd2luZyB0aGlzXG4gICAqIGluc3RhbmNlIHRvIGJlIHJldXNlZC5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIGNoZWNrcG9pbnQ6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIHJvbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxufTtcblxuX2Fzc2lnbihSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIE1peGluKTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0U2VydmVyVXBkYXRlUXVldWVcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb3V0c2lkZSBjb21wb25lbnRXaWxsTW91bnQoKSBvbiB0aGUgc2VydmVyLiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgdXBkYXRlIHF1ZXVlIHVzZWQgZm9yIHNlcnZlciByZW5kZXJpbmcuXG4gKiBJdCBkZWxlZ2F0ZXMgdG8gUmVhY3RVcGRhdGVRdWV1ZSB3aGlsZSBzZXJ2ZXIgcmVuZGVyaW5nIGlzIGluIHByb2dyZXNzIGFuZFxuICogc3dpdGNoZXMgdG8gUmVhY3ROb29wVXBkYXRlUXVldWUgYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uIGhhcyBjb21wbGV0ZWQuXG4gKiBAY2xhc3MgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZVxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqL1xuXG52YXIgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyogOjogdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uOyAqL1xuXG4gIGZ1bmN0aW9uIFJlYWN0U2VydmVyVXBkYXRlUXVldWUodHJhbnNhY3Rpb24pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSk7XG5cbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmlzTW91bnRlZCA9IGZ1bmN0aW9uIGlzTW91bnRlZChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVDYWxsYmFjayA9IGZ1bmN0aW9uIGVucXVldWVDYWxsYmFjayhwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2socHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVGb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIGVucXVldWVGb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVGb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZVJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIGVucXVldWVSZXBsYWNlU3RhdGUocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlUmVwbGFjZVN0YXRlKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZVNldFN0YXRlID0gZnVuY3Rpb24gZW5xdWV1ZVNldFN0YXRlKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlU2V0U3RhdGUocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0U2VydmVyVXBkYXRlUXVldWU7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0U2VydmVyVXBkYXRlUXVldWUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RVcGRhdGVRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKSB7XG4gIFJlYWN0VXBkYXRlcy5lbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQoYXJnKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGFyZztcbiAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgdmFyIGRpc3BsYXlOYW1lID0gYXJnLmNvbnN0cnVjdG9yICYmIGFyZy5jb25zdHJ1Y3Rvci5uYW1lIHx8IHR5cGU7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYXJnKTtcbiAgaWYgKGtleXMubGVuZ3RoID4gMCAmJiBrZXlzLmxlbmd0aCA8IDIwKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lICsgJyAoa2V5czogJyArIGtleXMuam9pbignLCAnKSArICcpJztcbiAgfVxuICByZXR1cm4gZGlzcGxheU5hbWU7XG59XG5cbmZ1bmN0aW9uIGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgICAvLyBPbmx5IHdhcm4gd2hlbiB3ZSBoYXZlIGEgY2FsbGVyTmFtZS4gT3RoZXJ3aXNlIHdlIHNob3VsZCBiZSBzaWxlbnQuXG4gICAgICAvLyBXZSdyZSBwcm9iYWJseSBjYWxsaW5nIGZyb20gZW5xdWV1ZUNhbGxiYWNrLiBXZSBkb24ndCB3YW50IHRvIHdhcm5cbiAgICAgIC8vIHRoZXJlIGJlY2F1c2Ugd2UgYWxyZWFkeSB3YXJuZWQgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGxpZmVjeWNsZSBtZXRob2QuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY2FsbGVyTmFtZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjdG9yICYmIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJyVzKC4uLik6IENhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgJyArICd3aXRoaW4gYHJlbmRlcmAgb3IgYW5vdGhlciBjb21wb25lbnRcXCdzIGNvbnN0cnVjdG9yKS4gUmVuZGVyIG1ldGhvZHMgJyArICdzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgY29uc3RydWN0b3IgJyArICdzaWRlLWVmZmVjdHMgYXJlIGFuIGFudGktcGF0dGVybiwgYnV0IGNhbiBiZSBtb3ZlZCB0byAnICsgJ2Bjb21wb25lbnRXaWxsTW91bnRgLicsIGNhbGxlck5hbWUpIDogdm9pZCAwO1xuICB9XG5cbiAgcmV0dXJuIGludGVybmFsSW5zdGFuY2U7XG59XG5cbi8qKlxuICogUmVhY3RVcGRhdGVRdWV1ZSBhbGxvd3MgZm9yIHN0YXRlIHVwZGF0ZXMgdG8gYmUgc2NoZWR1bGVkIGludG8gYSBsYXRlclxuICogcmVjb25jaWxpYXRpb24gc3RlcC5cbiAqL1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSB7XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgLy8gRHVyaW5nIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyIHRoaXMgd2lsbCBzdGlsbCBiZSBudWxsIGJ1dCBhZnRlclxuICAgICAgLy8gdGhhdCB3aWxsIGFsd2F5cyByZW5kZXIgdG8gc29tZXRoaW5nLiBBdCBsZWFzdCBmb3Igbm93LiBTbyB3ZSBjYW4gdXNlXG4gICAgICAvLyB0aGlzIGhhY2suXG4gICAgICByZXR1cm4gISFpbnRlcm5hbEluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWxsZXJOYW1lIE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS52YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBjYWxsZXJOYW1lKTtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG5cbiAgICAvLyBQcmV2aW91c2x5IHdlIHdvdWxkIHRocm93IGFuIGVycm9yIGlmIHdlIGRpZG4ndCBoYXZlIGFuIGludGVybmFsXG4gICAgLy8gaW5zdGFuY2UuIFNpbmNlIHdlIHdhbnQgdG8gbWFrZSBpdCBhIG5vLW9wIGluc3RlYWQsIHdlIG1pcnJvciB0aGUgc2FtZVxuICAgIC8vIGJlaGF2aW9yIHdlIGhhdmUgaW4gb3RoZXIgZW5xdWV1ZSogbWV0aG9kcy5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gaWdub3JlIGNhbGxiYWNrcyBpbiBjb21wb25lbnRXaWxsTW91bnQuIFNlZVxuICAgIC8vIGVucXVldWVVcGRhdGVzLlxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICAvLyBUT0RPOiBUaGUgY2FsbGJhY2sgaGVyZSBpcyBpZ25vcmVkIHdoZW4gc2V0U3RhdGUgaXMgY2FsbGVkIGZyb21cbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQuIEVpdGhlciBmaXggaXQgb3IgZGlzYWxsb3cgZG9pbmcgc28gY29tcGxldGVseSBpblxuICAgIC8vIGZhdm9yIG9mIGdldEluaXRpYWxTdGF0ZS4gQWx0ZXJuYXRpdmVseSwgd2UgY2FuIGRpc2FsbG93XG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGR1cmluZyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICBlbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gdHJ1ZTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgPSBbY29tcGxldGVTdGF0ZV07XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRTdGF0ZSgpO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocGFydGlhbFN0YXRlICE9IG51bGwsICdzZXRTdGF0ZSguLi4pOiBZb3UgcGFzc2VkIGFuIHVuZGVmaW5lZCBvciBudWxsIHN0YXRlIG9iamVjdDsgJyArICdpbnN0ZWFkLCB1c2UgZm9yY2VVcGRhdGUoKS4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcXVldWUgPSBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSB8fCAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgPSBbXSk7XG4gICAgcXVldWUucHVzaChwYXJ0aWFsU3RhdGUpO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICBlbnF1ZXVlRWxlbWVudEludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgbmV4dEVsZW1lbnQsIG5leHRDb250ZXh0KSB7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0VsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICAvLyBUT0RPOiBpbnRyb2R1Y2UgX3BlbmRpbmdDb250ZXh0IGluc3RlYWQgb2Ygc2V0dGluZyBpdCBkaXJlY3RseS5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICB2YWxpZGF0ZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICAhKCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgZm9ybWF0VW5leHBlY3RlZEFyZ3VtZW50KGNhbGxiYWNrKSkgOiBfcHJvZEludmFyaWFudCgnMTIyJywgY2FsbGVyTmFtZSwgZm9ybWF0VW5leHBlY3RlZEFyZ3VtZW50KGNhbGxiYWNrKSkgOiB2b2lkIDA7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZVF1ZXVlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RVcGRhdGVRdWV1ZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB2YWxpZGF0ZURPTU5lc3RpbmdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG5cbiAgICAgIGNhc2UgJ3RhYmxlJzpcblxuICAgICAgY2FzZSAnaHInOlxuXG4gICAgICBjYXNlICd4bXAnOlxuXG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCBpbnN0YW5jZSwgcmV0dXJuIGEgbGlzdCBvZiBpdHMgcmVjdXJzaXZlXG4gICAqIG93bmVycywgc3RhcnRpbmcgYXQgdGhlIHJvb3QgYW5kIGVuZGluZyB3aXRoIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICB2YXIgZmluZE93bmVyU3RhY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgZG8ge1xuICAgICAgc3RhY2sucHVzaChpbnN0YW5jZSk7XG4gICAgfSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICBzdGFjay5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZEluc3RhbmNlLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBwcm9ibGVtYXRpYyA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuXG4gICAgaWYgKHByb2JsZW1hdGljKSB7XG4gICAgICB2YXIgYW5jZXN0b3JUYWcgPSBwcm9ibGVtYXRpYy50YWc7XG4gICAgICB2YXIgYW5jZXN0b3JJbnN0YW5jZSA9IHByb2JsZW1hdGljLmluc3RhbmNlO1xuXG4gICAgICB2YXIgY2hpbGRPd25lciA9IGNoaWxkSW5zdGFuY2UgJiYgY2hpbGRJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXIgPSBhbmNlc3Rvckluc3RhbmNlICYmIGFuY2VzdG9ySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgdmFyIGNoaWxkT3duZXJzID0gZmluZE93bmVyU3RhY2soY2hpbGRPd25lcik7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lcnMgPSBmaW5kT3duZXJTdGFjayhhbmNlc3Rvck93bmVyKTtcblxuICAgICAgdmFyIG1pblN0YWNrTGVuID0gTWF0aC5taW4oY2hpbGRPd25lcnMubGVuZ3RoLCBhbmNlc3Rvck93bmVycy5sZW5ndGgpO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIHZhciBkZWVwZXN0Q29tbW9uID0gLTE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbWluU3RhY2tMZW47IGkrKykge1xuICAgICAgICBpZiAoY2hpbGRPd25lcnNbaV0gPT09IGFuY2VzdG9yT3duZXJzW2ldKSB7XG4gICAgICAgICAgZGVlcGVzdENvbW1vbiA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFVOS05PV04gPSAnKHVua25vd24pJztcbiAgICAgIHZhciBjaGlsZE93bmVyTmFtZXMgPSBjaGlsZE93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lck5hbWVzID0gYW5jZXN0b3JPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcbiAgICAgIH0pO1xuICAgICAgdmFyIG93bmVySW5mbyA9IFtdLmNvbmNhdChcbiAgICAgIC8vIElmIHRoZSBwYXJlbnQgYW5kIGNoaWxkIGluc3RhbmNlcyBoYXZlIGEgY29tbW9uIG93bmVyIGFuY2VzdG9yLCBzdGFydFxuICAgICAgLy8gd2l0aCB0aGF0IC0tIG90aGVyd2lzZSB3ZSBqdXN0IHN0YXJ0IHdpdGggdGhlIHBhcmVudCdzIG93bmVycy5cbiAgICAgIGRlZXBlc3RDb21tb24gIT09IC0xID8gY2hpbGRPd25lcnNbZGVlcGVzdENvbW1vbl0uZ2V0TmFtZSgpIHx8IFVOS05PV04gOiBbXSwgYW5jZXN0b3JPd25lck5hbWVzLCBhbmNlc3RvclRhZyxcbiAgICAgIC8vIElmIHdlJ3JlIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCAobm9uLXBhcmVudCkgYW5jZXN0cnksIGFkZCAnLi4uJ1xuICAgICAgaW52YWxpZEFuY2VzdG9yID8gWycuLi4nXSA6IFtdLCBjaGlsZE93bmVyTmFtZXMsIGNoaWxkVGFnKS5qb2luKCcgPiAnKTtcblxuICAgICAgdmFyIHdhcm5LZXkgPSAhIWludmFsaWRQYXJlbnQgKyAnfCcgKyBjaGlsZFRhZyArICd8JyArIGFuY2VzdG9yVGFnICsgJ3wnICsgb3duZXJJbmZvO1xuICAgICAgaWYgKGRpZFdhcm5bd2FybktleV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGlkV2Fyblt3YXJuS2V5XSA9IHRydWU7XG5cbiAgICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgICAgaWYgKGNoaWxkVGFnICE9PSAnI3RleHQnKSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJzwnICsgY2hpbGRUYWcgKyAnPic7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgIGlmIChhbmNlc3RvclRhZyA9PT0gJ3RhYmxlJyAmJiBjaGlsZFRhZyA9PT0gJ3RyJykge1xuICAgICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4gJyArICdTZWUgJXMuJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIG93bmVySW5mbywgaW5mbykgOiB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnICsgJzwlcz4uIFNlZSAlcy4nLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIG93bmVySW5mbykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbztcblxuICAvLyBGb3IgdGVzdGluZ1xuICB2YWxpZGF0ZURPTU5lc3RpbmcuaXNUYWdWYWxpZEluQ29udGV4dCA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuICAgIHJldHVybiBpc1RhZ1ZhbGlkV2l0aFBhcmVudCh0YWcsIHBhcmVudFRhZykgJiYgIWZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcodGFnLCBhbmNlc3RvckluZm8pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkYXRlRE9NTmVzdGluZztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL3ZhbGlkYXRlRE9NTmVzdGluZy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUVtcHR5Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbnZhciBSZWFjdERPTUVtcHR5Q29tcG9uZW50ID0gZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XG4gIC8vIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IHVzZXMgdGhpczpcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAvLyBSZWFjdERPTUNvbXBvbmVudFRyZWUgdXNlcyB0aGVzZTpcbiAgdGhpcy5faG9zdE5vZGUgPSBudWxsO1xuICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcbiAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuICB0aGlzLl9kb21JRCA9IDA7XG59O1xuX2Fzc2lnbihSZWFjdERPTUVtcHR5Q29tcG9uZW50LnByb3RvdHlwZSwge1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIHZhciBkb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcbiAgICB0aGlzLl9kb21JRCA9IGRvbUlEO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgbm9kZVZhbHVlID0gJyByZWFjdC1lbXB0eTogJyArIHRoaXMuX2RvbUlEICsgJyAnO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICAgICAgdmFyIG5vZGUgPSBvd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQobm9kZVZhbHVlKTtcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgbm9kZSk7XG4gICAgICByZXR1cm4gRE9NTGF6eVRyZWUobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIGluc2VydCBhIGNvbW1lbnQgbm9kZSwgYnV0IHNpbmNlIHRoaXMgaXMgYSBzaXR1YXRpb25cbiAgICAgICAgLy8gd2hlcmUgUmVhY3Qgd29uJ3QgdGFrZSBvdmVyIChzdGF0aWMgcGFnZXMpLCB3ZSBjYW4gc2ltcGx5IHJldHVyblxuICAgICAgICAvLyBub3RoaW5nLlxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJzwhLS0nICsgbm9kZVZhbHVlICsgJy0tPic7XG4gICAgfVxuICB9LFxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7fSxcbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XG4gIH0sXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUudW5jYWNoZU5vZGUodGhpcyk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRW1wdHlDb21wb25lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUVtcHR5Q29tcG9uZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVHJlZVRyYXZlcnNhbFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RBKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzMzJykgOiB2b2lkIDA7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcblxuICB2YXIgZGVwdGhBID0gMDtcbiAgZm9yICh2YXIgdGVtcEEgPSBpbnN0QTsgdGVtcEE7IHRlbXBBID0gdGVtcEEuX2hvc3RQYXJlbnQpIHtcbiAgICBkZXB0aEErKztcbiAgfVxuICB2YXIgZGVwdGhCID0gMDtcbiAgZm9yICh2YXIgdGVtcEIgPSBpbnN0QjsgdGVtcEI7IHRlbXBCID0gdGVtcEIuX2hvc3RQYXJlbnQpIHtcbiAgICBkZXB0aEIrKztcbiAgfVxuXG4gIC8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBpbnN0QSA9IGluc3RBLl9ob3N0UGFyZW50O1xuICAgIGRlcHRoQS0tO1xuICB9XG5cbiAgLy8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhCIC0gZGVwdGhBID4gMCkge1xuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gICAgZGVwdGhCLS07XG4gIH1cblxuICAvLyBXYWxrIGluIGxvY2tzdGVwIHVudGlsIHdlIGZpbmQgYSBtYXRjaC5cbiAgdmFyIGRlcHRoID0gZGVwdGhBO1xuICB3aGlsZSAoZGVwdGgtLSkge1xuICAgIGlmIChpbnN0QSA9PT0gaW5zdEIpIHtcbiAgICAgIHJldHVybiBpbnN0QTtcbiAgICB9XG4gICAgaW5zdEEgPSBpbnN0QS5faG9zdFBhcmVudDtcbiAgICBpbnN0QiA9IGluc3RCLl9ob3N0UGFyZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiBpZiBBIGlzIGFuIGFuY2VzdG9yIG9mIEIuXG4gKi9cbmZ1bmN0aW9uIGlzQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2lzQW5jZXN0b3I6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzUnKSA6IHZvaWQgMDtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaXNBbmNlc3RvcjogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNScpIDogdm9pZCAwO1xuXG4gIHdoaWxlIChpbnN0Qikge1xuICAgIGlmIChpbnN0QiA9PT0gaW5zdEEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbnN0QiA9IGluc3RCLl9ob3N0UGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBhcmVudCBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkLWluIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRJbnN0YW5jZShpbnN0KSB7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0UGFyZW50SW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzYnKSA6IHZvaWQgMDtcblxuICByZXR1cm4gaW5zdC5faG9zdFBhcmVudDtcbn1cblxuLyoqXG4gKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlVHdvUGhhc2UoaW5zdCwgZm4sIGFyZykge1xuICB2YXIgcGF0aCA9IFtdO1xuICB3aGlsZSAoaW5zdCkge1xuICAgIHBhdGgucHVzaChpbnN0KTtcbiAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFtpXSwgZmFsc2UsIGFyZyk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoW2ldLCB0cnVlLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlIChmcm9tICYmIGZyb20gIT09IGNvbW1vbikge1xuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGZyb20uX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIHBhdGhUbyA9IFtdO1xuICB3aGlsZSAodG8gJiYgdG8gIT09IGNvbW1vbikge1xuICAgIHBhdGhUby5wdXNoKHRvKTtcbiAgICB0byA9IHRvLl9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgdHJ1ZSwgYXJnRnJvbSk7XG4gIH1cbiAgZm9yIChpID0gcGF0aFRvLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoVG9baV0sIGZhbHNlLCBhcmdUbyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQW5jZXN0b3I6IGlzQW5jZXN0b3IsXG4gIGdldExvd2VzdENvbW1vbkFuY2VzdG9yOiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcixcbiAgZ2V0UGFyZW50SW5zdGFuY2U6IGdldFBhcmVudEluc3RhbmNlLFxuICB0cmF2ZXJzZVR3b1BoYXNlOiB0cmF2ZXJzZVR3b1BoYXNlLFxuICB0cmF2ZXJzZUVudGVyTGVhdmU6IHRyYXZlcnNlRW50ZXJMZWF2ZVxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NVHJlZVRyYXZlcnNhbC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcblxuLyoqXG4gKiBUZXh0IG5vZGVzIHZpb2xhdGUgYSBjb3VwbGUgYXNzdW1wdGlvbnMgdGhhdCBSZWFjdCBtYWtlcyBhYm91dCBjb21wb25lbnRzOlxuICpcbiAqICAtIFdoZW4gbW91bnRpbmcgdGV4dCBpbnRvIHRoZSBET00sIGFkamFjZW50IHRleHQgbm9kZXMgYXJlIG1lcmdlZC5cbiAqICAtIFRleHQgbm9kZXMgY2Fubm90IGJlIGFzc2lnbmVkIGEgUmVhY3Qgcm9vdCBJRC5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIHRvIHdyYXAgc3RyaW5ncyBiZXR3ZWVuIGNvbW1lbnQgbm9kZXMgc28gdGhhdCB0aGV5XG4gKiBjYW4gdW5kZXJnbyB0aGUgc2FtZSByZWNvbmNpbGlhdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gZWxlbWVudHMuXG4gKlxuICogVE9ETzogSW52ZXN0aWdhdGUgcmVwcmVzZW50aW5nIFJlYWN0IGNvbXBvbmVudHMgaW4gdGhlIERPTSB3aXRoIHRleHQgbm9kZXMuXG4gKlxuICogQGNsYXNzIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RDb21wb25lbnRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgLy8gVE9ETzogVGhpcyBpcyByZWFsbHkgYSBSZWFjdFRleHQgKFJlYWN0Tm9kZSksIG5vdCBhIFJlYWN0RWxlbWVudFxuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IHRleHQ7XG4gIHRoaXMuX3N0cmluZ1RleHQgPSAnJyArIHRleHQ7XG4gIC8vIFJlYWN0RE9NQ29tcG9uZW50VHJlZSB1c2VzIHRoZXNlOlxuICB0aGlzLl9ob3N0Tm9kZSA9IG51bGw7XG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuXG4gIC8vIFByb3BlcnRpZXNcbiAgdGhpcy5fZG9tSUQgPSAwO1xuICB0aGlzLl9tb3VudEluZGV4ID0gMDtcbiAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBudWxsO1xuICB0aGlzLl9jb21tZW50Tm9kZXMgPSBudWxsO1xufTtcblxuX2Fzc2lnbihSZWFjdERPTVRleHRDb21wb25lbnQucHJvdG90eXBlLCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIG1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuIFRoaXMgbm9kZSBpcyBub3QgaW50ZW5kZWQgdG8gaGF2ZVxuICAgKiBhbnkgZmVhdHVyZXMgYmVzaWRlcyBjb250YWluaW5nIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGFyZW50SW5mbztcbiAgICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RQYXJlbnQuX2FuY2VzdG9ySW5mbztcbiAgICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8gIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdENvbnRhaW5lckluZm8uX2FuY2VzdG9ySW5mbztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRJbmZvKSB7XG4gICAgICAgIC8vIHBhcmVudEluZm8gc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50IGV4Y2VwdCBmb3IgdGhlIHRvcC1sZXZlbFxuICAgICAgICAvLyBjb21wb25lbnQgd2hlbiBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZygnI3RleHQnLCB0aGlzLCBwYXJlbnRJbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XG4gICAgdmFyIG9wZW5pbmdWYWx1ZSA9ICcgcmVhY3QtdGV4dDogJyArIGRvbUlEICsgJyAnO1xuICAgIHZhciBjbG9zaW5nVmFsdWUgPSAnIC9yZWFjdC10ZXh0ICc7XG4gICAgdGhpcy5fZG9tSUQgPSBkb21JRDtcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBvcGVuaW5nQ29tbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChvcGVuaW5nVmFsdWUpO1xuICAgICAgdmFyIGNsb3NpbmdDb21tZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KGNsb3NpbmdWYWx1ZSk7XG4gICAgICB2YXIgbGF6eVRyZWUgPSBET01MYXp5VHJlZShvd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XG4gICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShvcGVuaW5nQ29tbWVudCkpO1xuICAgICAgaWYgKHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUob3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLl9zdHJpbmdUZXh0KSkpO1xuICAgICAgfVxuICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUoY2xvc2luZ0NvbW1lbnQpKTtcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgb3BlbmluZ0NvbW1lbnQpO1xuICAgICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBjbG9zaW5nQ29tbWVudDtcbiAgICAgIHJldHVybiBsYXp5VHJlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVzY2FwZWRUZXh0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRoaXMuX3N0cmluZ1RleHQpO1xuXG4gICAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCB3cmFwIHRoaXMgYmV0d2VlbiBjb21tZW50IG5vZGVzIGZvciB0aGUgcmVhc29ucyBzdGF0ZWRcbiAgICAgICAgLy8gYWJvdmUsIGJ1dCBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlclxuICAgICAgICAvLyAoc3RhdGljIHBhZ2VzKSwgd2UgY2FuIHNpbXBseSByZXR1cm4gdGhlIHRleHQgYXMgaXQgaXMuXG4gICAgICAgIHJldHVybiBlc2NhcGVkVGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8IS0tJyArIG9wZW5pbmdWYWx1ZSArICctLT4nICsgZXNjYXBlZFRleHQgKyAnPCEtLScgKyBjbG9zaW5nVmFsdWUgKyAnLS0+JztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBjb21wb25lbnQgYnkgdXBkYXRpbmcgdGhlIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFRleHR9IG5leHRUZXh0IFRoZSBuZXh0IHRleHQgY29udGVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRUZXh0LCB0cmFuc2FjdGlvbikge1xuICAgIGlmIChuZXh0VGV4dCAhPT0gdGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFRleHQ7XG4gICAgICB2YXIgbmV4dFN0cmluZ1RleHQgPSAnJyArIG5leHRUZXh0O1xuICAgICAgaWYgKG5leHRTdHJpbmdUZXh0ICE9PSB0aGlzLl9zdHJpbmdUZXh0KSB7XG4gICAgICAgIC8vIFRPRE86IFNhdmUgdGhpcyBhcyBwZW5kaW5nIHByb3BzIGFuZCB1c2UgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5XG4gICAgICAgIC8vIGFuZC9vciB1cGRhdGVDb21wb25lbnQgdG8gZG8gdGhlIGFjdHVhbCB1cGRhdGUgZm9yIGNvbnNpc3RlbmN5IHdpdGhcbiAgICAgICAgLy8gb3RoZXIgY29tcG9uZW50IHR5cGVzP1xuICAgICAgICB0aGlzLl9zdHJpbmdUZXh0ID0gbmV4dFN0cmluZ1RleHQ7XG4gICAgICAgIHZhciBjb21tZW50Tm9kZXMgPSB0aGlzLmdldEhvc3ROb2RlKCk7XG4gICAgICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5yZXBsYWNlRGVsaW1pdGVkVGV4dChjb21tZW50Tm9kZXNbMF0sIGNvbW1lbnROb2Rlc1sxXSwgbmV4dFN0cmluZ1RleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBob3N0Tm9kZSA9IHRoaXMuX2NvbW1lbnROb2RlcztcbiAgICBpZiAoaG9zdE5vZGUpIHtcbiAgICAgIHJldHVybiBob3N0Tm9kZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9jbG9zaW5nQ29tbWVudCkge1xuICAgICAgdmFyIG9wZW5pbmdDb21tZW50ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XG4gICAgICB2YXIgbm9kZSA9IG9wZW5pbmdDb21tZW50Lm5leHRTaWJsaW5nO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgIShub2RlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc3NpbmcgY2xvc2luZyBjb21tZW50IGZvciB0ZXh0IGNvbXBvbmVudCAlcycsIHRoaXMuX2RvbUlEKSA6IF9wcm9kSW52YXJpYW50KCc2NycsIHRoaXMuX2RvbUlEKSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgL3JlYWN0LXRleHQgJykge1xuICAgICAgICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgaG9zdE5vZGUgPSBbdGhpcy5faG9zdE5vZGUsIHRoaXMuX2Nsb3NpbmdDb21tZW50XTtcbiAgICB0aGlzLl9jb21tZW50Tm9kZXMgPSBob3N0Tm9kZTtcbiAgICByZXR1cm4gaG9zdE5vZGU7XG4gIH0sXG5cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbnVsbDtcbiAgICB0aGlzLl9jb21tZW50Tm9kZXMgPSBudWxsO1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRDb21wb25lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTVRleHRDb21wb25lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcblxudmFyIFJFU0VUX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBGTFVTSF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBSZWFjdFVwZGF0ZXMuZmx1c2hCYXRjaGVkVXBkYXRlcy5iaW5kKFJlYWN0VXBkYXRlcylcbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtGTFVTSF9CQVRDSEVEX1VQREFURVMsIFJFU0VUX0JBVENIRURfVVBEQVRFU107XG5cbmZ1bmN0aW9uIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xufVxuXG5fYXNzaWduKFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH1cbn0pO1xuXG52YXIgdHJhbnNhY3Rpb24gPSBuZXcgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCk7XG5cbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0ge1xuICBpc0JhdGNoaW5nVXBkYXRlczogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGluIGEgY29udGV4dCB3aXRoaW4gd2hpY2ggY2FsbHMgdG8gYHNldFN0YXRlYFxuICAgKiBhbmQgZnJpZW5kcyBhcmUgYmF0Y2hlZCBzdWNoIHRoYXQgY29tcG9uZW50cyBhcmVuJ3QgdXBkYXRlZCB1bm5lY2Vzc2FyaWx5LlxuICAgKi9cbiAgYmF0Y2hlZFVwZGF0ZXM6IGZ1bmN0aW9uIChjYWxsYmFjaywgYSwgYiwgYywgZCwgZSkge1xuICAgIHZhciBhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcztcblxuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuXG4gICAgLy8gVGhlIGNvZGUgaXMgd3JpdHRlbiB0aGlzIHdheSB0byBhdm9pZCBleHRyYSBhbGxvY2F0aW9uc1xuICAgIGlmIChhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICBjYWxsYmFjayhhLCBiLCBjLCBkLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShjYWxsYmFjaywgbnVsbCwgYSwgYiwgYywgZCwgZSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3k7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXZlbnRMaXN0ZW5lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnZmJqcy9saWIvRXZlbnRMaXN0ZW5lcicpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uJyk7XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcbiAqIG90aGVyKS4gSWYgUmVhY3QgdHJlZXMgYXJlIG5vdCBuZXN0ZWQsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmluZFBhcmVudChpbnN0KSB7XG4gIC8vIFRPRE86IEl0IG1heSBiZSBhIGdvb2QgaWRlYSB0byBjYWNoZSB0aGlzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgRE9NXG4gIC8vIHRyYXZlcnNhbCwgYnV0IGNhY2hpbmcgaXMgZGlmZmljdWx0IHRvIGRvIGNvcnJlY3RseSB3aXRob3V0IHVzaW5nIGFcbiAgLy8gbXV0YXRpb24gb2JzZXJ2ZXIgdG8gbGlzdGVuIGZvciBhbGwgRE9NIGNoYW5nZXMuXG4gIHdoaWxlIChpbnN0Ll9ob3N0UGFyZW50KSB7XG4gICAgaW5zdCA9IGluc3QuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIHJvb3ROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gIHZhciBjb250YWluZXIgPSByb290Tm9kZS5wYXJlbnROb2RlO1xuICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lcik7XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xuZnVuY3Rpb24gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgdGhpcy50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgdGhpcy5hbmNlc3RvcnMgPSBbXTtcbn1cbl9hc3NpZ24oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnByb3RvdHlwZSwge1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50b3BMZXZlbFR5cGUgPSBudWxsO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIH1cbn0pO1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZywgUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpO1xuICB2YXIgdGFyZ2V0SW5zdCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRhcmdldEluc3Q7XG4gIGRvIHtcbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBhbmNlc3RvciAmJiBmaW5kUGFyZW50KGFuY2VzdG9yKTtcbiAgfSB3aGlsZSAoYW5jZXN0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgYm9va0tlZXBpbmcubmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2Nyb2xsVmFsdWVNb25pdG9yKGNiKSB7XG4gIHZhciBzY3JvbGxQb3NpdGlvbiA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uKHdpbmRvdyk7XG4gIGNiKHNjcm9sbFBvc2l0aW9uKTtcbn1cblxudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHtcbiAgX2VuYWJsZWQ6IHRydWUsXG4gIF9oYW5kbGVUb3BMZXZlbDogbnVsbCxcblxuICBXSU5ET1dfSEFORExFOiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyB3aW5kb3cgOiBudWxsLFxuXG4gIHNldEhhbmRsZVRvcExldmVsOiBmdW5jdGlvbiAoaGFuZGxlVG9wTGV2ZWwpIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG4gIH0sXG5cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG4gIH0sXG5cbiAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZSBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHZhciBlbGVtZW50ID0gaGFuZGxlO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmxpc3RlbihlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZSBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGhhbmRsZTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5jYXB0dXJlKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbiAgfSxcblxuICBtb25pdG9yU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uIChyZWZyZXNoKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gc2Nyb2xsVmFsdWVNb25pdG9yLmJpbmQobnVsbCwgcmVmcmVzaCk7XG4gICAgRXZlbnRMaXN0ZW5lci5saXN0ZW4od2luZG93LCAnc2Nyb2xsJywgY2FsbGJhY2spO1xuICB9LFxuXG4gIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCFSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYm9va0tlZXBpbmcgPSBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcuZ2V0UG9vbGVkKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICAgIHRyeSB7XG4gICAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgICAvLyBgcHJldmVudERlZmF1bHRgLlxuICAgICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGhhbmRsZVRvcExldmVsSW1wbCwgYm9va0tlZXBpbmcpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucmVsZWFzZShib29rS2VlcGluZyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24gY2FwdHVyZSh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgKyAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArICd3aWxsIG5vdCByZWNlaXZlIHNvbWUgZXZlbnRzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICByZWdpc3RlckRlZmF1bHQ6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdCgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBzdXBwbGllZCBlbGVtZW50IG9yIHdpbmRvdy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlcyBhcmUgdW5ib3VuZGVkLCB1bmxpa2UgYGdldFNjcm9sbFBvc2l0aW9uYC4gVGhpcyBtZWFucyB0aGV5XG4gKiBtYXkgYmUgbmVnYXRpdmUgb3IgZXhjZWVkIHRoZSBlbGVtZW50IGJvdW5kYXJpZXMgKHdoaWNoIGlzIHBvc3NpYmxlIHVzaW5nXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxuICpcbiAqIEBwYXJhbSB7RE9NV2luZG93fERPTUVsZW1lbnR9IHNjcm9sbGFibGVcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlKSB7XG4gIGlmIChzY3JvbGxhYmxlID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0LFxuICAgIHk6IHNjcm9sbGFibGUuc2Nyb2xsVG9wXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5qZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5VdGlscycpO1xudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZSgnLi9SZWFjdENsYXNzJyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RIb3N0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEhvc3RDb21wb25lbnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgUmVhY3RJbmplY3Rpb24gPSB7XG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5pbmplY3Rpb24sXG4gIENsYXNzOiBSZWFjdENsYXNzLmluamVjdGlvbixcbiAgRE9NUHJvcGVydHk6IERPTVByb3BlcnR5LmluamVjdGlvbixcbiAgRW1wdHlDb21wb25lbnQ6IFJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uLFxuICBFdmVudFBsdWdpbkh1YjogRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLFxuICBFdmVudFBsdWdpblV0aWxzOiBFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbixcbiAgRXZlbnRFbWl0dGVyOiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaW5qZWN0aW9uLFxuICBIb3N0Q29tcG9uZW50OiBSZWFjdEhvc3RDb21wb25lbnQuaW5qZWN0aW9uLFxuICBVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5qZWN0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbmplY3Rpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCwgd2hlbiBwb3NzaWJsZSwgdGhlIHNlbGVjdGlvbiByYW5nZSAoY3VycmVudGx5IHNlbGVjdGVkIHRleHRcbiAqIGlucHV0KSBpcyBub3QgZGlzdHVyYmVkIGJ5IHBlcmZvcm1pbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgU0VMRUNUSU9OX1JFU1RPUkFUSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBTZWxlY3Rpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbkluZm9ybWF0aW9uLFxuICAvKipcbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbCBTZWxlY3Rpb24gaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBgaW5pdGlhbGl6ZWAuXG4gICAqL1xuICBjbG9zZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5yZXN0b3JlU2VsZWN0aW9uXG59O1xuXG4vKipcbiAqIFN1cHByZXNzZXMgZXZlbnRzIChibHVyL2ZvY3VzKSB0aGF0IGNvdWxkIGJlIGluYWR2ZXJ0ZW50bHkgZGlzcGF0Y2hlZCBkdWUgdG9cbiAqIGhpZ2ggbGV2ZWwgRE9NIG1hbmlwdWxhdGlvbnMgKGxpa2UgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgYSB0ZXh0IGlucHV0IGZyb20gdGhlXG4gKiBET00pLlxuICovXG52YXIgRVZFTlRfU1VQUFJFU1NJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlXG4gICAqIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudGx5RW5hYmxlZCA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pc0VuYWJsZWQoKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgcmV0dXJuIGN1cnJlbnRseUVuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmlvdXNseUVuYWJsZWQgRW5hYmxlZCBzdGF0dXMgb2ZcbiAgICogICBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmUgdGhlIHJlY29uY2lsaWF0aW9uIG9jY3VycmVkLiBgY2xvc2VgXG4gICAqICAgcmVzdG9yZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uIChwcmV2aW91c2x5RW5hYmxlZCkge1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKHByZXZpb3VzbHlFbmFibGVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBjb21wb25lbnREaWRNb3VudGAgYW5kXG4gKiBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgZHVyaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgRE9NIGlzIGZsdXNoZWQsIGludm9rZSBhbGwgcmVnaXN0ZXJlZCBgb25ET01SZWFkeWAgY2FsbGJhY2tzLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW1NFTEVDVElPTl9SRVNUT1JBVElPTiwgRVZFTlRfU1VQUFJFU1NJT04sIE9OX0RPTV9SRUFEWV9RVUVVRUlOR107XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRSQU5TQUNUSU9OX1dSQVBQRVJTLnB1c2goe1xuICAgIGluaXRpYWxpemU6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2gsXG4gICAgY2xvc2U6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoXG4gIH0pO1xufVxuXG4vKipcbiAqIEN1cnJlbnRseTpcbiAqIC0gVGhlIG9yZGVyIHRoYXQgdGhlc2UgYXJlIGxpc3RlZCBpbiB0aGUgdHJhbnNhY3Rpb24gaXMgY3JpdGljYWw6XG4gKiAtIFN1cHByZXNzZXMgZXZlbnRzLlxuICogLSBSZXN0b3JlcyBzZWxlY3Rpb24gcmFuZ2UuXG4gKlxuICogRnV0dXJlOlxuICogLSBSZXN0b3JlIGRvY3VtZW50L292ZXJmbG93IHNjcm9sbCBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVuaW50ZW50aW9uYWxseVxuICogICBtb2RpZmllZCB2aWEgRE9NIGluc2VydGlvbnMgYWJvdmUgdGhlIHRvcCB2aWV3cG9ydCBib3VuZGFyeS5cbiAqIC0gSW1wbGVtZW50L2ludGVncmF0ZSB3aXRoIGN1c3RvbWl6ZWQgY29uc3RyYWludCBiYXNlZCBsYXlvdXQgc3lzdGVtIGFuZCBrZWVwXG4gKiAgIHRyYWNrIG9mIHdoaWNoIGRpbWVuc2lvbnMgbXVzdCBiZSByZW1lYXN1cmVkLlxuICpcbiAqIEBjbGFzcyBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24odXNlQ3JlYXRlRWxlbWVudCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIC8vIE9ubHkgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHJlYWxseSBuZWVkcyB0aGlzIG9wdGlvbiAoc2VlXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ2ApLCBidXQgc2VydmVyLXNpZGUgdXNlc1xuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbmAgaW5zdGVhZC4gVGhpcyBvcHRpb24gaXMgaGVyZSBzbyB0aGF0IGl0J3NcbiAgLy8gYWNjZXNzaWJsZSBhbmQgZGVmYXVsdHMgdG8gZmFsc2Ugd2hlbiBgUmVhY3RET01Db21wb25lbnRgIGFuZFxuICAvLyBgUmVhY3RET01UZXh0Q29tcG9uZW50YCBjaGVja3MgaXQgaW4gYG1vdW50Q29tcG9uZW50YC5gXG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSBmYWxzZTtcbiAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gdXNlQ3JlYXRlRWxlbWVudDtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5PG9iamVjdD59IExpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cbiAgICogICBUT0RPOiBjb252ZXJ0IHRvIGFycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IFJlYWN0IGFzeW5jIGV2ZW50cy5cbiAgICovXG4gIGdldFVwZGF0ZVF1ZXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0VXBkYXRlUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhdmUgY3VycmVudCB0cmFuc2FjdGlvbiBzdGF0ZSAtLSBpZiB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhpcyBtZXRob2QgaXNcbiAgICogcGFzc2VkIHRvIGByb2xsYmFja2AsIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJlc2V0IHRvIHRoYXQgc3RhdGUuXG4gICAqL1xuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVhY3RNb3VudFJlYWR5IGlzIHRoZSBvdXIgb25seSBzdGF0ZWZ1bCB3cmFwcGVyXG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5LmNoZWNrcG9pbnQoKTtcbiAgfSxcblxuICByb2xsYmFjazogZnVuY3Rpb24gKGNoZWNrcG9pbnQpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yb2xsYmFjayhjaGVja3BvaW50KTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuICB9XG59O1xuXG5fYXNzaWduKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnB1dFNlbGVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdGlvbicpO1xuXG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSB7XG5cbiAgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbiAgfSxcblxuICBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZm9jdXNlZEVsZW06IGZvY3VzZWRFbGVtLFxuICAgICAgc2VsZWN0aW9uUmFuZ2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAgICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gICAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICAgKi9cbiAgcmVzdG9yZVNlbGVjdGlvbjogZnVuY3Rpb24gKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICAgIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICBpZiAoUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgICAgUmVhY3RJbnB1dFNlbGVjdGlvbi5zZXRTZWxlY3Rpb24ocHJpb3JGb2N1c2VkRWxlbSwgcHJpb3JTZWxlY3Rpb25SYW5nZSk7XG4gICAgICB9XG4gICAgICBmb2N1c05vZGUocHJpb3JGb2N1c2VkRWxlbSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAZ2V0U2VsZWN0aW9uOiBHZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgZm9jdXNlZCB0ZXh0YXJlYSwgaW5wdXQgb3JcbiAgICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gICAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gICAqIC1AcmV0dXJuIHtzdGFydDogc2VsZWN0aW9uU3RhcnQsIGVuZDogc2VsZWN0aW9uRW5kfVxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgc2VsZWN0aW9uO1xuXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgLy8gSUU4IGlucHV0LlxuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAvLyBUaGVyZSBjYW4gb25seSBiZSBvbmUgc2VsZWN0aW9uIHBlciBkb2N1bWVudCBpbiBJRSwgc28gaXQgbXVzdFxuICAgICAgLy8gYmUgaW4gb3VyIGVsZW1lbnQuXG4gICAgICBpZiAocmFuZ2UucGFyZW50RWxlbWVudCgpID09PSBpbnB1dCkge1xuICAgICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgICAgc3RhcnQ6IC1yYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpLFxuICAgICAgICAgIGVuZDogLXJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgICAgc2VsZWN0aW9uID0gUmVhY3RET01TZWxlY3Rpb24uZ2V0T2Zmc2V0cyhpbnB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXG4gICAqIHRoZSBpbnB1dC5cbiAgICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICAgKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXG4gICAqL1xuICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCwgb2Zmc2V0cykge1xuICAgIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IG9mZnNldHMuZW5kO1xuICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgdmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RE9NU2VsZWN0aW9uLnNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdElucHV0U2VsZWN0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQgPSByZXF1aXJlKCcuL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQnKTtcbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogV2hpbGUgYGlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgb24gdGhlIFNlbGVjdGlvbiBvYmplY3QgYW5kIGBjb2xsYXBzZWRgXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIFJhbmdlIG9iamVjdCwgSUUxMSBzb21ldGltZXMgZ2V0cyB0aGVtIHdyb25nLlxuICogSWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhbmQgb2Zmc2V0cyBhcmUgdGhlIHNhbWUsIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQ29sbGFwc2VkKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICByZXR1cm4gYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGFuY2hvck9mZnNldCA9PT0gZm9jdXNPZmZzZXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhcHByb3ByaWF0ZSBhbmNob3IgYW5kIGZvY3VzIG5vZGUvb2Zmc2V0IHBhaXJzIGZvciBJRS5cbiAqXG4gKiBUaGUgY2F0Y2ggaGVyZSBpcyB0aGF0IElFJ3Mgc2VsZWN0aW9uIEFQSSBkb2Vzbid0IHByb3ZpZGUgaW5mb3JtYXRpb25cbiAqIGFib3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBmb3J3YXJkIG9yIGJhY2t3YXJkLCBzbyB3ZSBoYXZlIHRvXG4gKiBiZWhhdmUgYXMgdGhvdWdoIGl0J3MgYWx3YXlzIGZvcndhcmQuXG4gKlxuICogSUUgdGV4dCBkaWZmZXJzIGZyb20gbW9kZXJuIHNlbGVjdGlvbiBpbiB0aGF0IGl0IGJlaGF2ZXMgYXMgdGhvdWdoXG4gKiBibG9jayBlbGVtZW50cyBlbmQgd2l0aCBhIG5ldyBsaW5lLiBUaGlzIG1lYW5zIGNoYXJhY3RlciBvZmZzZXRzIHdpbGxcbiAqIGRpZmZlciBiZXR3ZWVuIHRoZSB0d28gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0SUVPZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LnNlbGVjdGlvbjtcbiAgdmFyIHNlbGVjdGVkUmFuZ2UgPSBzZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgdmFyIHNlbGVjdGVkTGVuZ3RoID0gc2VsZWN0ZWRSYW5nZS50ZXh0Lmxlbmd0aDtcblxuICAvLyBEdXBsaWNhdGUgc2VsZWN0aW9uIHNvIHdlIGNhbiBtb3ZlIHJhbmdlIHdpdGhvdXQgYnJlYWtpbmcgdXNlciBzZWxlY3Rpb24uXG4gIHZhciBmcm9tU3RhcnQgPSBzZWxlY3RlZFJhbmdlLmR1cGxpY2F0ZSgpO1xuICBmcm9tU3RhcnQubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIGZyb21TdGFydC5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHNlbGVjdGVkUmFuZ2UpO1xuXG4gIHZhciBzdGFydE9mZnNldCA9IGZyb21TdGFydC50ZXh0Lmxlbmd0aDtcbiAgdmFyIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgc2VsZWN0ZWRMZW5ndGg7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnRPZmZzZXQsXG4gICAgZW5kOiBlbmRPZmZzZXRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICB2YXIgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgdmFyIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIHZhciBjdXJyZW50UmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcblxuICAvLyBJbiBGaXJlZm94LCByYW5nZS5zdGFydENvbnRhaW5lciBhbmQgcmFuZ2UuZW5kQ29udGFpbmVyIGNhbiBiZSBcImFub255bW91c1xuICAvLyBkaXZzXCIsIGUuZy4gdGhlIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzXG4gIC8vIGRpdnMgZG8gbm90IHNlZW0gdG8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkXG4gIC8vIGVycm9yXCIgaWYgYW55IG9mIGl0cyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlXG4gIC8vIHdheSB0byBhdm9pZCBlcnJvcmluZyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3JcbiAgLy8gbm9uLWFub255bW91cyBkaXZzIGFuZCBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlO1xuICAgIGN1cnJlbnRSYW5nZS5lbmRDb250YWluZXIubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5vZGUgYW5kIG9mZnNldCB2YWx1ZXMgYXJlIHRoZSBzYW1lLCB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZC5cbiAgLy8gYFNlbGVjdGlvbi5pc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBidXQgSUUgc29tZXRpbWVzIGdldHNcbiAgLy8gdGhpcyB2YWx1ZSB3cm9uZy5cbiAgdmFyIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsIHNlbGVjdGlvbi5mb2N1c05vZGUsIHNlbGVjdGlvbi5mb2N1c09mZnNldCk7XG5cbiAgdmFyIHJhbmdlTGVuZ3RoID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQgPyAwIDogY3VycmVudFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gIHZhciB0ZW1wUmFuZ2UgPSBjdXJyZW50UmFuZ2UuY2xvbmVSYW5nZSgpO1xuICB0ZW1wUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICB0ZW1wUmFuZ2Uuc2V0RW5kKGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lciwgY3VycmVudFJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICB2YXIgaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPSBpc0NvbGxhcHNlZCh0ZW1wUmFuZ2Uuc3RhcnRDb250YWluZXIsIHRlbXBSYW5nZS5zdGFydE9mZnNldCwgdGVtcFJhbmdlLmVuZENvbnRhaW5lciwgdGVtcFJhbmdlLmVuZE9mZnNldCk7XG5cbiAgdmFyIHN0YXJ0ID0gaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPyAwIDogdGVtcFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgZW5kID0gc3RhcnQgKyByYW5nZUxlbmd0aDtcblxuICAvLyBEZXRlY3Qgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkLlxuICB2YXIgZGV0ZWN0aW9uUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRTdGFydChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRFbmQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG4gIHZhciBpc0JhY2t3YXJkID0gZGV0ZWN0aW9uUmFuZ2UuY29sbGFwc2VkO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGlzQmFja3dhcmQgPyBlbmQgOiBzdGFydCxcbiAgICBlbmQ6IGlzQmFja3dhcmQgPyBzdGFydCA6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0SUVPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZHVwbGljYXRlKCk7XG4gIHZhciBzdGFydCwgZW5kO1xuXG4gIGlmIChvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKG9mZnNldHMuc3RhcnQgPiBvZmZzZXRzLmVuZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5lbmQ7XG4gICAgZW5kID0gb2Zmc2V0cy5zdGFydDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gIH1cblxuICByYW5nZS5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gIHJhbmdlLnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0JywgcmFuZ2UpO1xuICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gIHJhbmdlLnNlbGVjdCgpO1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0TW9kZXJuT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciB1c2VJRU9mZnNldHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ3NlbGVjdGlvbicgaW4gZG9jdW1lbnQgJiYgISgnZ2V0U2VsZWN0aW9uJyBpbiB3aW5kb3cpO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIGdldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IGdldElFT2Zmc2V0cyA6IGdldE1vZGVybk9mZnNldHMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICAgKi9cbiAgc2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gc2V0SUVPZmZzZXRzIDogc2V0TW9kZXJuT2Zmc2V0c1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYW55IG5vZGUgcmV0dXJuIHRoZSBmaXJzdCBsZWFmIG5vZGUgd2l0aG91dCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cblxuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbnZhciBpc1RleHROb2RlID0gcmVxdWlyZSgnLi9pc1RleHROb2RlJyk7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIERPTSBub2RlIGNvbnRhaW5zIG9yIGlzIGFub3RoZXIgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZSkge1xuICBpZiAoIW91dGVyTm9kZSB8fCAhaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZSA9PT0gaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShvdXRlck5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUoaW5uZXJOb2RlKSkge1xuICAgIHJldHVybiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUucGFyZW50Tm9kZSk7XG4gIH0gZWxzZSBpZiAoJ2NvbnRhaW5zJyBpbiBvdXRlck5vZGUpIHtcbiAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuICEhKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihpbm5lck5vZGUpICYgMTYpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zTm9kZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvY29udGFpbnNOb2RlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9pc05vZGUnKTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSB0ZXh0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUob2JqZWN0KSB7XG4gIHJldHVybiBpc05vZGUob2JqZWN0KSAmJiBvYmplY3Qubm9kZVR5cGUgPT0gMztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHROb2RlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9pc1RleHROb2RlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZShvYmplY3QpIHtcbiAgcmV0dXJuICEhKG9iamVjdCAmJiAodHlwZW9mIE5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBOb2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2lzTm9kZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgb3IgZG9jdW1lbnQgYm9keSBpcyBub3RcbiAqIHlldCBkZWZpbmVkLlxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KCkgLyo/RE9NRWxlbWVudCove1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTVkdET01Qcm9wZXJ0eUNvbmZpZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE5TID0ge1xuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG4vLyBXZSB1c2UgYXR0cmlidXRlcyBmb3IgZXZlcnl0aGluZyBTVkcgc28gbGV0J3MgYXZvaWQgc29tZSBkdXBsaWNhdGlvbiBhbmQgcnVuXG4vLyBjb2RlIGluc3RlYWQuXG4vLyBUaGUgZm9sbG93aW5nIGFyZSBhbGwgc3BlY2lmaWVkIGluIHRoZSBIVE1MIGNvbmZpZyBhbHJlYWR5IHNvIHdlIGV4Y2x1ZGUgaGVyZS5cbi8vIC0gY2xhc3MgKGFzIGNsYXNzTmFtZSlcbi8vIC0gY29sb3Jcbi8vIC0gaGVpZ2h0XG4vLyAtIGlkXG4vLyAtIGxhbmdcbi8vIC0gbWF4XG4vLyAtIG1lZGlhXG4vLyAtIG1ldGhvZFxuLy8gLSBtaW5cbi8vIC0gbmFtZVxuLy8gLSBzdHlsZVxuLy8gLSB0YXJnZXRcbi8vIC0gdHlwZVxuLy8gLSB3aWR0aFxudmFyIEFUVFJTID0ge1xuICBhY2NlbnRIZWlnaHQ6ICdhY2NlbnQtaGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogMCxcbiAgYWRkaXRpdmU6IDAsXG4gIGFsaWdubWVudEJhc2VsaW5lOiAnYWxpZ25tZW50LWJhc2VsaW5lJyxcbiAgYWxsb3dSZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogMCxcbiAgYW1wbGl0dWRlOiAwLFxuICBhcmFiaWNGb3JtOiAnYXJhYmljLWZvcm0nLFxuICBhc2NlbnQ6IDAsXG4gIGF0dHJpYnV0ZU5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRlVHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvUmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogMCxcbiAgYmFzZUZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlUHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmFzZWxpbmVTaGlmdDogJ2Jhc2VsaW5lLXNoaWZ0JyxcbiAgYmJveDogMCxcbiAgYmVnaW46IDAsXG4gIGJpYXM6IDAsXG4gIGJ5OiAwLFxuICBjYWxjTW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwSGVpZ2h0OiAnY2FwLWhlaWdodCcsXG4gIGNsaXA6IDAsXG4gIGNsaXBQYXRoOiAnY2xpcC1wYXRoJyxcbiAgY2xpcFJ1bGU6ICdjbGlwLXJ1bGUnLFxuICBjbGlwUGF0aFVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNvbG9ySW50ZXJwb2xhdGlvbjogJ2NvbG9yLWludGVycG9sYXRpb24nLFxuICBjb2xvckludGVycG9sYXRpb25GaWx0ZXJzOiAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJyxcbiAgY29sb3JQcm9maWxlOiAnY29sb3ItcHJvZmlsZScsXG4gIGNvbG9yUmVuZGVyaW5nOiAnY29sb3ItcmVuZGVyaW5nJyxcbiAgY29udGVudFNjcmlwdFR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRTdHlsZVR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAwLFxuICBjeDogMCxcbiAgY3k6IDAsXG4gIGQ6IDAsXG4gIGRlY2VsZXJhdGU6IDAsXG4gIGRlc2NlbnQ6IDAsXG4gIGRpZmZ1c2VDb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogMCxcbiAgZGlzcGxheTogMCxcbiAgZGl2aXNvcjogMCxcbiAgZG9taW5hbnRCYXNlbGluZTogJ2RvbWluYW50LWJhc2VsaW5lJyxcbiAgZHVyOiAwLFxuICBkeDogMCxcbiAgZHk6IDAsXG4gIGVkZ2VNb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246IDAsXG4gIGVuYWJsZUJhY2tncm91bmQ6ICdlbmFibGUtYmFja2dyb3VuZCcsXG4gIGVuZDogMCxcbiAgZXhwb25lbnQ6IDAsXG4gIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogMCxcbiAgZmlsbE9wYWNpdHk6ICdmaWxsLW9wYWNpdHknLFxuICBmaWxsUnVsZTogJ2ZpbGwtcnVsZScsXG4gIGZpbHRlcjogMCxcbiAgZmlsdGVyUmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVyVW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kQ29sb3I6ICdmbG9vZC1jb2xvcicsXG4gIGZsb29kT3BhY2l0eTogJ2Zsb29kLW9wYWNpdHknLFxuICBmb2N1c2FibGU6IDAsXG4gIGZvbnRGYW1pbHk6ICdmb250LWZhbWlseScsXG4gIGZvbnRTaXplOiAnZm9udC1zaXplJyxcbiAgZm9udFNpemVBZGp1c3Q6ICdmb250LXNpemUtYWRqdXN0JyxcbiAgZm9udFN0cmV0Y2g6ICdmb250LXN0cmV0Y2gnLFxuICBmb250U3R5bGU6ICdmb250LXN0eWxlJyxcbiAgZm9udFZhcmlhbnQ6ICdmb250LXZhcmlhbnQnLFxuICBmb250V2VpZ2h0OiAnZm9udC13ZWlnaHQnLFxuICBmb3JtYXQ6IDAsXG4gIGZyb206IDAsXG4gIGZ4OiAwLFxuICBmeTogMCxcbiAgZzE6IDAsXG4gIGcyOiAwLFxuICBnbHlwaE5hbWU6ICdnbHlwaC1uYW1lJyxcbiAgZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWw6ICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJyxcbiAgZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsOiAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLFxuICBnbHlwaFJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnRUcmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50VW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogMCxcbiAgaG9yaXpBZHZYOiAnaG9yaXotYWR2LXgnLFxuICBob3Jpek9yaWdpblg6ICdob3Jpei1vcmlnaW4teCcsXG4gIGlkZW9ncmFwaGljOiAwLFxuICBpbWFnZVJlbmRlcmluZzogJ2ltYWdlLXJlbmRlcmluZycsXG4gICdpbic6IDAsXG4gIGluMjogMCxcbiAgaW50ZXJjZXB0OiAwLFxuICBrOiAwLFxuICBrMTogMCxcbiAgazI6IDAsXG4gIGszOiAwLFxuICBrNDogMCxcbiAga2VybmVsTWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsVW5pdExlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAwLFxuICBrZXlQb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlTcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleVRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhBZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJTcGFjaW5nOiAnbGV0dGVyLXNwYWNpbmcnLFxuICBsaWdodGluZ0NvbG9yOiAnbGlnaHRpbmctY29sb3InLFxuICBsaW1pdGluZ0NvbmVBbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6IDAsXG4gIG1hcmtlckVuZDogJ21hcmtlci1lbmQnLFxuICBtYXJrZXJNaWQ6ICdtYXJrZXItbWlkJyxcbiAgbWFya2VyU3RhcnQ6ICdtYXJrZXItc3RhcnQnLFxuICBtYXJrZXJIZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJVbml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2VyV2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6IDAsXG4gIG1hc2tDb250ZW50VW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza1VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAwLFxuICBtb2RlOiAwLFxuICBudW1PY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogMCxcbiAgb3BhY2l0eTogMCxcbiAgb3BlcmF0b3I6IDAsXG4gIG9yZGVyOiAwLFxuICBvcmllbnQ6IDAsXG4gIG9yaWVudGF0aW9uOiAwLFxuICBvcmlnaW46IDAsXG4gIG92ZXJmbG93OiAwLFxuICBvdmVybGluZVBvc2l0aW9uOiAnb3ZlcmxpbmUtcG9zaXRpb24nLFxuICBvdmVybGluZVRoaWNrbmVzczogJ292ZXJsaW5lLXRoaWNrbmVzcycsXG4gIHBhaW50T3JkZXI6ICdwYWludC1vcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UtMScsXG4gIHBhdGhMZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybkNvbnRlbnRVbml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJuVHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm5Vbml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJFdmVudHM6ICdwb2ludGVyLWV2ZW50cycsXG4gIHBvaW50czogMCxcbiAgcG9pbnRzQXRYOiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzQXRZOiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzQXRaOiAncG9pbnRzQXRaJyxcbiAgcHJlc2VydmVBbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZVVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICByOiAwLFxuICByYWRpdXM6IDAsXG4gIHJlZlg6ICdyZWZYJyxcbiAgcmVmWTogJ3JlZlknLFxuICByZW5kZXJpbmdJbnRlbnQ6ICdyZW5kZXJpbmctaW50ZW50JyxcbiAgcmVwZWF0Q291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdER1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkRXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkRmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzdGFydDogMCxcbiAgcmVzdWx0OiAwLFxuICByb3RhdGU6IDAsXG4gIHJ4OiAwLFxuICByeTogMCxcbiAgc2NhbGU6IDAsXG4gIHNlZWQ6IDAsXG4gIHNoYXBlUmVuZGVyaW5nOiAnc2hhcGUtcmVuZGVyaW5nJyxcbiAgc2xvcGU6IDAsXG4gIHNwYWNpbmc6IDAsXG4gIHNwZWN1bGFyQ29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJFeHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogMCxcbiAgc3ByZWFkTWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRPZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZERldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAwLFxuICBzdGVtdjogMCxcbiAgc3RpdGNoVGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3BDb2xvcjogJ3N0b3AtY29sb3InLFxuICBzdG9wT3BhY2l0eTogJ3N0b3Atb3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hQb3NpdGlvbjogJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdoVGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLFxuICBzdHJpbmc6IDAsXG4gIHN0cm9rZTogMCxcbiAgc3Ryb2tlRGFzaGFycmF5OiAnc3Ryb2tlLWRhc2hhcnJheScsXG4gIHN0cm9rZURhc2hvZmZzZXQ6ICdzdHJva2UtZGFzaG9mZnNldCcsXG4gIHN0cm9rZUxpbmVjYXA6ICdzdHJva2UtbGluZWNhcCcsXG4gIHN0cm9rZUxpbmVqb2luOiAnc3Ryb2tlLWxpbmVqb2luJyxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogJ3N0cm9rZS1taXRlcmxpbWl0JyxcbiAgc3Ryb2tlT3BhY2l0eTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgc3Ryb2tlV2lkdGg6ICdzdHJva2Utd2lkdGgnLFxuICBzdXJmYWNlU2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1MYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGVWYWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldFg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0WTogJ3RhcmdldFknLFxuICB0ZXh0QW5jaG9yOiAndGV4dC1hbmNob3InLFxuICB0ZXh0RGVjb3JhdGlvbjogJ3RleHQtZGVjb3JhdGlvbicsXG4gIHRleHRSZW5kZXJpbmc6ICd0ZXh0LXJlbmRlcmluZycsXG4gIHRleHRMZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdG86IDAsXG4gIHRyYW5zZm9ybTogMCxcbiAgdTE6IDAsXG4gIHUyOiAwLFxuICB1bmRlcmxpbmVQb3NpdGlvbjogJ3VuZGVybGluZS1wb3NpdGlvbicsXG4gIHVuZGVybGluZVRoaWNrbmVzczogJ3VuZGVybGluZS10aGlja25lc3MnLFxuICB1bmljb2RlOiAwLFxuICB1bmljb2RlQmlkaTogJ3VuaWNvZGUtYmlkaScsXG4gIHVuaWNvZGVSYW5nZTogJ3VuaWNvZGUtcmFuZ2UnLFxuICB1bml0c1BlckVtOiAndW5pdHMtcGVyLWVtJyxcbiAgdkFscGhhYmV0aWM6ICd2LWFscGhhYmV0aWMnLFxuICB2SGFuZ2luZzogJ3YtaGFuZ2luZycsXG4gIHZJZGVvZ3JhcGhpYzogJ3YtaWRlb2dyYXBoaWMnLFxuICB2TWF0aGVtYXRpY2FsOiAndi1tYXRoZW1hdGljYWwnLFxuICB2YWx1ZXM6IDAsXG4gIHZlY3RvckVmZmVjdDogJ3ZlY3Rvci1lZmZlY3QnLFxuICB2ZXJzaW9uOiAwLFxuICB2ZXJ0QWR2WTogJ3ZlcnQtYWR2LXknLFxuICB2ZXJ0T3JpZ2luWDogJ3ZlcnQtb3JpZ2luLXgnLFxuICB2ZXJ0T3JpZ2luWTogJ3ZlcnQtb3JpZ2luLXknLFxuICB2aWV3Qm94OiAndmlld0JveCcsXG4gIHZpZXdUYXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogMCxcbiAgd2lkdGhzOiAwLFxuICB3b3JkU3BhY2luZzogJ3dvcmQtc3BhY2luZycsXG4gIHdyaXRpbmdNb2RlOiAnd3JpdGluZy1tb2RlJyxcbiAgeDogMCxcbiAgeEhlaWdodDogJ3gtaGVpZ2h0JyxcbiAgeDE6IDAsXG4gIHgyOiAwLFxuICB4Q2hhbm5lbFNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhsaW5rQWN0dWF0ZTogJ3hsaW5rOmFjdHVhdGUnLFxuICB4bGlua0FyY3JvbGU6ICd4bGluazphcmNyb2xlJyxcbiAgeGxpbmtIcmVmOiAneGxpbms6aHJlZicsXG4gIHhsaW5rUm9sZTogJ3hsaW5rOnJvbGUnLFxuICB4bGlua1Nob3c6ICd4bGluazpzaG93JyxcbiAgeGxpbmtUaXRsZTogJ3hsaW5rOnRpdGxlJyxcbiAgeGxpbmtUeXBlOiAneGxpbms6dHlwZScsXG4gIHhtbEJhc2U6ICd4bWw6YmFzZScsXG4gIHhtbG5zOiAwLFxuICB4bWxuc1hsaW5rOiAneG1sbnM6eGxpbmsnLFxuICB4bWxMYW5nOiAneG1sOmxhbmcnLFxuICB4bWxTcGFjZTogJ3htbDpzcGFjZScsXG4gIHk6IDAsXG4gIHkxOiAwLFxuICB5MjogMCxcbiAgeUNoYW5uZWxTZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAwLFxuICB6b29tQW5kUGFuOiAnem9vbUFuZFBhbidcbn07XG5cbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgUHJvcGVydGllczoge30sXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcbiAgICB4bGlua0FjdHVhdGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcbiAgICB4bGlua1JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXG4gICAgeGxpbmtUeXBlOiBOUy54bGluayxcbiAgICB4bWxCYXNlOiBOUy54bWwsXG4gICAgeG1sTGFuZzogTlMueG1sLFxuICAgIHhtbFNwYWNlOiBOUy54bWxcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHt9XG59O1xuXG5PYmplY3Qua2V5cyhBVFRSUykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFNWR0RPTVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXNba2V5XSA9IDA7XG4gIGlmIChBVFRSU1trZXldKSB7XG4gICAgU1ZHRE9NUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNba2V5XSA9IEFUVFJTW2tleV07XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR0RPTVByb3BlcnR5Q29uZmlnO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU1ZHRE9NUHJvcGVydHlDb25maWcuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2VsZWN0RXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnB1dFNlbGVjdGlvbicpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2VsZWN0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWxlY3RDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnUsIHRvcExldmVsVHlwZXMudG9wRm9jdXMsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd24sIHRvcExldmVsVHlwZXMudG9wTW91c2VVcCwgdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2VdXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8vIFRyYWNrIHdoZXRoZXIgYSBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuLy8gbm90IGV4dHJhY3QgZXZlbnRzLiBTZWUgIzM2MzkuXG52YXIgaGFzTGlzdGVuZXIgPSBmYWxzZTtcbnZhciBPTl9TRUxFQ1RfS0VZID0ga2V5T2YoeyBvblNlbGVjdDogbnVsbCB9KTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHJhbmdlLnBhcmVudEVsZW1lbnQoKSxcbiAgICAgIHRleHQ6IHJhbmdlLnRleHQsXG4gICAgICB0b3A6IHJhbmdlLmJvdW5kaW5nVG9wLFxuICAgICAgbGVmdDogcmFuZ2UuYm91bmRpbmdMZWZ0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50KTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICBzeW50aGV0aWNFdmVudC50eXBlID0gJ3NlbGVjdCc7XG4gICAgc3ludGhldGljRXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudDtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhzeW50aGV0aWNFdmVudCk7XG5cbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAoIWhhc0xpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BGb2N1czpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSB8fCB0YXJnZXROb2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXA6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgICAgLy8gdG8ga2V5IGFuZCBpbnB1dCBldmVudHMgb24gZGVsZXRpb24sIHNvIHdlIGRpc2NhcmQgaXQuXG4gICAgICAvL1xuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgLy8gVGhpcyBpcyBhbHNvIG91ciBhcHByb2FjaCBmb3IgSUUgaGFuZGxpbmcsIGZvciB0aGUgcmVhc29uIGFib3ZlLlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZTpcbiAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9TRUxFQ1RfS0VZKSB7XG4gICAgICBoYXNMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdEV2ZW50UGx1Z2luO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU2VsZWN0RXZlbnRQbHVnaW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2ltcGxlRXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnZmJqcy9saWIvRXZlbnRMaXN0ZW5lcicpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNBbmltYXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0ZvY3VzRXZlbnQnKTtcbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNLZXlib2FyZEV2ZW50Jyk7XG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xudmFyIFN5bnRoZXRpY0RyYWdFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRHJhZ0V2ZW50Jyk7XG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVG91Y2hFdmVudCcpO1xudmFyIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVHJhbnNpdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1doZWVsRXZlbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYWJvcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkFib3J0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25BYm9ydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGFuaW1hdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQW5pbWF0aW9uRW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25BbmltYXRpb25FbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBhbmltYXRpb25JdGVyYXRpb246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkFuaW1hdGlvbkl0ZXJhdGlvbjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQW5pbWF0aW9uSXRlcmF0aW9uQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgYW5pbWF0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkFuaW1hdGlvblN0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25BbmltYXRpb25TdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGJsdXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkJsdXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkJsdXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjYW5QbGF5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DYW5QbGF5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DYW5QbGF5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2FuUGxheVRocm91Z2g6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNhblBsYXlUaHJvdWdoOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DYW5QbGF5VGhyb3VnaENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DbGljazogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2xpY2tDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjb250ZXh0TWVudToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29udGV4dE1lbnU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbnRleHRNZW51Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY29weToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29weTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29weUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGN1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ3V0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkb3VibGVDbGljazoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRG91YmxlQ2xpY2s6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRvdWJsZUNsaWNrQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRW50ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFbnRlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0VudGVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0V4aXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFeGl0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRXhpdENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdMZWF2ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0xlYXZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnTGVhdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnT3Zlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ092ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdPdmVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ1N0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyb3A6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyb3A6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyb3BDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkdXJhdGlvbkNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHVyYXRpb25DaGFuZ2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkR1cmF0aW9uQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZW1wdGllZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRW1wdGllZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRW1wdGllZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVuY3J5cHRlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRW5jcnlwdGVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FbmNyeXB0ZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlbmRlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRW5kZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVuZGVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZXJyb3I6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkVycm9yOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FcnJvckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGZvY3VzOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Gb2N1czogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRm9jdXNDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBpbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uSW5wdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbklucHV0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgaW52YWxpZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uSW52YWxpZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uSW52YWxpZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleURvd246IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleURvd25DYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlQcmVzczoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uS2V5UHJlc3M6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleVByZXNzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5VXA6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleVVwOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlVcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkZWREYXRhOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkZWREYXRhOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkZWREYXRhQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZGVkTWV0YWRhdGE6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWRlZE1ldGFkYXRhOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkZWRNZXRhZGF0YUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWRTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZFN0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICAvLyBOb3RlOiBXZSBkbyBub3QgYWxsb3cgbGlzdGVuaW5nIHRvIG1vdXNlT3ZlciBldmVudHMuIEluc3RlYWQsIHVzZSB0aGVcbiAgLy8gb25Nb3VzZUVudGVyL29uTW91c2VMZWF2ZSBjcmVhdGVkIGJ5IGBFbnRlckxlYXZlRXZlbnRQbHVnaW5gLlxuICBtb3VzZURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlRG93bjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VEb3duQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VNb3ZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU1vdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlTW92ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlT3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU91dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VPdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU92ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlT3ZlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VPdmVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VVcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VVcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VVcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBhc3RlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QYXN0ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGFzdGVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwYXVzZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGF1c2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBhdXNlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGxheToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGxheTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGxheUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBsYXlpbmc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBsYXlpbmc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBsYXlpbmdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwcm9ncmVzczoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUHJvZ3Jlc3M6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblByb2dyZXNzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcmF0ZUNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUmF0ZUNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUmF0ZUNoYW5nZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHJlc2V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25SZXNldDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUmVzZXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzY3JvbGw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNjcm9sbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2Nyb2xsQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Vla2VkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWVrZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlZWtlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNlZWtpbmc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNlZWtpbmc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlZWtpbmdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdGFsbGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdGFsbGVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdGFsbGVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc3VibWl0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdWJtaXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblN1Ym1pdENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN1c3BlbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblN1c3BlbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblN1c3BlbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0aW1lVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25UaW1lVXBkYXRlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25UaW1lVXBkYXRlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hDYW5jZWw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoQ2FuY2VsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaENhbmNlbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaEVuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hFbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaE1vdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoTW92ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hNb3ZlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRyYW5zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRyYW5zaXRpb25FbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRyYW5zaXRpb25FbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB2b2x1bWVDaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblZvbHVtZUNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVm9sdW1lQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgd2FpdGluZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uV2FpdGluZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2FpdGluZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHdoZWVsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25XaGVlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2hlZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICB0b3BBYm9ydDogZXZlbnRUeXBlcy5hYm9ydCxcbiAgdG9wQW5pbWF0aW9uRW5kOiBldmVudFR5cGVzLmFuaW1hdGlvbkVuZCxcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBldmVudFR5cGVzLmFuaW1hdGlvbkl0ZXJhdGlvbixcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGV2ZW50VHlwZXMuYW5pbWF0aW9uU3RhcnQsXG4gIHRvcEJsdXI6IGV2ZW50VHlwZXMuYmx1cixcbiAgdG9wQ2FuUGxheTogZXZlbnRUeXBlcy5jYW5QbGF5LFxuICB0b3BDYW5QbGF5VGhyb3VnaDogZXZlbnRUeXBlcy5jYW5QbGF5VGhyb3VnaCxcbiAgdG9wQ2xpY2s6IGV2ZW50VHlwZXMuY2xpY2ssXG4gIHRvcENvbnRleHRNZW51OiBldmVudFR5cGVzLmNvbnRleHRNZW51LFxuICB0b3BDb3B5OiBldmVudFR5cGVzLmNvcHksXG4gIHRvcEN1dDogZXZlbnRUeXBlcy5jdXQsXG4gIHRvcERvdWJsZUNsaWNrOiBldmVudFR5cGVzLmRvdWJsZUNsaWNrLFxuICB0b3BEcmFnOiBldmVudFR5cGVzLmRyYWcsXG4gIHRvcERyYWdFbmQ6IGV2ZW50VHlwZXMuZHJhZ0VuZCxcbiAgdG9wRHJhZ0VudGVyOiBldmVudFR5cGVzLmRyYWdFbnRlcixcbiAgdG9wRHJhZ0V4aXQ6IGV2ZW50VHlwZXMuZHJhZ0V4aXQsXG4gIHRvcERyYWdMZWF2ZTogZXZlbnRUeXBlcy5kcmFnTGVhdmUsXG4gIHRvcERyYWdPdmVyOiBldmVudFR5cGVzLmRyYWdPdmVyLFxuICB0b3BEcmFnU3RhcnQ6IGV2ZW50VHlwZXMuZHJhZ1N0YXJ0LFxuICB0b3BEcm9wOiBldmVudFR5cGVzLmRyb3AsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiBldmVudFR5cGVzLmR1cmF0aW9uQ2hhbmdlLFxuICB0b3BFbXB0aWVkOiBldmVudFR5cGVzLmVtcHRpZWQsXG4gIHRvcEVuY3J5cHRlZDogZXZlbnRUeXBlcy5lbmNyeXB0ZWQsXG4gIHRvcEVuZGVkOiBldmVudFR5cGVzLmVuZGVkLFxuICB0b3BFcnJvcjogZXZlbnRUeXBlcy5lcnJvcixcbiAgdG9wRm9jdXM6IGV2ZW50VHlwZXMuZm9jdXMsXG4gIHRvcElucHV0OiBldmVudFR5cGVzLmlucHV0LFxuICB0b3BJbnZhbGlkOiBldmVudFR5cGVzLmludmFsaWQsXG4gIHRvcEtleURvd246IGV2ZW50VHlwZXMua2V5RG93bixcbiAgdG9wS2V5UHJlc3M6IGV2ZW50VHlwZXMua2V5UHJlc3MsXG4gIHRvcEtleVVwOiBldmVudFR5cGVzLmtleVVwLFxuICB0b3BMb2FkOiBldmVudFR5cGVzLmxvYWQsXG4gIHRvcExvYWRlZERhdGE6IGV2ZW50VHlwZXMubG9hZGVkRGF0YSxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6IGV2ZW50VHlwZXMubG9hZGVkTWV0YWRhdGEsXG4gIHRvcExvYWRTdGFydDogZXZlbnRUeXBlcy5sb2FkU3RhcnQsXG4gIHRvcE1vdXNlRG93bjogZXZlbnRUeXBlcy5tb3VzZURvd24sXG4gIHRvcE1vdXNlTW92ZTogZXZlbnRUeXBlcy5tb3VzZU1vdmUsXG4gIHRvcE1vdXNlT3V0OiBldmVudFR5cGVzLm1vdXNlT3V0LFxuICB0b3BNb3VzZU92ZXI6IGV2ZW50VHlwZXMubW91c2VPdmVyLFxuICB0b3BNb3VzZVVwOiBldmVudFR5cGVzLm1vdXNlVXAsXG4gIHRvcFBhc3RlOiBldmVudFR5cGVzLnBhc3RlLFxuICB0b3BQYXVzZTogZXZlbnRUeXBlcy5wYXVzZSxcbiAgdG9wUGxheTogZXZlbnRUeXBlcy5wbGF5LFxuICB0b3BQbGF5aW5nOiBldmVudFR5cGVzLnBsYXlpbmcsXG4gIHRvcFByb2dyZXNzOiBldmVudFR5cGVzLnByb2dyZXNzLFxuICB0b3BSYXRlQ2hhbmdlOiBldmVudFR5cGVzLnJhdGVDaGFuZ2UsXG4gIHRvcFJlc2V0OiBldmVudFR5cGVzLnJlc2V0LFxuICB0b3BTY3JvbGw6IGV2ZW50VHlwZXMuc2Nyb2xsLFxuICB0b3BTZWVrZWQ6IGV2ZW50VHlwZXMuc2Vla2VkLFxuICB0b3BTZWVraW5nOiBldmVudFR5cGVzLnNlZWtpbmcsXG4gIHRvcFN0YWxsZWQ6IGV2ZW50VHlwZXMuc3RhbGxlZCxcbiAgdG9wU3VibWl0OiBldmVudFR5cGVzLnN1Ym1pdCxcbiAgdG9wU3VzcGVuZDogZXZlbnRUeXBlcy5zdXNwZW5kLFxuICB0b3BUaW1lVXBkYXRlOiBldmVudFR5cGVzLnRpbWVVcGRhdGUsXG4gIHRvcFRvdWNoQ2FuY2VsOiBldmVudFR5cGVzLnRvdWNoQ2FuY2VsLFxuICB0b3BUb3VjaEVuZDogZXZlbnRUeXBlcy50b3VjaEVuZCxcbiAgdG9wVG91Y2hNb3ZlOiBldmVudFR5cGVzLnRvdWNoTW92ZSxcbiAgdG9wVG91Y2hTdGFydDogZXZlbnRUeXBlcy50b3VjaFN0YXJ0LFxuICB0b3BUcmFuc2l0aW9uRW5kOiBldmVudFR5cGVzLnRyYW5zaXRpb25FbmQsXG4gIHRvcFZvbHVtZUNoYW5nZTogZXZlbnRUeXBlcy52b2x1bWVDaGFuZ2UsXG4gIHRvcFdhaXRpbmc6IGV2ZW50VHlwZXMud2FpdGluZyxcbiAgdG9wV2hlZWw6IGV2ZW50VHlwZXMud2hlZWxcbn07XG5cbmZvciAodmFyIHR5cGUgaW4gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnKSB7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0eXBlXS5kZXBlbmRlbmNpZXMgPSBbdHlwZV07XG59XG5cbnZhciBPTl9DTElDS19LRVkgPSBrZXlPZih7IG9uQ2xpY2s6IG51bGwgfSk7XG52YXIgb25DbGlja0xpc3RlbmVycyA9IHt9O1xuXG5mdW5jdGlvbiBnZXREaWN0aW9uYXJ5S2V5KGluc3QpIHtcbiAgLy8gUHJldmVudHMgVjggcGVyZm9ybWFuY2UgaXNzdWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgcmV0dXJuICcuJyArIGluc3QuX3Jvb3ROb2RlSUQ7XG59XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEFib3J0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENhblBsYXk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2FuUGxheVRocm91Z2g6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHVyYXRpb25DaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW1wdGllZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbmNyeXB0ZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW5kZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRXJyb3I6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wSW5wdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wSW52YWxpZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRlZERhdGE6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZGVkTWV0YWRhdGE6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZFN0YXJ0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhdXNlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBsYXk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGxheWluZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQcm9ncmVzczpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BSYXRlQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFJlc2V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNlZWtlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWVraW5nOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN0YWxsZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU3VibWl0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN1c3BlbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVGltZVVwZGF0ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BWb2x1bWVDaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wV2FpdGluZzpcbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICAgIGlmIChnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRm9jdXM6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDbGljazpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAgIC8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRG91YmxlQ2xpY2s6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlTW92ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRW50ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0V4aXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0xlYXZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdTdGFydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcm9wOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaEVuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEFuaW1hdGlvbkVuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BBbmltYXRpb25JdGVyYXRpb246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQW5pbWF0aW9uU3RhcnQ6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVHJhbnNpdGlvbkVuZDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2Nyb2xsOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wV2hlZWw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb3B5OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEN1dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZTpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgIUV2ZW50Q29uc3RydWN0b3IgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU2ltcGxlRXZlbnRQbHVnaW46IFVuaGFuZGxlZCBldmVudCB0eXBlLCBgJXNgLicsIHRvcExldmVsVHlwZSkgOiBfcHJvZEludmFyaWFudCgnODYnLCB0b3BMZXZlbFR5cGUpIDogdm9pZCAwO1xuICAgIHZhciBldmVudCA9IEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9LFxuXG4gIGRpZFB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAgIC8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3RcbiAgICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gICAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9DTElDS19LRVkpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgIGlmICghb25DbGlja0xpc3RlbmVyc1trZXldKSB7XG4gICAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XSA9IEV2ZW50TGlzdGVuZXIubGlzdGVuKG5vZGUsICdjbGljaycsIGVtcHR5RnVuY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB3aWxsRGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09IE9OX0NMSUNLX0tFWSkge1xuICAgICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgICBvbkNsaWNrTGlzdGVuZXJzW2tleV0ucmVtb3ZlKCk7XG4gICAgICBkZWxldGUgb25DbGlja0xpc3RlbmVyc1trZXldO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUV2ZW50UGx1Z2luO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU2ltcGxlRXZlbnRQbHVnaW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQW5pbWF0aW9uRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG52YXIgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGFuaW1hdGlvbk5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQW5pbWF0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQW5pbWF0aW9uRXZlbnQsIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDbGlwYm9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDbGlwYm9hcmRFdmVudCwgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRm9jdXNFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRm9jdXNFdmVudEludGVyZmFjZSA9IHtcbiAgcmVsYXRlZFRhcmdldDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRm9jdXNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRm9jdXNFdmVudCwgRm9jdXNFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRm9jdXNFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljS2V5Ym9hcmRFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcbnZhciBnZXRFdmVudEtleSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRLZXknKTtcbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBsb2NhdGlvbjogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgcmVwZWF0OiBudWxsLFxuICBsb2NhbGU6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuXG4gICAgLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCwgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3RcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci4gT25seSBLZXlQcmVzcyBoYXMgY2hhckNvZGUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBwaHlzaWNhbCBrZXlib2FyZCBrZXkuXG5cbiAgICAvLyBUaGUgYWN0dWFsIG1lYW5pbmcgb2YgdGhlIHZhbHVlIGRlcGVuZHMgb24gdGhlIHVzZXJzJyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyB3aGljaCBjYW5ub3QgYmUgZGV0ZWN0ZWQuIEFzc3VtaW5nIHRoYXQgaXQgaXMgYSBVUyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyBwcm92aWRlcyBhIHN1cnByaXNpbmdseSBhY2N1cmF0ZSBtYXBwaW5nIGZvciBVUyBhbmQgRXVyb3BlYW4gdXNlcnMuXG4gICAgLy8gRHVlIHRvIHRoaXMsIGl0IGlzIGxlZnQgdG8gdGhlIHVzZXIgdG8gaW1wbGVtZW50IGF0IHRoaXMgdGltZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50Q2hhckNvZGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogYGNoYXJDb2RlYCByZXByZXNlbnRzIHRoZSBhY3R1YWwgXCJjaGFyYWN0ZXIgY29kZVwiIGFuZCBpcyBzYWZlIHRvIHVzZSB3aXRoXG4gKiBgU3RyaW5nLmZyb21DaGFyQ29kZWAuIEFzIHN1Y2gsIG9ubHkga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gcHJpbnRhYmxlXG4gKiBjaGFyYWN0ZXJzIHByb2R1Y2UgYSB2YWxpZCBgY2hhckNvZGVgLCB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyBFbnRlci5cbiAqIFRoZSBUYWIta2V5IGlzIGNvbnNpZGVyZWQgbm9uLXByaW50YWJsZSBhbmQgZG9lcyBub3QgaGF2ZSBhIGBjaGFyQ29kZWAsXG4gKiBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgZG9lcyBub3QgcHJvZHVjZSBhIHRhYi1jaGFyYWN0ZXIgaW4gYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBOb3JtYWxpemVkIGBjaGFyQ29kZWAgcHJvcGVydHkuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRDaGFyQ29kZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2dldEV2ZW50Q2hhckNvZGUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRLZXlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgJ0VzYyc6ICdFc2NhcGUnLFxuICAnU3BhY2ViYXInOiAnICcsXG4gICdMZWZ0JzogJ0Fycm93TGVmdCcsXG4gICdVcCc6ICdBcnJvd1VwJyxcbiAgJ1JpZ2h0JzogJ0Fycm93UmlnaHQnLFxuICAnRG93bic6ICdBcnJvd0Rvd24nLFxuICAnRGVsJzogJ0RlbGV0ZScsXG4gICdXaW4nOiAnT1MnLFxuICAnTWVudSc6ICdDb250ZXh0TWVudScsXG4gICdBcHBzJzogJ0NvbnRleHRNZW51JyxcbiAgJ1Njcm9sbCc6ICdTY3JvbGxMb2NrJyxcbiAgJ01velByaW50YWJsZUtleSc6ICdVbmlkZW50aWZpZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICA4OiAnQmFja3NwYWNlJyxcbiAgOTogJ1RhYicsXG4gIDEyOiAnQ2xlYXInLFxuICAxMzogJ0VudGVyJyxcbiAgMTY6ICdTaGlmdCcsXG4gIDE3OiAnQ29udHJvbCcsXG4gIDE4OiAnQWx0JyxcbiAgMTk6ICdQYXVzZScsXG4gIDIwOiAnQ2Fwc0xvY2snLFxuICAyNzogJ0VzY2FwZScsXG4gIDMyOiAnICcsXG4gIDMzOiAnUGFnZVVwJyxcbiAgMzQ6ICdQYWdlRG93bicsXG4gIDM1OiAnRW5kJyxcbiAgMzY6ICdIb21lJyxcbiAgMzc6ICdBcnJvd0xlZnQnLFxuICAzODogJ0Fycm93VXAnLFxuICAzOTogJ0Fycm93UmlnaHQnLFxuICA0MDogJ0Fycm93RG93bicsXG4gIDQ1OiAnSW5zZXJ0JyxcbiAgNDY6ICdEZWxldGUnLFxuICAxMTI6ICdGMScsIDExMzogJ0YyJywgMTE0OiAnRjMnLCAxMTU6ICdGNCcsIDExNjogJ0Y1JywgMTE3OiAnRjYnLFxuICAxMTg6ICdGNycsIDExOTogJ0Y4JywgMTIwOiAnRjknLCAxMjE6ICdGMTAnLCAxMjI6ICdGMTEnLCAxMjM6ICdGMTInLFxuICAxNDQ6ICdOdW1Mb2NrJyxcbiAgMTQ1OiAnU2Nyb2xsTG9jaycsXG4gIDIyNDogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7XG5cbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRLZXk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRFdmVudEtleS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNEcmFnRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0RyYWdFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRHJhZ0V2ZW50LCBEcmFnRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0RyYWdFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNUb3VjaEV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFRvdWNoRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzL1xuICovXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IHtcbiAgdG91Y2hlczogbnVsbCxcbiAgdGFyZ2V0VG91Y2hlczogbnVsbCxcbiAgY2hhbmdlZFRvdWNoZXM6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVG91Y2hFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVG91Y2hFdmVudCwgVG91Y2hFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVG91Y2hFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVHJhbnNpdGlvbkV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELWNzczMtdHJhbnNpdGlvbnMtMjAwOTAzMjAvI3RyYW5zaXRpb24tZXZlbnRzLVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XG4gKi9cbnZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHByb3BlcnR5TmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LCBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNXaGVlbEV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0ge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IG51bGwsXG5cbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY01vdXNlRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1doZWVsRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1doZWVsRXZlbnQsIFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TW91bnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01Db250YWluZXJJbmZvID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbnRhaW5lckluZm8nKTtcbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01GZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdEZlYXR1cmVGbGFncycpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0gcmVxdWlyZSgnLi9SZWFjdE1hcmt1cENoZWNrc3VtJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUU7XG52YXIgUk9PVF9BVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FO1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSA9IDExO1xuXG52YXIgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCA9IHt9O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gKiB0aGF0J3Mgbm90IGNvbW1vbiBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gc3RyaW5ncy5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgY2hhcmFjdGVyIHdoZXJlIHRoZSBzdHJpbmdzIGRpdmVyZ2VcbiAqL1xuZnVuY3Rpb24gZmlyc3REaWZmZXJlbmNlSW5kZXgoc3RyaW5nMSwgc3RyaW5nMikge1xuICB2YXIgbWluTGVuID0gTWF0aC5taW4oc3RyaW5nMS5sZW5ndGgsIHN0cmluZzIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5MZW47IGkrKykge1xuICAgIGlmIChzdHJpbmcxLmNoYXJBdChpKSAhPT0gc3RyaW5nMi5jaGFyQXQoaSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyaW5nMS5sZW5ndGggPT09IHN0cmluZzIubGVuZ3RoID8gLTEgOiBtaW5MZW47XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTURvY3VtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBtYXkgY29udGFpblxuICogYSBSZWFjdCBjb21wb25lbnRcbiAqIEByZXR1cm4gez8qfSBET00gZWxlbWVudCB0aGF0IG1heSBoYXZlIHRoZSByZWFjdFJvb3QgSUQsIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxHZXRJRChub2RlKSB7XG4gIC8vIElmIG5vZGUgaXMgc29tZXRoaW5nIGxpa2UgYSB3aW5kb3csIGRvY3VtZW50LCBvciB0ZXh0IG5vZGUsIG5vbmUgb2ZcbiAgLy8gd2hpY2ggc3VwcG9ydCBhdHRyaWJ1dGVzIG9yIGEgLmdldEF0dHJpYnV0ZSBtZXRob2QsIGdyYWNlZnVsbHkgcmV0dXJuXG4gIC8vIHRoZSBlbXB0eSBzdHJpbmcsIGFzIGlmIHRoZSBhdHRyaWJ1dGUgd2VyZSBtaXNzaW5nLlxuICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSB8fCAnJztcbn1cblxuLyoqXG4gKiBNb3VudHMgdGhpcyBjb21wb25lbnQgYW5kIGluc2VydHMgaXQgaW50byB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50SW50b05vZGUod3JhcHBlckluc3RhbmNlLCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICB2YXIgbWFya2VyTmFtZTtcbiAgaWYgKFJlYWN0RmVhdHVyZUZsYWdzLmxvZ1RvcExldmVsUmVuZGVycykge1xuICAgIHZhciB3cmFwcGVkRWxlbWVudCA9IHdyYXBwZXJJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHR5cGUgPSB3cmFwcGVkRWxlbWVudC50eXBlO1xuICAgIG1hcmtlck5hbWUgPSAnUmVhY3QgbW91bnQ6ICcgKyAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZSA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lKTtcbiAgICBjb25zb2xlLnRpbWUobWFya2VyTmFtZSk7XG4gIH1cblxuICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KHdyYXBwZXJJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIG51bGwsIFJlYWN0RE9NQ29udGFpbmVySW5mbyh3cmFwcGVySW5zdGFuY2UsIGNvbnRhaW5lciksIGNvbnRleHQsIDAgLyogcGFyZW50RGVidWdJRCAqL1xuICApO1xuXG4gIGlmIChtYXJrZXJOYW1lKSB7XG4gICAgY29uc29sZS50aW1lRW5kKG1hcmtlck5hbWUpO1xuICB9XG5cbiAgd3JhcHBlckluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudC5fdG9wTGV2ZWxXcmFwcGVyID0gd3JhcHBlckluc3RhbmNlO1xuICBSZWFjdE1vdW50Ll9tb3VudEltYWdlSW50b05vZGUobWFya3VwLCBjb250YWluZXIsIHdyYXBwZXJJbnN0YW5jZSwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBCYXRjaGVkIG1vdW50LlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIGJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlKGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmdldFBvb2xlZChcbiAgLyogdXNlQ3JlYXRlRWxlbWVudCAqL1xuICAhc2hvdWxkUmV1c2VNYXJrdXAgJiYgUmVhY3RET01GZWF0dXJlRmxhZ3MudXNlQ3JlYXRlRWxlbWVudCk7XG4gIHRyYW5zYWN0aW9uLnBlcmZvcm0obW91bnRDb21wb25lbnRJbnRvTm9kZSwgbnVsbCwgY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcbiAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogVW5tb3VudHMgYSBjb21wb25lbnQgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGluc3RhbmNlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHVubW91bnQgZnJvbS5cbiAqIEBmaW5hbFxuICogQGludGVybmFsXG4gKiBAc2VlIHtSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGV9XG4gKi9cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRGcm9tTm9kZShpbnN0YW5jZSwgY29udGFpbmVyLCBzYWZlbHkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkZsdXNoKCk7XG4gIH1cbiAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQoaW5zdGFuY2UsIHNhZmVseSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2goKTtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICBjb250YWluZXIgPSBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gaHR0cDovL2pzcGVyZi5jb20vZW1wdHlpbmctYS1ub2RlXG4gIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICB9XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaGFzIGEgZGlyZWN0IFJlYWN0LXJlbmRlcmVkIGNoaWxkIHRoYXQgaXNcbiAqIG5vdCBhIFJlYWN0IHJvb3QgZWxlbWVudC4gVXNlZnVsIGZvciB3YXJuaW5nIGluIGByZW5kZXJgLFxuICogYHVubW91bnRDb21wb25lbnRBdE5vZGVgLCBldGMuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGVsZW1lbnQgY29udGFpbnMgYSBkaXJlY3QgY2hpbGQgdGhhdCB3YXNcbiAqIHJlbmRlcmVkIGJ5IFJlYWN0IGJ1dCBpcyBub3QgYSByb290IGVsZW1lbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKSB7XG4gIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgaWYgKHJvb3RFbCkge1xuICAgIHZhciBpbnN0ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKTtcbiAgICByZXR1cm4gISEoaW5zdCAmJiBpbnN0Ll9ob3N0UGFyZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgUmVhY3QgRE9NIGVsZW1lbnQgYW5kXG4gKiBpdCBoYXMgYmVlbiByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGhhcyBiZWVuIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdFxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiAhIShyb290RWwgJiYgaXNSZWFjdE5vZGUocm9vdEVsKSAmJiAhUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKSk7XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSB2YWxpZCBub2RlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGlzIGEgdmFsaWQgRE9NIG5vZGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkpO1xufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgUmVhY3Qgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIFJlYWN0IERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzUmVhY3ROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIGlzVmFsaWRDb250YWluZXIobm9kZSkgJiYgKG5vZGUuaGFzQXR0cmlidXRlKFJPT1RfQVRUUl9OQU1FKSB8fCBub2RlLmhhc0F0dHJpYnV0ZShBVFRSX05BTUUpKTtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFJvb3RJbnN0YW5jZUluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHZhciBwcmV2SG9zdEluc3RhbmNlID0gcm9vdEVsICYmIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCk7XG4gIHJldHVybiBwcmV2SG9zdEluc3RhbmNlICYmICFwcmV2SG9zdEluc3RhbmNlLl9ob3N0UGFyZW50ID8gcHJldkhvc3RJbnN0YW5jZSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdCA9IGdldEhvc3RSb290SW5zdGFuY2VJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gcm9vdCA/IHJvb3QuX2hvc3RDb250YWluZXJJbmZvLl90b3BMZXZlbFdyYXBwZXIgOiBudWxsO1xufVxuXG4vKipcbiAqIFRlbXBvcmFyeSAoPykgaGFjayBzbyB0aGF0IHdlIGNhbiBzdG9yZSBhbGwgdG9wLWxldmVsIHBlbmRpbmcgdXBkYXRlcyBvblxuICogY29tcG9zaXRlcyBpbnN0ZWFkIG9mIGhhdmluZyB0byB3b3JyeSBhYm91dCBkaWZmZXJlbnQgdHlwZXMgb2YgY29tcG9uZW50c1xuICogaGVyZS5cbiAqL1xudmFyIHRvcExldmVsUm9vdENvdW50ZXIgPSAxO1xudmFyIFRvcExldmVsV3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yb290SUQgPSB0b3BMZXZlbFJvb3RDb3VudGVyKys7XG59O1xuVG9wTGV2ZWxXcmFwcGVyLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBUb3BMZXZlbFdyYXBwZXIuZGlzcGxheU5hbWUgPSAnVG9wTGV2ZWxXcmFwcGVyJztcbn1cblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAvLyB0aGlzLnByb3BzIGlzIGFjdHVhbGx5IGEgUmVhY3RFbGVtZW50XG4gIHJldHVybiB0aGlzLnByb3BzO1xufTtcblxuLyoqXG4gKiBNb3VudGluZyBpcyB0aGUgcHJvY2VzcyBvZiBpbml0aWFsaXppbmcgYSBSZWFjdCBjb21wb25lbnQgYnkgY3JlYXRpbmcgaXRzXG4gKiByZXByZXNlbnRhdGl2ZSBET00gZWxlbWVudHMgYW5kIGluc2VydGluZyB0aGVtIGludG8gYSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAqIEFueSBwcmlvciBjb250ZW50IGluc2lkZSBgY29udGFpbmVyYCBpcyBkZXN0cm95ZWQgaW4gdGhlIHByb2Nlc3MuXG4gKlxuICogICBSZWFjdE1vdW50LnJlbmRlcihcbiAqICAgICBjb21wb25lbnQsXG4gKiAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpXG4gKiAgICk7XG4gKlxuICogICA8ZGl2IGlkPVwiY29udGFpbmVyXCI+ICAgICAgICAgICAgICAgICAgIDwtLSBTdXBwbGllZCBgY29udGFpbmVyYC5cbiAqICAgICA8ZGl2IGRhdGEtcmVhY3RpZD1cIi4zXCI+ICAgICAgICAgICAgICA8LS0gUmVuZGVyZWQgcmVhY3RSb290IG9mIFJlYWN0XG4gKiAgICAgICAvLyAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuXG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvZGl2PlxuICpcbiAqIEluc2lkZSBvZiBgY29udGFpbmVyYCwgdGhlIGZpcnN0IGVsZW1lbnQgcmVuZGVyZWQgaXMgdGhlIFwicmVhY3RSb290XCIuXG4gKi9cbnZhciBSZWFjdE1vdW50ID0ge1xuXG4gIFRvcExldmVsV3JhcHBlcjogVG9wTGV2ZWxXcmFwcGVyLFxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGRldnRvb2xzLiBUaGUga2V5cyBhcmUgbm90IGltcG9ydGFudC5cbiAgICovXG4gIF9pbnN0YW5jZXNCeVJlYWN0Um9vdElEOiBpbnN0YW5jZXNCeVJlYWN0Um9vdElELFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgaG9vayBwcm92aWRlZCB0byBzdXBwb3J0IHJlbmRlcmluZyBSZWFjdCBjb21wb25lbnRzIHdoaWxlXG4gICAqIGVuc3VyaW5nIHRoYXQgdGhlIGFwcGFyZW50IHNjcm9sbCBwb3NpdGlvbiBvZiBpdHMgYGNvbnRhaW5lcmAgZG9lcyBub3RcbiAgICogY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBUaGUgYGNvbnRhaW5lcmAgYmVpbmcgcmVuZGVyZWQgaW50by5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmVuZGVyQ2FsbGJhY2sgVGhpcyBtdXN0IGJlIGNhbGxlZCBvbmNlIHRvIGRvIHRoZSByZW5kZXIuXG4gICAqL1xuICBzY3JvbGxNb25pdG9yOiBmdW5jdGlvbiAoY29udGFpbmVyLCByZW5kZXJDYWxsYmFjaykge1xuICAgIHJlbmRlckNhbGxiYWNrKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRha2UgYSBjb21wb25lbnQgdGhhdCdzIGFscmVhZHkgbW91bnRlZCBpbnRvIHRoZSBET00gYW5kIHJlcGxhY2UgaXRzIHByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHByZXZDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIGFscmVhZHkgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgY29tcG9uZW50IGluc3RhbmNlIHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqL1xuICBfdXBkYXRlUm9vdENvbXBvbmVudDogZnVuY3Rpb24gKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIFJlYWN0TW91bnQuc2Nyb2xsTW9uaXRvcihjb250YWluZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgbmV4dENvbnRleHQpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwocHJldkNvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByZXZDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIG5ldyBjb21wb25lbnQgaW50byB0aGUgRE9NLiBIb29rZWQgYnkgaG9va3MhXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBlbGVtZW50IHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBpZiB3ZSBzaG91bGQgc2tpcCB0aGUgbWFya3VwIGluc2VydGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gbmV4dENvbXBvbmVudFxuICAgKi9cbiAgX3JlbmRlck5ld1Jvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tICcgKyAncmVuZGVyIGlzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ19yZWdpc3RlckNvbXBvbmVudCguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM3JykgOiB2b2lkIDA7XG5cbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nKCk7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgZmFsc2UpO1xuXG4gICAgLy8gVGhlIGluaXRpYWwgcmVuZGVyIGlzIHN5bmNocm9ub3VzIGJ1dCBhbnkgdXBkYXRlcyB0aGF0IGhhcHBlbiBkdXJpbmdcbiAgICAvLyByZW5kZXJpbmcsIGluIGNvbXBvbmVudFdpbGxNb3VudCBvciBjb21wb25lbnREaWRNb3VudCwgd2lsbCBiZSBiYXRjaGVkXG4gICAgLy8gYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGJhdGNoaW5nIHN0cmF0ZWd5LlxuXG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlLCBjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG5cbiAgICB2YXIgd3JhcHBlcklEID0gY29tcG9uZW50SW5zdGFuY2UuX2luc3RhbmNlLnJvb3RJRDtcbiAgICBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3dyYXBwZXJJRF0gPSBjb21wb25lbnRJbnN0YW5jZTtcblxuICAgIHJldHVybiBjb21wb25lbnRJbnN0YW5jZTtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBpbnRvIHRoZSBET00gaW4gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICAgKlxuICAgKiBJZiB0aGUgUmVhY3QgY29tcG9uZW50IHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGludG8gYGNvbnRhaW5lcmAsIHRoaXMgd2lsbFxuICAgKiBwZXJmb3JtIGFuIHVwZGF0ZSBvbiBpdCBhbmQgb25seSBtdXRhdGUgdGhlIERPTSBhcyBuZWNlc3NhcnkgdG8gcmVmbGVjdCB0aGVcbiAgICogbGF0ZXN0IFJlYWN0IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcGFyZW50Q29tcG9uZW50IFRoZSBjb25jZXB0dWFsIHBhcmVudCBvZiB0aGlzIHJlbmRlciB0cmVlLlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgQ29tcG9uZW50IGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAhKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIFJlYWN0SW5zdGFuY2VNYXAuaGFzKHBhcmVudENvbXBvbmVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMzgnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIFJlYWN0VXBkYXRlUXVldWUudmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjaywgJ1JlYWN0RE9NLnJlbmRlcicpO1xuICAgICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobmV4dEVsZW1lbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NLnJlbmRlcigpOiBJbnZhbGlkIGNvbXBvbmVudCBlbGVtZW50LiVzJywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgc3RyaW5nIGxpa2UgXFwnZGl2XFwnLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChcXCdkaXZcXCcpIG9yIDxkaXYgLz4uJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY2xhc3MgbGlrZSBGb28sIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KEZvbykgb3IgPEZvbyAvPi4nIDpcbiAgICAvLyBDaGVjayBpZiBpdCBxdWFja3MgbGlrZSBhbiBlbGVtZW50XG4gICAgbmV4dEVsZW1lbnQgIT0gbnVsbCAmJiBuZXh0RWxlbWVudC5wcm9wcyAhPT0gdW5kZWZpbmVkID8gJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgKyAnY29waWVzIG9mIFJlYWN0LicgOiAnJykgOiBfcHJvZEludmFyaWFudCgnMzknLCB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdzdHJpbmcnID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYSBzdHJpbmcgbGlrZSBcXCdkaXZcXCcsIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KFxcJ2RpdlxcJykgb3IgPGRpdiAvPi4nIDogdHlwZW9mIG5leHRFbGVtZW50ID09PSAnZnVuY3Rpb24nID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYSBjbGFzcyBsaWtlIEZvbywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9vKSBvciA8Rm9vIC8+LicgOiBuZXh0RWxlbWVudCAhPSBudWxsICYmIG5leHRFbGVtZW50LnByb3BzICE9PSB1bmRlZmluZWQgPyAnIFRoaXMgbWF5IGJlIGNhdXNlZCBieSB1bmludGVudGlvbmFsbHkgbG9hZGluZyB0d28gaW5kZXBlbmRlbnQgJyArICdjb3BpZXMgb2YgUmVhY3QuJyA6ICcnKSA6IHZvaWQgMDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci50YWdOYW1lIHx8IGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdCT0RZJywgJ3JlbmRlcigpOiBSZW5kZXJpbmcgY29tcG9uZW50cyBkaXJlY3RseSBpbnRvIGRvY3VtZW50LmJvZHkgaXMgJyArICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICsgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSByZW5kZXJpbmcgaW50byBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArICdmb3IgeW91ciBhcHAuJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgbmV4dFdyYXBwZWRFbGVtZW50ID0gUmVhY3RFbGVtZW50KFRvcExldmVsV3JhcHBlciwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbmV4dEVsZW1lbnQpO1xuXG4gICAgdmFyIG5leHRDb250ZXh0O1xuICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIHZhciBwYXJlbnRJbnN0ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocGFyZW50Q29tcG9uZW50KTtcbiAgICAgIG5leHRDb250ZXh0ID0gcGFyZW50SW5zdC5fcHJvY2Vzc0NoaWxkQ29udGV4dChwYXJlbnRJbnN0Ll9jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dENvbnRleHQgPSBlbXB0eU9iamVjdDtcbiAgICB9XG5cbiAgICB2YXIgcHJldkNvbXBvbmVudCA9IGdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyKGNvbnRhaW5lcik7XG5cbiAgICBpZiAocHJldkNvbXBvbmVudCkge1xuICAgICAgdmFyIHByZXZXcmFwcGVkRWxlbWVudCA9IHByZXZDb21wb25lbnQuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldldyYXBwZWRFbGVtZW50LnByb3BzO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgdmFyIHB1YmxpY0luc3QgPSBwcmV2Q29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICAgICB2YXIgdXBkYXRlZENhbGxiYWNrID0gY2FsbGJhY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwocHVibGljSW5zdCk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0TW91bnQuX3VwZGF0ZVJvb3RDb21wb25lbnQocHJldkNvbXBvbmVudCwgbmV4dFdyYXBwZWRFbGVtZW50LCBuZXh0Q29udGV4dCwgY29udGFpbmVyLCB1cGRhdGVkQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gcHVibGljSW5zdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWFjdFJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGNvbnRhaW5lckhhc1JlYWN0TWFya3VwID0gcmVhY3RSb290RWxlbWVudCAmJiAhIWludGVybmFsR2V0SUQocmVhY3RSb290RWxlbWVudCk7XG4gICAgdmFyIGNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkID0gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpIDogdm9pZCAwO1xuXG4gICAgICBpZiAoIWNvbnRhaW5lckhhc1JlYWN0TWFya3VwIHx8IHJlYWN0Um9vdEVsZW1lbnQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgdmFyIHJvb3RFbGVtZW50U2libGluZyA9IHJlYWN0Um9vdEVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChyb290RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgICBpZiAoaW50ZXJuYWxHZXRJRChyb290RWxlbWVudFNpYmxpbmcpKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3JlbmRlcigpOiBUYXJnZXQgbm9kZSBoYXMgbWFya3VwIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgdGhlcmUgJyArICdhcmUgdW5yZWxhdGVkIG5vZGVzIGFzIHdlbGwuIFRoaXMgaXMgbW9zdCBjb21tb25seSBjYXVzZWQgYnkgJyArICd3aGl0ZS1zcGFjZSBpbnNlcnRlZCBhcm91bmQgc2VydmVyLXJlbmRlcmVkIG1hcmt1cC4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByb290RWxlbWVudFNpYmxpbmcgPSByb290RWxlbWVudFNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkUmV1c2VNYXJrdXAgPSBjb250YWluZXJIYXNSZWFjdE1hcmt1cCAmJiAhcHJldkNvbXBvbmVudCAmJiAhY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQ7XG4gICAgdmFyIGNvbXBvbmVudCA9IFJlYWN0TW91bnQuX3JlbmRlck5ld1Jvb3RDb21wb25lbnQobmV4dFdyYXBwZWRFbGVtZW50LCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBuZXh0Q29udGV4dCkuX3JlbmRlcmVkQ29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0ZG9tLnJlbmRlclxuICAgKlxuICAgKiBJZiB0aGUgUmVhY3QgY29tcG9uZW50IHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGludG8gYGNvbnRhaW5lcmAsIHRoaXMgd2lsbFxuICAgKiBwZXJmb3JtIGFuIHVwZGF0ZSBvbiBpdCBhbmQgb25seSBtdXRhdGUgdGhlIERPTSBhcyBuZWNlc3NhcnkgdG8gcmVmbGVjdCB0aGVcbiAgICogbGF0ZXN0IFJlYWN0IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbmQgZGVzdHJveXMgdGhlIFJlYWN0IGNvbXBvbmVudCByZW5kZXJlZCBpbiB0aGUgYGNvbnRhaW5lcmAuXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS51bm1vdW50Y29tcG9uZW50YXRub2RlXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IGNvbnRhaW5pbmcgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYSBjb21wb25lbnQgd2FzIGZvdW5kIGluIGFuZCB1bm1vdW50ZWQgZnJvbVxuICAgKiAgICAgICAgICAgICAgICAgICBgY29udGFpbmVyYFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFN0cmljdGx5IHNwZWFraW5nLCB1bm1vdW50aW5nIHdvbid0IGNhdXNlIGFcbiAgICAvLyByZW5kZXIgYnV0IHdlIHN0aWxsIGRvbid0IGV4cGVjdCB0byBiZSBpbiBhIHJlbmRlciBjYWxsIGhlcmUuKVxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgJyArICdpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnNDAnKSA6IHZvaWQgMDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghbm9kZUlzUmVuZGVyZWRCeU90aGVySW5zdGFuY2UoY29udGFpbmVyKSwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91XFwncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50ICcgKyAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgcHJldkNvbXBvbmVudCA9IGdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgaWYgKCFwcmV2Q29tcG9uZW50KSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSBiZWluZyB1bm1vdW50ZWQgd2FzIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgaXNuJ3QgYVxuICAgICAgLy8gcm9vdCBub2RlLlxuICAgICAgdmFyIGNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkID0gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRhaW5lciBpdHNlbGYgaXMgYSBSZWFjdCByb290IG5vZGUuXG4gICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXIubm9kZVR5cGUgPT09IDEgJiYgY29udGFpbmVyLmhhc0F0dHJpYnV0ZShST09UX0FUVFJfTkFNRSk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91XFwncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50ICcgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkZWxldGUgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtwcmV2Q29tcG9uZW50Ll9pbnN0YW5jZS5yb290SURdO1xuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyh1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUsIHByZXZDb21wb25lbnQsIGNvbnRhaW5lciwgZmFsc2UpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIF9tb3VudEltYWdlSW50b05vZGU6IGZ1bmN0aW9uIChtYXJrdXAsIGNvbnRhaW5lciwgaW5zdGFuY2UsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbikge1xuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbW91bnRDb21wb25lbnRJbnRvTm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCB2YWxpZC4nKSA6IF9wcm9kSW52YXJpYW50KCc0MScpIDogdm9pZCAwO1xuXG4gICAgaWYgKHNob3VsZFJldXNlTWFya3VwKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIGlmIChSZWFjdE1hcmt1cENoZWNrc3VtLmNhblJldXNlTWFya3VwKG1hcmt1cCwgcm9vdEVsZW1lbnQpKSB7XG4gICAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUoaW5zdGFuY2UsIHJvb3RFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcblxuICAgICAgICB2YXIgcm9vdE1hcmt1cCA9IHJvb3RFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FLCBjaGVja3N1bSk7XG5cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRNYXJrdXAgPSBtYXJrdXA7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgLy8gYmVjYXVzZSByb290TWFya3VwIGlzIHJldHJpZXZlZCBmcm9tIHRoZSBET00sIHZhcmlvdXMgbm9ybWFsaXphdGlvbnNcbiAgICAgICAgICAvLyB3aWxsIGhhdmUgb2NjdXJyZWQgd2hpY2ggd2lsbCBub3QgYmUgcHJlc2VudCBpbiBgbWFya3VwYC4gSGVyZSxcbiAgICAgICAgICAvLyBpbnNlcnQgbWFya3VwIGludG8gYSA8ZGl2PiBvciA8aWZyYW1lPiBkZXBlbmRpbmcgb24gdGhlIGNvbnRhaW5lclxuICAgICAgICAgIC8vIHR5cGUgdG8gcGVyZm9ybSB0aGUgc2FtZSBub3JtYWxpemF0aW9ucyBiZWZvcmUgY29tcGFyaW5nLlxuICAgICAgICAgIHZhciBub3JtYWxpemVyO1xuICAgICAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFKSB7XG4gICAgICAgICAgICBub3JtYWxpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBub3JtYWxpemVyLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXJrdXAgPSBub3JtYWxpemVyLmlubmVySFRNTDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub3JtYWxpemVyKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LndyaXRlKG1hcmt1cCk7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5jb250ZW50RG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZmZJbmRleCA9IGZpcnN0RGlmZmVyZW5jZUluZGV4KG5vcm1hbGl6ZWRNYXJrdXAsIHJvb3RNYXJrdXApO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9ICcgKGNsaWVudCkgJyArIG5vcm1hbGl6ZWRNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCkgKyAnXFxuIChzZXJ2ZXIpICcgKyByb290TWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApO1xuXG4gICAgICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCB1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGJ1dCB0aGUgY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgdXN1YWxseSBtZWFucyB5b3UgcmVuZGVyZWQgYSBkaWZmZXJlbnQgY29tcG9uZW50IHR5cGUgb3IgcHJvcHMgb24gdGhlIGNsaWVudCBmcm9tIHRoZSBvbmUgb24gdGhlIHNlcnZlciwgb3IgeW91ciByZW5kZXIoKSBtZXRob2RzIGFyZSBpbXB1cmUuIFJlYWN0IGNhbm5vdCBoYW5kbGUgdGhpcyBjYXNlIGR1ZSB0byBjcm9zcy1icm93c2VyIHF1aXJrcyBieSByZW5kZXJpbmcgYXQgdGhlIGRvY3VtZW50IHJvb3QuIFlvdSBzaG91bGQgbG9vayBmb3IgZW52aXJvbm1lbnQgZGVwZW5kZW50IGNvZGUgaW4geW91ciBjb21wb25lbnRzIGFuZCBlbnN1cmUgdGhlIHByb3BzIGFyZSB0aGUgc2FtZSBjbGllbnQgYW5kIHNlcnZlciBzaWRlOlxcbiVzJywgZGlmZmVyZW5jZSkgOiBfcHJvZEludmFyaWFudCgnNDInLCBkaWZmZXJlbmNlKSA6IHZvaWQgMDtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgYXR0ZW1wdGVkIHRvIHJldXNlIG1hcmt1cCBpbiBhIGNvbnRhaW5lciBidXQgdGhlICcgKyAnY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgeW91IGFyZSAnICsgJ3VzaW5nIHNlcnZlciByZW5kZXJpbmcgYW5kIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSAnICsgJ3NlcnZlciB3YXMgbm90IHdoYXQgdGhlIGNsaWVudCB3YXMgZXhwZWN0aW5nLiBSZWFjdCBpbmplY3RlZCAnICsgJ25ldyBtYXJrdXAgdG8gY29tcGVuc2F0ZSB3aGljaCB3b3JrcyBidXQgeW91IGhhdmUgbG9zdCBtYW55ICcgKyAnb2YgdGhlIGJlbmVmaXRzIG9mIHNlcnZlciByZW5kZXJpbmcuIEluc3RlYWQsIGZpZ3VyZSBvdXQgJyArICd3aHkgdGhlIG1hcmt1cCBiZWluZyBnZW5lcmF0ZWQgaXMgZGlmZmVyZW50IG9uIHRoZSBjbGllbnQgJyArICdvciBzZXJ2ZXI6XFxuJXMnLCBkaWZmZXJlbmNlKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCBidXQgeW91IGRpZG5cXCd0IHVzZSBzZXJ2ZXIgcmVuZGVyaW5nLiBXZSBjYW5cXCd0IGRvIHRoaXMgd2l0aG91dCB1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGR1ZSB0byBjcm9zcy1icm93c2VyIHF1aXJrcy4gU2VlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBfcHJvZEludmFyaWFudCgnNDMnKSA6IHZvaWQgMDtcblxuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBET01MYXp5VHJlZS5pbnNlcnRUcmVlQmVmb3JlKGNvbnRhaW5lciwgbWFya3VwLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SW5uZXJIVE1MKGNvbnRhaW5lciwgbWFya3VwKTtcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUoaW5zdGFuY2UsIGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGhvc3ROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUoY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgaWYgKGhvc3ROb2RlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oaG9zdE5vZGUuX2RlYnVnSUQsICdtb3VudCcsIG1hcmt1cC50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0TW91bnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Db250YWluZXJJbmZvXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcblxudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xuXG5mdW5jdGlvbiBSZWFjdERPTUNvbnRhaW5lckluZm8odG9wTGV2ZWxXcmFwcGVyLCBub2RlKSB7XG4gIHZhciBpbmZvID0ge1xuICAgIF90b3BMZXZlbFdyYXBwZXI6IHRvcExldmVsV3JhcHBlcixcbiAgICBfaWRDb3VudGVyOiAxLFxuICAgIF9vd25lckRvY3VtZW50OiBub2RlID8gbm9kZS5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSA/IG5vZGUgOiBub2RlLm93bmVyRG9jdW1lbnQgOiBudWxsLFxuICAgIF9ub2RlOiBub2RlLFxuICAgIF90YWc6IG5vZGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsLFxuICAgIF9uYW1lc3BhY2VVUkk6IG5vZGUgPyBub2RlLm5hbWVzcGFjZVVSSSA6IG51bGxcbiAgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpbmZvLl9hbmNlc3RvckluZm8gPSBub2RlID8gdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgaW5mby5fdGFnLCBudWxsKSA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db250YWluZXJJbmZvO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NRmVhdHVyZUZsYWdzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSB7XG4gIHVzZUNyZWF0ZUVsZW1lbnQ6IHRydWVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GZWF0dXJlRmxhZ3M7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZlYXR1cmVGbGFncy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE1hcmt1cENoZWNrc3VtXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xuXG52YXIgVEFHX0VORCA9IC9cXC8/Pi87XG52YXIgQ09NTUVOVF9TVEFSVCA9IC9ePFxcIVxcLVxcLS87XG5cbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0ge1xuICBDSEVDS1NVTV9BVFRSX05BTUU6ICdkYXRhLXJlYWN0LWNoZWNrc3VtJyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZyB3aXRoIGNoZWNrc3VtIGF0dHJpYnV0ZSBhdHRhY2hlZFxuICAgKi9cbiAgYWRkQ2hlY2tzdW1Ub01hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBjaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcblxuICAgIC8vIEFkZCBjaGVja3N1bSAoaGFuZGxlIGJvdGggcGFyZW50IHRhZ3MsIGNvbW1lbnRzIGFuZCBzZWxmLWNsb3NpbmcgdGFncylcbiAgICBpZiAoQ09NTUVOVF9TVEFSVC50ZXN0KG1hcmt1cCkpIHtcbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtYXJrdXAucmVwbGFjZShUQUdfRU5ELCAnICcgKyBSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSArICc9XCInICsgY2hlY2tzdW0gKyAnXCIkJicpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCB0byB1c2VcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHJvb3QgUmVhY3QgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIG1hcmt1cCBpcyB0aGUgc2FtZVxuICAgKi9cbiAgY2FuUmV1c2VNYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXAsIGVsZW1lbnQpIHtcbiAgICB2YXIgZXhpc3RpbmdDaGVja3N1bSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICBleGlzdGluZ0NoZWNrc3VtID0gZXhpc3RpbmdDaGVja3N1bSAmJiBwYXJzZUludChleGlzdGluZ0NoZWNrc3VtLCAxMCk7XG4gICAgdmFyIG1hcmt1cENoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuICAgIHJldHVybiBtYXJrdXBDaGVja3N1bSA9PT0gZXhpc3RpbmdDaGVja3N1bTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1hcmt1cENoZWNrc3VtO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhZGxlcjMyXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNT0QgPSA2NTUyMTtcblxuLy8gYWRsZXIzMiBpcyBub3QgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nLCBhbmQgaXMgb25seSB1c2VkIHRvIHNhbml0eSBjaGVjayB0aGF0XG4vLyBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgbWF0Y2hlcyB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LlxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiAoYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBTaGVldEpTIHZlcnNpb24pIGhhcyBiZWVuIG9wdGltaXplZFxuLy8gZm9yIG91ciB1c2UgY2FzZSwgYXQgdGhlIGV4cGVuc2Ugb2YgY29uZm9ybWluZyB0byB0aGUgYWRsZXIzMiBzcGVjaWZpY2F0aW9uXG4vLyBmb3Igbm9uLWFzY2lpIGlucHV0cy5cbmZ1bmN0aW9uIGFkbGVyMzIoZGF0YSkge1xuICB2YXIgYSA9IDE7XG4gIHZhciBiID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGRhdGEubGVuZ3RoO1xuICB2YXIgbSA9IGwgJiB+MHgzO1xuICB3aGlsZSAoaSA8IG0pIHtcbiAgICB2YXIgbiA9IE1hdGgubWluKGkgKyA0MDk2LCBtKTtcbiAgICBmb3IgKDsgaSA8IG47IGkgKz0gNCkge1xuICAgICAgYiArPSAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAxKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDIpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMykpO1xuICAgIH1cbiAgICBhICU9IE1PRDtcbiAgICBiICU9IE1PRDtcbiAgfVxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGIgKz0gYSArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgYSAlPSBNT0Q7XG4gIGIgJT0gTU9EO1xuICByZXR1cm4gYSB8IGIgPDwgMTY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2FkbGVyMzIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmluZERPTU5vZGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcblxudmFyIGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlID0gcmVxdWlyZSgnLi9nZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgRE9NIG5vZGUgcmVuZGVyZWQgYnkgdGhpcyBlbGVtZW50LlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS5maW5kZG9tbm9kZVxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR8RE9NRWxlbWVudH0gY29tcG9uZW50T3JFbGVtZW50XG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gVGhlIHJvb3Qgbm9kZSBvZiB0aGlzIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gY29tcG9uZW50T3JFbGVtZW50O1xuICB9XG5cbiAgdmFyIGluc3QgPSBSZWFjdEluc3RhbmNlTWFwLmdldChjb21wb25lbnRPckVsZW1lbnQpO1xuICBpZiAoaW5zdCkge1xuICAgIGluc3QgPSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KTtcbiAgICByZXR1cm4gaW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpIDogbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50T3JFbGVtZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdmaW5kRE9NTm9kZSB3YXMgY2FsbGVkIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnNDQnKSA6IHZvaWQgMDtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCBhcHBlYXJzIHRvIGJlIG5laXRoZXIgUmVhY3RDb21wb25lbnQgbm9yIERPTU5vZGUgKGtleXM6ICVzKScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogX3Byb2RJbnZhcmlhbnQoJzQ1JywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSkgOiB2b2lkIDA7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kRE9NTm9kZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2ZpbmRET01Ob2RlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3ROb2RlVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0Tm9kZVR5cGVzJyk7XG5cbmZ1bmN0aW9uIGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlKGluc3QpIHtcbiAgdmFyIHR5cGU7XG5cbiAgd2hpbGUgKCh0eXBlID0gaW5zdC5fcmVuZGVyZWROb2RlVHlwZSkgPT09IFJlYWN0Tm9kZVR5cGVzLkNPTVBPU0lURSkge1xuICAgIGluc3QgPSBpbnN0Ll9yZW5kZXJlZENvbXBvbmVudDtcbiAgfVxuXG4gIGlmICh0eXBlID09PSBSZWFjdE5vZGVUeXBlcy5IT1NUKSB7XG4gICAgcmV0dXJuIGluc3QuX3JlbmRlcmVkQ29tcG9uZW50O1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFJlYWN0Tm9kZVR5cGVzLkVNUFRZKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuKiBAcHJvdmlkZXNNb2R1bGUgcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50LnJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvcmVuZGVyU3VidHJlZUludG9Db250YWluZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciByZWFjdFByb3BzID0ge1xuICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB0cnVlLFxuICAgIGtleTogdHJ1ZSxcbiAgICByZWY6IHRydWUsXG5cbiAgICBhdXRvRm9jdXM6IHRydWUsXG4gICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgIHZhbHVlTGluazogdHJ1ZSxcbiAgICBkZWZhdWx0Q2hlY2tlZDogdHJ1ZSxcbiAgICBjaGVja2VkTGluazogdHJ1ZSxcbiAgICBpbm5lckhUTUw6IHRydWUsXG4gICAgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiB0cnVlLFxuICAgIG9uRm9jdXNJbjogdHJ1ZSxcbiAgICBvbkZvY3VzT3V0OiB0cnVlXG4gIH07XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG5cbiAgdmFyIHZhbGlkYXRlUHJvcGVydHkgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgZGVidWdJRCkge1xuICAgIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHJlYWN0UHJvcHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgcmVhY3RQcm9wc1tuYW1lXSB8fCB3YXJuZWRQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIGRhdGEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgaWYgKHN0YW5kYXJkTmFtZSAhPSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gRE9NIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBldmVudCBoYW5kbGVyIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHdlcmUgdW5hYmxlIHRvIGd1ZXNzIHdoaWNoIHByb3AgdGhlIHVzZXIgaW50ZW5kZWQuXG4gICAgICAvLyBJdCBpcyBsaWtlbHkgdGhhdCB0aGUgdXNlciB3YXMganVzdCBibGluZGx5IHNwcmVhZGluZy9mb3J3YXJkaW5nIHByb3BzXG4gICAgICAvLyBDb21wb25lbnRzIHNob3VsZCBiZSBjYXJlZnVsIHRvIG9ubHkgcmVuZGVyIHZhbGlkIHByb3BzL2F0dHJpYnV0ZXMuXG4gICAgICAvLyBXYXJuaW5nIHdpbGwgYmUgaW52b2tlZCBpbiB3YXJuVW5rbm93blByb3BlcnRpZXMgdG8gYWxsb3cgZ3JvdXBpbmcuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gZWxlbWVudC5wcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eShlbGVtZW50LnR5cGUsIGtleSwgZGVidWdJRCk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBwcm9wICVzIG9uIDwlcz4gdGFnLiBSZW1vdmUgdGhpcyBwcm9wIGZyb20gdGhlIGVsZW1lbnQuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXVua25vd24tcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gIH0gZWxzZSBpZiAodW5rbm93blByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gcHJvcHMgJXMgb24gPCVzPiB0YWcuIFJlbW92ZSB0aGVzZSBwcm9wcyBmcm9tIHRoZSBlbGVtZW50LiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC11bmtub3duLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC50eXBlLmluZGV4T2YoJy0nKSA+PSAwIHx8IGVsZW1lbnQucHJvcHMuaXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKGRlYnVnSUQsIGVsZW1lbnQpO1xufVxuXG52YXIgUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rID0ge1xuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9va1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LnR5cGUgIT09ICdpbnB1dCcgJiYgZWxlbWVudC50eXBlICE9PSAndGV4dGFyZWEnICYmIGVsZW1lbnQudHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQucHJvcHMgIT0gbnVsbCAmJiBlbGVtZW50LnByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgdGhlIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcblxuICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuICB9XG59XG5cbnZhciBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2sgPSB7XG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2s7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2suanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbm5lY3QgPSBleHBvcnRzLlByb3ZpZGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX1Byb3ZpZGVyID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL1Byb3ZpZGVyJyk7XG5cbnZhciBfUHJvdmlkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUHJvdmlkZXIpO1xuXG52YXIgX2Nvbm5lY3QgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvY29ubmVjdCcpO1xuXG52YXIgX2Nvbm5lY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29ubmVjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5leHBvcnRzLlByb3ZpZGVyID0gX1Byb3ZpZGVyMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmNvbm5lY3QgPSBfY29ubmVjdDJbXCJkZWZhdWx0XCJdO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yZWR1eC9saWIvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHVuZGVmaW5lZDtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfc3RvcmVTaGFwZSA9IHJlcXVpcmUoJy4uL3V0aWxzL3N0b3JlU2hhcGUnKTtcblxudmFyIF9zdG9yZVNoYXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0b3JlU2hhcGUpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlID0gZmFsc2U7XG5mdW5jdGlvbiB3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSgpIHtcbiAgaWYgKGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlID0gdHJ1ZTtcblxuICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkoJzxQcm92aWRlcj4gZG9lcyBub3Qgc3VwcG9ydCBjaGFuZ2luZyBgc3RvcmVgIG9uIHRoZSBmbHkuICcgKyAnSXQgaXMgbW9zdCBsaWtlbHkgdGhhdCB5b3Ugc2VlIHRoaXMgZXJyb3IgYmVjYXVzZSB5b3UgdXBkYXRlZCB0byAnICsgJ1JlZHV4IDIueCBhbmQgUmVhY3QgUmVkdXggMi54IHdoaWNoIG5vIGxvbmdlciBob3QgcmVsb2FkIHJlZHVjZXJzICcgKyAnYXV0b21hdGljYWxseS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXJlZHV4L3JlbGVhc2VzLycgKyAndGFnL3YyLjAuMCBmb3IgdGhlIG1pZ3JhdGlvbiBpbnN0cnVjdGlvbnMuJyk7XG59XG5cbnZhciBQcm92aWRlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhQcm92aWRlciwgX0NvbXBvbmVudCk7XG5cbiAgUHJvdmlkZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4geyBzdG9yZTogdGhpcy5zdG9yZSB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIFByb3ZpZGVyKHByb3BzLCBjb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb3ZpZGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xuXG4gICAgX3RoaXMuc3RvcmUgPSBwcm9wcy5zdG9yZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBQcm92aWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG5cbiAgICByZXR1cm4gX3JlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICB9O1xuXG4gIHJldHVybiBQcm92aWRlcjtcbn0oX3JlYWN0LkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUHJvdmlkZXI7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFByb3ZpZGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xuICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgdmFyIG5leHRTdG9yZSA9IG5leHRQcm9wcy5zdG9yZTtcblxuICAgIGlmIChzdG9yZSAhPT0gbmV4dFN0b3JlKSB7XG4gICAgICB3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSgpO1xuICAgIH1cbiAgfTtcbn1cblxuUHJvdmlkZXIucHJvcFR5cGVzID0ge1xuICBzdG9yZTogX3N0b3JlU2hhcGUyW1wiZGVmYXVsdFwiXS5pc1JlcXVpcmVkLFxuICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5lbGVtZW50LmlzUmVxdWlyZWRcbn07XG5Qcm92aWRlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgc3RvcmU6IF9zdG9yZVNoYXBlMltcImRlZmF1bHRcIl0uaXNSZXF1aXJlZFxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QtcmVkdXgvbGliL2NvbXBvbmVudHMvUHJvdmlkZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9yZWFjdC5Qcm9wVHlwZXMuc2hhcGUoe1xuICBzdWJzY3JpYmU6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBkaXNwYXRjaDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGdldFN0YXRlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy9zdG9yZVNoYXBlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB3YXJuaW5nO1xuLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjb25uZWN0O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9zdG9yZVNoYXBlID0gcmVxdWlyZSgnLi4vdXRpbHMvc3RvcmVTaGFwZScpO1xuXG52YXIgX3N0b3JlU2hhcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RvcmVTaGFwZSk7XG5cbnZhciBfc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnLi4vdXRpbHMvc2hhbGxvd0VxdWFsJyk7XG5cbnZhciBfc2hhbGxvd0VxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYWxsb3dFcXVhbCk7XG5cbnZhciBfd3JhcEFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi4vdXRpbHMvd3JhcEFjdGlvbkNyZWF0b3JzJyk7XG5cbnZhciBfd3JhcEFjdGlvbkNyZWF0b3JzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dyYXBBY3Rpb25DcmVhdG9ycyk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4uL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MgPSByZXF1aXJlKCdob2lzdC1ub24tcmVhY3Qtc3RhdGljcycpO1xuXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hvaXN0Tm9uUmVhY3RTdGF0aWNzKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzKHN0YXRlKSB7XG4gIHJldHVybiB7fTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzID0gZnVuY3Rpb24gZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCkge1xuICByZXR1cm4geyBkaXNwYXRjaDogZGlzcGF0Y2ggfTtcbn07XG52YXIgZGVmYXVsdE1lcmdlUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0TWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBwYXJlbnRQcm9wcykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIHBhcmVudFByb3BzLCBzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzKTtcbn07XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpIHtcbiAgcmV0dXJuIFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xufVxuXG52YXIgZXJyb3JPYmplY3QgPSB7IHZhbHVlOiBudWxsIH07XG5mdW5jdGlvbiB0cnlDYXRjaChmbiwgY3R4KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGN0eCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvck9iamVjdC52YWx1ZSA9IGU7XG4gICAgcmV0dXJuIGVycm9yT2JqZWN0O1xuICB9XG59XG5cbi8vIEhlbHBzIHRyYWNrIGhvdCByZWxvYWRpbmcuXG52YXIgbmV4dFZlcnNpb24gPSAwO1xuXG5mdW5jdGlvbiBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbM107XG5cbiAgdmFyIHNob3VsZFN1YnNjcmliZSA9IEJvb2xlYW4obWFwU3RhdGVUb1Byb3BzKTtcbiAgdmFyIG1hcFN0YXRlID0gbWFwU3RhdGVUb1Byb3BzIHx8IGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHM7XG5cbiAgdmFyIG1hcERpc3BhdGNoID0gdW5kZWZpbmVkO1xuICBpZiAodHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1hcERpc3BhdGNoID0gbWFwRGlzcGF0Y2hUb1Byb3BzO1xuICB9IGVsc2UgaWYgKCFtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgICBtYXBEaXNwYXRjaCA9IGRlZmF1bHRNYXBEaXNwYXRjaFRvUHJvcHM7XG4gIH0gZWxzZSB7XG4gICAgbWFwRGlzcGF0Y2ggPSAoMCwgX3dyYXBBY3Rpb25DcmVhdG9yczJbXCJkZWZhdWx0XCJdKShtYXBEaXNwYXRjaFRvUHJvcHMpO1xuICB9XG5cbiAgdmFyIGZpbmFsTWVyZ2VQcm9wcyA9IG1lcmdlUHJvcHMgfHwgZGVmYXVsdE1lcmdlUHJvcHM7XG4gIHZhciBfb3B0aW9ucyRwdXJlID0gb3B0aW9ucy5wdXJlO1xuICB2YXIgcHVyZSA9IF9vcHRpb25zJHB1cmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfb3B0aW9ucyRwdXJlO1xuICB2YXIgX29wdGlvbnMkd2l0aFJlZiA9IG9wdGlvbnMud2l0aFJlZjtcbiAgdmFyIHdpdGhSZWYgPSBfb3B0aW9ucyR3aXRoUmVmID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJHdpdGhSZWY7XG5cbiAgdmFyIGNoZWNrTWVyZ2VkRXF1YWxzID0gcHVyZSAmJiBmaW5hbE1lcmdlUHJvcHMgIT09IGRlZmF1bHRNZXJnZVByb3BzO1xuXG4gIC8vIEhlbHBzIHRyYWNrIGhvdCByZWxvYWRpbmcuXG4gIHZhciB2ZXJzaW9uID0gbmV4dFZlcnNpb24rKztcblxuICByZXR1cm4gZnVuY3Rpb24gd3JhcFdpdGhDb25uZWN0KFdyYXBwZWRDb21wb25lbnQpIHtcbiAgICB2YXIgY29ubmVjdERpc3BsYXlOYW1lID0gJ0Nvbm5lY3QoJyArIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpICsgJyknO1xuXG4gICAgZnVuY3Rpb24gY2hlY2tTdGF0ZVNoYXBlKHByb3BzLCBtZXRob2ROYW1lKSB7XG4gICAgICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbXCJkZWZhdWx0XCJdKShwcm9wcykpIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMltcImRlZmF1bHRcIl0pKG1ldGhvZE5hbWUgKyAnKCkgaW4gJyArIGNvbm5lY3REaXNwbGF5TmFtZSArICcgbXVzdCByZXR1cm4gYSBwbGFpbiBvYmplY3QuICcgKyAoJ0luc3RlYWQgcmVjZWl2ZWQgJyArIHByb3BzICsgJy4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZU1lcmdlZFByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIHBhcmVudFByb3BzKSB7XG4gICAgICB2YXIgbWVyZ2VkUHJvcHMgPSBmaW5hbE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgcGFyZW50UHJvcHMpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKG1lcmdlZFByb3BzLCAnbWVyZ2VQcm9wcycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICAgIH1cblxuICAgIHZhciBDb25uZWN0ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICAgIF9pbmhlcml0cyhDb25uZWN0LCBfQ29tcG9uZW50KTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gIXB1cmUgfHwgdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkIHx8IHRoaXMuaGFzU3RvcmVTdGF0ZUNoYW5nZWQ7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBDb25uZWN0KHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25uZWN0KTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpKTtcblxuICAgICAgICBfdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgX3RoaXMuc3RvcmUgPSBwcm9wcy5zdG9yZSB8fCBjb250ZXh0LnN0b3JlO1xuXG4gICAgICAgICgwLCBfaW52YXJpYW50MltcImRlZmF1bHRcIl0pKF90aGlzLnN0b3JlLCAnQ291bGQgbm90IGZpbmQgXCJzdG9yZVwiIGluIGVpdGhlciB0aGUgY29udGV4dCBvciAnICsgKCdwcm9wcyBvZiBcIicgKyBjb25uZWN0RGlzcGxheU5hbWUgKyAnXCIuICcpICsgJ0VpdGhlciB3cmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhIDxQcm92aWRlcj4sICcgKyAoJ29yIGV4cGxpY2l0bHkgcGFzcyBcInN0b3JlXCIgYXMgYSBwcm9wIHRvIFwiJyArIGNvbm5lY3REaXNwbGF5TmFtZSArICdcIi4nKSk7XG5cbiAgICAgICAgdmFyIHN0b3JlU3RhdGUgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHsgc3RvcmVTdGF0ZTogc3RvcmVTdGF0ZSB9O1xuICAgICAgICBfdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcHV0ZVN0YXRlUHJvcHMgPSBmdW5jdGlvbiBjb21wdXRlU3RhdGVQcm9wcyhzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJlRmluYWxNYXBTdGF0ZShzdG9yZSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgdmFyIHN0YXRlUHJvcHMgPSB0aGlzLmRvU3RhdGVQcm9wc0RlcGVuZE9uT3duUHJvcHMgPyB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBwcm9wcykgOiB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzKHN0YXRlKTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrU3RhdGVTaGFwZShzdGF0ZVByb3BzLCAnbWFwU3RhdGVUb1Byb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlUHJvcHM7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb25maWd1cmVGaW5hbE1hcFN0YXRlID0gZnVuY3Rpb24gY29uZmlndXJlRmluYWxNYXBTdGF0ZShzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgdmFyIG1hcHBlZFN0YXRlID0gbWFwU3RhdGUoc3RvcmUuZ2V0U3RhdGUoKSwgcHJvcHMpO1xuICAgICAgICB2YXIgaXNGYWN0b3J5ID0gdHlwZW9mIG1hcHBlZFN0YXRlID09PSAnZnVuY3Rpb24nO1xuXG4gICAgICAgIHRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMgPSBpc0ZhY3RvcnkgPyBtYXBwZWRTdGF0ZSA6IG1hcFN0YXRlO1xuICAgICAgICB0aGlzLmRvU3RhdGVQcm9wc0RlcGVuZE9uT3duUHJvcHMgPSB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzLmxlbmd0aCAhPT0gMTtcblxuICAgICAgICBpZiAoaXNGYWN0b3J5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZVN0YXRlUHJvcHMoc3RvcmUsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKG1hcHBlZFN0YXRlLCAnbWFwU3RhdGVUb1Byb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcHBlZFN0YXRlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcHV0ZURpc3BhdGNoUHJvcHMgPSBmdW5jdGlvbiBjb21wdXRlRGlzcGF0Y2hQcm9wcyhzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJlRmluYWxNYXBEaXNwYXRjaChzdG9yZSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpc3BhdGNoID0gc3RvcmUuZGlzcGF0Y2g7XG5cbiAgICAgICAgdmFyIGRpc3BhdGNoUHJvcHMgPSB0aGlzLmRvRGlzcGF0Y2hQcm9wc0RlcGVuZE9uT3duUHJvcHMgPyB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBwcm9wcykgOiB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoKTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrU3RhdGVTaGFwZShkaXNwYXRjaFByb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoUHJvcHM7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb25maWd1cmVGaW5hbE1hcERpc3BhdGNoID0gZnVuY3Rpb24gY29uZmlndXJlRmluYWxNYXBEaXNwYXRjaChzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgdmFyIG1hcHBlZERpc3BhdGNoID0gbWFwRGlzcGF0Y2goc3RvcmUuZGlzcGF0Y2gsIHByb3BzKTtcbiAgICAgICAgdmFyIGlzRmFjdG9yeSA9IHR5cGVvZiBtYXBwZWREaXNwYXRjaCA9PT0gJ2Z1bmN0aW9uJztcblxuICAgICAgICB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzID0gaXNGYWN0b3J5ID8gbWFwcGVkRGlzcGF0Y2ggOiBtYXBEaXNwYXRjaDtcbiAgICAgICAgdGhpcy5kb0Rpc3BhdGNoUHJvcHNEZXBlbmRPbk93blByb3BzID0gdGhpcy5maW5hbE1hcERpc3BhdGNoVG9Qcm9wcy5sZW5ndGggIT09IDE7XG5cbiAgICAgICAgaWYgKGlzRmFjdG9yeSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVEaXNwYXRjaFByb3BzKHN0b3JlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrU3RhdGVTaGFwZShtYXBwZWREaXNwYXRjaCwgJ21hcERpc3BhdGNoVG9Qcm9wcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWREaXNwYXRjaDtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnVwZGF0ZVN0YXRlUHJvcHNJZk5lZWRlZCA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlUHJvcHNJZk5lZWRlZCgpIHtcbiAgICAgICAgdmFyIG5leHRTdGF0ZVByb3BzID0gdGhpcy5jb21wdXRlU3RhdGVQcm9wcyh0aGlzLnN0b3JlLCB0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVQcm9wcyAmJiAoMCwgX3NoYWxsb3dFcXVhbDJbXCJkZWZhdWx0XCJdKShuZXh0U3RhdGVQcm9wcywgdGhpcy5zdGF0ZVByb3BzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGVQcm9wcyA9IG5leHRTdGF0ZVByb3BzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnVwZGF0ZURpc3BhdGNoUHJvcHNJZk5lZWRlZCA9IGZ1bmN0aW9uIHVwZGF0ZURpc3BhdGNoUHJvcHNJZk5lZWRlZCgpIHtcbiAgICAgICAgdmFyIG5leHREaXNwYXRjaFByb3BzID0gdGhpcy5jb21wdXRlRGlzcGF0Y2hQcm9wcyh0aGlzLnN0b3JlLCB0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMuZGlzcGF0Y2hQcm9wcyAmJiAoMCwgX3NoYWxsb3dFcXVhbDJbXCJkZWZhdWx0XCJdKShuZXh0RGlzcGF0Y2hQcm9wcywgdGhpcy5kaXNwYXRjaFByb3BzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hQcm9wcyA9IG5leHREaXNwYXRjaFByb3BzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnVwZGF0ZU1lcmdlZFByb3BzSWZOZWVkZWQgPSBmdW5jdGlvbiB1cGRhdGVNZXJnZWRQcm9wc0lmTmVlZGVkKCkge1xuICAgICAgICB2YXIgbmV4dE1lcmdlZFByb3BzID0gY29tcHV0ZU1lcmdlZFByb3BzKHRoaXMuc3RhdGVQcm9wcywgdGhpcy5kaXNwYXRjaFByb3BzLCB0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMubWVyZ2VkUHJvcHMgJiYgY2hlY2tNZXJnZWRFcXVhbHMgJiYgKDAsIF9zaGFsbG93RXF1YWwyW1wiZGVmYXVsdFwiXSkobmV4dE1lcmdlZFByb3BzLCB0aGlzLm1lcmdlZFByb3BzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuaXNTdWJzY3JpYmVkID0gZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMudW5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbic7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS50cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlTdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmIChzaG91bGRTdWJzY3JpYmUgJiYgIXRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlID0gdGhpcy5zdG9yZS5zdWJzY3JpYmUodGhpcy5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUudHJ5VW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgdGhpcy51bnN1YnNjcmliZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudHJ5U3Vic2NyaWJlKCk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKCFwdXJlIHx8ICEoMCwgX3NoYWxsb3dFcXVhbDJbXCJkZWZhdWx0XCJdKShuZXh0UHJvcHMsIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLm1lcmdlZFByb3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5maW5hbE1hcFN0YXRlVG9Qcm9wcyA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoKSB7XG4gICAgICAgIGlmICghdGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdG9yZVN0YXRlID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICB2YXIgcHJldlN0b3JlU3RhdGUgPSB0aGlzLnN0YXRlLnN0b3JlU3RhdGU7XG4gICAgICAgIGlmIChwdXJlICYmIHByZXZTdG9yZVN0YXRlID09PSBzdG9yZVN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHB1cmUgJiYgIXRoaXMuZG9TdGF0ZVByb3BzRGVwZW5kT25Pd25Qcm9wcykge1xuICAgICAgICAgIHZhciBoYXZlU3RhdGVQcm9wc0NoYW5nZWQgPSB0cnlDYXRjaCh0aGlzLnVwZGF0ZVN0YXRlUHJvcHNJZk5lZWRlZCwgdGhpcyk7XG4gICAgICAgICAgaWYgKCFoYXZlU3RhdGVQcm9wc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9PT0gZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3IgPSBlcnJvck9iamVjdC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYXZlU3RhdGVQcm9wc0JlZW5QcmVjYWxjdWxhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFzU3RvcmVTdGF0ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgc3RvcmVTdGF0ZTogc3RvcmVTdGF0ZSB9KTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmdldFdyYXBwZWRJbnN0YW5jZSA9IGZ1bmN0aW9uIGdldFdyYXBwZWRJbnN0YW5jZSgpIHtcbiAgICAgICAgKDAsIF9pbnZhcmlhbnQyW1wiZGVmYXVsdFwiXSkod2l0aFJlZiwgJ1RvIGFjY2VzcyB0aGUgd3JhcHBlZCBpbnN0YW5jZSwgeW91IG5lZWQgdG8gc3BlY2lmeSAnICsgJ3sgd2l0aFJlZjogdHJ1ZSB9IGFzIHRoZSBmb3VydGggYXJndW1lbnQgb2YgdGhlIGNvbm5lY3QoKSBjYWxsLicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlZnMud3JhcHBlZEluc3RhbmNlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgaGF2ZU93blByb3BzQ2hhbmdlZCA9IHRoaXMuaGF2ZU93blByb3BzQ2hhbmdlZDtcbiAgICAgICAgdmFyIGhhc1N0b3JlU3RhdGVDaGFuZ2VkID0gdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZDtcbiAgICAgICAgdmFyIGhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQgPSB0aGlzLmhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQ7XG4gICAgICAgIHZhciBzdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvciA9IHRoaXMuc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3I7XG4gICAgICAgIHZhciByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLnJlbmRlcmVkRWxlbWVudDtcblxuICAgICAgICB0aGlzLmhhdmVPd25Qcm9wc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvciA9IG51bGw7XG5cbiAgICAgICAgaWYgKHN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvdWxkVXBkYXRlU3RhdGVQcm9wcyA9IHRydWU7XG4gICAgICAgIHZhciBzaG91bGRVcGRhdGVEaXNwYXRjaFByb3BzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHB1cmUgJiYgcmVuZGVyZWRFbGVtZW50KSB7XG4gICAgICAgICAgc2hvdWxkVXBkYXRlU3RhdGVQcm9wcyA9IGhhc1N0b3JlU3RhdGVDaGFuZ2VkIHx8IGhhdmVPd25Qcm9wc0NoYW5nZWQgJiYgdGhpcy5kb1N0YXRlUHJvcHNEZXBlbmRPbk93blByb3BzO1xuICAgICAgICAgIHNob3VsZFVwZGF0ZURpc3BhdGNoUHJvcHMgPSBoYXZlT3duUHJvcHNDaGFuZ2VkICYmIHRoaXMuZG9EaXNwYXRjaFByb3BzRGVwZW5kT25Pd25Qcm9wcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXZlU3RhdGVQcm9wc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhdmVEaXNwYXRjaFByb3BzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZCkge1xuICAgICAgICAgIGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkVXBkYXRlU3RhdGVQcm9wcykge1xuICAgICAgICAgIGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9IHRoaXMudXBkYXRlU3RhdGVQcm9wc0lmTmVlZGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZURpc3BhdGNoUHJvcHMpIHtcbiAgICAgICAgICBoYXZlRGlzcGF0Y2hQcm9wc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZURpc3BhdGNoUHJvcHNJZk5lZWRlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhdmVNZXJnZWRQcm9wc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICBpZiAoaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkIHx8IGhhdmVEaXNwYXRjaFByb3BzQ2hhbmdlZCB8fCBoYXZlT3duUHJvcHNDaGFuZ2VkKSB7XG4gICAgICAgICAgaGF2ZU1lcmdlZFByb3BzQ2hhbmdlZCA9IHRoaXMudXBkYXRlTWVyZ2VkUHJvcHNJZk5lZWRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhdmVNZXJnZWRQcm9wc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGF2ZU1lcmdlZFByb3BzQ2hhbmdlZCAmJiByZW5kZXJlZEVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyZWRFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdpdGhSZWYpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudCA9ICgwLCBfcmVhY3QuY3JlYXRlRWxlbWVudCkoV3JhcHBlZENvbXBvbmVudCwgX2V4dGVuZHMoe30sIHRoaXMubWVyZ2VkUHJvcHMsIHtcbiAgICAgICAgICAgIHJlZjogJ3dyYXBwZWRJbnN0YW5jZSdcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQgPSAoMCwgX3JlYWN0LmNyZWF0ZUVsZW1lbnQpKFdyYXBwZWRDb21wb25lbnQsIHRoaXMubWVyZ2VkUHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWRFbGVtZW50O1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbm5lY3Q7XG4gICAgfShfcmVhY3QuQ29tcG9uZW50KTtcblxuICAgIENvbm5lY3QuZGlzcGxheU5hbWUgPSBjb25uZWN0RGlzcGxheU5hbWU7XG4gICAgQ29ubmVjdC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICBDb25uZWN0LmNvbnRleHRUeXBlcyA9IHtcbiAgICAgIHN0b3JlOiBfc3RvcmVTaGFwZTJbXCJkZWZhdWx0XCJdXG4gICAgfTtcbiAgICBDb25uZWN0LnByb3BUeXBlcyA9IHtcbiAgICAgIHN0b3JlOiBfc3RvcmVTaGFwZTJbXCJkZWZhdWx0XCJdXG4gICAgfTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gdmVyc2lvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGFyZSBob3QgcmVsb2FkaW5nIVxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLnRyeVN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfaG9pc3ROb25SZWFjdFN0YXRpY3MyW1wiZGVmYXVsdFwiXSkoQ29ubmVjdCwgV3JhcHBlZENvbXBvbmVudCk7XG4gIH07XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi9jb21wb25lbnRzL2Nvbm5lY3QuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gc2hhbGxvd0VxdWFsO1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duLmNhbGwob2JqQiwga2V5c0FbaV0pIHx8IG9iakFba2V5c0FbaV1dICE9PSBvYmpCW2tleXNBW2ldXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvc2hhbGxvd0VxdWFsLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB3cmFwQWN0aW9uQ3JlYXRvcnM7XG5cbnZhciBfcmVkdXggPSByZXF1aXJlKCdyZWR1eCcpO1xuXG5mdW5jdGlvbiB3cmFwQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkge1xuICAgIHJldHVybiAoMCwgX3JlZHV4LmJpbmRBY3Rpb25DcmVhdG9ycykoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QtcmVkdXgvbGliL3V0aWxzL3dyYXBBY3Rpb25DcmVhdG9ycy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY29tcG9zZSA9IGV4cG9ydHMuYXBwbHlNaWRkbGV3YXJlID0gZXhwb3J0cy5iaW5kQWN0aW9uQ3JlYXRvcnMgPSBleHBvcnRzLmNvbWJpbmVSZWR1Y2VycyA9IGV4cG9ydHMuY3JlYXRlU3RvcmUgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlU3RvcmUgPSByZXF1aXJlKCcuL2NyZWF0ZVN0b3JlJyk7XG5cbnZhciBfY3JlYXRlU3RvcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlU3RvcmUpO1xuXG52YXIgX2NvbWJpbmVSZWR1Y2VycyA9IHJlcXVpcmUoJy4vY29tYmluZVJlZHVjZXJzJyk7XG5cbnZhciBfY29tYmluZVJlZHVjZXJzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbWJpbmVSZWR1Y2Vycyk7XG5cbnZhciBfYmluZEFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi9iaW5kQWN0aW9uQ3JlYXRvcnMnKTtcblxudmFyIF9iaW5kQWN0aW9uQ3JlYXRvcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmluZEFjdGlvbkNyZWF0b3JzKTtcblxudmFyIF9hcHBseU1pZGRsZXdhcmUgPSByZXF1aXJlKCcuL2FwcGx5TWlkZGxld2FyZScpO1xuXG52YXIgX2FwcGx5TWlkZGxld2FyZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcHBseU1pZGRsZXdhcmUpO1xuXG52YXIgX2NvbXBvc2UgPSByZXF1aXJlKCcuL2NvbXBvc2UnKTtcblxudmFyIF9jb21wb3NlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvc2UpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qXG4qIFRoaXMgaXMgYSBkdW1teSBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgZnVuY3Rpb24gbmFtZSBoYXMgYmVlbiBhbHRlcmVkIGJ5IG1pbmlmaWNhdGlvbi5cbiogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuKi9cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gICgwLCBfd2FybmluZzJbJ2RlZmF1bHQnXSkoJ1lvdSBhcmUgY3VycmVudGx5IHVzaW5nIG1pbmlmaWVkIGNvZGUgb3V0c2lkZSBvZiBOT0RFX0VOViA9PT0gXFwncHJvZHVjdGlvblxcJy4gJyArICdUaGlzIG1lYW5zIHRoYXQgeW91IGFyZSBydW5uaW5nIGEgc2xvd2VyIGRldmVsb3BtZW50IGJ1aWxkIG9mIFJlZHV4LiAnICsgJ1lvdSBjYW4gdXNlIGxvb3NlLWVudmlmeSAoaHR0cHM6Ly9naXRodWIuY29tL3plcnRvc2gvbG9vc2UtZW52aWZ5KSBmb3IgYnJvd3NlcmlmeSAnICsgJ29yIERlZmluZVBsdWdpbiBmb3Igd2VicGFjayAoaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMDAzMDAzMSkgJyArICd0byBlbnN1cmUgeW91IGhhdmUgdGhlIGNvcnJlY3QgY29kZSBmb3IgeW91ciBwcm9kdWN0aW9uIGJ1aWxkLicpO1xufVxuXG5leHBvcnRzLmNyZWF0ZVN0b3JlID0gX2NyZWF0ZVN0b3JlMlsnZGVmYXVsdCddO1xuZXhwb3J0cy5jb21iaW5lUmVkdWNlcnMgPSBfY29tYmluZVJlZHVjZXJzMlsnZGVmYXVsdCddO1xuZXhwb3J0cy5iaW5kQWN0aW9uQ3JlYXRvcnMgPSBfYmluZEFjdGlvbkNyZWF0b3JzMlsnZGVmYXVsdCddO1xuZXhwb3J0cy5hcHBseU1pZGRsZXdhcmUgPSBfYXBwbHlNaWRkbGV3YXJlMlsnZGVmYXVsdCddO1xuZXhwb3J0cy5jb21wb3NlID0gX2NvbXBvc2UyWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlZHV4L2xpYi9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQWN0aW9uVHlwZXMgPSB1bmRlZmluZWQ7XG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVTdG9yZTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX3N5bWJvbE9ic2VydmFibGUgPSByZXF1aXJlKCdzeW1ib2wtb2JzZXJ2YWJsZScpO1xuXG52YXIgX3N5bWJvbE9ic2VydmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sT2JzZXJ2YWJsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cbnZhciBBY3Rpb25UeXBlcyA9IGV4cG9ydHMuQWN0aW9uVHlwZXMgPSB7XG4gIElOSVQ6ICdAQHJlZHV4L0lOSVQnXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBSZWR1eCBzdG9yZSB0aGF0IGhvbGRzIHRoZSBzdGF0ZSB0cmVlLlxuICogVGhlIG9ubHkgd2F5IHRvIGNoYW5nZSB0aGUgZGF0YSBpbiB0aGUgc3RvcmUgaXMgdG8gY2FsbCBgZGlzcGF0Y2goKWAgb24gaXQuXG4gKlxuICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgYSBzaW5nbGUgc3RvcmUgaW4geW91ciBhcHAuIFRvIHNwZWNpZnkgaG93IGRpZmZlcmVudFxuICogcGFydHMgb2YgdGhlIHN0YXRlIHRyZWUgcmVzcG9uZCB0byBhY3Rpb25zLCB5b3UgbWF5IGNvbWJpbmUgc2V2ZXJhbCByZWR1Y2Vyc1xuICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZHVjZXIgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5leHQgc3RhdGUgdHJlZSwgZ2l2ZW5cbiAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxuICpcbiAqIEBwYXJhbSB7YW55fSBbcHJlbG9hZGVkU3RhdGVdIFRoZSBpbml0aWFsIHN0YXRlLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gaHlkcmF0ZSB0aGUgc3RhdGUgZnJvbSB0aGUgc2VydmVyIGluIHVuaXZlcnNhbCBhcHBzLCBvciB0byByZXN0b3JlIGFcbiAqIHByZXZpb3VzbHkgc2VyaWFsaXplZCB1c2VyIHNlc3Npb24uXG4gKiBJZiB5b3UgdXNlIGBjb21iaW5lUmVkdWNlcnNgIHRvIHByb2R1Y2UgdGhlIHJvb3QgcmVkdWNlciBmdW5jdGlvbiwgdGhpcyBtdXN0IGJlXG4gKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBgY29tYmluZVJlZHVjZXJzYCBrZXlzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuaGFuY2VyIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGVuaGFuY2UgdGhlIHN0b3JlIHdpdGggdGhpcmQtcGFydHkgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgbWlkZGxld2FyZSxcbiAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcbiAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gKlxuICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcbiAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKSB7XG4gIHZhciBfcmVmMjtcblxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmhhbmNlciA9IHByZWxvYWRlZFN0YXRlO1xuICAgIHByZWxvYWRlZFN0YXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmhhbmNlcihjcmVhdGVTdG9yZSkocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IHByZWxvYWRlZFN0YXRlO1xuICB2YXIgY3VycmVudExpc3RlbmVycyA9IFtdO1xuICB2YXIgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIHZhciBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpIHtcbiAgICBpZiAobmV4dExpc3RlbmVycyA9PT0gY3VycmVudExpc3RlbmVycykge1xuICAgICAgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIHN0YXRlIHRyZWUgbWFuYWdlZCBieSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSBjdXJyZW50IHN0YXRlIHRyZWUgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNoYW5nZSBsaXN0ZW5lci4gSXQgd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQsXG4gICAqIGFuZCBzb21lIHBhcnQgb2YgdGhlIHN0YXRlIHRyZWUgbWF5IHBvdGVudGlhbGx5IGhhdmUgY2hhbmdlZC4gWW91IG1heSB0aGVuXG4gICAqIGNhbGwgYGdldFN0YXRlKClgIHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBpbnNpZGUgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBZb3UgbWF5IGNhbGwgYGRpc3BhdGNoKClgIGZyb20gYSBjaGFuZ2UgbGlzdGVuZXIsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBjYXZlYXRzOlxuICAgKlxuICAgKiAxLiBUaGUgc3Vic2NyaXB0aW9ucyBhcmUgc25hcHNob3R0ZWQganVzdCBiZWZvcmUgZXZlcnkgYGRpc3BhdGNoKClgIGNhbGwuXG4gICAqIElmIHlvdSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgd2hpbGUgdGhlIGxpc3RlbmVycyBhcmUgYmVpbmcgaW52b2tlZCwgdGhpc1xuICAgKiB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGBkaXNwYXRjaCgpYCB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cbiAgICogSG93ZXZlciwgdGhlIG5leHQgYGRpc3BhdGNoKClgIGNhbGwsIHdoZXRoZXIgbmVzdGVkIG9yIG5vdCwgd2lsbCB1c2UgYSBtb3JlXG4gICAqIHJlY2VudCBzbmFwc2hvdCBvZiB0aGUgc3Vic2NyaXB0aW9uIGxpc3QuXG4gICAqXG4gICAqIDIuIFRoZSBsaXN0ZW5lciBzaG91bGQgbm90IGV4cGVjdCB0byBzZWUgYWxsIHN0YXRlIGNoYW5nZXMsIGFzIHRoZSBzdGF0ZVxuICAgKiBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBuZXN0ZWQgYGRpc3BhdGNoKClgIGJlZm9yZVxuICAgKiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLiBJdCBpcywgaG93ZXZlciwgZ3VhcmFudGVlZCB0aGF0IGFsbCBzdWJzY3JpYmVyc1xuICAgKiByZWdpc3RlcmVkIGJlZm9yZSB0aGUgYGRpc3BhdGNoKClgIHN0YXJ0ZWQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbGF0ZXN0XG4gICAqIHN0YXRlIGJ5IHRoZSB0aW1lIGl0IGV4aXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG5cbiAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgbmV4dExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICAgIHZhciBpbmRleCA9IG5leHRMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBuZXh0TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFuIGFjdGlvbi4gSXQgaXMgdGhlIG9ubHkgd2F5IHRvIHRyaWdnZXIgYSBzdGF0ZSBjaGFuZ2UuXG4gICAqXG4gICAqIFRoZSBgcmVkdWNlcmAgZnVuY3Rpb24sIHVzZWQgdG8gY3JlYXRlIHRoZSBzdG9yZSwgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGVcbiAgICogY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgZ2l2ZW4gYGFjdGlvbmAuIEl0cyByZXR1cm4gdmFsdWUgd2lsbFxuICAgKiBiZSBjb25zaWRlcmVkIHRoZSAqKm5leHQqKiBzdGF0ZSBvZiB0aGUgdHJlZSwgYW5kIHRoZSBjaGFuZ2UgbGlzdGVuZXJzXG4gICAqIHdpbGwgYmUgbm90aWZpZWQuXG4gICAqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgcGxhaW4gb2JqZWN0IGFjdGlvbnMuIElmIHlvdSB3YW50IHRvXG4gICAqIGRpc3BhdGNoIGEgUHJvbWlzZSwgYW4gT2JzZXJ2YWJsZSwgYSB0aHVuaywgb3Igc29tZXRoaW5nIGVsc2UsIHlvdSBuZWVkIHRvXG4gICAqIHdyYXAgeW91ciBzdG9yZSBjcmVhdGluZyBmdW5jdGlvbiBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIG1pZGRsZXdhcmUuIEZvclxuICAgKiBleGFtcGxlLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UuIEV2ZW4gdGhlXG4gICAqIG1pZGRsZXdhcmUgd2lsbCBldmVudHVhbGx5IGRpc3BhdGNoIHBsYWluIG9iamVjdCBhY3Rpb25zIHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIEEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGluZyDigJx3aGF0IGNoYW5nZWTigJ0uIEl0IGlzXG4gICAqIGEgZ29vZCBpZGVhIHRvIGtlZXAgYWN0aW9ucyBzZXJpYWxpemFibGUgc28geW91IGNhbiByZWNvcmQgYW5kIHJlcGxheSB1c2VyXG4gICAqIHNlc3Npb25zLCBvciB1c2UgdGhlIHRpbWUgdHJhdmVsbGluZyBgcmVkdXgtZGV2dG9vbHNgLiBBbiBhY3Rpb24gbXVzdCBoYXZlXG4gICAqIGEgYHR5cGVgIHByb3BlcnR5IHdoaWNoIG1heSBub3QgYmUgYHVuZGVmaW5lZGAuIEl0IGlzIGEgZ29vZCBpZGVhIHRvIHVzZVxuICAgKiBzdHJpbmcgY29uc3RhbnRzIGZvciBhY3Rpb24gdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEZvciBjb252ZW5pZW5jZSwgdGhlIHNhbWUgYWN0aW9uIG9iamVjdCB5b3UgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0LCBpZiB5b3UgdXNlIGEgY3VzdG9tIG1pZGRsZXdhcmUsIGl0IG1heSB3cmFwIGBkaXNwYXRjaCgpYCB0b1xuICAgKiByZXR1cm4gc29tZXRoaW5nIGVsc2UgKGZvciBleGFtcGxlLCBhIFByb21pc2UgeW91IGNhbiBhd2FpdCkuXG4gICAqL1xuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbJ2RlZmF1bHQnXSkoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gJyArICdVc2UgY3VzdG9tIG1pZGRsZXdhcmUgZm9yIGFzeW5jIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtYXkgbm90IGhhdmUgYW4gdW5kZWZpbmVkIFwidHlwZVwiIHByb3BlcnR5LiAnICsgJ0hhdmUgeW91IG1pc3NwZWxsZWQgYSBjb25zdGFudD8nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyO1xuICAgIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4geyB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmW19zeW1ib2xPYnNlcnZhYmxlMlsnZGVmYXVsdCddXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH1cblxuICAvLyBXaGVuIGEgc3RvcmUgaXMgY3JlYXRlZCwgYW4gXCJJTklUXCIgYWN0aW9uIGlzIGRpc3BhdGNoZWQgc28gdGhhdCBldmVyeVxuICAvLyByZWR1Y2VyIHJldHVybnMgdGhlaXIgaW5pdGlhbCBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgLy8gdGhlIGluaXRpYWwgc3RhdGUgdHJlZS5cbiAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMltfc3ltYm9sT2JzZXJ2YWJsZTJbJ2RlZmF1bHQnXV0gPSBvYnNlcnZhYmxlLCBfcmVmMjtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVkdXgvbGliL2NyZWF0ZVN0b3JlLmpzXG4gKiovIiwidmFyIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzSG9zdE9iamVjdCA9IHJlcXVpcmUoJy4vX2lzSG9zdE9iamVjdCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8XG4gICAgICBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSAhPSBvYmplY3RUYWcgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiZcbiAgICBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJiBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzXG4gKiovIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9sb2Rhc2gvX2dldFByb3RvdHlwZS5qc1xuICoqLyIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vbG9kYXNoL19vdmVyQXJnLmpzXG4gKiovIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0IGluIElFIDwgOS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSG9zdE9iamVjdCh2YWx1ZSkge1xuICAvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuICAvLyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxuICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9ICEhKHZhbHVlICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0hvc3RPYmplY3Q7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vbG9kYXNoL19pc0hvc3RPYmplY3QuanNcbiAqKi8iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvaW5kZXgnKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wb255ZmlsbCA9IHJlcXVpcmUoJy4vcG9ueWZpbGwnKTtcblxudmFyIF9wb255ZmlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb255ZmlsbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHJvb3QgPSB1bmRlZmluZWQ7IC8qIGdsb2JhbCB3aW5kb3cgKi9cblxuaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdHJvb3QgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdHJvb3QgPSB3aW5kb3c7XG59XG5cbnZhciByZXN1bHQgPSAoMCwgX3BvbnlmaWxsMlsnZGVmYXVsdCddKShyb290KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHJlc3VsdDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc3ltYm9sLW9ic2VydmFibGUvbGliL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsO1xuZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIF9TeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRpZiAodHlwZW9mIF9TeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcblx0XHRpZiAoX1N5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBfU3ltYm9sLm9ic2VydmFibGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IF9TeW1ib2woJ29ic2VydmFibGUnKTtcblx0XHRcdF9TeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc3ltYm9sLW9ic2VydmFibGUvbGliL3BvbnlmaWxsLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1snZGVmYXVsdCddID0gY29tYmluZVJlZHVjZXJzO1xuXG52YXIgX2NyZWF0ZVN0b3JlID0gcmVxdWlyZSgnLi9jcmVhdGVTdG9yZScpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4vdXRpbHMvd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pIHtcbiAgdmFyIGFjdGlvblR5cGUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGU7XG4gIHZhciBhY3Rpb25OYW1lID0gYWN0aW9uVHlwZSAmJiAnXCInICsgYWN0aW9uVHlwZS50b1N0cmluZygpICsgJ1wiJyB8fCAnYW4gYWN0aW9uJztcblxuICByZXR1cm4gJ0dpdmVuIGFjdGlvbiAnICsgYWN0aW9uTmFtZSArICcsIHJlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZC4gJyArICdUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuJztcbn1cblxuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCA/ICdwcmVsb2FkZWRTdGF0ZSBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU3RvcmUnIDogJ3ByZXZpb3VzIHN0YXRlIHJlY2VpdmVkIGJ5IHRoZSByZWR1Y2VyJztcblxuICBpZiAocmVkdWNlcktleXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdTdG9yZSBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgcmVkdWNlci4gTWFrZSBzdXJlIHRoZSBhcmd1bWVudCBwYXNzZWQgJyArICd0byBjb21iaW5lUmVkdWNlcnMgaXMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgcmVkdWNlcnMuJztcbiAgfVxuXG4gIGlmICghKDAsIF9pc1BsYWluT2JqZWN0MlsnZGVmYXVsdCddKShpbnB1dFN0YXRlKSkge1xuICAgIHJldHVybiAnVGhlICcgKyBhcmd1bWVudE5hbWUgKyAnIGhhcyB1bmV4cGVjdGVkIHR5cGUgb2YgXCInICsge30udG9TdHJpbmcuY2FsbChpbnB1dFN0YXRlKS5tYXRjaCgvXFxzKFthLXp8QS1aXSspLylbMV0gKyAnXCIuIEV4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgJyArICgna2V5czogXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCInKTtcbiAgfVxuXG4gIHZhciB1bmV4cGVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGlucHV0U3RhdGUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICFyZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XTtcbiAgfSk7XG5cbiAgdW5leHBlY3RlZEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlW2tleV0gPSB0cnVlO1xuICB9KTtcblxuICBpZiAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiAnVW5leHBlY3RlZCAnICsgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDEgPyAna2V5cycgOiAna2V5JykgKyAnICcgKyAoJ1wiJyArIHVuZXhwZWN0ZWRLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiIGZvdW5kIGluICcgKyBhcmd1bWVudE5hbWUgKyAnLiAnKSArICdFeHBlY3RlZCB0byBmaW5kIG9uZSBvZiB0aGUga25vd24gcmVkdWNlciBrZXlzIGluc3RlYWQ6ICcgKyAoJ1wiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiLiBVbmV4cGVjdGVkIGtleXMgd2lsbCBiZSBpZ25vcmVkLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlZHVjZXJTYW5pdHkocmVkdWNlcnMpIHtcbiAgT2JqZWN0LmtleXMocmVkdWNlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgfSk7XG5cbiAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gJyArICdJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgJyArICdleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5ICcgKyAnbm90IGJlIHVuZGVmaW5lZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9ICdAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OXycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoJycpLmpvaW4oJy4nKTtcbiAgICBpZiAodHlwZW9mIHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IHR5cGUgfSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIHByb2JlZCB3aXRoIGEgcmFuZG9tIHR5cGUuICcgKyAoJ0RvblxcJ3QgdHJ5IHRvIGhhbmRsZSAnICsgX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgKyAnIG9yIG90aGVyIGFjdGlvbnMgaW4gXCJyZWR1eC8qXCIgJykgKyAnbmFtZXNwYWNlLiBUaGV5IGFyZSBjb25zaWRlcmVkIHByaXZhdGUuIEluc3RlYWQsIHlvdSBtdXN0IHJldHVybiB0aGUgJyArICdjdXJyZW50IHN0YXRlIGZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCAnICsgJ2luIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSAnICsgJ2FjdGlvbiB0eXBlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4nKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCByZWR1Y2VyIGZ1bmN0aW9ucywgaW50byBhIHNpbmdsZVxuICogcmVkdWNlciBmdW5jdGlvbi4gSXQgd2lsbCBjYWxsIGV2ZXJ5IGNoaWxkIHJlZHVjZXIsIGFuZCBnYXRoZXIgdGhlaXIgcmVzdWx0c1xuICogaW50byBhIHNpbmdsZSBzdGF0ZSBvYmplY3QsIHdob3NlIGtleXMgY29ycmVzcG9uZCB0byB0aGUga2V5cyBvZiB0aGUgcGFzc2VkXG4gKiByZWR1Y2VyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVkdWNlcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBjb3JyZXNwb25kIHRvIGRpZmZlcmVudFxuICogcmVkdWNlciBmdW5jdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNvbWJpbmVkIGludG8gb25lLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpblxuICogaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXMgcmVkdWNlcnNgIHN5bnRheC4gVGhlIHJlZHVjZXJzIG1heSBuZXZlciByZXR1cm5cbiAqIHVuZGVmaW5lZCBmb3IgYW55IGFjdGlvbi4gSW5zdGVhZCwgdGhleSBzaG91bGQgcmV0dXJuIHRoZWlyIGluaXRpYWwgc3RhdGVcbiAqIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueVxuICogdW5yZWNvZ25pemVkIGFjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlXG4gKiBwYXNzZWQgb2JqZWN0LCBhbmQgYnVpbGRzIGEgc3RhdGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2Vycykge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBmaW5hbFJlZHVjZXJzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gcmVkdWNlcktleXNbaV07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKCdObyByZWR1Y2VyIHByb3ZpZGVkIGZvciBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmaW5hbFJlZHVjZXJzW2tleV0gPSByZWR1Y2Vyc1trZXldO1xuICAgIH1cbiAgfVxuICB2YXIgZmluYWxSZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKGZpbmFsUmVkdWNlcnMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIHNhbml0eUVycm9yO1xuICB0cnkge1xuICAgIGFzc2VydFJlZHVjZXJTYW5pdHkoZmluYWxSZWR1Y2Vycyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzYW5pdHlFcnJvciA9IGU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gY29tYmluYXRpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcblxuICAgIGlmIChzYW5pdHlFcnJvcikge1xuICAgICAgdGhyb3cgc2FuaXR5RXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0U3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBmaW5hbFJlZHVjZXJLZXlzW2ldO1xuICAgICAgdmFyIHJlZHVjZXIgPSBmaW5hbFJlZHVjZXJzW2tleV07XG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW2tleV07XG4gICAgICB2YXIgbmV4dFN0YXRlRm9yS2V5ID0gcmVkdWNlcihwcmV2aW91c1N0YXRlRm9yS2V5LCBhY3Rpb24pO1xuICAgICAgaWYgKHR5cGVvZiBuZXh0U3RhdGVGb3JLZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgbmV4dFN0YXRlW2tleV0gPSBuZXh0U3RhdGVGb3JLZXk7XG4gICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXh0U3RhdGVGb3JLZXkgIT09IHByZXZpb3VzU3RhdGVGb3JLZXk7XG4gICAgfVxuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlZHV4L2xpYi9jb21iaW5lUmVkdWNlcnMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzWydkZWZhdWx0J10gPSB3YXJuaW5nO1xuLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVkdXgvbGliL3V0aWxzL3dhcm5pbmcuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzWydkZWZhdWx0J10gPSBiaW5kQWN0aW9uQ3JlYXRvcnM7XG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uIGNyZWF0b3JzLCBpbnRvIGFuIG9iamVjdCB3aXRoIHRoZVxuICogc2FtZSBrZXlzLCBidXQgd2l0aCBldmVyeSBmdW5jdGlvbiB3cmFwcGVkIGludG8gYSBgZGlzcGF0Y2hgIGNhbGwgc28gdGhleVxuICogbWF5IGJlIGludm9rZWQgZGlyZWN0bHkuIFRoaXMgaXMganVzdCBhIGNvbnZlbmllbmNlIG1ldGhvZCwgYXMgeW91IGNhbiBjYWxsXG4gKiBgc3RvcmUuZGlzcGF0Y2goTXlBY3Rpb25DcmVhdG9ycy5kb1NvbWV0aGluZygpKWAgeW91cnNlbGYganVzdCBmaW5lLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxuICogYW5kIGdldCBhIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXNgXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgIT09ICdvYmplY3QnIHx8IGFjdGlvbkNyZWF0b3JzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGluc3RlYWQgcmVjZWl2ZWQgJyArIChhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBhY3Rpb25DcmVhdG9ycykgKyAnLiAnICsgJ0RpZCB5b3Ugd3JpdGUgXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiIGluc3RlYWQgb2YgXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXCI/Jyk7XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFjdGlvbkNyZWF0b3JzKTtcbiAgdmFyIGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVkdXgvbGliL2JpbmRBY3Rpb25DcmVhdG9ycy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gYXBwbHlNaWRkbGV3YXJlO1xuXG52YXIgX2NvbXBvc2UgPSByZXF1aXJlKCcuL2NvbXBvc2UnKTtcblxudmFyIF9jb21wb3NlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvc2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0b3JlIGVuaGFuY2VyIHRoYXQgYXBwbGllcyBtaWRkbGV3YXJlIHRvIHRoZSBkaXNwYXRjaCBtZXRob2RcbiAqIG9mIHRoZSBSZWR1eCBzdG9yZS4gVGhpcyBpcyBoYW5keSBmb3IgYSB2YXJpZXR5IG9mIHRhc2tzLCBzdWNoIGFzIGV4cHJlc3NpbmdcbiAqIGFzeW5jaHJvbm91cyBhY3Rpb25zIGluIGEgY29uY2lzZSBtYW5uZXIsIG9yIGxvZ2dpbmcgZXZlcnkgYWN0aW9uIHBheWxvYWQuXG4gKlxuICogU2VlIGByZWR1eC10aHVua2AgcGFja2FnZSBhcyBhbiBleGFtcGxlIG9mIHRoZSBSZWR1eCBtaWRkbGV3YXJlLlxuICpcbiAqIEJlY2F1c2UgbWlkZGxld2FyZSBpcyBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMsIHRoaXMgc2hvdWxkIGJlIHRoZSBmaXJzdFxuICogc3RvcmUgZW5oYW5jZXIgaW4gdGhlIGNvbXBvc2l0aW9uIGNoYWluLlxuICpcbiAqIE5vdGUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBiZSBnaXZlbiB0aGUgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBmdW5jdGlvbnNcbiAqIGFzIG5hbWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBtaWRkbGV3YXJlcyBUaGUgbWlkZGxld2FyZSBjaGFpbiB0byBiZSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHN0b3JlIGVuaGFuY2VyIGFwcGx5aW5nIHRoZSBtaWRkbGV3YXJlLlxuICovXG5mdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtaWRkbGV3YXJlcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjcmVhdGVTdG9yZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKSB7XG4gICAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpO1xuICAgICAgdmFyIF9kaXNwYXRjaCA9IHN0b3JlLmRpc3BhdGNoO1xuICAgICAgdmFyIGNoYWluID0gW107XG5cbiAgICAgIHZhciBtaWRkbGV3YXJlQVBJID0ge1xuICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gX2Rpc3BhdGNoKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFpbiA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgICAgICByZXR1cm4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKTtcbiAgICAgIH0pO1xuICAgICAgX2Rpc3BhdGNoID0gX2NvbXBvc2UyWydkZWZhdWx0J10uYXBwbHkodW5kZWZpbmVkLCBjaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0b3JlLCB7XG4gICAgICAgIGRpc3BhdGNoOiBfZGlzcGF0Y2hcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlZHV4L2xpYi9hcHBseU1pZGRsZXdhcmUuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY29tcG9zZTtcbi8qKlxuICogQ29tcG9zZXMgc2luZ2xlLWFyZ3VtZW50IGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuIFRoZSByaWdodG1vc3RcbiAqIGZ1bmN0aW9uIGNhbiB0YWtlIG11bHRpcGxlIGFyZ3VtZW50cyBhcyBpdCBwcm92aWRlcyB0aGUgc2lnbmF0dXJlIGZvclxuICogdGhlIHJlc3VsdGluZyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3MgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIG9idGFpbmVkIGJ5IGNvbXBvc2luZyB0aGUgYXJndW1lbnQgZnVuY3Rpb25zXG4gKiBmcm9tIHJpZ2h0IHRvIGxlZnQuIEZvciBleGFtcGxlLCBjb21wb3NlKGYsIGcsIGgpIGlzIGlkZW50aWNhbCB0byBkb2luZ1xuICogKC4uLmFyZ3MpID0+IGYoZyhoKC4uLmFyZ3MpKSkuXG4gKi9cblxuZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZnVuY3NbMF07XG4gIH1cblxuICB2YXIgbGFzdCA9IGZ1bmNzW2Z1bmNzLmxlbmd0aCAtIDFdO1xuICB2YXIgcmVzdCA9IGZ1bmNzLnNsaWNlKDAsIC0xKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVzdC5yZWR1Y2VSaWdodChmdW5jdGlvbiAoY29tcG9zZWQsIGYpIHtcbiAgICAgIHJldHVybiBmKGNvbXBvc2VkKTtcbiAgICB9LCBsYXN0LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlZHV4L2xpYi9jb21wb3NlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBjb250ZXh0VHlwZXM6IHRydWUsXG4gICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGRpc3BsYXlOYW1lOiB0cnVlLFxuICAgIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBtaXhpbnM6IHRydWUsXG4gICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICAgIG5hbWU6IHRydWUsXG4gICAgbGVuZ3RoOiB0cnVlLFxuICAgIHByb3RvdHlwZTogdHJ1ZSxcbiAgICBjYWxsZXI6IHRydWUsXG4gICAgYXJndW1lbnRzOiB0cnVlLFxuICAgIGFyaXR5OiB0cnVlXG59O1xuXG52YXIgaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUgPSB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgY3VzdG9tU3RhdGljcykge1xuICAgIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykgeyAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFSRUFDVF9TVEFUSUNTW2tleXNbaV1dICYmICFLTk9XTl9TVEFUSUNTW2tleXNbaV1dICYmICghY3VzdG9tU3RhdGljcyB8fCAhY3VzdG9tU3RhdGljc1trZXlzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb21wb25lbnRba2V5c1tpXV0gPSBzb3VyY2VDb21wb25lbnRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9pbnZhcmlhbnQvYnJvd3Nlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmZ1bmN0aW9uIGNyZWF0ZVRodW5rTWlkZGxld2FyZShleHRyYUFyZ3VtZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBkaXNwYXRjaCA9IF9yZWYuZGlzcGF0Y2g7XG4gICAgdmFyIGdldFN0YXRlID0gX3JlZi5nZXRTdGF0ZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGlvbihkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhQXJndW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn1cblxudmFyIHRodW5rID0gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKCk7XG50aHVuay53aXRoRXh0cmFBcmd1bWVudCA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gdGh1bms7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlZHV4LXRodW5rL2xpYi9pbmRleC5qc1xuICoqLyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuXG5pbXBvcnQge1xuICBjb25uZWN0U29ja2V0LFxuICBkaXNjb25uZWN0U29ja2V0LFxuICBzZW5kTWVzc2FnZVxufSBmcm9tICcuLy4uL2FjdGlvbnMnO1xuXG5jbGFzcyBBcHAgZXh0ZW5kcyBDb21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgbGV0IHtcbiAgICAgIGRpc3BsYXksXG4gICAgICBkaXNwYXRjaCxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2PlxuICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IGRpc3BhdGNoKGNvbm5lY3RTb2NrZXQoKSkgfT5Db25uZWN0PC9idXR0b24+XG4gICAgICAgIDxici8+XG4gICAgICAgIDxici8+XG4gICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gZGlzcGF0Y2goZGlzY29ubmVjdFNvY2tldCgpKSB9PkRpc0Nvbm5lY3Q8L2J1dHRvbj5cbiAgICAgICAgPGJyLz5cbiAgICAgICAgPGJyLz5cbiAgICAgICAgPGlucHV0IHJlZj1cIm1lc3NhZ2VcIj48L2lucHV0PlxuICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IGRpc3BhdGNoKHNlbmRNZXNzYWdlKHRoaXMucmVmcy5tZXNzYWdlLnZhbHVlKSkgfT5TZW5kIE1lc3NhZ2U8L2J1dHRvbj5cbiAgICAgICAgPGRpdj57ZGlzcGxheX08L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KHN0YXRlID0+IHtcbiAgcmV0dXJuIHtcbiAgICBkaXNwbGF5OiBzdGF0ZS5kaXNwbGF5XG4gIH1cbn0pKEFwcCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2NvbXBvbmVudHMvQXBwLmpzXG4gKiovIiwiaW1wb3J0IGlvIGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xuXG5pbXBvcnQge1xuICBDT05ORUNULFxuICBESVNDT05ORUNULFxuICBSRUNFSVZFX01FU1NBR0UsXG4gIFBPU1RfTUVTU0FHRSxcbiAgVVBEQVRFLFxufSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25uZWN0U29ja2V0KCkge1xuICByZXR1cm4gZGlzcGF0Y2ggPT4ge1xuICAgIGxldCBzb2NrZXQgPSBpbygpO1xuICAgIHNvY2tldC5vbigncmVzdWx0JywgZGF0YSA9PiB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgbmFtZTogJ0phc29uJ1xuICAgICAgfSlcbiAgICB9KVxuICAgIGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IENPTk5FQ1QsXG4gICAgICBzb2NrZXRcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNjb25uZWN0U29ja2V0KCkge1xuICByZXR1cm4gKGRpc3BhdGNoLCBzdGF0ZSkgPT4ge1xuICAgIGxldCBzb2NrZXQgPSBzdGF0ZSgpLnNvY2tldDtcbiAgICBPYmplY3Qua2V5cyhzb2NrZXQpLmxlbmd0aCA+IDAgPyBzb2NrZXQuZGlzY29ubmVjdCgpIDogbnVsbDtcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiBESVNDT05ORUNUXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSl7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDRUlWRV9NRVNTQUdFLFxuICAgIG1lc3NhZ2VcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zdE1lc3NhZ2UodGV4dCl7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUE9TVF9NRVNTQUdFLFxuICAgIHRleHRcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICByZXR1cm4gKGRpc3BhdGNoLCBzdGF0ZSkgPT4ge1xuICAgIGxldCBzb2NrZXQgPSBzdGF0ZSgpLnNvY2tldDtcbiAgICBzb2NrZXQuZW1pdCgnbWVzc2FnZScsIHsgbWVzc2FnZSB9KTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hY3Rpb25zLmpzXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIE1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBsb29rdXA7XG5cbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cblxudmFyIGNhY2hlID0gZXhwb3J0cy5tYW5hZ2VycyA9IHt9O1xuXG4vKipcbiAqIExvb2tzIHVwIGFuIGV4aXN0aW5nIGBNYW5hZ2VyYCBmb3IgbXVsdGlwbGV4aW5nLlxuICogSWYgdGhlIHVzZXIgc3VtbW9uczpcbiAqXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9hJyk7YFxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2BcbiAqXG4gKiBXZSByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgYmFzZWQgb24gc2FtZSBzY2hlbWUvcG9ydC9ob3N0LFxuICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb29rdXAodXJpLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdXJpID09ICdvYmplY3QnKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgcGFyc2VkID0gdXJsKHVyaSk7XG4gIHZhciBzb3VyY2UgPSBwYXJzZWQuc291cmNlO1xuICB2YXIgaWQgPSBwYXJzZWQuaWQ7XG4gIHZhciBwYXRoID0gcGFyc2VkLnBhdGg7XG4gIHZhciBzYW1lTmFtZXNwYWNlID0gY2FjaGVbaWRdICYmIHBhdGggaW4gY2FjaGVbaWRdLm5zcHM7XG4gIHZhciBuZXdDb25uZWN0aW9uID0gb3B0cy5mb3JjZU5ldyB8fCBvcHRzWydmb3JjZSBuZXcgY29ubmVjdGlvbiddIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZmFsc2UgPT09IG9wdHMubXVsdGlwbGV4IHx8IHNhbWVOYW1lc3BhY2U7XG5cbiAgdmFyIGlvO1xuXG4gIGlmIChuZXdDb25uZWN0aW9uKSB7XG4gICAgZGVidWcoJ2lnbm9yaW5nIHNvY2tldCBjYWNoZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgIGlvID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICBkZWJ1ZygnbmV3IGlvIGluc3RhbmNlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgICBjYWNoZVtpZF0gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgfVxuICAgIGlvID0gY2FjaGVbaWRdO1xuICB9XG5cbiAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCk7XG59XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cbi8qKlxuICogYGNvbm5lY3RgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLk1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbmV4cG9ydHMuU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9pbmRleC5qc1xuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwodXJpLCBsb2Mpe1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIHZhciBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uO1xuICBpZiAobnVsbCA9PSB1cmkpIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyBsb2MuaG9zdDtcblxuICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSBsb2MuaG9zdCArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eKGh0dHBzP3x3c3M/KTpcXC9cXC8vLnRlc3QodXJpKSkge1xuICAgICAgZGVidWcoJ3Byb3RvY29sLWxlc3MgdXJsICVzJywgdXJpKTtcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG4gICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9XG4gICAgZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc0NDMnO1xuICAgIH1cbiAgfVxuXG4gIG9iai5wYXRoID0gb2JqLnBhdGggfHwgJy8nO1xuXG4gIHZhciBpcHY2ID0gb2JqLmhvc3QuaW5kZXhPZignOicpICE9PSAtMTtcbiAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblxuICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIG9iai5wb3J0O1xuICAvLyBkZWZpbmUgaHJlZlxuICBvYmouaHJlZiA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArIChsb2MgJiYgbG9jLnBvcnQgPT0gb2JqLnBvcnQgPyAnJyA6ICgnOicgKyBvYmoucG9ydCkpO1xuXG4gIHJldHVybiBvYmo7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzXG4gKiovIiwiLyoqXG4gKiBQYXJzZXMgYW4gVVJJXG4gKlxuICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHJlID0gL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oKD86W2EtZjAtOV17MCw0fTopezIsN31bYS1mMC05XXswLDR9fFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS87XG5cbnZhciBwYXJ0cyA9IFtcbiAgICAnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvcidcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2V1cmkoc3RyKSB7XG4gICAgdmFyIHNyYyA9IHN0cixcbiAgICAgICAgYiA9IHN0ci5pbmRleE9mKCdbJyksXG4gICAgICAgIGUgPSBzdHIuaW5kZXhPZignXScpO1xuXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGIpICsgc3RyLnN1YnN0cmluZyhiLCBlKS5yZXBsYWNlKC86L2csICc7JykgKyBzdHIuc3Vic3RyaW5nKGUsIHN0ci5sZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBtID0gcmUuZXhlYyhzdHIgfHwgJycpLFxuICAgICAgICB1cmkgPSB7fSxcbiAgICAgICAgaSA9IDE0O1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcbiAgICB9XG5cbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHVyaS5zb3VyY2UgPSBzcmM7XG4gICAgICAgIHVyaS5ob3N0ID0gdXJpLmhvc3Quc3Vic3RyaW5nKDEsIHVyaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgJzonKTtcbiAgICAgICAgdXJpLmF1dGhvcml0eSA9IHVyaS5hdXRob3JpdHkucmVwbGFjZSgnWycsICcnKS5yZXBsYWNlKCddJywgJycpLnJlcGxhY2UoLzsvZywgJzonKTtcbiAgICAgICAgdXJpLmlwdjZ1cmkgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB1cmk7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3BhcnNldXJpL2luZGV4LmpzXG4gKiovIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICByZXR1cm4gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpe1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2RlYnVnL2Jyb3dzZXIuanNcbiAqKi8iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gKi9cblxudmFyIHByZXZDb2xvciA9IDA7XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuICB9XG4gIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cbiAgICB2YXIgc2VsZiA9IGVuYWJsZWQ7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG4gICAgaWYgKG51bGwgPT0gc2VsZi51c2VDb2xvcnMpIHNlbGYudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgICBpZiAobnVsbCA9PSBzZWxmLmNvbG9yICYmIHNlbGYudXNlQ29sb3JzKSBzZWxmLmNvbG9yID0gc2VsZWN0Q29sb3IoKTtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3MpIHtcbiAgICAgIGFyZ3MgPSBleHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgZW5hYmxlZC5lbmFibGVkID0gdHJ1ZTtcblxuICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9kZWJ1Zy9kZWJ1Zy5qc1xuICoqLyIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2YWwpIHJldHVybiBwYXJzZSh2YWwpO1xuICByZXR1cm4gb3B0aW9ucy5sb25nXG4gICAgPyBsb25nKHZhbClcbiAgICA6IHNob3J0KHZhbCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gJycgKyBzdHI7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwMDApIHJldHVybjtcbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm47XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICBpZiAobXMgPj0gaCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JylcbiAgICB8fCBwbHVyYWwobXMsIGgsICdob3VyJylcbiAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxuICAgIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG4gICAgfHwgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikgcmV0dXJuO1xuICBpZiAobXMgPCBuICogMS41KSByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9tcy9pbmRleC5qc1xuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBqc29uID0gcmVxdWlyZSgnanNvbjMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGJpbmFyeSA9IHJlcXVpcmUoJy4vYmluYXJ5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnR5cGVzID0gW1xuICAnQ09OTkVDVCcsXG4gICdESVNDT05ORUNUJyxcbiAgJ0VWRU5UJyxcbiAgJ0FDSycsXG4gICdFUlJPUicsXG4gICdCSU5BUllfRVZFTlQnLFxuICAnQklOQVJZX0FDSydcbl07XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGNvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5DT05ORUNUID0gMDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZGlzY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRJU0NPTk5FQ1QgPSAxO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBldmVudGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVWRU5UID0gMjtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYWNrYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQUNLID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXJyb3JgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FUlJPUiA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgJ2JpbmFyeSBldmVudCdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0VWRU5UID0gNTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYmluYXJ5IGFja2AuIEZvciBhY2tzIHdpdGggYmluYXJ5IGFyZ3VtZW50cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0FDSyA9IDY7XG5cbi8qKlxuICogRW5jb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG5cbi8qKlxuICogRGVjb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRGVjb2RlciA9IERlY29kZXI7XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRW5jb2RlciBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW5jb2RlcigpIHt9XG5cbi8qKlxuICogRW5jb2RlIGEgcGFja2V0IGFzIGEgc2luZ2xlIHN0cmluZyBpZiBub24tYmluYXJ5LCBvciBhcyBhXG4gKiBidWZmZXIgc2VxdWVuY2UsIGRlcGVuZGluZyBvbiBwYWNrZXQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gcGFja2V0IG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBmdW5jdGlvbiB0byBoYW5kbGUgZW5jb2RpbmdzIChsaWtlbHkgZW5naW5lLndyaXRlKVxuICogQHJldHVybiBDYWxscyBjYWxsYmFjayB3aXRoIEFycmF5IG9mIGVuY29kaW5nc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihvYmosIGNhbGxiYWNrKXtcbiAgZGVidWcoJ2VuY29kaW5nIHBhY2tldCAlaicsIG9iaik7XG5cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuICAgIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBlbmNvZGluZyA9IGVuY29kZUFzU3RyaW5nKG9iaik7XG4gICAgY2FsbGJhY2soW2VuY29kaW5nXSk7XG4gIH1cbn07XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc1N0cmluZyhvYmopIHtcbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgbnNwID0gZmFsc2U7XG5cbiAgLy8gZmlyc3QgaXMgdHlwZVxuICBzdHIgKz0gb2JqLnR5cGU7XG5cbiAgLy8gYXR0YWNobWVudHMgaWYgd2UgaGF2ZSB0aGVtXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcbiAgICBzdHIgKz0gb2JqLmF0dGFjaG1lbnRzO1xuICAgIHN0ciArPSAnLSc7XG4gIH1cblxuICAvLyBpZiB3ZSBoYXZlIGEgbmFtZXNwYWNlIG90aGVyIHRoYW4gYC9gXG4gIC8vIHdlIGFwcGVuZCBpdCBmb2xsb3dlZCBieSBhIGNvbW1hIGAsYFxuICBpZiAob2JqLm5zcCAmJiAnLycgIT0gb2JqLm5zcCkge1xuICAgIG5zcCA9IHRydWU7XG4gICAgc3RyICs9IG9iai5uc3A7XG4gIH1cblxuICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcbiAgaWYgKG51bGwgIT0gb2JqLmlkKSB7XG4gICAgaWYgKG5zcCkge1xuICAgICAgc3RyICs9ICcsJztcbiAgICAgIG5zcCA9IGZhbHNlO1xuICAgIH1cbiAgICBzdHIgKz0gb2JqLmlkO1xuICB9XG5cbiAgLy8ganNvbiBkYXRhXG4gIGlmIChudWxsICE9IG9iai5kYXRhKSB7XG4gICAgaWYgKG5zcCkgc3RyICs9ICcsJztcbiAgICBzdHIgKz0ganNvbi5zdHJpbmdpZnkob2JqLmRhdGEpO1xuICB9XG5cbiAgZGVidWcoJ2VuY29kZWQgJWogYXMgJXMnLCBvYmosIHN0cik7XG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyAnYnVmZmVyIHNlcXVlbmNlJyBieSByZW1vdmluZyBibG9icywgYW5kXG4gKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG4gKiBhIGxpc3Qgb2YgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spIHtcblxuICBmdW5jdGlvbiB3cml0ZUVuY29kaW5nKGJsb2JsZXNzRGF0YSkge1xuICAgIHZhciBkZWNvbnN0cnVjdGlvbiA9IGJpbmFyeS5kZWNvbnN0cnVjdFBhY2tldChibG9ibGVzc0RhdGEpO1xuICAgIHZhciBwYWNrID0gZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTtcbiAgICB2YXIgYnVmZmVycyA9IGRlY29uc3RydWN0aW9uLmJ1ZmZlcnM7XG5cbiAgICBidWZmZXJzLnVuc2hpZnQocGFjayk7IC8vIGFkZCBwYWNrZXQgaW5mbyB0byBiZWdpbm5pbmcgb2YgZGF0YSBsaXN0XG4gICAgY2FsbGJhY2soYnVmZmVycyk7IC8vIHdyaXRlIGFsbCB0aGUgYnVmZmVyc1xuICB9XG5cbiAgYmluYXJ5LnJlbW92ZUJsb2JzKG9iaiwgd3JpdGVFbmNvZGluZyk7XG59XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRGVjb2RlciBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBEZWNvZGVyKCkge1xuICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAgd2l0aCBEZWNvZGVyLlxuICovXG5cbkVtaXR0ZXIoRGVjb2Rlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERlY29kZXMgYW4gZWNvZGVkIHBhY2tldCBzdHJpbmcgaW50byBwYWNrZXQgSlNPTi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gZW5jb2RlZCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcGFja2V0O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIG9iaikge1xuICAgIHBhY2tldCA9IGRlY29kZVN0cmluZyhvYmopO1xuICAgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwYWNrZXQudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gcGFja2V0LnR5cGUpIHsgLy8gYmluYXJ5IHBhY2tldCdzIGpzb25cbiAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG5ldyBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCk7XG5cbiAgICAgIC8vIG5vIGF0dGFjaG1lbnRzLCBsYWJlbGVkIGJpbmFyeSBidXQgbm8gYmluYXJ5IGRhdGEgdG8gZm9sbG93XG4gICAgICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yLnJlY29uUGFjay5hdHRhY2htZW50cyA9PT0gMCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIG5vbi1iaW5hcnkgZnVsbCBwYWNrZXRcbiAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGlzQnVmKG9iaikgfHwgb2JqLmJhc2U2NCkgeyAvLyByYXcgYmluYXJ5IGRhdGFcbiAgICBpZiAoIXRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb3QgYmluYXJ5IGRhdGEgd2hlbiBub3QgcmVjb25zdHJ1Y3RpbmcgYSBwYWNrZXQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFja2V0ID0gdGhpcy5yZWNvbnN0cnVjdG9yLnRha2VCaW5hcnlEYXRhKG9iaik7XG4gICAgICBpZiAocGFja2V0KSB7IC8vIHJlY2VpdmVkIGZpbmFsIGJ1ZmZlclxuICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZTogJyArIG9iaik7XG4gIH1cbn07XG5cbi8qKlxuICogRGVjb2RlIGEgcGFja2V0IFN0cmluZyAoSlNPTiBkYXRhKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBkZWNvZGVTdHJpbmcoc3RyKSB7XG4gIHZhciBwID0ge307XG4gIHZhciBpID0gMDtcblxuICAvLyBsb29rIHVwIHR5cGVcbiAgcC50eXBlID0gTnVtYmVyKHN0ci5jaGFyQXQoMCkpO1xuICBpZiAobnVsbCA9PSBleHBvcnRzLnR5cGVzW3AudHlwZV0pIHJldHVybiBlcnJvcigpO1xuXG4gIC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gcC50eXBlKSB7XG4gICAgdmFyIGJ1ZiA9ICcnO1xuICAgIHdoaWxlIChzdHIuY2hhckF0KCsraSkgIT0gJy0nKSB7XG4gICAgICBidWYgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoYnVmICE9IE51bWJlcihidWYpIHx8IHN0ci5jaGFyQXQoaSkgIT0gJy0nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXR0YWNobWVudHMnKTtcbiAgICB9XG4gICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcbiAgaWYgKCcvJyA9PSBzdHIuY2hhckF0KGkgKyAxKSkge1xuICAgIHAubnNwID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKCcsJyA9PSBjKSBicmVhaztcbiAgICAgIHAubnNwICs9IGM7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcC5uc3AgPSAnLyc7XG4gIH1cblxuICAvLyBsb29rIHVwIGlkXG4gIHZhciBuZXh0ID0gc3RyLmNoYXJBdChpICsgMSk7XG4gIGlmICgnJyAhPT0gbmV4dCAmJiBOdW1iZXIobmV4dCkgPT0gbmV4dCkge1xuICAgIHAuaWQgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAobnVsbCA9PSBjIHx8IE51bWJlcihjKSAhPSBjKSB7XG4gICAgICAgIC0taTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwLmlkICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgcC5pZCA9IE51bWJlcihwLmlkKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAganNvbiBkYXRhXG4gIGlmIChzdHIuY2hhckF0KCsraSkpIHtcbiAgICB0cnkge1xuICAgICAgcC5kYXRhID0ganNvbi5wYXJzZShzdHIuc3Vic3RyKGkpKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGVycm9yKCk7XG4gICAgfVxuICB9XG5cbiAgZGVidWcoJ2RlY29kZWQgJXMgYXMgJWonLCBzdHIsIHApO1xuICByZXR1cm4gcDtcbn1cblxuLyoqXG4gKiBEZWFsbG9jYXRlcyBhIHBhcnNlcidzIHJlc291cmNlc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgdGhpcy5yZWNvbnN0cnVjdG9yLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIG1hbmFnZXIgb2YgYSBiaW5hcnkgZXZlbnQncyAnYnVmZmVyIHNlcXVlbmNlJy4gU2hvdWxkXG4gKiBiZSBjb25zdHJ1Y3RlZCB3aGVuZXZlciBhIHBhY2tldCBvZiB0eXBlIEJJTkFSWV9FVkVOVCBpc1xuICogZGVjb2RlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCaW5hcnlSZWNvbnN0cnVjdG9yfSBpbml0aWFsaXplZCByZWNvbnN0cnVjdG9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCkge1xuICB0aGlzLnJlY29uUGFjayA9IHBhY2tldDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIGJpbmFyeSBkYXRhIHJlY2VpdmVkIGZyb20gY29ubmVjdGlvblxuICogYWZ0ZXIgYSBCSU5BUllfRVZFTlQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyIHwgQXJyYXlCdWZmZXJ9IGJpbkRhdGEgLSB0aGUgcmF3IGJpbmFyeSBkYXRhIHJlY2VpdmVkXG4gKiBAcmV0dXJuIHtudWxsIHwgT2JqZWN0fSByZXR1cm5zIG51bGwgaWYgbW9yZSBiaW5hcnkgZGF0YSBpcyBleHBlY3RlZCBvclxuICogICBhIHJlY29uc3RydWN0ZWQgcGFja2V0IG9iamVjdCBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS50YWtlQmluYXJ5RGF0YSA9IGZ1bmN0aW9uKGJpbkRhdGEpIHtcbiAgdGhpcy5idWZmZXJzLnB1c2goYmluRGF0YSk7XG4gIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7IC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuICAgIHZhciBwYWNrZXQgPSBiaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGJpbmFyeSBwYWNrZXQgcmVjb25zdHJ1Y3Rpb24gdmFyaWFibGVzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn07XG5cbmZ1bmN0aW9uIGVycm9yKGRhdGEpe1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuRVJST1IsXG4gICAgZGF0YTogJ3BhcnNlciBlcnJvcidcbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9zb2NrZXQuaW8tcGFyc2VyL2luZGV4LmpzXG4gKiovIiwiLyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcblxuICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgIFwib2JqZWN0XCI6IHRydWVcbiAgfTtcblxuICAvLyBEZXRlY3QgdGhlIGBleHBvcnRzYCBvYmplY3QgZXhwb3NlZCBieSBDb21tb25KUyBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLy8gVXNlIHRoZSBgZ2xvYmFsYCBvYmplY3QgZXhwb3NlZCBieSBOb2RlIChpbmNsdWRpbmcgQnJvd3NlcmlmeSB2aWFcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcbiAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuICAvLyBpbnN0ZWFkLlxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxuICAgICAgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWw7XG5cbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXG4gIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XG4gICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG4gICAgZXhwb3J0cyB8fCAoZXhwb3J0cyA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cbiAgICAvLyBOYXRpdmUgY29uc3RydWN0b3IgYWxpYXNlcy5cbiAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHRbXCJPYmplY3RcIl0gfHwgcm9vdFtcIk9iamVjdFwiXSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHRbXCJUeXBlRXJyb3JcIl0gfHwgcm9vdFtcIlR5cGVFcnJvclwiXSxcbiAgICAgICAgTWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XG5cbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cbiAgICBpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XG4gICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuICAgICAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBnZXRDbGFzcyA9IG9iamVjdFByb3RvLnRvU3RyaW5nLFxuICAgICAgICBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAgIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG4gICAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N1cHBvcnRlZDtcbiAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBkZWZpbmUgYSBjYW5vbmljYWwgSlNPTiByZXByZXNlbnRhdGlvbiAodGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGdldENsYXNzKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAvLyBgXCJbbnVsbF1cImAuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsKSA9PSBcIm51bGxcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxuICAgICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHNlcmlhbGl6YXRpb24gdGVzdC4gRkYgMy4xYjEgdXNlcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEgYW5kIGIyIGlnbm9yZSB0aGUgYGZpbHRlcmAgYW5kIGB3aWR0aGAgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcbiAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuICAgICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIGlmICghaGFzKFwianNvblwiKSkge1xuICAgICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cbiAgICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLFxuICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuICAgICAgICAgIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIixcbiAgICAgICAgICBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCIsXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcbiAgICAgICAgICBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cbiAgICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuICAgICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuICAgICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuICAgICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgICAvLyBUaGUgKnByb3RvKiBwcm9wZXJ0eSBjYW5ub3QgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGluIHJlY2VudFxuICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgICAgfSwgbWVtYmVycykudG9TdHJpbmcgIT0gZ2V0Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cbiAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXG4gICAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXG4gICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eV0gJiYgb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGlzUHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGlzQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgICAgLy8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG4gICAgICAgICAgdmFyIHN5bWJvbHMgPSB1c2VDaGFySW5kZXggJiYgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSk7XG4gICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG4gICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuICAgICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cbiAgICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG4gICAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cbiAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2VcbiAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XG4gICAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcbiAgICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG4gICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAgIC8vIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgICAzNDogJ1wiJyxcbiAgICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgICAgMTE2OiBcIlxcdFwiLFxuICAgICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgICAgMTE0OiBcIlxcclwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcbiAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgICBJbmRleCA9IDA7XG4gICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXG4gICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcbiAgICAgICAgaXNSZXN0b3JlZCA9IGZhbHNlO1xuXG4gICAgdmFyIEpTT04zID0gcnVuSW5Db250ZXh0KHJvb3QsIChyb290W1wiSlNPTjNcIl0gPSB7XG4gICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cbiAgICAgIFwibm9Db25mbGljdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICAgIHJvb3QuSlNPTiA9IG5hdGl2ZUpTT047XG4gICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OMztcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByb290LkpTT04gPSB7XG4gICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuICAgICAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICBpZiAoaXNMb2FkZXIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEpTT04zO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3NvY2tldC5pby1wYXJzZXIvfi9qc29uMy9saWIvanNvbjMuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9pc2FycmF5L2luZGV4LmpzXG4gKiovIiwiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXG4gKiovIiwiLypnbG9iYWwgQmxvYixGaWxlKi9cblxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xuXG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG4gKiBoZXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcblxuICBmdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuICAgIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgICBpZiAoaXNCdWYoZGF0YSkpIHtcbiAgICAgIHZhciBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG4gICAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBwYWNrID0gcGFja2V0O1xuICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSk7XG4gIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcbn07XG5cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG4gIHZhciBjdXJQbGFjZUhvbGRlciA9IDA7XG5cbiAgZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlcikge1xuICAgICAgdmFyIGJ1ZiA9IGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgICAgIHJldHVybiBidWY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSk7XG4gIHBhY2tldC5hdHRhY2htZW50cyA9IHVuZGVmaW5lZDsgLy8gbm8gbG9uZ2VyIHVzZWZ1bFxuICByZXR1cm4gcGFja2V0O1xufTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAqIEZpbGVSZWFkZXIncyByZWFkQXNBcnJheUJ1ZmZlciBtZXRob2QuIFVzZWQgYmVmb3JlIGVuY29kaW5nXG4gKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cbiAgICAvLyBjb252ZXJ0IGFueSBibG9iXG4gICAgaWYgKChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIHBlbmRpbmdCbG9icysrO1xuXG4gICAgICAvLyBhc3luYyBmaWxlcmVhZGVyXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuICAgICAgICBpZiAoY29udGFpbmluZ09iamVjdCkge1xuICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJsb2JsZXNzRGF0YSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBwZW5kaW5nIGl0cyBjYWxsYmFjayB0aW1lXG4gICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcbiAgICAgICAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iaik7IC8vIGJsb2IgLT4gYXJyYXlidWZmZXJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaiAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nQmxvYnMgPSAwO1xuICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcbiAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG4gIGlmICghcGVuZGluZ0Jsb2JzKSB7XG4gICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgfVxufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qc1xuICoqLyIsIlxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZjtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgYnVmZmVyIG9yIGFuIGFycmF5YnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzQnVmKG9iaikge1xuICByZXR1cm4gKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanNcbiAqKi8iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZWlvID0gcmVxdWlyZSgnZW5naW5lLmlvLWNsaWVudCcpO1xudmFyIFNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDptYW5hZ2VyJyk7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBCYWNrb2ZmID0gcmVxdWlyZSgnYmFja28yJyk7XG5cbi8qKlxuICogSUU2KyBoYXNPd25Qcm9wZXJ0eVxuICovXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNYW5hZ2VyO1xuXG4vKipcbiAqIGBNYW5hZ2VyYCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5naW5lIGluc3RhbmNlIG9yIGVuZ2luZSB1cmkvb3B0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTWFuYWdlcih1cmksIG9wdHMpe1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFuYWdlcikpIHJldHVybiBuZXcgTWFuYWdlcih1cmksIG9wdHMpO1xuICBpZiAodXJpICYmICgnb2JqZWN0JyA9PSB0eXBlb2YgdXJpKSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCAnL3NvY2tldC5pbyc7XG4gIHRoaXMubnNwcyA9IHt9O1xuICB0aGlzLnN1YnMgPSBbXTtcbiAgdGhpcy5vcHRzID0gb3B0cztcbiAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzIHx8IEluZmluaXR5KTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheShvcHRzLnJlY29ubmVjdGlvbkRlbGF5IHx8IDEwMDApO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG4gIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcihvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3IgfHwgMC41KTtcbiAgdGhpcy5iYWNrb2ZmID0gbmV3IEJhY2tvZmYoe1xuICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuICAgIG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuICAgIGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKClcbiAgfSk7XG4gIHRoaXMudGltZW91dChudWxsID09IG9wdHMudGltZW91dCA/IDIwMDAwIDogb3B0cy50aW1lb3V0KTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMudXJpID0gdXJpO1xuICB0aGlzLmNvbm5lY3RpbmcgPSBbXTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdGhpcy5lbmNvZGVyID0gbmV3IHBhcnNlci5FbmNvZGVyKCk7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBwYXJzZXIuRGVjb2RlcigpO1xuICB0aGlzLmF1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBQcm9wYWdhdGUgZ2l2ZW4gZXZlbnQgdG8gc29ja2V0cyBhbmQgZW1pdCBvbiBgdGhpc2BcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU29ja2V0SWRzID0gZnVuY3Rpb24oKXtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5lbmdpbmUuaWQ7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3RcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcbiAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWluKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0Sml0dGVyKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgdGhpcy5fdGltZW91dCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24oKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub3BlbiA9XG5NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oZm4pe1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbigpIHtcbiAgICBzZWxmLm9ub3BlbigpO1xuICAgIGZuICYmIGZuKCk7XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfZXJyb3JgXG4gIHZhciBlcnJvclN1YiA9IG9uKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcbiAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLnN1YnMucHVzaChvcGVuU3ViKTtcbiAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5sYXN0UGluZyA9IG5ldyBEYXRlO1xuICB0aGlzLmVtaXRBbGwoJ3BpbmcnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25wb25nID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUgLSB0aGlzLmxhc3RQaW5nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kZWNvZGVkID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICB0aGlzLmVtaXRBbGwoJ2Vycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uKG5zcCl7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24oKXtcbiAgICAgIHNvY2tldC5pZCA9IHNlbGYuZW5naW5lLmlkO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHtcbiAgICAgIC8vIG1hbnVhbGx5IGNhbGwgaGVyZSBzaW5jZSBjb25uZWN0aW5nIGV2bmV0IGlzIGZpcmVkIGJlZm9yZSBsaXN0ZW5pbmdcbiAgICAgIG9uQ29ubmVjdGluZygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29ubmVjdGluZygpIHtcbiAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKHNvY2tldCl7XG4gIHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5jb25uZWN0aW5nLCBzb2NrZXQpO1xuICBpZiAofmluZGV4KSB0aGlzLmNvbm5lY3Rpbmcuc3BsaWNlKGluZGV4LCAxKTtcbiAgaWYgKHRoaXMuY29ubmVjdGluZy5sZW5ndGgpIHJldHVybjtcblxuICB0aGlzLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBkZWJ1Zygnd3JpdGluZyBwYWNrZXQgJWonLCBwYWNrZXQpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCFzZWxmLmVuY29kaW5nKSB7XG4gICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuICAgIHNlbGYuZW5jb2RpbmcgPSB0cnVlO1xuICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0LCBmdW5jdGlvbihlbmNvZGVkUGFja2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnBhY2tldEJ1ZmZlci5sZW5ndGggPiAwICYmICF0aGlzLmVuY29kaW5nKSB7XG4gICAgdmFyIHBhY2sgPSB0aGlzLnBhY2tldEJ1ZmZlci5zaGlmdCgpO1xuICAgIHRoaXMucGFja2V0KHBhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIHRyYW5zcG9ydCBzdWJzY3JpcHRpb25zIGFuZCBwYWNrZXQgYnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuXG4gIHZhciBzdWI7XG4gIHdoaWxlIChzdWIgPSB0aGlzLnN1YnMuc2hpZnQoKSkgc3ViLmRlc3Ryb3koKTtcblxuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXG4gIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7XG59O1xuXG4vKipcbiAqIENsb3NlIHRoZSBjdXJyZW50IHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9XG5NYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ2Rpc2Nvbm5lY3QnKTtcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gdHJ1ZTtcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBgb25jbG9zZWAgd2lsbCBub3QgZmlyZSBiZWNhdXNlXG4gICAgLy8gYW4gb3BlbiBldmVudCBuZXZlciBoYXBwZW5lZFxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgaWYgKHRoaXMuZW5naW5lKSB0aGlzLmVuZ2luZS5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbil7XG4gIGRlYnVnKCdvbmNsb3NlJyk7XG5cbiAgdGhpcy5jbGVhbnVwKCk7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbik7XG5cbiAgaWYgKHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0KSB7XG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBdHRlbXB0IGEgcmVjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcbiAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBkZWJ1ZygnYXR0ZW1wdGluZyByZWNvbm5lY3QnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2F0dGVtcHQnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG4gICAgICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uKGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IGF0dGVtcHQgZXJyb3InKTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0KCk7XG4gICAgICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfZXJyb3InLCBlcnIuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBzdWNjZXNzJyk7XG4gICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBkZWxheSk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGF0dGVtcHQgPSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHM7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnVwZGF0ZVNvY2tldElkcygpO1xuICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdCcsIGF0dGVtcHQpO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9tYW5hZ2VyLmpzXG4gKiovIiwiXG5tb2R1bGUuZXhwb3J0cyA9ICByZXF1aXJlKCcuL2xpYi8nKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2luZGV4LmpzXG4gKiovIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0cyBwYXJzZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgcGFyc2Vqc29uID0gcmVxdWlyZSgncGFyc2Vqc29uJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBOb29wIGZ1bmN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG5vb3AoKXt9XG5cbi8qKlxuICogU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIG9yIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCh1cmksIG9wdHMpe1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja2V0KSkgcmV0dXJuIG5ldyBTb2NrZXQodXJpLCBvcHRzKTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBpZiAodXJpICYmICdvYmplY3QnID09IHR5cGVvZiB1cmkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IG51bGw7XG4gIH1cblxuICBpZiAodXJpKSB7XG4gICAgdXJpID0gcGFyc2V1cmkodXJpKTtcbiAgICBvcHRzLmhvc3RuYW1lID0gdXJpLmhvc3Q7XG4gICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT0gJ3dzcyc7XG4gICAgb3B0cy5wb3J0ID0gdXJpLnBvcnQ7XG4gICAgaWYgKHVyaS5xdWVyeSkgb3B0cy5xdWVyeSA9IHVyaS5xdWVyeTtcbiAgfSBlbHNlIGlmIChvcHRzLmhvc3QpIHtcbiAgICBvcHRzLmhvc3RuYW1lID0gcGFyc2V1cmkob3B0cy5ob3N0KS5ob3N0O1xuICB9XG5cbiAgdGhpcy5zZWN1cmUgPSBudWxsICE9IG9wdHMuc2VjdXJlID8gb3B0cy5zZWN1cmUgOlxuICAgIChnbG9iYWwubG9jYXRpb24gJiYgJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2wpO1xuXG4gIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcbiAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgb3B0cy5wb3J0ID0gdGhpcy5zZWN1cmUgPyAnNDQzJyA6ICc4MCc7XG4gIH1cblxuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHxcbiAgICAoZ2xvYmFsLmxvY2F0aW9uID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0Jyk7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAoZ2xvYmFsLmxvY2F0aW9uICYmIGxvY2F0aW9uLnBvcnQgP1xuICAgICAgIGxvY2F0aW9uLnBvcnQgOlxuICAgICAgICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5IHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHRoaXMucXVlcnkpIHRoaXMucXVlcnkgPSBwYXJzZXFzLmRlY29kZSh0aGlzLnF1ZXJ5KTtcbiAgdGhpcy51cGdyYWRlID0gZmFsc2UgIT09IG9wdHMudXBncmFkZTtcbiAgdGhpcy5wYXRoID0gKG9wdHMucGF0aCB8fCAnL2VuZ2luZS5pbycpLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLyc7XG4gIHRoaXMuZm9yY2VKU09OUCA9ICEhb3B0cy5mb3JjZUpTT05QO1xuICB0aGlzLmpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG4gIHRoaXMuZm9yY2VCYXNlNjQgPSAhIW9wdHMuZm9yY2VCYXNlNjQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9ICEhb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbSB8fCAndCc7XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnRyYW5zcG9ydHMgPSBvcHRzLnRyYW5zcG9ydHMgfHwgWydwb2xsaW5nJywgJ3dlYnNvY2tldCddO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gZmFsc2UgIT09IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgPyAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB7fSkgOiBmYWxzZTtcblxuICBpZiAodHJ1ZSA9PT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSkgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICBpZiAodGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJiBudWxsID09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuICB9XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZnggfHwgbnVsbDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleSB8fCBudWxsO1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0IHx8IG51bGw7XG4gIHRoaXMuY2EgPSBvcHRzLmNhIHx8IG51bGw7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsKSB7XG4gICAgaWYgKG9wdHMuZXh0cmFIZWFkZXJzICYmIE9iamVjdC5rZXlzKG9wdHMuZXh0cmFIZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub3BlbigpO1xufVxuXG5Tb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7IC8vIHRoaXMgaXMgYW4gaW50XG5cbi8qKlxuICogRXhwb3NlIGRlcHMgZm9yIGxlZ2FjeSBjb21wYXRpYmlsaXR5XG4gKiBhbmQgc3RhbmRhbG9uZSBicm93c2VyIGFjY2Vzcy5cbiAqL1xuXG5Tb2NrZXQuU29ja2V0ID0gU29ja2V0O1xuU29ja2V0LlRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0Jyk7XG5Tb2NrZXQudHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cycpO1xuU29ja2V0LnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ2NyZWF0aW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHF1ZXJ5ID0gY2xvbmUodGhpcy5xdWVyeSk7XG5cbiAgLy8gYXBwZW5kIGVuZ2luZS5pbyBwcm90b2NvbCBpZGVudGlmaWVyXG4gIHF1ZXJ5LkVJTyA9IHBhcnNlci5wcm90b2NvbDtcblxuICAvLyB0cmFuc3BvcnQgbmFtZVxuICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lO1xuXG4gIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAodGhpcy5pZCkgcXVlcnkuc2lkID0gdGhpcy5pZDtcblxuICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNbbmFtZV0oe1xuICAgIGFnZW50OiB0aGlzLmFnZW50LFxuICAgIGhvc3RuYW1lOiB0aGlzLmhvc3RuYW1lLFxuICAgIHBvcnQ6IHRoaXMucG9ydCxcbiAgICBzZWN1cmU6IHRoaXMuc2VjdXJlLFxuICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgZm9yY2VKU09OUDogdGhpcy5mb3JjZUpTT05QLFxuICAgIGpzb25wOiB0aGlzLmpzb25wLFxuICAgIGZvcmNlQmFzZTY0OiB0aGlzLmZvcmNlQmFzZTY0LFxuICAgIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUixcbiAgICB0aW1lc3RhbXBSZXF1ZXN0czogdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyxcbiAgICB0aW1lc3RhbXBQYXJhbTogdGhpcy50aW1lc3RhbXBQYXJhbSxcbiAgICBwb2xpY3lQb3J0OiB0aGlzLnBvbGljeVBvcnQsXG4gICAgc29ja2V0OiB0aGlzLFxuICAgIHBmeDogdGhpcy5wZngsXG4gICAga2V5OiB0aGlzLmtleSxcbiAgICBwYXNzcGhyYXNlOiB0aGlzLnBhc3NwaHJhc2UsXG4gICAgY2VydDogdGhpcy5jZXJ0LFxuICAgIGNhOiB0aGlzLmNhLFxuICAgIGNpcGhlcnM6IHRoaXMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgIGV4dHJhSGVhZGVyczogdGhpcy5leHRyYUhlYWRlcnNcbiAgfSk7XG5cbiAgcmV0dXJuIHRyYW5zcG9ydDtcbn07XG5cbmZ1bmN0aW9uIGNsb25lIChvYmopIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBvW2ldID0gb2JqW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbztcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0cmFuc3BvcnQgdG8gdXNlIGFuZCBzdGFydHMgcHJvYmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNvY2tldC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRyYW5zcG9ydDtcbiAgaWYgKHRoaXMucmVtZW1iZXJVcGdyYWRlICYmIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgJiYgdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoJ3dlYnNvY2tldCcpICE9IC0xKSB7XG4gICAgdHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG4gIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsICdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG4gIH1cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXG4gIC8vIFJldHJ5IHdpdGggdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSB0cmFuc3BvcnQgaXMgZGlzYWJsZWQgKGpzb25wOiBmYWxzZSlcbiAgdHJ5IHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRUcmFuc3BvcnQgPSBmdW5jdGlvbih0cmFuc3BvcnQpe1xuICBkZWJ1Zygnc2V0dGluZyB0cmFuc3BvcnQgJXMnLCB0cmFuc3BvcnQubmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICBkZWJ1ZygnY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzJywgdGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gIHRyYW5zcG9ydFxuICAub24oJ2RyYWluJywgZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uRHJhaW4oKTtcbiAgfSlcbiAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbihwYWNrZXQpe1xuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfSlcbiAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcihlKTtcbiAgfSlcbiAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucHJvYmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pXG4gICAgLCBmYWlsZWQgPSBmYWxzZVxuICAgICwgc2VsZiA9IHRoaXM7XG5cbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0T3Blbigpe1xuICAgIGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcbiAgICB9XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PSBtc2cudHlwZSAmJiAncHJvYmUnID09IG1zZy5kYXRhKSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcbiAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGluZycsIHRyYW5zcG9ydCk7XG4gICAgICAgIGlmICghdHJhbnNwb3J0KSByZXR1cm47XG4gICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PSB0cmFuc3BvcnQubmFtZTtcblxuICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgICAgZGVidWcoJ2NoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldCcpO1xuXG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3InKTtcbiAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQoKSB7XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgLy8gQW55IGNhbGxiYWNrIGNhbGxlZCBieSB0cmFuc3BvcnQgc2hvdWxkIGJlIGlnbm9yZWQgc2luY2Ugbm93XG4gICAgZmFpbGVkID0gdHJ1ZTtcblxuICAgIGNsZWFudXAoKTtcblxuICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICAvL0hhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcbiAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSgpe1xuICAgIG9uZXJyb3IoXCJ0cmFuc3BvcnQgY2xvc2VkXCIpO1xuICB9XG5cbiAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25jbG9zZSgpe1xuICAgIG9uZXJyb3IoXCJzb2NrZXQgY2xvc2VkXCIpO1xuICB9XG5cbiAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUodG8pe1xuICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICBmdW5jdGlvbiBjbGVhbnVwKCl7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkaW5nJywgb251cGdyYWRlKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG4gIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG4gIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgdGhpcy5vbmNlKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG5cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc29ja2V0IG9wZW4nKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIHRoaXMuZmx1c2goKTtcblxuICAvLyB3ZSBjaGVjayBmb3IgYHJlYWR5U3RhdGVgIGluIGNhc2UgYW4gYG9wZW5gXG4gIC8vIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VkIHRoZSBzb2NrZXRcbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG4gICAgZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG4gICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cbiAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShwYXJzZWpzb24ocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICAoJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICBzZWxmLm9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuICB9LCB0aW1lb3V0IHx8IChzZWxmLnBpbmdJbnRlcnZhbCArIHNlbGYucGluZ1RpbWVvdXQpKTtcbn07XG5cbi8qKlxuICogUGluZ3Mgc2VydmVyIGV2ZXJ5IGB0aGlzLnBpbmdJbnRlcnZhbGAgYW5kIGV4cGVjdHMgcmVzcG9uc2VcbiAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRQaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNsZWFyVGltZW91dChzZWxmLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgc2VsZi5waW5nSW50ZXJ2YWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXMnLCBzZWxmLnBpbmdUaW1lb3V0KTtcbiAgICBzZWxmLnBpbmcoKTtcbiAgICBzZWxmLm9uSGVhcnRiZWF0KHNlbGYucGluZ1RpbWVvdXQpO1xuICB9LCBzZWxmLnBpbmdJbnRlcnZhbCk7XG59O1xuXG4vKipcbiogU2VuZHMgYSBwaW5nIHBhY2tldC5cbipcbiogQGFwaSBwcml2YXRlXG4qL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZW5kUGFja2V0KCdwaW5nJywgZnVuY3Rpb24oKXtcbiAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG5cbiAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3ZlcixcbiAgLy8gYW5kIGEgbm9uemVybyBwcmV2QnVmZmVyTGVuIGNvdWxkIGNhdXNlIHByb2JsZW1zIG9uIGBkcmFpbmBcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblxuICBpZiAoMCA9PT0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIGRlYnVnKCdmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldCcsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMud3JpdGVCdWZmZXIpO1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcbiAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcbiAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLndyaXRlID1cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGZuKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIG1zZywgb3B0aW9ucywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG4gIGlmKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICBmbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgZm4gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgaWYgKCdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuY29tcHJlc3MgPSBmYWxzZSAhPT0gb3B0aW9ucy5jb21wcmVzcztcblxuICB2YXIgcGFja2V0ID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgZGF0YTogZGF0YSxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH07XG4gIHRoaXMuZW1pdCgncGFja2V0Q3JlYXRlJywgcGFja2V0KTtcbiAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIGlmIChmbikgdGhpcy5vbmNlKCdmbHVzaCcsIGZuKTtcbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZScpO1xuICAgIHNlbGYudHJhbnNwb3J0LmNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBjbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUoKSB7XG4gICAgLy8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYub25jZSgndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgZXJyb3JcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGRlYnVnKCdzb2NrZXQgZXJyb3IgJWonLCBlcnIpO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLm9uQ2xvc2UoJ3RyYW5zcG9ydCBlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAocmVhc29uLCBkZXNjKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicsIHJlYXNvbik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gY2xlYXIgdGltZXJzXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuXG4gICAgLy8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuXG4gICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cbiAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXG4gICAgLy8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXG4gICAgLy8gY2xlYXIgc2Vzc2lvbiBpZFxuICAgIHRoaXMuaWQgPSBudWxsO1xuXG4gICAgLy8gZW1pdCBjbG9zZSBldmVudFxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24sIGRlc2MpO1xuXG4gICAgLy8gY2xlYW4gYnVmZmVycyBhZnRlciwgc28gdXNlcnMgY2FuIHN0aWxsXG4gICAgLy8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG4gICAgc2VsZi53cml0ZUJ1ZmZlciA9IFtdO1xuICAgIHNlbGYucHJldkJ1ZmZlckxlbiA9IDA7XG4gIH1cbn07XG5cbi8qKlxuICogRmlsdGVycyB1cGdyYWRlcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgbWF0Y2hpbmcgY2xpZW50IHRyYW5zcG9ydHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2VydmVyIHVwZ3JhZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcyA9IGZ1bmN0aW9uICh1cGdyYWRlcykge1xuICB2YXIgZmlsdGVyZWRVcGdyYWRlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IHVwZ3JhZGVzLmxlbmd0aDsgaTxqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi9zb2NrZXQuanNcbiAqKi8iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcob3B0cyl7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuICB2YXIgeHMgPSBmYWxzZTtcbiAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qc1xuICoqLyIsIi8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG52YXIgaGFzQ09SUyA9IHJlcXVpcmUoJ2hhcy1jb3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcbiAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIC8vIFVzZSBYRG9tYWluUmVxdWVzdCBmb3IgSUU4IGlmIGVuYWJsZXNYRFIgaXMgdHJ1ZVxuICAvLyBiZWNhdXNlIGxvYWRpbmcgYmFyIGtlZXBzIGZsYXNoaW5nIHdoZW4gdXNpbmcganNvbnAtcG9sbGluZ1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20veXVqaW9zYWthL3NvY2tlLmlvLWllOC1sb2FkaW5nLWV4YW1wbGVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcbiAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIGlmICgheGRvbWFpbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaChlKSB7IH1cbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3htbGh0dHByZXF1ZXN0LmpzXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICpcbiAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICpcbiAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICovXG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xufSBjYXRjaCAoZXJyKSB7XG4gIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaGFzLWNvcnMvaW5kZXguanNcbiAqKi8iLCIvKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSgpe31cblxuLyoqXG4gKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBYSFIob3B0cyl7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgdGhpcy54ZCA9IG9wdHMuaG9zdG5hbWUgIT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG4gICAgICBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT0gaXNTU0w7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KFhIUiwgUG9sbGluZyk7XG5cbi8qKlxuICogWEhSIHN1cHBvcnRzIGJpbmFyeVxuICovXG5cblhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKG9wdHMpe1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy51cmkgPSB0aGlzLnVyaSgpO1xuICBvcHRzLnhkID0gdGhpcy54ZDtcbiAgb3B0cy54cyA9IHRoaXMueHM7XG4gIG9wdHMuYWdlbnQgPSB0aGlzLmFnZW50IHx8IGZhbHNlO1xuICBvcHRzLnN1cHBvcnRzQmluYXJ5ID0gdGhpcy5zdXBwb3J0c0JpbmFyeTtcbiAgb3B0cy5lbmFibGVzWERSID0gdGhpcy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLmV4dHJhSGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXG4gIHJldHVybiBuZXcgUmVxdWVzdChvcHRzKTtcbn07XG5cbi8qKlxuICogU2VuZHMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbihkYXRhLCBmbil7XG4gIHZhciBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiBkYXRhICE9PSB1bmRlZmluZWQ7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgZGF0YTogZGF0YSwgaXNCaW5hcnk6IGlzQmluYXJ5IH0pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignc3VjY2VzcycsIGZuKTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnNlbmRYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygneGhyIHBvbGwnKTtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpe1xuICAgIHNlbGYub25EYXRhKGRhdGEpO1xuICB9KTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG9wdHMpe1xuICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuICB0aGlzLnhkID0gISFvcHRzLnhkO1xuICB0aGlzLnhzID0gISFvcHRzLnhzO1xuICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG4gIHRoaXMuZGF0YSA9IHVuZGVmaW5lZCAhPSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG4gIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cbiAgdGhpcy5jcmVhdGUoKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIFhIUiBvYmplY3QgYW5kIHNlbmRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmICh0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAvLyBUaGlzIGhhcyB0byBiZSBkb25lIGFmdGVyIG9wZW4gYmVjYXVzZSBGaXJlZm94IGlzIHN0dXBpZFxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzIxNjkwMy9nZXQtYmluYXJ5LWRhdGEtd2l0aC14bWxodHRwcmVxdWVzdC1pbi1hLWZpcmVmb3gtZXh0ZW5zaW9uXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB9XG5cbiAgICBpZiAoJ1BPU1QnID09IHRoaXMubWV0aG9kKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc0JpbmFyeSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICAvLyBpZTYgY2hlY2tcbiAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKDQgIT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgaWYgKDIwMCA9PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT0geGhyLnN0YXR1cykge1xuICAgICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG4gICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWJ1ZygneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYub25FcnJvcihlKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgdGhpcy5pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgdGhpcy5vblN1Y2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uKGVycil7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLmNsZWFudXAodHJ1ZSk7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBob3VzZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oZnJvbUVycm9yKXtcbiAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyB4bWxodHRwcmVxdWVzdFxuICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgIHRoaXMueGhyLm9ubG9hZCA9IHRoaXMueGhyLm9uZXJyb3IgPSBlbXB0eTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcbiAgfVxuXG4gIGlmIChmcm9tRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoKGUpIHt9XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF07XG4gIH1cblxuICB0aGlzLnhociA9IG51bGw7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGxvYWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25Mb2FkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGRhdGE7XG4gIHRyeSB7XG4gICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50VHlwZSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKS5zcGxpdCgnOycpWzBdO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkodGhpcy54aHIucmVzcG9uc2UpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHZhciB1aThBcnIgPSBuZXcgVWludDhBcnJheSh0aGlzLnhoci5yZXNwb25zZSk7XG4gICAgICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IHVpOEFyci5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGRhdGFBcnJheS5wdXNoKHVpOEFycltpZHhdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXRhQXJyYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5vbkVycm9yKGUpO1xuICB9XG4gIGlmIChudWxsICE9IGRhdGEpIHtcbiAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuaGFzWERSID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICd1bmRlZmluZWQnICE9PSB0eXBlb2YgZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmICF0aGlzLnhzICYmIHRoaXMuZW5hYmxlc1hEUjtcbn07XG5cbi8qKlxuICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuXG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIFJlcXVlc3QucmVxdWVzdHNDb3VudCA9IDA7XG4gIFJlcXVlc3QucmVxdWVzdHMgPSB7fTtcbiAgaWYgKGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb251bmxvYWQnLCB1bmxvYWRIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5sb2FkSGFuZGxlcigpIHtcbiAgZm9yICh2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG4gICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbi8qKlxuICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG4gKi9cblxudmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nKG9wdHMpe1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMucG9sbCgpO1xufTtcblxuLyoqXG4gKiBQYXVzZXMgcG9sbGluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24ob25QYXVzZSl7XG4gIHZhciBwZW5kaW5nID0gMDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblxuICBmdW5jdGlvbiBwYXVzZSgpe1xuICAgIGRlYnVnKCdwYXVzZWQnKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAncGF1c2VkJztcbiAgICBvblBhdXNlKCk7XG4gIH1cblxuICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhdXNlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3BvbGxpbmcnKTtcbiAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcbiAgdGhpcy5kb1BvbGwoKTtcbiAgdGhpcy5lbWl0KCdwb2xsJyk7XG59O1xuXG4vKipcbiAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT0gc2VsZi5yZWFkeVN0YXRlKSB7XG4gICAgICBzZWxmLm9uT3BlbigpO1xuICAgIH1cblxuICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICBpZiAoJ2Nsb3NlJyA9PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuICAgIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICB0aGlzLnBvbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9yIHBvbGxpbmcsIHNlbmQgYSBjbG9zZSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjbG9zZSgpe1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmcnKTtcbiAgICBjbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG4gICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG5vdCBvcGVuIC0gZGVmZXJyaW5nIGNsb3NlJyk7XG4gICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIHBhY2tldHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWluIGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH07XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qc1xuICoqLyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG4gIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBFbWl0cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBkZXNjKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICAgIHRoaXMuZG9PcGVuKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy53cml0ZShwYWNrZXRzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIG9wZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydC5qc1xuICoqLyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IHJlcXVpcmUoJ2hhcy1iaW5hcnknKTtcbnZhciBzbGljZUJ1ZmZlciA9IHJlcXVpcmUoJ2FycmF5YnVmZmVyLnNsaWNlJyk7XG52YXIgYmFzZTY0ZW5jb2RlciA9IHJlcXVpcmUoJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgndXRmOCcpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG4gKlxuICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAqL1xuXG52YXIgaXNBbmRyb2lkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZC9pKTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG4gKiBVcGxvYWRpbmcgYSBCbG9iIHdpdGggUGhhbnRvbUpTIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5LCBhcyByZXBvcnRlZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGlzUGhhbnRvbUpTID0gL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblxuLyoqXG4gKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5cbnZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuICAgIG9wZW46ICAgICAwICAgIC8vIG5vbi13c1xuICAsIGNsb3NlOiAgICAxICAgIC8vIG5vbi13c1xuICAsIHBpbmc6ICAgICAyXG4gICwgcG9uZzogICAgIDNcbiAgLCBtZXNzYWdlOiAgNFxuICAsIHVwZ3JhZGU6ICA1XG4gICwgbm9vcDogICAgIDZcbn07XG5cbnZhciBwYWNrZXRzbGlzdCA9IGtleXMocGFja2V0cyk7XG5cbi8qKlxuICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG4gKi9cblxudmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSBibG9iIGFwaSBldmVuIGZvciBibG9iIGJ1aWxkZXIgd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYiA9IHJlcXVpcmUoJ2Jsb2InKTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0LlxuICpcbiAqICAgICA8cGFja2V0IHR5cGUgaWQ+IFsgPGRhdGE+IF1cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA1aGVsbG8gd29ybGRcbiAqICAgICAzXG4gKiAgICAgNFxuICpcbiAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB1dGY4ZW5jb2RlLCBjYWxsYmFjaykge1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXRmOGVuY29kZSkge1xuICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICB1dGY4ZW5jb2RlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkYXRhID0gKHBhY2tldC5kYXRhID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuICBpZiAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoQmxvYiAmJiBkYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgaWYgKGRhdGEgJiYgZGF0YS5iYXNlNjQpIHtcbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG4gIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cbiAgLy8gZGF0YSBmcmFnbWVudCBpcyBvcHRpb25hbFxuICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuICAgIGVuY29kZWQgKz0gdXRmOGVuY29kZSA/IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSkpIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXG59O1xuXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuICAvLyBwYWNrZXQgZGF0YSBpcyBhbiBvYmplY3QgeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblxuICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRCdWZmZXJbaSsxXSA9IGNvbnRlbnRBcnJheVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjayhyZXN1bHRCdWZmZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHBhY2tldC5kYXRhID0gZnIucmVzdWx0O1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHRydWUsIGNhbGxiYWNrKTtcbiAgfTtcbiAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlciwgcGFja2V0LmRhdGFdKTtcblxuICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgaWYgKEJsb2IgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcbiAgICB9O1xuICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHZhciBiNjRkYXRhO1xuICB0cnkge1xuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB3aXRoIHR5cGVkIGFycmF5c1xuICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcbiAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuICAgIH1cbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYXNpYyk7XG4gIH1cbiAgbWVzc2FnZSArPSBnbG9iYWwuYnRvYShiNjRkYXRhKTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0LiBDaGFuZ2VzIGZvcm1hdCB0byBCbG9iIGlmIHJlcXVlc3RlZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIHV0ZjhkZWNvZGUpIHtcbiAgLy8gU3RyaW5nIGRhdGFcbiAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkYXRhLmNoYXJBdCgwKSA9PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICovXG5cbmV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24obXNnLCBiaW5hcnlUeXBlKSB7XG4gIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG4gIGlmICghZ2xvYmFsLkFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpc0JpbmFyeSA9IGhhc0JpbmFyeShwYWNrZXRzKTtcblxuICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaXNCaW5hcnkpIHtcbiAgICBpZiAoQmxvYiAmJiAhZG9udFNlbmRCbG9icykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYihwYWNrZXRzLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIocGFja2V0cywgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjaygnMDonKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UubGVuZ3RoICsgJzonICsgbWVzc2FnZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgIWlzQmluYXJ5ID8gZmFsc2UgOiBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcbiAqL1xuXG5mdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJ5Lmxlbmd0aCk7XG4gIHZhciBuZXh0ID0gYWZ0ZXIoYXJ5Lmxlbmd0aCwgZG9uZSk7XG5cbiAgdmFyIGVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbihpLCBlbCwgY2IpIHtcbiAgICBlYWNoKGVsLCBmdW5jdGlvbihlcnJvciwgbXNnKSB7XG4gICAgICByZXN1bHRbaV0gPSBtc2c7XG4gICAgICBjYihlcnJvciwgcmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGVhY2hXaXRoSW5kZXgoaSwgYXJ5W2ldLCBuZXh0KTtcbiAgfVxufVxuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBQb3NzaWJsZSBiaW5hcnkgY29udGVudHMgYXJlXG4gKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkYXRhICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9ICcnXG4gICAgLCBuLCBtc2c7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaHIgPSBkYXRhLmNoYXJBdChpKTtcblxuICAgIGlmICgnOicgIT0gY2hyKSB7XG4gICAgICBsZW5ndGggKz0gY2hyO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJycgPT0gbGVuZ3RoIHx8IChsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIG1zZyA9IGRhdGEuc3Vic3RyKGkgKyAxLCBuKTtcblxuICAgICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtc2cubGVuZ3RoKSB7XG4gICAgICAgIHBhY2tldCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGVyci50eXBlID09IHBhY2tldC50eXBlICYmIGVyci5kYXRhID09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgICAgLy8gcGFyc2VyIGVycm9yIGluIGluZGl2aWR1YWwgcGFja2V0IC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKHBhY2tldCwgaSArIG4sIGwpO1xuICAgICAgICBpZiAoZmFsc2UgPT09IHJldCkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhZHZhbmNlIGN1cnNvclxuICAgICAgaSArPSBuO1xuICAgICAgbGVuZ3RoID0gJyc7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxlbmd0aCAhPSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHZhciBudW1iZXJUb29Mb25nID0gZmFsc2U7XG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT0gMjU1KSBicmVhaztcblxuICAgICAgaWYgKG1zZ0xlbmd0aC5sZW5ndGggPiAzMTApIHtcbiAgICAgICAgbnVtYmVyVG9vTG9uZyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGlmKG51bWJlclRvb0xvbmcpIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuXG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDIgKyBtc2dMZW5ndGgubGVuZ3RoKTtcbiAgICBtc2dMZW5ndGggPSBwYXJzZUludChtc2dMZW5ndGgpO1xuXG4gICAgdmFyIG1zZyA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDAsIG1zZ0xlbmd0aCk7XG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtc2cgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KG1zZykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB0byB0eXBlZCBhcnJheXNcbiAgICAgICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkobXNnKTtcbiAgICAgICAgbXNnID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtc2cgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0eXBlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBidWZmZXJzLnB1c2gobXNnKTtcbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgbXNnTGVuZ3RoKTtcbiAgfVxuXG4gIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuICBidWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmZmVyLCBpKSB7XG4gICAgY2FsbGJhY2soZXhwb3J0cy5kZWNvZGVQYWNrZXQoYnVmZmVyLCBiaW5hcnlUeXBlLCB0cnVlKSwgaSwgdG90YWwpO1xuICB9KTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZW5naW5lLmlvLXBhcnNlci9saWIvYnJvd3Nlci5qc1xuICoqLyIsIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qc1xuICoqLyIsIlxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBSaWdodCBub3cgb25seSBCdWZmZXIgYW5kIEFycmF5QnVmZmVyIGFyZSBzdXBwb3J0ZWQuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG4gIGZ1bmN0aW9uIF9oYXNCaW5hcnkob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBmYWxzZTtcblxuICAgIGlmICggKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICAgIChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoX2hhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgICBpZiAob2JqLnRvSlNPTikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgX2hhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBfaGFzQmluYXJ5KGRhdGEpO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VuZ2luZS5pby1wYXJzZXIvfi9oYXMtYmluYXJ5L2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBBbiBhYnN0cmFjdGlvbiBmb3Igc2xpY2luZyBhbiBhcnJheWJ1ZmZlciBldmVuIHdoZW5cbiAqIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGFycmF5YnVmZmVyLmJ5dGVMZW5ndGg7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgZW5kID0gZW5kIHx8IGJ5dGVzO1xuXG4gIGlmIChhcnJheWJ1ZmZlci5zbGljZSkgeyByZXR1cm4gYXJyYXlidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCk7IH1cblxuICBpZiAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPCAwKSB7IGVuZCArPSBieXRlczsgfVxuICBpZiAoZW5kID4gYnl0ZXMpIHsgZW5kID0gYnl0ZXM7IH1cblxuICBpZiAoc3RhcnQgPj0gYnl0ZXMgfHwgc3RhcnQgPj0gZW5kIHx8IGJ5dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgfVxuXG4gIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShlbmQgLSBzdGFydCk7XG4gIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSAwOyBpIDwgZW5kOyBpKyssIGlpKyspIHtcbiAgICByZXN1bHRbaWldID0gYWJ2W2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQuYnVmZmVyO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9hcnJheWJ1ZmZlci5zbGljZS9pbmRleC5qc1xuICoqLyIsIi8qXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbihjaGFycyl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmICgobGVuICUgMykgPT09IDIpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9O1xuXG4gIGV4cG9ydHMuZGVjb2RlID0gIGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcbiAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcbiAgICBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICBlbmNvZGVkMSA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2ldKTtcbiAgICAgIGVuY29kZWQyID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsxXSk7XG4gICAgICBlbmNvZGVkMyA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krMl0pO1xuICAgICAgZW5jb2RlZDQgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzNdKTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KShcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIik7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cbmZ1bmN0aW9uIGFmdGVyKGNvdW50LCBjYWxsYmFjaywgZXJyX2NiKSB7XG4gICAgdmFyIGJhaWwgPSBmYWxzZVxuICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG4gICAgcHJveHkuY291bnQgPSBjb3VudFxuXG4gICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuICAgIGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG4gICAgICAgIH1cbiAgICAgICAgLS1wcm94eS5jb3VudFxuXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGJhaWwgPSB0cnVlXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJfY2JcbiAgICAgICAgfSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9hZnRlci9pbmRleC5qc1xuICoqLyIsIi8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjAuMCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHR2YXIgY291bnRlciA9IDA7XG5cdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcblx0XHRcdHRocm93IEVycm9yKFxuXHRcdFx0XHQnTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0JyBpcyBub3QgYSBzY2FsYXIgdmFsdWUnXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcblx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KSB7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDEyKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdHN5bWJvbCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoKGNvZGVQb2ludCAmIDB4M0YpIHwgMHg4MCk7XG5cdFx0cmV0dXJuIHN5bWJvbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdFx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gYnl0ZVN0cmluZztcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuXHRcdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHRpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG5cdFx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNvZGVTeW1ib2woKSB7XG5cdFx0dmFyIGJ5dGUxO1xuXHRcdHZhciBieXRlMjtcblx0XHR2YXIgYnl0ZTM7XG5cdFx0dmFyIGJ5dGU0O1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cblx0XHRpZiAoYnl0ZUluZGV4ID4gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBSZWFkIGZpcnN0IGJ5dGVcblx0XHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gYnl0ZTE7XG5cdFx0fVxuXG5cdFx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RTApID09IDB4QzApIHtcblx0XHRcdHZhciBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xuXHR9XG5cblx0dmFyIGJ5dGVBcnJheTtcblx0dmFyIGJ5dGVDb3VudDtcblx0dmFyIGJ5dGVJbmRleDtcblx0ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nKSB7XG5cdFx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0XHRieXRlQ291bnQgPSBieXRlQXJyYXkubGVuZ3RoO1xuXHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0XHR2YXIgdG1wO1xuXHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKCkpICE9PSBmYWxzZSkge1xuXHRcdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdFx0fVxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHV0ZjggPSB7XG5cdFx0J3ZlcnNpb24nOiAnMi4wLjAnLFxuXHRcdCdlbmNvZGUnOiB1dGY4ZW5jb2RlLFxuXHRcdCdkZWNvZGUnOiB1dGY4ZGVjb2RlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdXRmODtcblx0XHR9KTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdGZvciAodmFyIGtleSBpbiB1dGY4KSB7XG5cdFx0XHRcdGhhc093blByb3BlcnR5LmNhbGwodXRmOCwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHV0Zjhba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC51dGY4ID0gdXRmODtcblx0fVxuXG59KHRoaXMpKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi91dGY4L3V0ZjguanNcbiAqKi8iLCIvKipcbiAqIENyZWF0ZSBhIGJsb2IgYnVpbGRlciBldmVuIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2JCdWlsZGVyID0gZ2xvYmFsLkJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTW96QmxvYkJ1aWxkZXI7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XG4gICAgcmV0dXJuIGEuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3Igc3VwcG9ydHMgQXJyYXlCdWZmZXJWaWV3c1xuICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoWzEsMl0pXSk7XG4gICAgcmV0dXJuIGIuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmRcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xuICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XG4gKiBzdXBwb3J0IGl0IGluIHRoZSBCbG9iIGNvbnN0cnVjdG9yLlxuICovXG5cbmZ1bmN0aW9uIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNodW5rID0gYXJ5W2ldO1xuICAgIGlmIChjaHVuay5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBhIHN1YmFycmF5LCBtYWtlIGEgY29weSBzbyB3ZSBvbmx5XG4gICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoICE9PSBidWYuYnl0ZUxlbmd0aCkge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgYnVmID0gY29weS5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGFyeVtpXSA9IGJ1ZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGJiLmFwcGVuZChhcnlbaV0pO1xuICB9XG5cbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xufTtcblxuZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSk7XG4gIHJldHVybiBuZXcgQmxvYihhcnksIG9wdGlvbnMgfHwge30pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGlmIChibG9iU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IGdsb2JhbC5CbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xuICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufSkoKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9ibG9iL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBDb21waWxlcyBhIHF1ZXJ5c3RyaW5nXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHN0ciA9ICcnO1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgaWYgKHN0ci5sZW5ndGgpIHN0ciArPSAnJic7XG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2ltcGxlIHF1ZXJ5c3RyaW5nIGludG8gYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHFzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKHFzKXtcbiAgdmFyIHFyeSA9IHt9O1xuICB2YXIgcGFpcnMgPSBxcy5zcGxpdCgnJicpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcbiAgICBxcnlbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgfVxuICByZXR1cm4gcXJ5O1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9wYXJzZXFzL2luZGV4LmpzXG4gKiovIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICB2YXIgZm4gPSBmdW5jdGlvbigpe307XG4gIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcbiAgYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhO1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29tcG9uZW50LWluaGVyaXQvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fJy5zcGxpdCgnJylcbiAgLCBsZW5ndGggPSA2NFxuICAsIG1hcCA9IHt9XG4gICwgc2VlZCA9IDBcbiAgLCBpID0gMFxuICAsIHByZXY7XG5cbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlci5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShudW0pIHtcbiAgdmFyIGVuY29kZWQgPSAnJztcblxuICBkbyB7XG4gICAgZW5jb2RlZCA9IGFscGhhYmV0W251bSAlIGxlbmd0aF0gKyBlbmNvZGVkO1xuICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gbGVuZ3RoKTtcbiAgfSB3aGlsZSAobnVtID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgdmFyIGRlY29kZWQgPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBkZWNvZGVkID0gZGVjb2RlZCAqIGxlbmd0aCArIG1hcFtzdHIuY2hhckF0KGkpXTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVkO1xufVxuXG4vKipcbiAqIFllYXN0OiBBIHRpbnkgZ3Jvd2luZyBpZCBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gQSB1bmlxdWUgaWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB5ZWFzdCgpIHtcbiAgdmFyIG5vdyA9IGVuY29kZSgrbmV3IERhdGUoKSk7XG5cbiAgaWYgKG5vdyAhPT0gcHJldikgcmV0dXJuIHNlZWQgPSAwLCBwcmV2ID0gbm93O1xuICByZXR1cm4gbm93ICsnLicrIGVuY29kZShzZWVkKyspO1xufVxuXG4vL1xuLy8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cbi8vXG5mb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBtYXBbYWxwaGFiZXRbaV1dID0gaTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgYHllYXN0YCwgYGVuY29kZWAgYW5kIGBkZWNvZGVgIGZ1bmN0aW9ucy5cbi8vXG55ZWFzdC5lbmNvZGUgPSBlbmNvZGU7XG55ZWFzdC5kZWNvZGUgPSBkZWNvZGU7XG5tb2R1bGUuZXhwb3J0cyA9IHllYXN0O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3llYXN0L2luZGV4LmpzXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIENhbGxiYWNrcyBjb3VudC5cbiAqL1xuXG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICBpZiAoIWNhbGxiYWNrcykge1xuICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG4gICAgaWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgIH0sIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KEpTT05QUG9sbGluZywgUG9sbGluZyk7XG5cbi8qXG4gKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG4vKipcbiAqIENsb3NlcyB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuZm9ybSkge1xuICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gIH1cblxuICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBpZiAoaW5zZXJ0QXQpIHtcbiAgICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgfVxuICBlbHNlIHtcbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9XG4gIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG4gIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIFxuICBpZiAoaXNVQWdlY2tvKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSwgMTAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5mb3JtKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgdmFyIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHZhciBpZCA9IHRoaXMuaWZyYW1lSWQgPSAnZWlvX2lmcmFtZV8nICsgdGhpcy5pbmRleDtcbiAgICB2YXIgaWZyYW1lO1xuXG4gICAgZm9ybS5jbGFzc05hbWUgPSAnc29ja2V0aW8nO1xuICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGZvcm0uc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgIGZvcm0uc3R5bGUubGVmdCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnRhcmdldCA9IGlkO1xuICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY2NlcHQtY2hhcnNldCcsICd1dGYtOCcpO1xuICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIHRoaXMuYXJlYSA9IGFyZWE7XG4gIH1cblxuICB0aGlzLmZvcm0uYWN0aW9uID0gdGhpcy51cmkoKTtcblxuICBmdW5jdGlvbiBjb21wbGV0ZSAoKSB7XG4gICAgaW5pdElmcmFtZSgpO1xuICAgIGZuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcbiAgICBpZiAoc2VsZi5pZnJhbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbGluZyBpZnJhbWUgcmVtb3ZhbCBlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICAgIHZhciBodG1sID0gJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicrIHNlbGYuaWZyYW1lSWQgKydcIj4nO1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcbiAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICB9XG5cbiAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG4gICAgc2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG4gIH1cblxuICBpbml0SWZyYW1lKCk7XG5cbiAgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG4gIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG4gIHRoaXMuYXJlYS52YWx1ZSA9IGRhdGEucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJyk7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmZvcm0uc3VibWl0KCk7XG4gIH0gY2F0Y2goZSkge31cblxuICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcbiAgICB0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pZnJhbWUub25sb2FkID0gY29tcGxldGU7XG4gIH1cbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xudmFyIEJyb3dzZXJXZWJTb2NrZXQgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5cbi8qKlxuICogR2V0IGVpdGhlciB0aGUgYFdlYlNvY2tldGAgb3IgYE1veldlYlNvY2tldGAgZ2xvYmFsc1xuICogaW4gdGhlIGJyb3dzZXIgb3IgdHJ5IHRvIHJlc29sdmUgV2ViU29ja2V0LWNvbXBhdGlibGVcbiAqIGludGVyZmFjZSBleHBvc2VkIGJ5IGB3c2AgZm9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudC5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldDtcbmlmICghV2ViU29ja2V0ICYmIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRyeSB7XG4gICAgV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcbiAgfSBjYXRjaCAoZSkgeyB9XG59XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdTKG9wdHMpe1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLmNoZWNrKCkpIHtcbiAgICAvLyBsZXQgcHJvYmUgdGltZW91dFxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB2b2lkKDApO1xuICB2YXIgb3B0cyA9IHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZVxuICB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgb3B0cy5oZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG4gIH1cblxuICB0aGlzLndzID0gQnJvd3NlcldlYlNvY2tldCA/IG5ldyBXZWJTb2NrZXQodXJpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuXG4gIGlmICh0aGlzLndzLmJpbmFyeVR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLndzLnN1cHBvcnRzICYmIHRoaXMud3Muc3VwcG9ydHMuYmluYXJ5KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2J1ZmZlcic7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgfVxuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG5cbi8qKlxuICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgfTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldil7XG4gICAgc2VsZi5vbkRhdGEoZXYuZGF0YSk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBvbkRhdGFgIHRvIHVzZSBhIHRpbWVyIG9uIGlPUy5cbiAqIFNlZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWxvdWdocmFuLzIwNTIwMDZcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5pZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvclxuICAmJiAvaVBhZHxpUGhvbmV8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgV1MucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YS5jYWxsKHNlbGYsIGRhdGEpO1xuICAgIH0sIDApO1xuICB9O1xufVxuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG4gIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcbiAgdmFyIHRvdGFsID0gcGFja2V0cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG90YWw7IGkgPCBsOyBpKyspIHtcbiAgICAoZnVuY3Rpb24ocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoIUJyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAvLyBhbHdheXMgY3JlYXRlIGEgbmV3IG9iamVjdCAoR0gtNDM3KVxuICAgICAgICAgIHZhciBvcHRzID0ge307XG4gICAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSAnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSA/IGdsb2JhbC5CdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA8IHNlbGYucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL1NvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgICAgLy9oYXZlIGEgY2hhbmNlIG9mIGluZm9ybWluZyB1cyBhYm91dCBpdCB5ZXQsIGluIHRoYXQgY2FzZSBzZW5kIHdpbGxcbiAgICAgICAgLy90aHJvdyBhbiBlcnJvclxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICBkZWJ1Zygnd2Vic29ja2V0IGNsb3NlZCBiZWZvcmUgb25jbG9zZSBldmVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLS10b3RhbCB8fCBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KShwYWNrZXRzW2ldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUoKXtcbiAgICBzZWxmLmVtaXQoJ2ZsdXNoJyk7XG5cbiAgICAvLyBmYWtlIGRyYWluXG4gICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbigpe1xuICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLndzLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0MylcbiAgICB8fCAoJ3dzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcbiAgaWYgKHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICAvLyBjb21tdW5pY2F0ZSBiaW5hcnkgc3VwcG9ydCBjYXBhYmlsaXRpZXNcbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cbi8qKlxuICogRmVhdHVyZSBkZXRlY3Rpb24gZm9yIFdlYlNvY2tldC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoaXMgdHJhbnNwb3J0IGlzIGF2YWlsYWJsZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICEhV2ViU29ja2V0ICYmICEoJ19faW5pdGlhbGl6ZScgaW4gV2ViU29ja2V0ICYmIHRoaXMubmFtZSA9PT0gV1MucHJvdG90eXBlLm5hbWUpO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qc1xuICoqLyIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogd3MgKGlnbm9yZWQpXG4gKiogbW9kdWxlIGlkID0gMjM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2luZGV4b2YvaW5kZXguanNcbiAqKi8iLCIvKipcbiAqIEpTT04gcGFyc2UuXG4gKlxuICogQHNlZSBCYXNlZCBvbiBqUXVlcnkjcGFyc2VKU09OIChNSVQpIGFuZCBKU09OMlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHJ2YWxpZGNoYXJzID0gL15bXFxdLDp7fVxcc10qJC87XG52YXIgcnZhbGlkZXNjYXBlID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZztcbnZhciBydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XG52YXIgcnZhbGlkYnJhY2VzID0gLyg/Ol58OnwsKSg/OlxccypcXFspKy9nO1xudmFyIHJ0cmltTGVmdCA9IC9eXFxzKy87XG52YXIgcnRyaW1SaWdodCA9IC9cXHMrJC87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2Vqc29uKGRhdGEpIHtcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBkYXRhIHx8ICFkYXRhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJ0cmltTGVmdCwgJycpLnJlcGxhY2UocnRyaW1SaWdodCwgJycpO1xuXG4gIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxuICBpZiAoZ2xvYmFsLkpTT04gJiYgSlNPTi5wYXJzZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICB9XG5cbiAgaWYgKHJ2YWxpZGNoYXJzLnRlc3QoZGF0YS5yZXBsYWNlKHJ2YWxpZGVzY2FwZSwgJ0AnKVxuICAgICAgLnJlcGxhY2UocnZhbGlkdG9rZW5zLCAnXScpXG4gICAgICAucmVwbGFjZShydmFsaWRicmFjZXMsICcnKSkpIHtcbiAgICByZXR1cm4gKG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyBkYXRhKSkoKTtcbiAgfVxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcGFyc2Vqc29uL2luZGV4LmpzXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgndG8tYXJyYXknKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaGFzQmluID0gcmVxdWlyZSgnaGFzLWJpbmFyeScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cbiAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBldmVudHMgPSB7XG4gIGNvbm5lY3Q6IDEsXG4gIGNvbm5lY3RfZXJyb3I6IDEsXG4gIGNvbm5lY3RfdGltZW91dDogMSxcbiAgY29ubmVjdGluZzogMSxcbiAgZGlzY29ubmVjdDogMSxcbiAgZXJyb3I6IDEsXG4gIHJlY29ubmVjdDogMSxcbiAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG4gIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG4gIHJlY29ubmVjdF9lcnJvcjogMSxcbiAgcmVjb25uZWN0aW5nOiAxLFxuICBwaW5nOiAxLFxuICBwb25nOiAxXG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIGBFbWl0dGVyI2VtaXRgLlxuICovXG5cbnZhciBlbWl0ID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuLyoqXG4gKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldChpbywgbnNwKXtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnN1YnMpIHJldHVybjtcblxuICB2YXIgaW8gPSB0aGlzLmlvO1xuICB0aGlzLnN1YnMgPSBbXG4gICAgb24oaW8sICdvcGVuJywgYmluZCh0aGlzLCAnb25vcGVuJykpLFxuICAgIG9uKGlvLCAncGFja2V0JywgYmluZCh0aGlzLCAnb25wYWNrZXQnKSksXG4gICAgb24oaW8sICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSlcbiAgXTtcbn07XG5cbi8qKlxuICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPVxuU29ja2V0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnN1YkV2ZW50cygpO1xuICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgaWYgKCdvcGVuJyA9PSB0aGlzLmlvLnJlYWR5U3RhdGUpIHRoaXMub25vcGVuKCk7XG4gIHRoaXMuZW1pdCgnY29ubmVjdGluZycpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYGVtaXRgLlxuICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldil7XG4gIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIHZhciBwYXJzZXJUeXBlID0gcGFyc2VyLkVWRU5UOyAvLyBkZWZhdWx0XG4gIGlmIChoYXNCaW4oYXJncykpIHsgcGFyc2VyVHlwZSA9IHBhcnNlci5CSU5BUllfRVZFTlQ7IH0gLy8gYmluYXJ5XG4gIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlclR5cGUsIGRhdGE6IGFyZ3MgfTtcblxuICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuICBwYWNrZXQub3B0aW9ucy5jb21wcmVzcyA9ICF0aGlzLmZsYWdzIHx8IGZhbHNlICE9PSB0aGlzLmZsYWdzLmNvbXByZXNzO1xuXG4gIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgZGVsZXRlIHRoaXMuZmxhZ3M7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3RyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZycpO1xuXG4gIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuICBpZiAoJy8nICE9IHRoaXMubnNwKSB7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuQ09OTkVDVCB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGlmIChwYWNrZXQubnNwICE9IHRoaXMubnNwKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgZGVidWcoJ2VtaXR0aW5nIGV2ZW50ICVqJywgYXJncyk7XG5cbiAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgZGVidWcoJ2F0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnQnKTtcbiAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbihpZCl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICBzZW50ID0gdHJ1ZTtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHZhciB0eXBlID0gaGFzQmluKGFyZ3MpID8gcGFyc2VyLkJJTkFSWV9BQ0sgOiBwYXJzZXIuQUNLO1xuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBhY2spIHtcbiAgICBkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdiYWQgYWNrICVzJywgcGFja2V0LmlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG59O1xuXG4vKipcbiAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbigpe1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIHRoaXMub25jbG9zZSgnaW8gc2VydmVyIGRpc2Nvbm5lY3QnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cbiAqXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuc3Vicykge1xuICAgIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnN1YnNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLnN1YnMgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5pby5kZXN0cm95KHRoaXMpO1xufTtcblxuLyoqXG4gKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0IG1hbnVhbGx5LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID1cblNvY2tldC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGRlYnVnKCdwZXJmb3JtaW5nIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcbiAgdGhpcy5kZXN0cm95KCk7XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgLy8gZmlyZSBldmVudHNcbiAgICB0aGlzLm9uY2xvc2UoJ2lvIGNsaWVudCBkaXNjb25uZWN0Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbihjb21wcmVzcyl7XG4gIHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHx8IHt9O1xuICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanNcbiAqKi8iLCJcbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICBmdW5jdGlvbiBvbigpIHtcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5XG5cbmZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgaW5kZXgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXVxuXG4gICAgaW5kZXggPSBpbmRleCB8fCAwXG5cbiAgICBmb3IgKHZhciBpID0gaW5kZXggfHwgMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaSAtIGluZGV4XSA9IGxpc3RbaV1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi90by1hcnJheS9pbmRleC5qc1xuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uO1xuXG4vKipcbiAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxFdmVudEVtaXR0ZXJ9IG9iaiB3aXRoIGBFbWl0dGVyYCBtaXhpbiBvciBgRXZlbnRFbWl0dGVyYFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG9uKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcbiAgICB9XG4gIH07XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9saWIvb24uanNcbiAqKi8iLCIvKipcbiAqIFNsaWNlIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuLyoqXG4gKiBCaW5kIGBvYmpgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIG9yIHN0cmluZ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZm4pIGZuID0gb2JqW2ZuXTtcbiAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmQoKSByZXF1aXJlcyBhIGZ1bmN0aW9uJyk7XG4gIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfVxufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb21wb25lbnQtYmluZC9pbmRleC5qc1xuICoqLyIsIlxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBSaWdodCBub3cgb25seSBCdWZmZXIgYW5kIEFycmF5QnVmZmVyIGFyZSBzdXBwb3J0ZWQuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG4gIGZ1bmN0aW9uIF9oYXNCaW5hcnkob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBmYWxzZTtcblxuICAgIGlmICggKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICAgICAgKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSlcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChfaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmopIHtcbiAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcbiAgICAgIGlmIChvYmoudG9KU09OICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIG9iai50b0pTT04pIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oYXMtYmluYXJ5L2luZGV4LmpzXG4gKiovIiwiXG4vKipcbiAqIEV4cG9zZSBgQmFja29mZmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuICB0aGlzLm1zID0gbWluO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG4gIHRoaXMubWF4ID0gbWF4O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcbiAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYmFja28yL2luZGV4LmpzXG4gKiovIiwiZXhwb3J0IGNvbnN0IENPTk5FQ1QgPSAnQ09OTkVDVCc7XG5leHBvcnQgY29uc3QgRElTQ09OTkVDVCA9ICdESVNDT05ORUNUJztcbmV4cG9ydCBjb25zdCBQT1NUX01FU1NBR0UgPSAnUE9TVF9NRVNTQUdFJztcbmV4cG9ydCBjb25zdCBSRUNFSVZFX01FU1NBR0UgPSAnUkVDRUlWRV9NRVNTQUdFJztcbmV4cG9ydCBjb25zdCBVUERBVEUgPSAnVVBEQVRFJztcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vY29uc3RhbnRzLmpzXG4gKiovIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSAncmVkdXgnO1xuXG5mdW5jdGlvbiBzb2NrZXQoc3RhdGUgPSB7fSwgYWN0aW9uKSB7XG4gIHN3aXRjaChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ0NPTk5FQ1QnOlxuICAgICAgcmV0dXJuIGFjdGlvbi5zb2NrZXQ7XG4gICAgY2FzZSAnRElTQ09OTkVDVCc6XG4gICAgICByZXR1cm4ge307XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwbGF5KHN0YXRlID0gXCJcIiwgYWN0aW9uKSB7XG4gIHN3aXRjaChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ1VQREFURSc6XG4gICAgICByZXR1cm4gYWN0aW9uLm5hbWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGRpc3BsYXksXG4gIHNvY2tldCxcbn0pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9yZWR1Y2Vycy5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=