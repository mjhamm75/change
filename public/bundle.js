/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(34);
	
	var _reactRedux = __webpack_require__(172);
	
	var _redux = __webpack_require__(179);
	
	var _reduxThunk = __webpack_require__(196);
	
	var _reduxThunk2 = _interopRequireDefault(_reduxThunk);
	
	var _App = __webpack_require__(197);
	
	var _App2 = _interopRequireDefault(_App);
	
	var _reducers = __webpack_require__(302);
	
	var _reducers2 = _interopRequireDefault(_reducers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var store = (0, _redux.createStore)(_reducers2.default, (0, _redux.applyMiddleware)(_reduxThunk2.default)); // import io from 'socket.io-client';
	//
	// let socket = io();
	//
	// socket.on('connection', s => {
	//   console.log('a user connected');
	//   s.on('disconnect', function(){
	//     console.log('user disconnected');
	//   });
	// });
	
	
	(0, _reactDom.render)(_react2.default.createElement(
	  _reactRedux.Provider,
	  { store: store },
	  _react2.default.createElement(_App2.default, null)
	), document.getElementById('app'));

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(2);

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var ReactChildren = __webpack_require__(5);
	var ReactComponent = __webpack_require__(17);
	var ReactPureComponent = __webpack_require__(20);
	var ReactClass = __webpack_require__(21);
	var ReactDOMFactories = __webpack_require__(26);
	var ReactElement = __webpack_require__(9);
	var ReactPropTypes = __webpack_require__(31);
	var ReactVersion = __webpack_require__(32);
	
	var onlyChild = __webpack_require__(33);
	var warning = __webpack_require__(11);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(27);
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var __spread = _assign;
	
	if (process.env.NODE_ENV !== 'production') {
	  var warned = false;
	  __spread = function __spread() {
	    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
	    warned = true;
	    return _assign.apply(null, arguments);
	  };
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	  PureComponent: ReactPureComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function createMixin(mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Deprecated hook for JSX spread, don't use this for anything.
	  __spread: __spread
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict';
	
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc'); // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(6);
	var ReactElement = __webpack_require__(9);
	
	var emptyFunction = __webpack_require__(12);
	var traverseAllChildren = __webpack_require__(14);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function fiveArgumentPooler(a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function standardReleaser(instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule reactProdInvariant
	 * 
	 */
	'use strict';
	
	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */
	
	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;
	
	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }
	
	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	  throw error;
	}
	
	module.exports = reactProdInvariant;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _assign = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(10);
	
	var warning = __webpack_require__(11);
	var canDefineProperty = __webpack_require__(13);
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	var specialPropKeyWarningShown, specialPropRefWarningShown;
	
	function hasValidRef(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}
	
	function hasValidKey(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}
	
	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function warnAboutAccessingKey() {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}
	
	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function warnAboutAccessingRef() {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}
	
	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	    var shadowChildren = Array.isArray(props.children) ? props.children.slice(0) : props.children;
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      Object.defineProperty(element, '_shadowChildren', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: shadowChildren
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._shadowChildren = shadowChildren;
	      element._source = source;
	    }
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }
	
	  return element;
	};
	
	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
	 */
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(
	      /* eslint-disable no-proto */
	      config.__proto__ == null || config.__proto__ === Object.prototype,
	      /* eslint-enable no-proto */
	      'React.createElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
	    }
	
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (key || ref) {
	      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
	        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	        if (key) {
	          defineKeyPropWarningGetter(props, displayName);
	        }
	        if (ref) {
	          defineRefPropWarningGetter(props, displayName);
	        }
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
	 */
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
	 */
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = _assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(
	      /* eslint-disable no-proto */
	      config.__proto__ == null || config.__proto__ === Object.prototype,
	      /* eslint-enable no-proto */
	      'React.cloneElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
	    }
	
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    // Remaining properties override existing props
	    var defaultProps;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * Verifies the object is a ReactElement.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	ReactElement.REACT_ELEMENT_TYPE = REACT_ELEMENT_TYPE;
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 10 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(12);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };
	
	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }
	
	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }
	
	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }
	
	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    Object.defineProperty({}, 'x', { get: function get() {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactCurrentOwner = __webpack_require__(10);
	var ReactElement = __webpack_require__(9);
	
	var getIteratorFn = __webpack_require__(15);
	var invariant = __webpack_require__(8);
	var KeyEscapeUtils = __webpack_require__(16);
	var warning = __webpack_require__(11);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && (typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 15 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * 
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 16 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule KeyEscapeUtils
	 * 
	 */
	
	'use strict';
	
	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });
	
	  return '$' + escapedString;
	}
	
	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
	
	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}
	
	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};
	
	module.exports = KeyEscapeUtils;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactNoopUpdateQueue = __webpack_require__(18);
	
	var canDefineProperty = __webpack_require__(13);
	var emptyObject = __webpack_require__(19);
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'setState');
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'forceUpdate');
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */
	
	'use strict';
	
	var warning = __webpack_require__(11);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    warnNoop(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    warnNoop(publicInstance, 'setState');
	  }
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPureComponent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var ReactComponent = __webpack_require__(17);
	var ReactNoopUpdateQueue = __webpack_require__(18);
	
	var emptyObject = __webpack_require__(19);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactPureComponent(props, context, updater) {
	  // Duplicated from ReactComponent.
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	function ComponentDummy() {}
	ComponentDummy.prototype = ReactComponent.prototype;
	ReactPureComponent.prototype = new ComponentDummy();
	ReactPureComponent.prototype.constructor = ReactPureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(ReactPureComponent.prototype, ReactComponent.prototype);
	ReactPureComponent.prototype.isPureReactComponent = true;
	
	module.exports = ReactPureComponent;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var ReactComponent = __webpack_require__(17);
	var ReactElement = __webpack_require__(9);
	var ReactPropTypeLocations = __webpack_require__(22);
	var ReactPropTypeLocationNames = __webpack_require__(24);
	var ReactNoopUpdateQueue = __webpack_require__(18);
	
	var emptyObject = __webpack_require__(19);
	var invariant = __webpack_require__(8);
	var keyMirror = __webpack_require__(23);
	var keyOf = __webpack_require__(25);
	var warning = __webpack_require__(11);
	
	var MIXINS_KEY = keyOf({ mixins: null });
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});
	
	var injectedMixins = [];
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or host components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function displayName(Constructor, _displayName) {
	    Constructor.displayName = _displayName;
	  },
	  mixins: function mixins(Constructor, _mixins) {
	    if (_mixins) {
	      for (var i = 0; i < _mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, _mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, _childContextTypes);
	  },
	  contextTypes: function contextTypes(Constructor, _contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = _assign({}, Constructor.contextTypes, _contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = _getDefaultProps;
	    }
	  },
	  propTypes: function propTypes(Constructor, _propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = _assign({}, Constructor.propTypes, _propTypes);
	  },
	  statics: function statics(Constructor, _statics) {
	    mixStaticSpecIntoComponent(Constructor, _statics);
	  },
	  autobind: function autobind() {} };
	
	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but only in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
	    }
	  }
	}
	
	function validateMethodOverride(isAlreadyDefined, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (isAlreadyDefined) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classes.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    if (process.env.NODE_ENV !== 'production') {
	      var typeofSpec = typeof spec === 'undefined' ? 'undefined' : _typeof(spec);
	      var isMixinValid = typeofSpec === 'object' && spec !== null;
	
	      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
	    }
	
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;
	
	  var proto = Constructor.prototype;
	  var autoBindPairs = proto.__reactAutoBindPairs;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    var isAlreadyDefined = proto.hasOwnProperty(name);
	    validateMethodOverride(isAlreadyDefined, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        autoBindPairs.push(name, property);
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;
	
	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && (typeof one === 'undefined' ? 'undefined' : _typeof(one)) === 'object' && (typeof two === 'undefined' ? 'undefined' : _typeof(two)) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  var pairs = component.__reactAutoBindPairs;
	  for (var i = 0; i < pairs.length; i += 2) {
	    var autoBindKey = pairs[i];
	    var method = pairs[i + 1];
	    component[autoBindKey] = bindAutoBindMethod(component, method);
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function replaceState(newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback, 'replaceState');
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted() {
	    return this.updater.isMounted(this);
	  }
	};
	
	var ReactClassComponent = function ReactClassComponent() {};
	_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function createClass(spec) {
	    var Constructor = function Constructor(props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (initialState === undefined && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;
	
	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function injectMixin(mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(23);
	
	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});
	
	module.exports = ReactPropTypeLocations;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function keyMirror(obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : void 0;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 25 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	
	var keyOf = function keyOf(oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};
	
	module.exports = keyOf;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(9);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @private
	 */
	var createDOMFactory = ReactElement.createFactory;
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(27);
	  createDOMFactory = ReactElementValidator.createFactory;
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = {
	  a: createDOMFactory('a'),
	  abbr: createDOMFactory('abbr'),
	  address: createDOMFactory('address'),
	  area: createDOMFactory('area'),
	  article: createDOMFactory('article'),
	  aside: createDOMFactory('aside'),
	  audio: createDOMFactory('audio'),
	  b: createDOMFactory('b'),
	  base: createDOMFactory('base'),
	  bdi: createDOMFactory('bdi'),
	  bdo: createDOMFactory('bdo'),
	  big: createDOMFactory('big'),
	  blockquote: createDOMFactory('blockquote'),
	  body: createDOMFactory('body'),
	  br: createDOMFactory('br'),
	  button: createDOMFactory('button'),
	  canvas: createDOMFactory('canvas'),
	  caption: createDOMFactory('caption'),
	  cite: createDOMFactory('cite'),
	  code: createDOMFactory('code'),
	  col: createDOMFactory('col'),
	  colgroup: createDOMFactory('colgroup'),
	  data: createDOMFactory('data'),
	  datalist: createDOMFactory('datalist'),
	  dd: createDOMFactory('dd'),
	  del: createDOMFactory('del'),
	  details: createDOMFactory('details'),
	  dfn: createDOMFactory('dfn'),
	  dialog: createDOMFactory('dialog'),
	  div: createDOMFactory('div'),
	  dl: createDOMFactory('dl'),
	  dt: createDOMFactory('dt'),
	  em: createDOMFactory('em'),
	  embed: createDOMFactory('embed'),
	  fieldset: createDOMFactory('fieldset'),
	  figcaption: createDOMFactory('figcaption'),
	  figure: createDOMFactory('figure'),
	  footer: createDOMFactory('footer'),
	  form: createDOMFactory('form'),
	  h1: createDOMFactory('h1'),
	  h2: createDOMFactory('h2'),
	  h3: createDOMFactory('h3'),
	  h4: createDOMFactory('h4'),
	  h5: createDOMFactory('h5'),
	  h6: createDOMFactory('h6'),
	  head: createDOMFactory('head'),
	  header: createDOMFactory('header'),
	  hgroup: createDOMFactory('hgroup'),
	  hr: createDOMFactory('hr'),
	  html: createDOMFactory('html'),
	  i: createDOMFactory('i'),
	  iframe: createDOMFactory('iframe'),
	  img: createDOMFactory('img'),
	  input: createDOMFactory('input'),
	  ins: createDOMFactory('ins'),
	  kbd: createDOMFactory('kbd'),
	  keygen: createDOMFactory('keygen'),
	  label: createDOMFactory('label'),
	  legend: createDOMFactory('legend'),
	  li: createDOMFactory('li'),
	  link: createDOMFactory('link'),
	  main: createDOMFactory('main'),
	  map: createDOMFactory('map'),
	  mark: createDOMFactory('mark'),
	  menu: createDOMFactory('menu'),
	  menuitem: createDOMFactory('menuitem'),
	  meta: createDOMFactory('meta'),
	  meter: createDOMFactory('meter'),
	  nav: createDOMFactory('nav'),
	  noscript: createDOMFactory('noscript'),
	  object: createDOMFactory('object'),
	  ol: createDOMFactory('ol'),
	  optgroup: createDOMFactory('optgroup'),
	  option: createDOMFactory('option'),
	  output: createDOMFactory('output'),
	  p: createDOMFactory('p'),
	  param: createDOMFactory('param'),
	  picture: createDOMFactory('picture'),
	  pre: createDOMFactory('pre'),
	  progress: createDOMFactory('progress'),
	  q: createDOMFactory('q'),
	  rp: createDOMFactory('rp'),
	  rt: createDOMFactory('rt'),
	  ruby: createDOMFactory('ruby'),
	  s: createDOMFactory('s'),
	  samp: createDOMFactory('samp'),
	  script: createDOMFactory('script'),
	  section: createDOMFactory('section'),
	  select: createDOMFactory('select'),
	  small: createDOMFactory('small'),
	  source: createDOMFactory('source'),
	  span: createDOMFactory('span'),
	  strong: createDOMFactory('strong'),
	  style: createDOMFactory('style'),
	  sub: createDOMFactory('sub'),
	  summary: createDOMFactory('summary'),
	  sup: createDOMFactory('sup'),
	  table: createDOMFactory('table'),
	  tbody: createDOMFactory('tbody'),
	  td: createDOMFactory('td'),
	  textarea: createDOMFactory('textarea'),
	  tfoot: createDOMFactory('tfoot'),
	  th: createDOMFactory('th'),
	  thead: createDOMFactory('thead'),
	  time: createDOMFactory('time'),
	  title: createDOMFactory('title'),
	  tr: createDOMFactory('tr'),
	  track: createDOMFactory('track'),
	  u: createDOMFactory('u'),
	  ul: createDOMFactory('ul'),
	  'var': createDOMFactory('var'),
	  video: createDOMFactory('video'),
	  wbr: createDOMFactory('wbr'),
	
	  // SVG
	  circle: createDOMFactory('circle'),
	  clipPath: createDOMFactory('clipPath'),
	  defs: createDOMFactory('defs'),
	  ellipse: createDOMFactory('ellipse'),
	  g: createDOMFactory('g'),
	  image: createDOMFactory('image'),
	  line: createDOMFactory('line'),
	  linearGradient: createDOMFactory('linearGradient'),
	  mask: createDOMFactory('mask'),
	  path: createDOMFactory('path'),
	  pattern: createDOMFactory('pattern'),
	  polygon: createDOMFactory('polygon'),
	  polyline: createDOMFactory('polyline'),
	  radialGradient: createDOMFactory('radialGradient'),
	  rect: createDOMFactory('rect'),
	  stop: createDOMFactory('stop'),
	  svg: createDOMFactory('svg'),
	  text: createDOMFactory('text'),
	  tspan: createDOMFactory('tspan')
	};
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var ReactCurrentOwner = __webpack_require__(10);
	var ReactComponentTreeHook = __webpack_require__(28);
	var ReactElement = __webpack_require__(9);
	var ReactPropTypeLocations = __webpack_require__(22);
	
	var checkReactTypeSpec = __webpack_require__(29);
	
	var canDefineProperty = __webpack_require__(13);
	var getIteratorFn = __webpack_require__(15);
	var warning = __webpack_require__(11);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	function getCurrentComponentErrorInfo(parentType) {
	  var info = getDeclarationErrorAddendum();
	
	  if (!info) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      info = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	  return info;
	}
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
	
	  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	  if (memoizer[currentComponentErrorInfo]) {
	    return;
	  }
	  memoizer[currentComponentErrorInfo] = true;
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwner = '';
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkReactTypeSpec(componentClass.propTypes, element.props, ReactPropTypeLocations.prop, name, element, null);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function createElement(type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    if (!validType) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
	    }
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function createFactory(type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function cloneElement(element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentTreeHook
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactCurrentOwner = __webpack_require__(10);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	function isNative(fn) {
	  // Based on isNative() from Lodash
	  var funcToString = Function.prototype.toString;
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var reIsNative = RegExp('^' + funcToString
	  // Take an example native function source for comparison
	  .call(hasOwnProperty)
	  // Strip regex characters so we can use it for regex
	  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  // Remove hasOwnProperty from the template to make it generic
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  try {
	    var source = funcToString.call(fn);
	    return reIsNative.test(source);
	  } catch (err) {
	    return false;
	  }
	}
	
	var canUseCollections =
	// Array.from
	typeof Array.from === 'function' &&
	// Map
	typeof Map === 'function' && isNative(Map) &&
	// Map.prototype.keys
	Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	// Set
	typeof Set === 'function' && isNative(Set) &&
	// Set.prototype.keys
	Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
	
	var itemMap;
	var rootIDSet;
	
	var itemByKey;
	var rootByKey;
	
	if (canUseCollections) {
	  itemMap = new Map();
	  rootIDSet = new Set();
	} else {
	  itemByKey = {};
	  rootByKey = {};
	}
	
	var unmountedIDs = [];
	
	// Use non-numeric keys to prevent V8 performance issues:
	// https://github.com/facebook/react/pull/7232
	function getKeyFromID(id) {
	  return '.' + id;
	}
	function getIDFromKey(key) {
	  return parseInt(key.substr(1), 10);
	}
	
	function get(id) {
	  if (canUseCollections) {
	    return itemMap.get(id);
	  } else {
	    var key = getKeyFromID(id);
	    return itemByKey[key];
	  }
	}
	
	function remove(id) {
	  if (canUseCollections) {
	    itemMap['delete'](id);
	  } else {
	    var key = getKeyFromID(id);
	    delete itemByKey[key];
	  }
	}
	
	function create(id, element, parentID) {
	  var item = {
	    element: element,
	    parentID: parentID,
	    text: null,
	    childIDs: [],
	    isMounted: false,
	    updateCount: 0
	  };
	
	  if (canUseCollections) {
	    itemMap.set(id, item);
	  } else {
	    var key = getKeyFromID(id);
	    itemByKey[key] = item;
	  }
	}
	
	function addRoot(id) {
	  if (canUseCollections) {
	    rootIDSet.add(id);
	  } else {
	    var key = getKeyFromID(id);
	    rootByKey[key] = true;
	  }
	}
	
	function removeRoot(id) {
	  if (canUseCollections) {
	    rootIDSet['delete'](id);
	  } else {
	    var key = getKeyFromID(id);
	    delete rootByKey[key];
	  }
	}
	
	function getRegisteredIDs() {
	  if (canUseCollections) {
	    return Array.from(itemMap.keys());
	  } else {
	    return Object.keys(itemByKey).map(getIDFromKey);
	  }
	}
	
	function getRootIDs() {
	  if (canUseCollections) {
	    return Array.from(rootIDSet.keys());
	  } else {
	    return Object.keys(rootByKey).map(getIDFromKey);
	  }
	}
	
	function purgeDeep(id) {
	  var item = get(id);
	  if (item) {
	    var childIDs = item.childIDs;
	
	    remove(id);
	    childIDs.forEach(purgeDeep);
	  }
	}
	
	function describeComponentFrame(name, source, ownerName) {
	  return '\n    in ' + name + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	}
	
	function _getDisplayName(element) {
	  if (element == null) {
	    return '#empty';
	  } else if (typeof element === 'string' || typeof element === 'number') {
	    return '#text';
	  } else if (typeof element.type === 'string') {
	    return element.type;
	  } else {
	    return element.type.displayName || element.type.name || 'Unknown';
	  }
	}
	
	function describeID(id) {
	  var name = ReactComponentTreeHook.getDisplayName(id);
	  var element = ReactComponentTreeHook.getElement(id);
	  var ownerID = ReactComponentTreeHook.getOwnerID(id);
	  var ownerName;
	  if (ownerID) {
	    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	  }
	  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	  return describeComponentFrame(name, element && element._source, ownerName);
	}
	
	var ReactComponentTreeHook = {
	  onSetChildren: function onSetChildren(id, nextChildIDs) {
	    var item = get(id);
	    item.childIDs = nextChildIDs;
	
	    for (var i = 0; i < nextChildIDs.length; i++) {
	      var nextChildID = nextChildIDs[i];
	      var nextChild = get(nextChildID);
	      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	      !(nextChild.childIDs != null || _typeof(nextChild.element) !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	      if (nextChild.parentID == null) {
	        nextChild.parentID = id;
	        // TODO: This shouldn't be necessary but mounting a new root during in
	        // componentWillMount currently causes not-yet-mounted components to
	        // be purged from our tree data so their parent ID is missing.
	      }
	      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	    }
	  },
	  onBeforeMountComponent: function onBeforeMountComponent(id, element, parentID) {
	    create(id, element, parentID);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(id, element) {
	    var item = get(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.element = element;
	  },
	  onMountComponent: function onMountComponent(id) {
	    var item = get(id);
	    item.isMounted = true;
	    var isRoot = item.parentID === 0;
	    if (isRoot) {
	      addRoot(id);
	    }
	  },
	  onUpdateComponent: function onUpdateComponent(id) {
	    var item = get(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.updateCount++;
	  },
	  onUnmountComponent: function onUnmountComponent(id) {
	    var item = get(id);
	    if (item) {
	      // We need to check if it exists.
	      // `item` might not exist if it is inside an error boundary, and a sibling
	      // error boundary child threw while mounting. Then this instance never
	      // got a chance to mount, but it still gets an unmounting event during
	      // the error boundary cleanup.
	      item.isMounted = false;
	      var isRoot = item.parentID === 0;
	      if (isRoot) {
	        removeRoot(id);
	      }
	    }
	    unmountedIDs.push(id);
	  },
	  purgeUnmountedComponents: function purgeUnmountedComponents() {
	    if (ReactComponentTreeHook._preventPurging) {
	      // Should only be used for testing.
	      return;
	    }
	
	    for (var i = 0; i < unmountedIDs.length; i++) {
	      var id = unmountedIDs[i];
	      purgeDeep(id);
	    }
	    unmountedIDs.length = 0;
	  },
	  isMounted: function isMounted(id) {
	    var item = get(id);
	    return item ? item.isMounted : false;
	  },
	  getCurrentStackAddendum: function getCurrentStackAddendum(topElement) {
	    var info = '';
	    if (topElement) {
	      var type = topElement.type;
	      var name = typeof type === 'function' ? type.displayName || type.name : type;
	      var owner = topElement._owner;
	      info += describeComponentFrame(name || 'Unknown', topElement._source, owner && owner.getName());
	    }
	
	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;
	
	    info += ReactComponentTreeHook.getStackAddendumByID(id);
	    return info;
	  },
	  getStackAddendumByID: function getStackAddendumByID(id) {
	    var info = '';
	    while (id) {
	      info += describeID(id);
	      id = ReactComponentTreeHook.getParentID(id);
	    }
	    return info;
	  },
	  getChildIDs: function getChildIDs(id) {
	    var item = get(id);
	    return item ? item.childIDs : [];
	  },
	  getDisplayName: function getDisplayName(id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element) {
	      return null;
	    }
	    return _getDisplayName(element);
	  },
	  getElement: function getElement(id) {
	    var item = get(id);
	    return item ? item.element : null;
	  },
	  getOwnerID: function getOwnerID(id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element || !element._owner) {
	      return null;
	    }
	    return element._owner._debugID;
	  },
	  getParentID: function getParentID(id) {
	    var item = get(id);
	    return item ? item.parentID : null;
	  },
	  getSource: function getSource(id) {
	    var item = get(id);
	    var element = item ? item.element : null;
	    var source = element != null ? element._source : null;
	    return source;
	  },
	  getText: function getText(id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (typeof element === 'string') {
	      return element;
	    } else if (typeof element === 'number') {
	      return '' + element;
	    } else {
	      return null;
	    }
	  },
	  getUpdateCount: function getUpdateCount(id) {
	    var item = get(id);
	    return item ? item.updateCount : 0;
	  },
	
	  getRegisteredIDs: getRegisteredIDs,
	
	  getRootIDs: getRootIDs
	};
	
	module.exports = ReactComponentTreeHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule checkReactTypeSpec
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactPropTypeLocationNames = __webpack_require__(24);
	var ReactPropTypesSecret = __webpack_require__(30);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(28);
	}
	
	var loggedTypeFailures = {};
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var componentStackInfo = '';
	
	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(28);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }
	
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}
	
	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 30 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypesSecret
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var ReactElement = __webpack_require__(9);
	var ReactPropTypeLocationNames = __webpack_require__(24);
	var ReactPropTypesSecret = __webpack_require__(30);
	
	var emptyFunction = __webpack_require__(12);
	var getIteratorFn = __webpack_require__(15);
	var warning = __webpack_require__(11);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	  symbol: createPrimitiveTypeChecker('symbol'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	/*eslint-disable no-self-compare*/
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	/*eslint-enable no-self-compare*/
	
	/**
	 * We use an Error-like object for backward compatibility as people may call
	 * PropTypes directly and inspect their output. However we don't use real
	 * Errors anymore. We don't inspect their stack anyway, and creating them
	 * is prohibitively expensive if they are created too often, such as what
	 * happens in oneOfType() for any type before the one that matched.
	 */
	function PropTypeError(message) {
	  this.message = message;
	  this.stack = '';
	}
	// Make `instanceof Error` still work for returned errors.
	PropTypeError.prototype = Error.prototype;
	
	function createChainableTypeChecker(validate) {
	  if (process.env.NODE_ENV !== 'production') {
	    var manualPropTypeCallCache = {};
	  }
	  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (process.env.NODE_ENV !== 'production') {
	      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
	        var cacheKey = componentName + ':' + propName;
	        if (!manualPropTypeCallCache[cacheKey]) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in the next major version. You may be ' + 'seeing this warning due to a third-party PropTypes library. ' + 'See https://fb.me/react-warning-dont-call-proptypes for details.', propFullName, componentName) : void 0;
	          manualPropTypeCallCache[cacheKey] = true;
	        }
	      }
	    }
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new PropTypeError('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName, secret) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	    }
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!ReactElement.isValidElement(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (is(propValue, expectedValues[i])) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	    }
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	function isSymbol(propType, propValue) {
	  // Native Symbol.
	  if (propType === 'symbol') {
	    return true;
	  }
	
	  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	  if (propValue['@@toStringTag'] === 'Symbol') {
	    return true;
	  }
	
	  // Fallback for non-spec compliant Symbols which are polyfilled.
	  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	    return true;
	  }
	
	  return false;
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  if (isSymbol(propType, propValue)) {
	    return 'symbol';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return ANONYMOUS;
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 32 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */
	
	'use strict';
	
	module.exports = '15.3.1';

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactElement = __webpack_require__(9);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(35);

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactDefaultInjection = __webpack_require__(39);
	var ReactMount = __webpack_require__(162);
	var ReactReconciler = __webpack_require__(59);
	var ReactUpdates = __webpack_require__(56);
	var ReactVersion = __webpack_require__(32);
	
	var findDOMNode = __webpack_require__(167);
	var getHostComponentFromComposite = __webpack_require__(168);
	var renderSubtreeIntoContainer = __webpack_require__(169);
	var warning = __webpack_require__(11);
	
	ReactDefaultInjection.inject();
	
	var ReactDOM = {
	  findDOMNode: findDOMNode,
	  render: ReactMount.render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    ComponentTree: {
	      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
	      getNodeFromInstance: function getNodeFromInstance(inst) {
	        // inst is an internal instance (but could be a composite)
	        if (inst._renderedComponent) {
	          inst = getHostComponentFromComposite(inst);
	        }
	        if (inst) {
	          return ReactDOMComponentTree.getNodeFromInstance(inst);
	        } else {
	          return null;
	        }
	      }
	    },
	    Mount: ReactMount,
	    Reconciler: ReactReconciler
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(49);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        // Firefox does not have the issue with devtools loaded over file://
	        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
	        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    var testFunc = function testFn() {};
	    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
	        break;
	      }
	    }
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactInstrumentation = __webpack_require__(62);
	  var ReactDOMUnknownPropertyHook = __webpack_require__(170);
	  var ReactDOMNullInputValuePropHook = __webpack_require__(171);
	
	  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
	}
	
	module.exports = ReactDOM;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponentTree
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var DOMProperty = __webpack_require__(37);
	var ReactDOMComponentFlags = __webpack_require__(38);
	
	var invariant = __webpack_require__(8);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var Flags = ReactDOMComponentFlags;
	
	var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
	
	/**
	 * Drill down (through composites and empty components) until we get a host or
	 * host text component.
	 *
	 * This is pretty polymorphic but unavoidable with the current structure we have
	 * for `_renderedChildren`.
	 */
	function getRenderedHostOrTextFromComponent(component) {
	  var rendered;
	  while (rendered = component._renderedComponent) {
	    component = rendered;
	  }
	  return component;
	}
	
	/**
	 * Populate `_hostNode` on the rendered host/text component with the given
	 * DOM node. The passed `inst` can be a composite.
	 */
	function precacheNode(inst, node) {
	  var hostInst = getRenderedHostOrTextFromComponent(inst);
	  hostInst._hostNode = node;
	  node[internalInstanceKey] = hostInst;
	}
	
	function uncacheNode(inst) {
	  var node = inst._hostNode;
	  if (node) {
	    delete node[internalInstanceKey];
	    inst._hostNode = null;
	  }
	}
	
	/**
	 * Populate `_hostNode` on each child of `inst`, assuming that the children
	 * match up with the DOM (element) children of `node`.
	 *
	 * We cache entire levels at once to avoid an n^2 problem where we access the
	 * children of a node sequentially and have to walk from the start to our target
	 * node every time.
	 *
	 * Since we update `_renderedChildren` and the actual DOM at (slightly)
	 * different times, we could race here and see a newer `_renderedChildren` than
	 * the DOM nodes we see. To avoid this, ReactMultiChild calls
	 * `prepareToManageChildren` before we change `_renderedChildren`, at which
	 * time the container's child nodes are always cached (until it unmounts).
	 */
	function precacheChildNodes(inst, node) {
	  if (inst._flags & Flags.hasCachedChildNodes) {
	    return;
	  }
	  var children = inst._renderedChildren;
	  var childNode = node.firstChild;
	  outer: for (var name in children) {
	    if (!children.hasOwnProperty(name)) {
	      continue;
	    }
	    var childInst = children[name];
	    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
	    if (childID === 0) {
	      // We're currently unmounting this child in ReactMultiChild; skip it.
	      continue;
	    }
	    // We assume the child nodes are in the same order as the child instances.
	    for (; childNode !== null; childNode = childNode.nextSibling) {
	      if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
	        precacheNode(childInst, childNode);
	        continue outer;
	      }
	    }
	    // We reached the end of the DOM children without finding an ID match.
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
	  }
	  inst._flags |= Flags.hasCachedChildNodes;
	}
	
	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }
	
	  // Walk up the tree until we find an ancestor whose instance we have cached.
	  var parents = [];
	  while (!node[internalInstanceKey]) {
	    parents.push(node);
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }
	
	  var closest;
	  var inst;
	  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
	    closest = inst;
	    if (parents.length) {
	      precacheChildNodes(inst, node);
	    }
	  }
	
	  return closest;
	}
	
	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode(node) {
	  var inst = getClosestInstanceFromNode(node);
	  if (inst != null && inst._hostNode === node) {
	    return inst;
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance(inst) {
	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  if (inst._hostNode) {
	    return inst._hostNode;
	  }
	
	  // Walk up the tree until we find an ancestor whose DOM node we have cached.
	  var parents = [];
	  while (!inst._hostNode) {
	    parents.push(inst);
	    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
	    inst = inst._hostParent;
	  }
	
	  // Now parents contains each ancestor that does *not* have a cached native
	  // node, and `inst` is the deepest ancestor that does.
	  for (; parents.length; inst = parents.pop()) {
	    precacheChildNodes(inst, inst._hostNode);
	  }
	
	  return inst._hostNode;
	}
	
	var ReactDOMComponentTree = {
	  getClosestInstanceFromNode: getClosestInstanceFromNode,
	  getInstanceFromNode: getInstanceFromNode,
	  getNodeFromInstance: getNodeFromInstance,
	  precacheChildNodes: precacheChildNodes,
	  precacheNode: precacheNode,
	  uncacheNode: uncacheNode
	};
	
	module.exports = ReactDOMComponentTree;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_PROPERTY: 0x1,
	  HAS_BOOLEAN_VALUE: 0x4,
	  HAS_NUMERIC_VALUE: 0x8,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function injectDOMPropertyConfig(domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	
	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	  ROOT_ATTRIBUTE_NAME: 'data-reactroot',
	
	  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
	  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function isCustomAttribute(attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 38 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponentFlags
	 */
	
	'use strict';
	
	var ReactDOMComponentFlags = {
	  hasCachedChildNodes: 1 << 0
	};
	
	module.exports = ReactDOMComponentFlags;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */
	
	'use strict';
	
	var BeforeInputEventPlugin = __webpack_require__(40);
	var ChangeEventPlugin = __webpack_require__(55);
	var DefaultEventPluginOrder = __webpack_require__(73);
	var EnterLeaveEventPlugin = __webpack_require__(74);
	var HTMLDOMPropertyConfig = __webpack_require__(79);
	var ReactComponentBrowserEnvironment = __webpack_require__(80);
	var ReactDOMComponent = __webpack_require__(94);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactDOMEmptyComponent = __webpack_require__(133);
	var ReactDOMTreeTraversal = __webpack_require__(134);
	var ReactDOMTextComponent = __webpack_require__(135);
	var ReactDefaultBatchingStrategy = __webpack_require__(136);
	var ReactEventListener = __webpack_require__(137);
	var ReactInjection = __webpack_require__(140);
	var ReactReconcileTransaction = __webpack_require__(141);
	var SVGDOMPropertyConfig = __webpack_require__(149);
	var SelectEventPlugin = __webpack_require__(150);
	var SimpleEventPlugin = __webpack_require__(151);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
	  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
	    return new ReactDOMEmptyComponent(instantiate);
	  });
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	}
	
	module.exports = {
	  inject: inject
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var EventConstants = __webpack_require__(41);
	var EventPropagators = __webpack_require__(42);
	var ExecutionEnvironment = __webpack_require__(49);
	var FallbackCompositionState = __webpack_require__(50);
	var SyntheticCompositionEvent = __webpack_require__(52);
	var SyntheticInputEvent = __webpack_require__(54);
	
	var keyOf = __webpack_require__(25);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return (typeof opera === 'undefined' ? 'undefined' : _typeof(opera)) === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if ((typeof detail === 'undefined' ? 'undefined' : _typeof(detail)) === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(23);
	
	var PropagationPhases = keyMirror({ bubbled: null, captured: null });
	
	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topAnimationEnd: null,
	  topAnimationIteration: null,
	  topAnimationStart: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topInvalid: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topTransitionEnd: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});
	
	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};
	
	module.exports = EventConstants;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(41);
	var EventPluginHub = __webpack_require__(43);
	var EventPluginUtils = __webpack_require__(45);
	
	var accumulateInto = __webpack_require__(47);
	var forEachAccumulated = __webpack_require__(48);
	var warning = __webpack_require__(11);
	
	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, upwards, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    var targetInst = event._targetInst;
	    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
	    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7);
	
	var EventPluginRegistry = __webpack_require__(44);
	var EventPluginUtils = __webpack_require__(45);
	var ReactErrorUtils = __webpack_require__(46);
	
	var accumulateInto = __webpack_require__(47);
	var forEachAccumulated = __webpack_require__(48);
	var invariant = __webpack_require__(8);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	var getDictionaryKey = function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	};
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {function} listener The callback to store.
	   */
	  putListener: function putListener(inst, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : _prodInvariant('94', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : void 0;
	
	    var key = getDictionaryKey(inst);
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[key] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(inst, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function getListener(inst, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    var key = getDictionaryKey(inst);
	    return bankForRegistrationName && bankForRegistrationName[key];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function deleteListener(inst, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(inst, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      var key = getDictionaryKey(inst);
	      delete bankForRegistrationName[key];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   */
	  deleteAllListeners: function deleteAllListeners(inst) {
	    var key = getDictionaryKey(inst);
	    for (var registrationName in listenerBank) {
	      if (!listenerBank.hasOwnProperty(registrationName)) {
	        continue;
	      }
	
	      if (!listenerBank[registrationName][key]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(inst, registrationName);
	      }
	
	      delete listenerBank[registrationName][key];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function enqueueEvents(events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function processEventQueue(simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function __purge() {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function __getListenerBank() {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	
	  if (process.env.NODE_ENV !== 'production') {
	    var lowerCasedName = registrationName.toLowerCase();
	    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
	
	    if (registrationName === 'onDoubleClick') {
	      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Mapping from lowercase registration names to the properly cased version,
	   * used to warn in the case of missing event handlers. Available
	   * only in __DEV__.
	   * @type {Object}
	   */
	  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function injectEventPluginOrder(InjectedEventPluginOrder) {
	    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function getPluginModuleForEvent(event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function _resetEventPlugins() {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
	      for (var lowerCasedName in possibleRegistrationNames) {
	        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
	          delete possibleRegistrationNames[lowerCasedName];
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var EventConstants = __webpack_require__(41);
	var ReactErrorUtils = __webpack_require__(46);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `ComponentTree`: [required] Module that can convert between React instances
	 *   and actual node references.
	 */
	var ComponentTree;
	var TreeTraversal;
	var injection = {
	  injectComponentTree: function injectComponentTree(Injected) {
	    ComponentTree = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	    }
	  },
	  injectTreeTraversal: function injectTreeTraversal(Injected) {
	    TreeTraversal = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
	    }
	  }
	};
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function validateEventDispatches(event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, simulated, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchInstances[i])) {
	        return dispatchInstances[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchInstances)) {
	      return dispatchInstances;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchInstances = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchInstance = event._dispatchInstances;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
	  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
	  var res = dispatchListener ? dispatchListener(event) : null;
	  event.currentTarget = null;
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getInstanceFromNode: function getInstanceFromNode(node) {
	    return ComponentTree.getInstanceFromNode(node);
	  },
	  getNodeFromInstance: function getNodeFromInstance(node) {
	    return ComponentTree.getNodeFromInstance(node);
	  },
	  isAncestor: function isAncestor(a, b) {
	    return TreeTraversal.isAncestor(a, b);
	  },
	  getLowestCommonAncestor: function getLowestCommonAncestor(a, b) {
	    return TreeTraversal.getLowestCommonAncestor(a, b);
	  },
	  getParentInstance: function getParentInstance(inst) {
	    return TreeTraversal.getParentInstance(inst);
	  },
	  traverseTwoPhase: function traverseTwoPhase(target, fn, arg) {
	    return TreeTraversal.traverseTwoPhase(target, fn, arg);
	  },
	  traverseEnterLeave: function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function rethrowCaughtError() {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
	
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }
	
	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 48 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 * 
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}
	
	module.exports = forEachAccumulated;

/***/ },
/* 49 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var PooledClass = __webpack_require__(6);
	
	var getTextContentAccessor = __webpack_require__(51);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	_assign(FallbackCompositionState.prototype, {
	  destructor: function destructor() {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function getText() {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function getData() {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(49);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(53);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var PooledClass = __webpack_require__(6);
	
	var emptyFunction = __webpack_require__(12);
	var warning = __webpack_require__(11);
	
	var didWarnForAddedNewProperty = false;
	var isProxySupported = typeof Proxy === 'function';
	
	var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function timeStamp(event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  if (process.env.NODE_ENV !== 'production') {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	  }
	
	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	  return this;
	}
	
	_assign(SyntheticEvent.prototype, {
	
	  preventDefault: function preventDefault() {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function stopPropagation() {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }
	
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function persist() {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function destructor() {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      if (process.env.NODE_ENV !== 'production') {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      } else {
	        this[propName] = null;
	      }
	    }
	    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
	      this[shouldBeReleasedProperties[i]] = null;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
	    }
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	if (process.env.NODE_ENV !== 'production') {
	  if (isProxySupported) {
	    /*eslint-disable no-func-assign */
	    SyntheticEvent = new Proxy(SyntheticEvent, {
	      construct: function construct(target, args) {
	        return this.apply(target, Object.create(target.prototype), args);
	      },
	      apply: function apply(constructor, that, args) {
	        return new Proxy(constructor.apply(that, args), {
	          set: function set(target, prop, value) {
	            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
	              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
	              didWarnForAddedNewProperty = true;
	            }
	            target[prop] = value;
	            return true;
	          }
	        });
	      }
	    });
	    /*eslint-enable no-func-assign */
	  }
	}
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var E = function E() {};
	  E.prototype = Super.prototype;
	  var prototype = new E();
	
	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	
	/**
	  * Helper to nullify syntheticEvent instance properties when destructing
	  *
	  * @param {object} SyntheticEvent
	  * @param {String} propName
	  * @return {object} defineProperty object
	  */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };
	
	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }
	
	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }
	
	  function warn(action, result) {
	    var warningCondition = false;
	    process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(53);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(41);
	var EventPluginHub = __webpack_require__(43);
	var EventPropagators = __webpack_require__(42);
	var ExecutionEnvironment = __webpack_require__(49);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactUpdates = __webpack_require__(56);
	var SyntheticEvent = __webpack_require__(53);
	
	var getEventTarget = __webpack_require__(70);
	var isEventSupported = __webpack_require__(71);
	var isTextInputElement = __webpack_require__(72);
	var keyOf = __webpack_require__(25);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementInst = null;
	}
	
	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return targetInst;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(target, targetInst);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.
	  // IE10+ fire input events to often, such when a placeholder
	  // changes or when an input with a placeholder is focused.
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 11);
	}
	
	/**
	 * (For IE <=11) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function get() {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function set(val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For IE <=11) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  if (activeElement.attachEvent) {
	    activeElement.attachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.addEventListener('propertychange', handlePropertyChange, false);
	  }
	}
	
	/**
	 * (For IE <=11) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	
	  if (activeElement.detachEvent) {
	    activeElement.detachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
	  }
	
	  activeElement = null;
	  activeElementInst = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For IE <=11) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetInstForInputEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return targetInst;
	  }
	}
	
	function handleEventsForInputEventIE(topLevelType, target, targetInst) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9-11, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetInstForInputEventIE(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementInst;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetInstForClickEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return targetInst;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    var getTargetInstFunc, handleEventFunc;
	    if (shouldUseChangeEvent(targetNode)) {
	      if (doesChangeEventBubble) {
	        getTargetInstFunc = getTargetInstForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }
	
	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst);
	      if (inst) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var CallbackQueue = __webpack_require__(57);
	var PooledClass = __webpack_require__(6);
	var ReactFeatureFlags = __webpack_require__(58);
	var ReactReconciler = __webpack_require__(59);
	var Transaction = __webpack_require__(69);
	
	var invariant = __webpack_require__(8);
	
	var dirtyComponents = [];
	var updateBatchNumber = 0;
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
	}
	
	var NESTED_UPDATES = {
	  initialize: function initialize() {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function close() {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function initialize() {
	    this.callbackQueue.reset();
	  },
	  close: function close() {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */true);
	}
	
	_assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function destructor() {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function perform(method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  // Any updates enqueued while reconciling must be performed after this entire
	  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
	  // C, B could update twice in a single batch if C's render enqueues an update
	  // to B (since B would have already updated, we should skip it, and the only
	  // way we can know to do so is by checking the batch counter).
	  updateBatchNumber++;
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    var markerName;
	    if (ReactFeatureFlags.logTopLevelRenders) {
	      var namedComponent = component;
	      // Duck type TopLevelWrapper. This is probably always true.
	      if (component._currentElement.props === component._renderedComponent._currentElement) {
	        namedComponent = component._renderedComponent;
	      }
	      markerName = 'React update: ' + namedComponent.getName();
	      console.time(markerName);
	    }
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
	
	    if (markerName) {
	      console.timeEnd(markerName);
	    }
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function flushBatchedUpdates() {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	  if (component._updateBatchNumber == null) {
	    component._updateBatchNumber = updateBatchNumber + 1;
	  }
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function injectReconcileTransaction(ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function injectBatchingStrategy(_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var PooledClass = __webpack_require__(6);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}
	
	_assign(CallbackQueue.prototype, {
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function enqueue(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function notifyAll() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },
	
	  checkpoint: function checkpoint() {
	    return this._callbacks ? this._callbacks.length : 0;
	  },
	
	  rollback: function rollback(len) {
	    if (this._callbacks) {
	      this._callbacks.length = len;
	      this._contexts.length = len;
	    }
	  },
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function reset() {
	    this._callbacks = null;
	    this._contexts = null;
	  },
	
	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function destructor() {
	    this.reset();
	  }
	
	});
	
	PooledClass.addPoolingTo(CallbackQueue);
	
	module.exports = CallbackQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 58 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactFeatureFlags
	 * 
	 */
	
	'use strict';
	
	var ReactFeatureFlags = {
	  // When true, call console.time() before and .timeEnd() after each top-level
	  // render (both initial renders and updates). Useful when looking at prod-mode
	  // timeline profiles in Chrome, for example.
	  logTopLevelRenders: false
	};
	
	module.exports = ReactFeatureFlags;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(60);
	var ReactInstrumentation = __webpack_require__(62);
	
	var warning = __webpack_require__(11);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} the containing host component instance
	   * @param {?object} info about the host container
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
	  ) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
	      }
	    }
	    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
	      }
	    }
	    return markup;
	  },
	
	  /**
	   * Returns a value that can be passed to
	   * ReactComponentEnvironment.replaceNodeWithMarkup.
	   */
	  getHostNode: function getHostNode(internalInstance) {
	    return internalInstance.getHostNode();
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent(internalInstance, safely) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
	      }
	    }
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent(safely);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function receiveComponent(internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
	      }
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(internalInstance, transaction, updateBatchNumber) {
	    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
	      // The component's enqueued batch number should always be the current
	      // batch or the following one.
	      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
	      return;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
	      }
	    }
	    internalInstance.performUpdateIfNecessary(transaction);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(61);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	
	  return (
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement.ref !== prevElement.ref ||
	    // If owner changes but we have an unchanged function ref, don't update refs
	    typeof nextElement.ref === 'string' && nextElement._owner !== prevElement._owner
	  );
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	
	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function isValidOwner(object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },
	
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function addComponentAsRefTo(component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function removeComponentAsRefFrom(component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
	    var ownerPublicInstance = owner.getPublicInstance();
	    // Check that `component`'s owner is still alive and that `component` is still the current ref
	    // because we do not want to detach the ref if another component stole it.
	    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstrumentation
	 */
	
	'use strict';
	
	var debugTool = null;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactDebugTool = __webpack_require__(63);
	  debugTool = ReactDebugTool;
	}
	
	module.exports = { debugTool: debugTool };
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDebugTool
	 */
	
	'use strict';
	
	var ReactInvalidSetStateWarningHook = __webpack_require__(64);
	var ReactHostOperationHistoryHook = __webpack_require__(65);
	var ReactComponentTreeHook = __webpack_require__(28);
	var ReactChildrenMutationWarningHook = __webpack_require__(66);
	var ExecutionEnvironment = __webpack_require__(49);
	
	var performanceNow = __webpack_require__(67);
	var warning = __webpack_require__(11);
	
	var hooks = [];
	var didHookThrowForEvent = {};
	
	function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
	  try {
	    fn.call(context, arg1, arg2, arg3, arg4, arg5);
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
	    didHookThrowForEvent[event] = true;
	  }
	}
	
	function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
	  for (var i = 0; i < hooks.length; i++) {
	    var hook = hooks[i];
	    var fn = hook[event];
	    if (fn) {
	      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
	    }
	  }
	}
	
	var _isProfiling = false;
	var flushHistory = [];
	var lifeCycleTimerStack = [];
	var currentFlushNesting = 0;
	var currentFlushMeasurements = null;
	var currentFlushStartTime = null;
	var currentTimerDebugID = null;
	var currentTimerStartTime = null;
	var currentTimerNestedFlushDuration = null;
	var currentTimerType = null;
	
	var lifeCycleTimerHasWarned = false;
	
	function clearHistory() {
	  ReactComponentTreeHook.purgeUnmountedComponents();
	  ReactHostOperationHistoryHook.clearHistory();
	}
	
	function getTreeSnapshot(registeredIDs) {
	  return registeredIDs.reduce(function (tree, id) {
	    var ownerID = ReactComponentTreeHook.getOwnerID(id);
	    var parentID = ReactComponentTreeHook.getParentID(id);
	    tree[id] = {
	      displayName: ReactComponentTreeHook.getDisplayName(id),
	      text: ReactComponentTreeHook.getText(id),
	      updateCount: ReactComponentTreeHook.getUpdateCount(id),
	      childIDs: ReactComponentTreeHook.getChildIDs(id),
	      // Text nodes don't have owners but this is close enough.
	      ownerID: ownerID || ReactComponentTreeHook.getOwnerID(parentID),
	      parentID: parentID
	    };
	    return tree;
	  }, {});
	}
	
	function resetMeasurements() {
	  var previousStartTime = currentFlushStartTime;
	  var previousMeasurements = currentFlushMeasurements || [];
	  var previousOperations = ReactHostOperationHistoryHook.getHistory();
	
	  if (currentFlushNesting === 0) {
	    currentFlushStartTime = null;
	    currentFlushMeasurements = null;
	    clearHistory();
	    return;
	  }
	
	  if (previousMeasurements.length || previousOperations.length) {
	    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
	    flushHistory.push({
	      duration: performanceNow() - previousStartTime,
	      measurements: previousMeasurements || [],
	      operations: previousOperations || [],
	      treeSnapshot: getTreeSnapshot(registeredIDs)
	    });
	  }
	
	  clearHistory();
	  currentFlushStartTime = performanceNow();
	  currentFlushMeasurements = [];
	}
	
	function checkDebugID(debugID) {
	  var allowRoot = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	  if (allowRoot && debugID === 0) {
	    return;
	  }
	  if (!debugID) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
	  }
	}
	
	function beginLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  currentTimerStartTime = performanceNow();
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	function endLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  if (_isProfiling) {
	    currentFlushMeasurements.push({
	      timerType: timerType,
	      instanceID: debugID,
	      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
	    });
	  }
	  currentTimerStartTime = null;
	  currentTimerNestedFlushDuration = null;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function pauseCurrentLifeCycleTimer() {
	  var currentTimer = {
	    startTime: currentTimerStartTime,
	    nestedFlushStartTime: performanceNow(),
	    debugID: currentTimerDebugID,
	    timerType: currentTimerType
	  };
	  lifeCycleTimerStack.push(currentTimer);
	  currentTimerStartTime = null;
	  currentTimerNestedFlushDuration = null;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function resumeCurrentLifeCycleTimer() {
	  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop();
	
	  var startTime = _lifeCycleTimerStack$.startTime;
	  var nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime;
	  var debugID = _lifeCycleTimerStack$.debugID;
	  var timerType = _lifeCycleTimerStack$.timerType;
	
	  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
	  currentTimerStartTime = startTime;
	  currentTimerNestedFlushDuration += nestedFlushDuration;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	var ReactDebugTool = {
	  addHook: function addHook(hook) {
	    hooks.push(hook);
	  },
	  removeHook: function removeHook(hook) {
	    for (var i = 0; i < hooks.length; i++) {
	      if (hooks[i] === hook) {
	        hooks.splice(i, 1);
	        i--;
	      }
	    }
	  },
	  isProfiling: function isProfiling() {
	    return _isProfiling;
	  },
	  beginProfiling: function beginProfiling() {
	    if (_isProfiling) {
	      return;
	    }
	
	    _isProfiling = true;
	    flushHistory.length = 0;
	    resetMeasurements();
	    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
	  },
	  endProfiling: function endProfiling() {
	    if (!_isProfiling) {
	      return;
	    }
	
	    _isProfiling = false;
	    resetMeasurements();
	    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
	  },
	  getFlushHistory: function getFlushHistory() {
	    return flushHistory;
	  },
	  onBeginFlush: function onBeginFlush() {
	    currentFlushNesting++;
	    resetMeasurements();
	    pauseCurrentLifeCycleTimer();
	    emitEvent('onBeginFlush');
	  },
	  onEndFlush: function onEndFlush() {
	    resetMeasurements();
	    currentFlushNesting--;
	    resumeCurrentLifeCycleTimer();
	    emitEvent('onEndFlush');
	  },
	  onBeginLifeCycleTimer: function onBeginLifeCycleTimer(debugID, timerType) {
	    checkDebugID(debugID);
	    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
	    beginLifeCycleTimer(debugID, timerType);
	  },
	  onEndLifeCycleTimer: function onEndLifeCycleTimer(debugID, timerType) {
	    checkDebugID(debugID);
	    endLifeCycleTimer(debugID, timerType);
	    emitEvent('onEndLifeCycleTimer', debugID, timerType);
	  },
	  onError: function onError(debugID) {
	    if (currentTimerDebugID != null) {
	      endLifeCycleTimer(currentTimerDebugID, currentTimerType);
	    }
	    emitEvent('onError', debugID);
	  },
	  onBeginProcessingChildContext: function onBeginProcessingChildContext() {
	    emitEvent('onBeginProcessingChildContext');
	  },
	  onEndProcessingChildContext: function onEndProcessingChildContext() {
	    emitEvent('onEndProcessingChildContext');
	  },
	  onHostOperation: function onHostOperation(debugID, type, payload) {
	    checkDebugID(debugID);
	    emitEvent('onHostOperation', debugID, type, payload);
	  },
	  onSetState: function onSetState() {
	    emitEvent('onSetState');
	  },
	  onSetChildren: function onSetChildren(debugID, childDebugIDs) {
	    checkDebugID(debugID);
	    childDebugIDs.forEach(checkDebugID);
	    emitEvent('onSetChildren', debugID, childDebugIDs);
	  },
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element, parentDebugID) {
	    checkDebugID(debugID);
	    checkDebugID(parentDebugID, true);
	    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
	  },
	  onMountComponent: function onMountComponent(debugID) {
	    checkDebugID(debugID);
	    emitEvent('onMountComponent', debugID);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUpdateComponent', debugID, element);
	  },
	  onUpdateComponent: function onUpdateComponent(debugID) {
	    checkDebugID(debugID);
	    emitEvent('onUpdateComponent', debugID);
	  },
	  onBeforeUnmountComponent: function onBeforeUnmountComponent(debugID) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUnmountComponent', debugID);
	  },
	  onUnmountComponent: function onUnmountComponent(debugID) {
	    checkDebugID(debugID);
	    emitEvent('onUnmountComponent', debugID);
	  },
	  onTestEvent: function onTestEvent() {
	    emitEvent('onTestEvent');
	  }
	};
	
	// TODO remove these when RN/www gets updated
	ReactDebugTool.addDevtool = ReactDebugTool.addHook;
	ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;
	
	ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
	ReactDebugTool.addHook(ReactComponentTreeHook);
	ReactDebugTool.addHook(ReactChildrenMutationWarningHook);
	var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	if (/[?&]react_perf\b/.test(url)) {
	  ReactDebugTool.beginProfiling();
	}
	
	module.exports = ReactDebugTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInvalidSetStateWarningHook
	 */
	
	'use strict';
	
	var warning = __webpack_require__(11);
	
	if (process.env.NODE_ENV !== 'production') {
	  var processingChildContext = false;
	
	  var warnInvalidSetState = function warnInvalidSetState() {
	    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
	  };
	}
	
	var ReactInvalidSetStateWarningHook = {
	  onBeginProcessingChildContext: function onBeginProcessingChildContext() {
	    processingChildContext = true;
	  },
	  onEndProcessingChildContext: function onEndProcessingChildContext() {
	    processingChildContext = false;
	  },
	  onSetState: function onSetState() {
	    warnInvalidSetState();
	  }
	};
	
	module.exports = ReactInvalidSetStateWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 65 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactHostOperationHistoryHook
	 */
	
	'use strict';
	
	var history = [];
	
	var ReactHostOperationHistoryHook = {
	  onHostOperation: function onHostOperation(debugID, type, payload) {
	    history.push({
	      instanceID: debugID,
	      type: type,
	      payload: payload
	    });
	  },
	  clearHistory: function clearHistory() {
	    if (ReactHostOperationHistoryHook._preventClearing) {
	      // Should only be used for tests.
	      return;
	    }
	
	    history = [];
	  },
	  getHistory: function getHistory() {
	    return history;
	  }
	};
	
	module.exports = ReactHostOperationHistoryHook;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildrenMutationWarningHook
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(28);
	
	var warning = __webpack_require__(11);
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element._shadowChildren === undefined) {
	    return;
	  }
	  if (element._shadowChildren === element.props.children) {
	    return;
	  }
	  var isMutated = false;
	  if (Array.isArray(element._shadowChildren)) {
	    if (element._shadowChildren.length === element.props.children.length) {
	      for (var i = 0; i < element._shadowChildren.length; i++) {
	        if (element._shadowChildren[i] !== element.props.children[i]) {
	          isMutated = true;
	        }
	      }
	    } else {
	      isMutated = true;
	    }
	  }
	  if (!Array.isArray(element._shadowChildren) || isMutated) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Component\'s children should not be mutated.%s', ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	}
	
	var ReactChildrenMutationWarningHook = {
	  onMountComponent: function onMountComponent(debugID) {
	    handleElement(debugID, ReactComponentTreeHook.getElement(debugID));
	  },
	  onUpdateComponent: function onUpdateComponent(debugID) {
	    handleElement(debugID, ReactComponentTreeHook.getElement(debugID));
	  }
	};
	
	module.exports = ReactChildrenMutationWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var performance = __webpack_require__(68);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(49);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function reinitializeTransaction() {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function isInTransaction() {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function perform(method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function initializeAll(startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function closeAll(startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	var Transaction = {
	
	  Mixin: Mixin,
	
	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}
	
	};
	
	module.exports = Transaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 70 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	
	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }
	
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(49);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 72 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 * 
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	
	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }
	
	  if (nodeName === 'textarea') {
	    return true;
	  }
	
	  return false;
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */
	
	'use strict';
	
	var keyOf = __webpack_require__(25);
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(41);
	var EventPropagators = __webpack_require__(42);
	var ReactDOMComponentTree = __webpack_require__(36);
	var SyntheticMouseEvent = __webpack_require__(75);
	
	var keyOf = __webpack_require__(25);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
	    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
	
	    return [leave, enter];
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(76);
	var ViewportMetrics = __webpack_require__(77);
	
	var getEventModifierState = __webpack_require__(78);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function button(event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function relatedTarget(event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function pageX(event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function pageY(event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(53);
	
	var getEventTarget = __webpack_require__(70);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function view(event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function detail(event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 77 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function refreshScrollValues(scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 78 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(37);
	
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: 0,
	    acceptCharset: 0,
	    accessKey: 0,
	    action: 0,
	    allowFullScreen: HAS_BOOLEAN_VALUE,
	    allowTransparency: 0,
	    alt: 0,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: 0,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: HAS_BOOLEAN_VALUE,
	    cellPadding: 0,
	    cellSpacing: 0,
	    charSet: 0,
	    challenge: 0,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    cite: 0,
	    classID: 0,
	    className: 0,
	    cols: HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: 0,
	    content: 0,
	    contentEditable: 0,
	    contextMenu: 0,
	    controls: HAS_BOOLEAN_VALUE,
	    coords: 0,
	    crossOrigin: 0,
	    data: 0, // For `<object />` acts as `src`.
	    dateTime: 0,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: 0,
	    disabled: HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: 0,
	    encType: 0,
	    form: 0,
	    formAction: 0,
	    formEncType: 0,
	    formMethod: 0,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: 0,
	    frameBorder: 0,
	    headers: 0,
	    height: 0,
	    hidden: HAS_BOOLEAN_VALUE,
	    high: 0,
	    href: 0,
	    hrefLang: 0,
	    htmlFor: 0,
	    httpEquiv: 0,
	    icon: 0,
	    id: 0,
	    inputMode: 0,
	    integrity: 0,
	    is: 0,
	    keyParams: 0,
	    keyType: 0,
	    kind: 0,
	    label: 0,
	    lang: 0,
	    list: 0,
	    loop: HAS_BOOLEAN_VALUE,
	    low: 0,
	    manifest: 0,
	    marginHeight: 0,
	    marginWidth: 0,
	    max: 0,
	    maxLength: 0,
	    media: 0,
	    mediaGroup: 0,
	    method: 0,
	    min: 0,
	    minLength: 0,
	    // Caution; `option.selected` is not updated if `select.multiple` is
	    // disabled with `removeAttribute`.
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: 0,
	    nonce: 0,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: 0,
	    pattern: 0,
	    placeholder: 0,
	    poster: 0,
	    preload: 0,
	    profile: 0,
	    radioGroup: 0,
	    readOnly: HAS_BOOLEAN_VALUE,
	    referrerPolicy: 0,
	    rel: 0,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: 0,
	    rows: HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: HAS_NUMERIC_VALUE,
	    sandbox: 0,
	    scope: 0,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: 0,
	    seamless: HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: 0,
	    size: HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: 0,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: 0,
	    src: 0,
	    srcDoc: 0,
	    srcLang: 0,
	    srcSet: 0,
	    start: HAS_NUMERIC_VALUE,
	    step: 0,
	    style: 0,
	    summary: 0,
	    tabIndex: 0,
	    target: 0,
	    title: 0,
	    // Setting .type throws on non-<input> tags
	    type: 0,
	    useMap: 0,
	    value: 0,
	    width: 0,
	    wmode: 0,
	    wrap: 0,
	
	    /**
	     * RDFa Properties
	     */
	    about: 0,
	    datatype: 0,
	    inlist: 0,
	    prefix: 0,
	    // property is also supported for OpenGraph in meta tags.
	    property: 0,
	    resource: 0,
	    'typeof': 0,
	    vocab: 0,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: 0,
	    autoCorrect: 0,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: 0,
	    // color is for Safari mask-icon link
	    color: 0,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: 0,
	    itemScope: HAS_BOOLEAN_VALUE,
	    itemType: 0,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: 0,
	    itemRef: 0,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: 0,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: 0,
	    // IE-only attribute that controls focus behavior
	    unselectable: 0
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {}
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(81);
	var ReactDOMIDOperations = __webpack_require__(93);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 */
	
	'use strict';
	
	var DOMLazyTree = __webpack_require__(82);
	var Danger = __webpack_require__(88);
	var ReactMultiChildUpdateTypes = __webpack_require__(92);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactInstrumentation = __webpack_require__(62);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(85);
	var setInnerHTML = __webpack_require__(84);
	var setTextContent = __webpack_require__(86);
	
	function getNodeAfter(parentNode, node) {
	  // Special case for text components, which return [open, close] comments
	  // from getHostNode.
	  if (Array.isArray(node)) {
	    node = node[1];
	  }
	  return node ? node.nextSibling : parentNode.firstChild;
	}
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
	  // We rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
	  // we are careful to use `null`.)
	  parentNode.insertBefore(childNode, referenceNode);
	});
	
	function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
	  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
	}
	
	function moveChild(parentNode, childNode, referenceNode) {
	  if (Array.isArray(childNode)) {
	    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
	  } else {
	    insertChildAt(parentNode, childNode, referenceNode);
	  }
	}
	
	function removeChild(parentNode, childNode) {
	  if (Array.isArray(childNode)) {
	    var closingComment = childNode[1];
	    childNode = childNode[0];
	    removeDelimitedText(parentNode, childNode, closingComment);
	    parentNode.removeChild(closingComment);
	  }
	  parentNode.removeChild(childNode);
	}
	
	function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
	  var node = openingComment;
	  while (true) {
	    var nextNode = node.nextSibling;
	    insertChildAt(parentNode, node, referenceNode);
	    if (node === closingComment) {
	      break;
	    }
	    node = nextNode;
	  }
	}
	
	function removeDelimitedText(parentNode, startNode, closingComment) {
	  while (true) {
	    var node = startNode.nextSibling;
	    if (node === closingComment) {
	      // The closing comment is removed by ReactMultiChild.
	      break;
	    } else {
	      parentNode.removeChild(node);
	    }
	  }
	}
	
	function replaceDelimitedText(openingComment, closingComment, stringText) {
	  var parentNode = openingComment.parentNode;
	  var nodeAfterComment = openingComment.nextSibling;
	  if (nodeAfterComment === closingComment) {
	    // There are no text nodes between the opening and closing comments; insert
	    // a new one if stringText isn't empty.
	    if (stringText) {
	      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
	    }
	  } else {
	    if (stringText) {
	      // Set the text content of the first node after the opening comment, and
	      // remove all following nodes up until the closing comment.
	      setTextContent(nodeAfterComment, stringText);
	      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
	    } else {
	      removeDelimitedText(parentNode, openingComment, closingComment);
	    }
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID, 'replace text', stringText);
	  }
	}
	
	var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
	if (process.env.NODE_ENV !== 'production') {
	  dangerouslyReplaceNodeWithMarkup = function dangerouslyReplaceNodeWithMarkup(oldChild, markup, prevInstance) {
	    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
	    if (prevInstance._debugID !== 0) {
	      ReactInstrumentation.debugTool.onHostOperation(prevInstance._debugID, 'replace with', markup.toString());
	    } else {
	      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
	      if (nextInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation(nextInstance._debugID, 'mount', markup.toString());
	      }
	    }
	  };
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
	
	  replaceDelimitedText: replaceDelimitedText,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  processUpdates: function processUpdates(parentNode, updates) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      var update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'insert child', { toIndex: update.toIndex, content: update.content.toString() });
	          }
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'move child', { fromIndex: update.fromIndex, toIndex: update.toIndex });
	          }
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace children', update.content.toString());
	          }
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace text', update.content.toString());
	          }
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          removeChild(parentNode, update.fromNode);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'remove child', { fromIndex: update.fromIndex });
	          }
	          break;
	      }
	    }
	  }
	
	};
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMLazyTree
	 */
	
	'use strict';
	
	var DOMNamespaces = __webpack_require__(83);
	var setInnerHTML = __webpack_require__(84);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(85);
	var setTextContent = __webpack_require__(86);
	
	var ELEMENT_NODE_TYPE = 1;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * In IE (8-11) and Edge, appending nodes with no children is dramatically
	 * faster than appending a full subtree, so we essentially queue up the
	 * .appendChild calls here and apply them so each node is added to its parent
	 * before any children are added.
	 *
	 * In other browsers, doing so is slower or neutral compared to the other order
	 * (in Firefox, twice as slow) so we only do this inversion in IE.
	 *
	 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
	 */
	var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
	
	function insertTreeChildren(tree) {
	  if (!enableLazy) {
	    return;
	  }
	  var node = tree.node;
	  var children = tree.children;
	  if (children.length) {
	    for (var i = 0; i < children.length; i++) {
	      insertTreeBefore(node, children[i], null);
	    }
	  } else if (tree.html != null) {
	    setInnerHTML(node, tree.html);
	  } else if (tree.text != null) {
	    setTextContent(node, tree.text);
	  }
	}
	
	var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
	  // DocumentFragments aren't actually part of the DOM after insertion so
	  // appending children won't update the DOM. We need to ensure the fragment
	  // is properly populated first, breaking out of our lazy approach for just
	  // this level. Also, some <object> plugins (like Flash Player) will read
	  // <param> nodes immediately upon insertion into the DOM, so <object>
	  // must also be populated prior to insertion into the DOM.
	  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
	    insertTreeChildren(tree);
	    parentNode.insertBefore(tree.node, referenceNode);
	  } else {
	    parentNode.insertBefore(tree.node, referenceNode);
	    insertTreeChildren(tree);
	  }
	});
	
	function replaceChildWithTree(oldNode, newTree) {
	  oldNode.parentNode.replaceChild(newTree.node, oldNode);
	  insertTreeChildren(newTree);
	}
	
	function queueChild(parentTree, childTree) {
	  if (enableLazy) {
	    parentTree.children.push(childTree);
	  } else {
	    parentTree.node.appendChild(childTree.node);
	  }
	}
	
	function queueHTML(tree, html) {
	  if (enableLazy) {
	    tree.html = html;
	  } else {
	    setInnerHTML(tree.node, html);
	  }
	}
	
	function queueText(tree, text) {
	  if (enableLazy) {
	    tree.text = text;
	  } else {
	    setTextContent(tree.node, text);
	  }
	}
	
	function toString() {
	  return this.node.nodeName;
	}
	
	function DOMLazyTree(node) {
	  return {
	    node: node,
	    children: [],
	    html: null,
	    text: null,
	    toString: toString
	  };
	}
	
	DOMLazyTree.insertTreeBefore = insertTreeBefore;
	DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
	DOMLazyTree.queueChild = queueChild;
	DOMLazyTree.queueHTML = queueHTML;
	DOMLazyTree.queueText = queueText;
	
	module.exports = DOMLazyTree;

/***/ },
/* 83 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMNamespaces
	 */
	
	'use strict';
	
	var DOMNamespaces = {
	  html: 'http://www.w3.org/1999/xhtml',
	  mathml: 'http://www.w3.org/1998/Math/MathML',
	  svg: 'http://www.w3.org/2000/svg'
	};
	
	module.exports = DOMNamespaces;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(49);
	var DOMNamespaces = __webpack_require__(83);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(85);
	
	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node
	  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var newNodes = reusableSVGContainer.firstChild.childNodes;
	    for (var i = 0; i < newNodes.length; i++) {
	      node.appendChild(newNodes[i]);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function setInnerHTML(node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	  testElement = null;
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 85 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createMicrosoftUnsafeLocalFunction
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */
	
	var createMicrosoftUnsafeLocalFunction = function createMicrosoftUnsafeLocalFunction(func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};
	
	module.exports = createMicrosoftUnsafeLocalFunction;

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(49);
	var escapeTextContentForBrowser = __webpack_require__(87);
	var setInnerHTML = __webpack_require__(84);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function setTextContent(node, text) {
	  if (text) {
	    var firstChild = node.firstChild;
	
	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function setTextContent(node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 87 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * Based on the escape-html library, which is used under the MIT License below:
	 *
	 * Copyright (c) 2012-2013 TJ Holowaychuk
	 * Copyright (c) 2015 Andreas Lubbe
	 * Copyright (c) 2015 Tiancheng "Timothy" Gu
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * 'Software'), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */
	
	'use strict';
	
	// code copied and modified from escape-html
	/**
	 * Module variables.
	 * @private
	 */
	
	var matchHtmlRegExp = /["'&<>]/;
	
	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */
	
	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);
	
	  if (!match) {
	    return str;
	  }
	
	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;
	
	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }
	
	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }
	
	    lastIndex = index + 1;
	    html += escape;
	  }
	
	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
	// end code copied and modified from escape-html
	
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  if (typeof text === 'boolean' || typeof text === 'number') {
	    // this shortcircuit helps perf for types that we know will never have
	    // special characters, especially given that this function is used often
	    // for numeric dom ids.
	    return '' + text;
	  }
	  return escapeHtml(text);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var DOMLazyTree = __webpack_require__(82);
	var ExecutionEnvironment = __webpack_require__(49);
	
	var createNodesFromMarkup = __webpack_require__(89);
	var emptyFunction = __webpack_require__(12);
	var invariant = __webpack_require__(8);
	
	var Danger = {
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function dangerouslyReplaceNodeWithMarkup(oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
	    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
	
	    if (typeof markup === 'string') {
	      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	      oldChild.parentNode.replaceChild(newChild, oldChild);
	    } else {
	      DOMLazyTree.replaceChildWithTree(oldChild, markup);
	    }
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	var ExecutionEnvironment = __webpack_require__(49);
	
	var createArrayFromMixed = __webpack_require__(90);
	var getMarkupWrap = __webpack_require__(91);
	var invariant = __webpack_require__(8);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = Array.from(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
	  // in old versions of Safari).
	  !(!Array.isArray(obj) && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
	
	  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	var ExecutionEnvironment = __webpack_require__(49);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(23);
	
	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});
	
	module.exports = ReactMultiChildUpdateTypes;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(81);
	var ReactDOMComponentTree = __webpack_require__(36);
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function dangerouslyProcessChildrenUpdates(parentInst, updates) {
	    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
	    DOMChildrenOperations.processUpdates(node, updates);
	  }
	};
	
	module.exports = ReactDOMIDOperations;

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var AutoFocusUtils = __webpack_require__(95);
	var CSSPropertyOperations = __webpack_require__(97);
	var DOMLazyTree = __webpack_require__(82);
	var DOMNamespaces = __webpack_require__(83);
	var DOMProperty = __webpack_require__(37);
	var DOMPropertyOperations = __webpack_require__(105);
	var EventConstants = __webpack_require__(41);
	var EventPluginHub = __webpack_require__(43);
	var EventPluginRegistry = __webpack_require__(44);
	var ReactBrowserEventEmitter = __webpack_require__(107);
	var ReactDOMButton = __webpack_require__(110);
	var ReactDOMComponentFlags = __webpack_require__(38);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactDOMInput = __webpack_require__(112);
	var ReactDOMOption = __webpack_require__(114);
	var ReactDOMSelect = __webpack_require__(115);
	var ReactDOMTextarea = __webpack_require__(116);
	var ReactInstrumentation = __webpack_require__(62);
	var ReactMultiChild = __webpack_require__(117);
	var ReactServerRenderingTransaction = __webpack_require__(129);
	
	var emptyFunction = __webpack_require__(12);
	var escapeTextContentForBrowser = __webpack_require__(87);
	var invariant = __webpack_require__(8);
	var isEventSupported = __webpack_require__(71);
	var keyOf = __webpack_require__(25);
	var shallowEqual = __webpack_require__(124);
	var validateDOMNesting = __webpack_require__(132);
	var warning = __webpack_require__(11);
	
	var Flags = ReactDOMComponentFlags;
	var deleteListener = EventPluginHub.deleteListener;
	var getNode = ReactDOMComponentTree.getNodeFromInstance;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = EventPluginRegistry.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });
	var RESERVED_PROPS = {
	  children: null,
	  dangerouslySetInnerHTML: null,
	  suppressContentEditableWarning: null
	};
	
	// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
	var DOC_FRAGMENT_TYPE = 11;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	function friendlyStringify(obj) {
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined because undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[component._tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
	    !(_typeof(props.dangerouslySetInnerHTML) === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
	  }
	  !(props.style == null || _typeof(props.style) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
	}
	
	function enqueuePutListener(inst, registrationName, listener, transaction) {
	  if (transaction instanceof ReactServerRenderingTransaction) {
	    return;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
	  }
	  var containerInfo = inst._hostContainerInfo;
	  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
	  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
	  listenTo(registrationName, doc);
	  transaction.getReactMountReady().enqueue(putListener, {
	    inst: inst,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	function inputPostMount() {
	  var inst = this;
	  ReactDOMInput.postMountWrapper(inst);
	}
	
	function textareaPostMount() {
	  var inst = this;
	  ReactDOMTextarea.postMountWrapper(inst);
	}
	
	function optionPostMount() {
	  var inst = this;
	  ReactDOMOption.postMountWrapper(inst);
	}
	
	var setContentChildForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  setContentChildForInstrumentation = function setContentChildForInstrumentation(content) {
	    var hasExistingContent = this._contentDebugID != null;
	    var debugID = this._debugID;
	    // This ID represents the inlined child that has no backing instance:
	    var contentDebugID = -debugID;
	
	    if (content == null) {
	      if (hasExistingContent) {
	        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
	      }
	      this._contentDebugID = null;
	      return;
	    }
	
	    this._contentDebugID = contentDebugID;
	    if (hasExistingContent) {
	      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
	      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
	    } else {
	      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
	      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
	      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
	    }
	  };
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
	  var node = getNode(inst);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
	
	  switch (inst._tag) {
	    case 'iframe':
	    case 'object':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // Create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }
	      break;
	    case 'source':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node)];
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	    case 'input':
	    case 'select':
	    case 'textarea':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topInvalid, 'invalid', node)];
	      break;
	  }
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = _assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	var globalIdCounter = 1;
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(element) {
	  var tag = element.type;
	  validateDangerousTag(tag);
	  this._currentElement = element;
	  this._tag = tag.toLowerCase();
	  this._namespaceURI = null;
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._hostNode = null;
	  this._hostParent = null;
	  this._rootNodeID = 0;
	  this._domID = 0;
	  this._hostContainerInfo = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._flags = 0;
	  if (process.env.NODE_ENV !== 'production') {
	    this._ancestorInfo = null;
	    setContentChildForInstrumentation.call(this, null);
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?ReactDOMComponent} the parent component instance
	   * @param {?object} info about the host container
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    this._rootNodeID = globalIdCounter++;
	    this._domID = hostContainerInfo._idCounter++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getHostProps(this, props, hostParent);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, hostParent);
	        props = ReactDOMInput.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, hostParent);
	        props = ReactDOMOption.getHostProps(this, props);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, hostParent);
	        props = ReactDOMSelect.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, hostParent);
	        props = ReactDOMTextarea.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	    }
	
	    assertValidProps(this, props);
	
	    // We create tags in the namespace of their parent container, except HTML
	    // tags get no namespace.
	    var namespaceURI;
	    var parentTag;
	    if (hostParent != null) {
	      namespaceURI = hostParent._namespaceURI;
	      parentTag = hostParent._tag;
	    } else if (hostContainerInfo._tag) {
	      namespaceURI = hostContainerInfo._namespaceURI;
	      parentTag = hostContainerInfo._tag;
	    }
	    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
	      namespaceURI = DOMNamespaces.html;
	    }
	    if (namespaceURI === DOMNamespaces.html) {
	      if (this._tag === 'svg') {
	        namespaceURI = DOMNamespaces.svg;
	      } else if (this._tag === 'math') {
	        namespaceURI = DOMNamespaces.mathml;
	      }
	    }
	    this._namespaceURI = namespaceURI;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo._tag) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(this._tag, this, parentInfo);
	      }
	      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var el;
	      if (namespaceURI === DOMNamespaces.html) {
	        if (this._tag === 'script') {
	          // Create the script via .innerHTML so its "parser-inserted" flag is
	          // set to true and it does not execute
	          var div = ownerDocument.createElement('div');
	          var type = this._currentElement.type;
	          div.innerHTML = '<' + type + '></' + type + '>';
	          el = div.removeChild(div.firstChild);
	        } else if (props.is) {
	          el = ownerDocument.createElement(this._currentElement.type, props.is);
	        } else {
	          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
	          // See discussion in https://github.com/facebook/react/pull/6896
	          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	          el = ownerDocument.createElement(this._currentElement.type);
	        }
	      } else {
	        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
	      }
	      ReactDOMComponentTree.precacheNode(this, el);
	      this._flags |= Flags.hasCachedChildNodes;
	      if (!this._hostParent) {
	        DOMPropertyOperations.setAttributeForRoot(el);
	      }
	      this._updateDOMProperties(null, props, transaction);
	      var lazyTree = DOMLazyTree(el);
	      this._createInitialChildren(transaction, props, context, lazyTree);
	      mountImage = lazyTree;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(inputPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'textarea':
	        transaction.getReactMountReady().enqueue(textareaPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'select':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'button':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'option':
	        transaction.getReactMountReady().enqueue(optionPostMount, this);
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function _createOpenTagMarkupAndPutListeners(transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = _assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    if (!this._hostParent) {
	      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
	    }
	    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
	    return ret;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function _createContentMarkup(transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function _createInitialChildren(transaction, props, context, lazyTree) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, contentToUse);
	        }
	        DOMLazyTree.queueText(lazyTree, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function receiveComponent(nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getHostProps(this, lastProps);
	        nextProps = ReactDOMButton.getHostProps(this, nextProps);
	        break;
	      case 'input':
	        lastProps = ReactDOMInput.getHostProps(this, lastProps);
	        nextProps = ReactDOMInput.getHostProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getHostProps(this, lastProps);
	        nextProps = ReactDOMOption.getHostProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
	        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
	        break;
	      case 'textarea':
	        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
	        break;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    switch (this._tag) {
	      case 'input':
	        // Update the wrapper around inputs *after* updating props. This has to
	        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
	        // raise warnings and prevent the new value from being assigned.
	        ReactDOMInput.updateWrapper(this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        break;
	      case 'select':
	        // <select> value update needs to occur after <option> children
	        // reconciliation
	        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	        break;
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function _updateDOMProperties(lastProps, nextProps, transaction) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, lastProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = _assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        var node = getNode(this);
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertently setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function _updateDOMChildren(lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[_typeof(lastProps.children)] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[_typeof(nextProps.children)] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, nextContent);
	        }
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    } else if (nextChildren != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        setContentChildForInstrumentation.call(this, null);
	      }
	
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  getHostNode: function getHostNode() {
	    return getNode(this);
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function unmountComponent(safely) {
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
	        break;
	    }
	
	    this.unmountChildren(safely);
	    ReactDOMComponentTree.uncacheNode(this);
	    EventPluginHub.deleteAllListeners(this);
	    this._rootNodeID = 0;
	    this._domID = 0;
	    this._wrapperState = null;
	
	    if (process.env.NODE_ENV !== 'production') {
	      setContentChildForInstrumentation.call(this, null);
	    }
	  },
	
	  getPublicInstance: function getPublicInstance() {
	    return getNode(this);
	  }
	
	};
	
	_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 */
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(36);
	
	var focusNode = __webpack_require__(96);
	
	var AutoFocusUtils = {
	  focusDOMComponent: function focusDOMComponent() {
	    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 96 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(98);
	var ExecutionEnvironment = __webpack_require__(49);
	var ReactInstrumentation = __webpack_require__(62);
	
	var camelizeStyleName = __webpack_require__(99);
	var dangerousStyleValue = __webpack_require__(101);
	var hyphenateStyleName = __webpack_require__(102);
	var memoizeStringOnly = __webpack_require__(104);
	var warning = __webpack_require__(11);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;
	
	  var warnHyphenatedStyleName = function warnHyphenatedStyleName(name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnBadVendoredStyleName = function warnBadVendoredStyleName(name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value, owner) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	  };
	
	  var warnStyleValueIsNaN = function warnStyleValueIsNaN(name, value, owner) {
	    if (warnedForNaNValue) {
	      return;
	    }
	
	    warnedForNaNValue = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	  };
	
	  var checkRenderMessage = function checkRenderMessage(owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   * @param {ReactDOMComponent} component
	   */
	  var warnValidStyle = function warnValidStyle(name, value, component) {
	    var owner;
	    if (component) {
	      owner = component._currentElement._owner;
	    }
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name, owner);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name, owner);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value, owner);
	    }
	
	    if (typeof value === 'number' && isNaN(value)) {
	      warnStyleValueIsNaN(name, value, owner);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   * @return {?string}
	   */
	  createMarkupForStyles: function createMarkupForStyles(styles, component) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue, component);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   */
	  setValueForStyles: function setValueForStyles(node, styles, component) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(component._debugID, 'update styles', styles);
	    }
	
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName], component);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
	      if (styleName === 'float' || styleName === 'cssFloat') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 98 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridRow: true,
	  gridColumn: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(100);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 100 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(98);
	var warning = __webpack_require__(11);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	var styleWarnings = {};
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @param {ReactDOMComponent} component
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, component) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    if (process.env.NODE_ENV !== 'production') {
	      // Allow '0' to pass through without warning. 0 is already special and
	      // doesn't require units, so we don't need to warn about it.
	      if (component && value !== '0') {
	        var owner = component._currentElement._owner;
	        var ownerName = owner ? owner.getName() : null;
	        if (ownerName && !styleWarnings[ownerName]) {
	          styleWarnings[ownerName] = {};
	        }
	        var warned = false;
	        if (ownerName) {
	          var warnings = styleWarnings[ownerName];
	          warned = warnings[name];
	          if (!warned) {
	            warnings[name] = true;
	          }
	        }
	        if (!warned) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	        }
	      }
	    }
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(103);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 103 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 104 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(37);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactInstrumentation = __webpack_require__(62);
	
	var quoteAttributeValueForBrowser = __webpack_require__(106);
	var warning = __webpack_require__(11);
	
	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function createMarkupForID(id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function setAttributeForID(node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  createMarkupForRoot: function createMarkupForRoot() {
	    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
	  },
	
	  setAttributeForRoot: function setAttributeForRoot(node) {
	    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function createMarkupForProperty(name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function createMarkupForCustomAttribute(name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function setValueForProperty(node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	        return;
	      } else if (propertyInfo.mustUseProperty) {
	        // Contrary to `setAttribute`, object properties are properly
	        // `toString`ed by IE8/9.
	        node[propertyInfo.propertyName] = value;
	      } else {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
	    }
	  },
	
	  setValueForAttribute: function setValueForAttribute(node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
	    }
	  },
	
	  /**
	   * Deletes an attributes from a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForAttribute: function deleteValueForAttribute(node, name) {
	    node.removeAttribute(name);
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function deleteValueForProperty(node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseProperty) {
	        var propName = propertyInfo.propertyName;
	        if (propertyInfo.hasBooleanValue) {
	          node[propName] = false;
	        } else {
	          node[propName] = '';
	        }
	      } else {
	        node.removeAttribute(propertyInfo.attributeName);
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
	    }
	  }
	
	};
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(87);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var EventConstants = __webpack_require__(41);
	var EventPluginRegistry = __webpack_require__(44);
	var ReactEventEmitterMixin = __webpack_require__(108);
	var ViewportMetrics = __webpack_require__(77);
	
	var getVendorPrefixedEventName = __webpack_require__(109);
	var isEventSupported = __webpack_require__(71);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var hasEventPageXY;
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
	  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
	  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function injectReactEventListener(ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function setEnabled(enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function isEnabled() {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function listenTo(registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
	   * pageX/pageY isn't supported (legacy browsers).
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function ensureScrollValueMonitoring() {
	    if (hasEventPageXY === undefined) {
	      hasEventPageXY = document.createEvent && 'pageX' in document.createEvent('MouseEvent');
	    }
	    if (!hasEventPageXY && !isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  }
	
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(43);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   */
	  handleTopLevel: function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getVendorPrefixedEventName
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(49);
	
	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};
	
	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;
	  prefixes['ms' + styleProp] = 'MS' + eventName;
	  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
	
	  return prefixes;
	}
	
	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};
	
	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};
	
	/**
	 * Element to check for prefixes on.
	 */
	var style = {};
	
	/**
	 * Bootstrap if a DOM exists.
	 */
	if (ExecutionEnvironment.canUseDOM) {
	  style = document.createElement('div').style;
	
	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }
	
	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}
	
	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }
	
	  var prefixMap = vendorPrefixes[eventName];
	
	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }
	
	  return '';
	}
	
	module.exports = getVendorPrefixedEventName;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */
	
	'use strict';
	
	var DisabledInputUtils = __webpack_require__(111);
	
	/**
	 * Implements a <button> host component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getHostProps: DisabledInputUtils.getHostProps
	};
	
	module.exports = ReactDOMButton;

/***/ },
/* 111 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DisabledInputUtils
	 */
	
	'use strict';
	
	var disableableMouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,
	
	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};
	
	/**
	 * Implements a host component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var DisabledInputUtils = {
	  getHostProps: function getHostProps(inst, props) {
	    if (!props.disabled) {
	      return props;
	    }
	
	    // Copy the props, except the mouse listeners
	    var hostProps = {};
	    for (var key in props) {
	      if (!disableableMouseListenerNames[key] && props.hasOwnProperty(key)) {
	        hostProps[key] = props[key];
	      }
	    }
	
	    return hostProps;
	  }
	};
	
	module.exports = DisabledInputUtils;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var DisabledInputUtils = __webpack_require__(111);
	var DOMPropertyOperations = __webpack_require__(105);
	var LinkedValueUtils = __webpack_require__(113);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactUpdates = __webpack_require__(56);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	var didWarnValueLink = false;
	var didWarnCheckedLink = false;
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked !== undefined : props.value !== undefined;
	}
	
	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getHostProps: function getHostProps(inst, props) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var hostProps = _assign({
	      // Make sure we set .type before any other properties (setting .value
	      // before .type means .value is lost in IE11 and below)
	      type: undefined,
	      // Make sure we set .step before .value (setting .value before .step
	      // means .value is rounded on mount, based upon step precision)
	      step: undefined,
	      // Make sure we set .min & .max before .value (to ensure proper order
	      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
	      min: undefined,
	      max: undefined
	    }, DisabledInputUtils.getHostProps(inst, props), {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	
	      var owner = inst._currentElement._owner;
	
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnCheckedLink = true;
	      }
	      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnCheckedDefaultChecked = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnValueDefaultValue = true;
	      }
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	      initialValue: props.value != null ? props.value : defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      inst._wrapperState.controlled = isControlled(props);
	    }
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var controlled = isControlled(props);
	      var owner = inst._currentElement._owner;
	
	      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnUncontrolledToControlled = true;
	      }
	      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnControlledToUncontrolled = true;
	      }
	    }
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
	    }
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	    } else {
	      if (props.value == null && props.defaultValue != null) {
	        node.defaultValue = '' + props.defaultValue;
	      }
	      if (props.checked == null && props.defaultChecked != null) {
	        node.defaultChecked = !!props.defaultChecked;
	      }
	    }
	  },
	
	  postMountWrapper: function postMountWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Detach value from defaultValue. We won't do anything if we're working on
	    // submit or reset inputs as those values & defaultValues are linked. They
	    // are not resetable nodes so this operation doesn't matter and actually
	    // removes browser-default values (eg "Submit Query") when no value is
	    // provided.
	
	    switch (props.type) {
	      case 'submit':
	      case 'reset':
	        break;
	      case 'color':
	      case 'date':
	      case 'datetime':
	      case 'datetime-local':
	      case 'month':
	      case 'time':
	      case 'week':
	        // This fixes the no-show issue on iOS Safari and Android Chrome:
	        // https://github.com/facebook/react/issues/7233
	        node.value = '';
	        node.value = node.defaultValue;
	        break;
	      default:
	        node.value = node.value;
	        break;
	    }
	
	    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	    // this is needed to work around a chrome bug where setting defaultChecked
	    // will sometimes influence the value of checked (even after detachment).
	    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	    // We need to temporarily unset name to avoid disrupting radio button groups.
	    var name = node.name;
	    if (name !== '') {
	      node.name = '';
	    }
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !node.defaultChecked;
	    if (name !== '') {
	      node.name = name;
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactPropTypes = __webpack_require__(31);
	var ReactPropTypeLocations = __webpack_require__(22);
	var ReactPropTypesSecret = __webpack_require__(30);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
	}
	
	var propTypes = {
	  value: function value(props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function checked(props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function checkPropTypes(tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop, null, ReactPropTypesSecret);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function getValue(inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function getChecked(inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function executeOnChange(inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var ReactChildren = __webpack_require__(5);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactDOMSelect = __webpack_require__(115);
	
	var warning = __webpack_require__(11);
	var didWarnInvalidOptionChildren = false;
	
	function flattenChildren(children) {
	  var content = '';
	
	  // Flatten children and warn if they aren't strings or numbers;
	  // invalid types are ignored.
	  ReactChildren.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    if (typeof child === 'string' || typeof child === 'number') {
	      content += child;
	    } else if (!didWarnInvalidOptionChildren) {
	      didWarnInvalidOptionChildren = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
	    }
	  });
	
	  return content;
	}
	
	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function mountWrapper(inst, props, hostParent) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
	    }
	
	    // Look up whether this option is 'selected'
	    var selectValue = null;
	    if (hostParent != null) {
	      var selectParent = hostParent;
	
	      if (selectParent._tag === 'optgroup') {
	        selectParent = selectParent._hostParent;
	      }
	
	      if (selectParent != null && selectParent._tag === 'select') {
	        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
	      }
	    }
	
	    // If the value is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      var value;
	      if (props.value != null) {
	        value = props.value + '';
	      } else {
	        value = flattenChildren(props.children);
	      }
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  postMountWrapper: function postMountWrapper(inst) {
	    // value="" should make a value attribute (#6219)
	    var props = inst._currentElement.props;
	    if (props.value != null) {
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      node.setAttribute('value', props.value);
	    }
	  },
	
	  getHostProps: function getHostProps(inst, props) {
	    var hostProps = _assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      hostProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = flattenChildren(props.children);
	
	    if (content) {
	      hostProps.children = content;
	    }
	
	    return hostProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var DisabledInputUtils = __webpack_require__(111);
	var LinkedValueUtils = __webpack_require__(113);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactUpdates = __webpack_require__(56);
	
	var warning = __webpack_require__(11);
	
	var didWarnValueLink = false;
	var didWarnValueDefaultValue = false;
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  if (props.valueLink !== undefined && !didWarnValueLink) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
	    didWarnValueLink = true;
	  }
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    } else if (!props.multiple && isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  getHostProps: function getHostProps(inst, props) {
	    return _assign({}, DisabledInputUtils.getHostProps(inst, props), {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	
	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	      didWarnValueDefaultValue = true;
	    }
	  },
	
	  getSelectValueContext: function getSelectValueContext(inst) {
	    // ReactDOMOption looks at this initial value so the initial generated
	    // markup has correct `selected` attributes
	    return inst._wrapperState.initialValue;
	  },
	
	  postUpdateWrapper: function postUpdateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // this value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  if (this._rootNodeID) {
	    this._wrapperState.pendingUpdate = true;
	  }
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var DisabledInputUtils = __webpack_require__(111);
	var LinkedValueUtils = __webpack_require__(113);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactUpdates = __webpack_require__(56);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	var didWarnValueLink = false;
	var didWarnValDefaultVal = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getHostProps: function getHostProps(inst, props) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.  We could add a check in setTextContent
	    // to only set the value if/when the value differs from the node value (which would
	    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
	    // The value can be a boolean or object so that's why it's forced to be a string.
	    var hostProps = _assign({}, DisabledInputUtils.getHostProps(inst, props), {
	      value: undefined,
	      defaultValue: undefined,
	      children: '' + inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	        didWarnValDefaultVal = true;
	      }
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    var initialValue = value;
	
	    // Only bother fetching default value if we're going to use it
	    if (value == null) {
	      var defaultValue = props.defaultValue;
	      // TODO (yungsters): Remove support for children content in <textarea>.
	      var children = props.children;
	      if (children != null) {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
	        }
	        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
	        if (Array.isArray(children)) {
	          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
	          children = children[0];
	        }
	
	        defaultValue = '' + children;
	      }
	      if (defaultValue == null) {
	        defaultValue = '';
	      }
	      initialValue = defaultValue;
	    }
	
	    inst._wrapperState = {
	      initialValue: '' + initialValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	      if (props.defaultValue == null) {
	        node.defaultValue = newValue;
	      }
	    }
	    if (props.defaultValue != null) {
	      node.defaultValue = props.defaultValue;
	    }
	  },
	
	  postMountWrapper: function postMountWrapper(inst) {
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Warning: node.value may be the empty string at this point (IE11) if placeholder is set.
	    node.value = node.textContent; // Detach value from defaultValue
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactComponentEnvironment = __webpack_require__(118);
	var ReactInstanceMap = __webpack_require__(119);
	var ReactInstrumentation = __webpack_require__(62);
	var ReactMultiChildUpdateTypes = __webpack_require__(92);
	
	var ReactCurrentOwner = __webpack_require__(10);
	var ReactReconciler = __webpack_require__(59);
	var ReactChildReconciler = __webpack_require__(120);
	
	var emptyFunction = __webpack_require__(12);
	var flattenChildren = __webpack_require__(128);
	var invariant = __webpack_require__(8);
	
	/**
	 * Make an update for markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function makeInsertMarkup(markup, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for moving an existing element to another index.
	 *
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function makeMove(child, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: ReactReconciler.getHostNode(child),
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for removing an element at an index.
	 *
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function makeRemove(child, node) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: node,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the markup of a node.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function makeSetMarkup(markup) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the text content.
	 *
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function makeTextContent(textContent) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    content: textContent,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Push an update, if any, onto the queue. Creates a new queue if none is
	 * passed and always returns the queue. Mutative.
	 */
	function enqueue(queue, update) {
	  if (update) {
	    queue = queue || [];
	    queue.push(update);
	  }
	  return queue;
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue(inst, updateQueue) {
	  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
	}
	
	var setChildrenForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  var getDebugID = function getDebugID(inst) {
	    if (!inst._debugID) {
	      // Check for ART-like instances. TODO: This is silly/gross.
	      var internal;
	      if (internal = ReactInstanceMap.get(inst)) {
	        inst = internal;
	      }
	    }
	    return inst._debugID;
	  };
	  setChildrenForInstrumentation = function setChildrenForInstrumentation(children) {
	    var debugID = getDebugID(this);
	    // TODO: React Native empty components are also multichild.
	    // This means they still get into this method but don't have _debugID.
	    if (debugID !== 0) {
	      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
	        return children[key]._debugID;
	      }) : []);
	    }
	  };
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function _reconcilerInstantiateChildren(nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        var selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function _reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
	      var nextChildren;
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          return nextChildren;
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	      return nextChildren;
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function mountChildren(nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          var selfDebugID = 0;
	          if (process.env.NODE_ENV !== 'production') {
	            selfDebugID = getDebugID(this);
	          }
	          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, children);
	      }
	
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function updateTextContent(nextContent) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      // Set new text content.
	      var updates = [makeTextContent(nextContent)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function updateMarkup(nextMarkup) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      var updates = [makeSetMarkup(nextMarkup)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function updateChildren(nextNestedChildrenElements, transaction, context) {
	      // Hook used by React ART
	      this._updateChildren(nextNestedChildrenElements, transaction, context);
	    },
	
	    /**
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function _updateChildren(nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var removedNodes = {};
	      var mountImages = [];
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var updates = null;
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var nextIndex = 0;
	      var lastIndex = 0;
	      // `nextMountIndex` will increment for each newly mounted child.
	      var nextMountIndex = 0;
	      var lastPlacedNode = null;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            // The `removedNodes` loop below will actually remove the child.
	          }
	          // The child must be instantiated before it's mounted.
	          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
	          nextMountIndex++;
	        }
	        nextIndex++;
	        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
	      }
	      // Remove children that are no longer present.
	      for (name in removedNodes) {
	        if (removedNodes.hasOwnProperty(name)) {
	          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
	        }
	      }
	      if (updates) {
	        processQueue(this, updates);
	      }
	      this._renderedChildren = nextChildren;
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, nextChildren);
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted. It does not actually perform any
	     * backend operations.
	     *
	     * @internal
	     */
	    unmountChildren: function unmountChildren(safely) {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren, safely);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function moveChild(child, afterNode, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        return makeMove(child, afterNode, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function createChild(child, afterNode, mountImage) {
	      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function removeChild(child, node) {
	      return makeRemove(child, node);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildAtIndex: function _mountChildAtIndex(child, mountImage, afterNode, index, transaction, context) {
	      child._mountIndex = index;
	      return this.createChild(child, afterNode, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function _unmountChild(child, node) {
	      var update = this.removeChild(child, node);
	      child._mountIndex = null;
	      return update;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkup: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function injectEnvironment(environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
	      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 119 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function remove(key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function get(key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function has(key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function set(key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(59);
	
	var instantiateReactComponent = __webpack_require__(121);
	var KeyEscapeUtils = __webpack_require__(16);
	var shouldUpdateReactComponent = __webpack_require__(125);
	var traverseAllChildren = __webpack_require__(14);
	var warning = __webpack_require__(11);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(28);
	}
	
	function instantiateChild(childInstances, child, name, selfDebugID) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    if (!ReactComponentTreeHook) {
	      ReactComponentTreeHook = __webpack_require__(28);
	    }
	    if (!keyUnique) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	    }
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, true);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function instantiateChildren(nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
	  ) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	
	    if (process.env.NODE_ENV !== 'production') {
	      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
	        return instantiateChild(childInsts, child, name, selfDebugID);
	      }, childInstances);
	    } else {
	      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    }
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
	  ) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return;
	    }
	    var name;
	    var prevChild;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	          ReactReconciler.unmountComponent(prevChild, false);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, true);
	        nextChildren[name] = nextChildInstance;
	        // Creating mount image now ensures refs are resolved in right order
	        // (see https://github.com/facebook/react/pull/7101 for explanation).
	        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
	        mountImages.push(nextChildMountImage);
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        prevChild = prevChildren[name];
	        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	        ReactReconciler.unmountComponent(prevChild, false);
	      }
	    }
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function unmountChildren(renderedChildren, safely) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild, safely);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var ReactCompositeComponent = __webpack_require__(122);
	var ReactEmptyComponent = __webpack_require__(126);
	var ReactHostComponent = __webpack_require__(127);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function ReactCompositeComponentWrapper(element) {
	  this.construct(element);
	};
	_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	var nextDebugID = 1;
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {boolean} shouldHaveDebugID
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, shouldHaveDebugID) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = ReactEmptyComponent.create(instantiateReactComponent);
	  } else if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : _typeof(element.type), getDeclarationErrorAddendum(element._owner)) : _prodInvariant('130', element.type == null ? element.type : _typeof(element.type), getDeclarationErrorAddendum(element._owner)) : void 0;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactHostComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	
	      // We renamed this. Allow the old name for compat. :(
	      if (!instance.getHostNode) {
	        instance.getHostNode = instance.getNativeNode;
	      }
	    } else {
	      instance = new ReactCompositeComponentWrapper(element);
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactHostComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : _prodInvariant('131', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : void 0;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
	  }
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._debugID = shouldHaveDebugID ? nextDebugID++ : 0;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var ReactComponentEnvironment = __webpack_require__(118);
	var ReactCurrentOwner = __webpack_require__(10);
	var ReactElement = __webpack_require__(9);
	var ReactErrorUtils = __webpack_require__(46);
	var ReactInstanceMap = __webpack_require__(119);
	var ReactInstrumentation = __webpack_require__(62);
	var ReactNodeTypes = __webpack_require__(123);
	var ReactPropTypeLocations = __webpack_require__(22);
	var ReactReconciler = __webpack_require__(59);
	
	var checkReactTypeSpec = __webpack_require__(29);
	var emptyObject = __webpack_require__(19);
	var invariant = __webpack_require__(8);
	var shallowEqual = __webpack_require__(124);
	var shouldUpdateReactComponent = __webpack_require__(125);
	var warning = __webpack_require__(11);
	
	var CompositeTypes = {
	  ImpureClass: 0,
	  PureClass: 1,
	  StatelessFunctional: 2
	};
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  var element = Component(this.props, this.context, this.updater);
	  warnIfInvalidElement(Component, element);
	  return element;
	};
	
	function warnIfInvalidElement(Component, element) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || ReactElement.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	}
	
	function invokeComponentDidMountWithTimer() {
	  var publicInstance = this._instance;
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidMount');
	  }
	  publicInstance.componentDidMount();
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidMount');
	  }
	}
	
	function invokeComponentDidUpdateWithTimer(prevProps, prevState, prevContext) {
	  var publicInstance = this._instance;
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidUpdate');
	  }
	  publicInstance.componentDidUpdate(prevProps, prevState, prevContext);
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidUpdate');
	  }
	}
	
	function shouldConstruct(Component) {
	  return !!(Component.prototype && Component.prototype.isReactComponent);
	}
	
	function isPureComponent(Component) {
	  return !!(Component.prototype && Component.prototype.isPureReactComponent);
	}
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function construct(element) {
	    this._currentElement = element;
	    this._rootNodeID = 0;
	    this._compositeType = null;
	    this._instance = null;
	    this._hostParent = null;
	    this._hostContainerInfo = null;
	
	    // See ReactUpdateQueue
	    this._updateBatchNumber = null;
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedNodeType = null;
	    this._renderedComponent = null;
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	
	    // ComponentWillUnmount shall only be called once
	    this._calledComponentWillUnmount = false;
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._warnedAboutRefsInRender = false;
	    }
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} hostParent
	   * @param {?object} hostContainerInfo
	   * @param {?object} context
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var publicProps = this._currentElement.props;
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    var updateQueue = transaction.getUpdateQueue();
	
	    // Initialize the public class
	    var doConstruct = shouldConstruct(Component);
	    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
	    var renderedElement;
	
	    // Support functional components
	    if (!doConstruct && (inst == null || inst.render == null)) {
	      renderedElement = inst;
	      warnIfInvalidElement(Component, renderedElement);
	      !(inst === null || inst === false || ReactElement.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
	      inst = new StatelessComponent(Component);
	      this._compositeType = CompositeTypes.StatelessFunctional;
	    } else {
	      if (isPureComponent(Component)) {
	        this._compositeType = CompositeTypes.PureClass;
	      } else {
	        this._compositeType = CompositeTypes.ImpureClass;
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
	      }
	
	      var propsMutated = inst.props !== publicProps;
	      var componentName = Component.displayName || Component.name || 'Component';
	
	      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = updateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    var markup;
	    if (inst.unstable_handleError) {
	      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } else {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	
	    if (inst.componentDidMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(invokeComponentDidMountWithTimer, this);
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	    }
	
	    return markup;
	  },
	
	  _constructComponent: function _constructComponent(doConstruct, publicProps, publicContext, updateQueue) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactCurrentOwner.current = this;
	      try {
	        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	    }
	  },
	
	  _constructComponentWithoutOwner: function _constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue) {
	    var Component = this._currentElement.type;
	    var instanceOrElement;
	    if (doConstruct) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'ctor');
	        }
	      }
	      instanceOrElement = new Component(publicProps, publicContext, updateQueue);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'ctor');
	        }
	      }
	    } else {
	      // This can still be an instance in case of factory components
	      // but we'll count this as time spent rendering as the more common case.
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
	        }
	      }
	      instanceOrElement = Component(publicProps, publicContext, updateQueue);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
	        }
	      }
	    }
	    return instanceOrElement;
	  },
	
	  performInitialMountWithErrorHandling: function performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var markup;
	    var checkpoint = transaction.checkpoint();
	    try {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } catch (e) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onError();
	        }
	      }
	      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
	      transaction.rollback(checkpoint);
	      this._instance.unstable_handleError(e);
	      if (this._pendingStateQueue) {
	        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
	      }
	      checkpoint = transaction.checkpoint();
	
	      this._renderedComponent.unmountComponent(true);
	      transaction.rollback(checkpoint);
	
	      // Try again - we've informed the component about the error, so they can render an error message this time.
	      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	    return markup;
	  },
	
	  performInitialMount: function performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var inst = this._instance;
	    if (inst.componentWillMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillMount');
	        }
	      }
	      inst.componentWillMount();
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillMount');
	        }
	      }
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    var nodeType = ReactNodeTypes.getType(renderedElement);
	    this._renderedNodeType = nodeType;
	    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	    );
	    this._renderedComponent = child;
	
	    var selfDebugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      selfDebugID = this._debugID;
	    }
	    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), selfDebugID);
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, child._debugID !== 0 ? [child._debugID] : []);
	      }
	    }
	
	    return markup;
	  },
	
	  getHostNode: function getHostNode() {
	    return ReactReconciler.getHostNode(this._renderedComponent);
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent(safely) {
	    if (!this._renderedComponent) {
	      return;
	    }
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
	      inst._calledComponentWillUnmount = true;
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUnmount');
	        }
	      }
	      if (safely) {
	        var name = this.getName() + '.componentWillUnmount()';
	        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
	      } else {
	        inst.componentWillUnmount();
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUnmount');
	        }
	      }
	    }
	
	    if (this._renderedComponent) {
	      ReactReconciler.unmountComponent(this._renderedComponent, safely);
	      this._renderedNodeType = null;
	      this._renderedComponent = null;
	      this._instance = null;
	    }
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = 0;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function _maskContext(context) {
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    var maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function _processContext(context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkContextTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function _processChildContext(currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onBeginProcessingChildContext();
	    }
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onEndProcessingChildContext();
	    }
	    if (childContext) {
	      !(_typeof(Component.childContextTypes) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkContextTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
	      }
	      return _assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Assert that the context types are valid
	   *
	   * @param {object} typeSpecs Map of context field to a ReactPropType
	   * @param {object} values Runtime values that need to be type-checked
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkContextTypes: function _checkContextTypes(typeSpecs, values, location) {
	    checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
	  },
	
	  receiveComponent: function receiveComponent(nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
	    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    } else {
	      this._updateBatchNumber = null;
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    var willReceive = false;
	    var nextContext;
	
	    // Determine if the context has changed or not
	    if (this._context === nextUnmaskedContext) {
	      nextContext = inst.context;
	    } else {
	      nextContext = this._processContext(nextUnmaskedContext);
	      willReceive = true;
	    }
	
	    var prevProps = prevParentElement.props;
	    var nextProps = nextParentElement.props;
	
	    // Not a simple state update but a props update
	    if (prevParentElement !== nextParentElement) {
	      willReceive = true;
	    }
	
	    // An update here will schedule an update but immediately set
	    // _pendingStateQueue which will ensure that any state updates gets
	    // immediately reconciled instead of waiting for the next batch.
	    if (willReceive && inst.componentWillReceiveProps) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
	        }
	      }
	      inst.componentWillReceiveProps(nextProps, nextContext);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
	        }
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	    var shouldUpdate = true;
	
	    if (!this._pendingForceUpdate) {
	      if (inst.shouldComponentUpdate) {
	        if (process.env.NODE_ENV !== 'production') {
	          if (this._debugID !== 0) {
	            ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
	          }
	        }
	        shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	        if (process.env.NODE_ENV !== 'production') {
	          if (this._debugID !== 0) {
	            ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
	          }
	        }
	      } else {
	        if (this._compositeType === CompositeTypes.PureClass) {
	          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
	        }
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
	    }
	
	    this._updateBatchNumber = null;
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function _processPendingState(props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = _assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function _performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUpdate');
	        }
	      }
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUpdate');
	        }
	      }
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(invokeComponentDidUpdateWithTimer.bind(this, prevProps, prevState, prevContext), this);
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	      }
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function _updateRenderedComponent(transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
	      ReactReconciler.unmountComponent(prevComponentInstance, false);
	
	      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
	      this._renderedNodeType = nodeType;
	      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	      );
	      this._renderedComponent = child;
	
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = this._debugID;
	      }
	      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), selfDebugID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onSetChildren(this._debugID, child._debugID !== 0 ? [child._debugID] : []);
	        }
	      }
	
	      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
	    }
	  },
	
	  /**
	   * Overridden in shallow rendering.
	   *
	   * @protected
	   */
	  _replaceNodeWithMarkup: function _replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance) {
	    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function _renderValidatedComponentWithoutOwnerOrContext() {
	    var inst = this._instance;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
	      }
	    }
	    var renderedComponent = inst.render();
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (renderedComponent === undefined && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }
	
	    return renderedComponent;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function _renderValidatedComponent() {
	    var renderedComponent;
	    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
	      ReactCurrentOwner.current = this;
	      try {
	        renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    return renderedComponent;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function attachRef(ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function detachRef(ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function getName() {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function getPublicInstance() {
	    var inst = this._instance;
	    if (this._compositeType === CompositeTypes.StatelessFunctional) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	var ReactCompositeComponent = {
	
	  Mixin: ReactCompositeComponentMixin
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNodeTypes
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactElement = __webpack_require__(9);
	
	var invariant = __webpack_require__(8);
	
	var ReactNodeTypes = {
	  HOST: 0,
	  COMPOSITE: 1,
	  EMPTY: 2,
	
	  getType: function getType(node) {
	    if (node === null || node === false) {
	      return ReactNodeTypes.EMPTY;
	    } else if (ReactElement.isValidElement(node)) {
	      if (typeof node.type === 'function') {
	        return ReactNodeTypes.COMPOSITE;
	      } else {
	        return ReactNodeTypes.HOST;
	      }
	    }
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
	  }
	};
	
	module.exports = ReactNodeTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 124 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */
	
	/*eslint-disable no-self-compare */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }
	
	  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 125 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement);
	  var nextType = typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement);
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 126 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */
	
	'use strict';
	
	var emptyComponentFactory;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponentFactory: function injectEmptyComponentFactory(factory) {
	    emptyComponentFactory = factory;
	  }
	};
	
	var ReactEmptyComponent = {
	  create: function create(instantiate) {
	    return emptyComponentFactory(instantiate);
	  }
	};
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactHostComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var invariant = __webpack_require__(8);
	
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around host tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactHostComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function injectGenericComponentClass(componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function injectTextComponentClass(componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function injectComponentClasses(componentClasses) {
	    _assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a host internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
	  return new genericComponentClass(element);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactHostComponent = {
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactHostComponentInjection
	};
	
	module.exports = ReactHostComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var KeyEscapeUtils = __webpack_require__(16);
	var traverseAllChildren = __webpack_require__(14);
	var warning = __webpack_require__(11);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(28);
	}
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 * @param {number=} selfDebugID Optional debugID of the current internal instance.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
	  // We found a component instance.
	  if (traverseContext && (typeof traverseContext === 'undefined' ? 'undefined' : _typeof(traverseContext)) === 'object') {
	    var result = traverseContext;
	    var keyUnique = result[name] === undefined;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!ReactComponentTreeHook) {
	        ReactComponentTreeHook = __webpack_require__(28);
	      }
	      if (!keyUnique) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	      }
	    }
	    if (keyUnique && child != null) {
	      result[name] = child;
	    }
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children, selfDebugID) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	
	  if (process.env.NODE_ENV !== 'production') {
	    traverseAllChildren(children, function (traverseContext, child, name) {
	      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
	    }, result);
	  } else {
	    traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  }
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var PooledClass = __webpack_require__(6);
	var Transaction = __webpack_require__(69);
	var ReactInstrumentation = __webpack_require__(62);
	var ReactServerUpdateQueue = __webpack_require__(130);
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	var noopCallbackQueue = {
	  enqueue: function enqueue() {}
	};
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.useCreateElement = false;
	  this.updateQueue = new ReactServerUpdateQueue(this);
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return noopCallbackQueue;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function getUpdateQueue() {
	    return this.updateQueue;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {},
	
	  checkpoint: function checkpoint() {},
	
	  rollback: function rollback() {}
	};
	
	_assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerUpdateQueue
	 * 
	 */
	
	'use strict';
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var ReactUpdateQueue = __webpack_require__(131);
	var Transaction = __webpack_require__(69);
	var warning = __webpack_require__(11);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the update queue used for server rendering.
	 * It delegates to ReactUpdateQueue while server rendering is in progress and
	 * switches to ReactNoopUpdateQueue after the transaction has completed.
	 * @class ReactServerUpdateQueue
	 * @param {Transaction} transaction
	 */
	
	var ReactServerUpdateQueue = function () {
	  /* :: transaction: Transaction; */
	
	  function ReactServerUpdateQueue(transaction) {
	    _classCallCheck(this, ReactServerUpdateQueue);
	
	    this.transaction = transaction;
	  }
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	
	  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
	    return false;
	  };
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
	    }
	  };
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
	    } else {
	      warnNoop(publicInstance, 'forceUpdate');
	    }
	  };
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} completeState Next state.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
	    } else {
	      warnNoop(publicInstance, 'replaceState');
	    }
	  };
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} partialState Next partial state to be merged with state.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
	    } else {
	      warnNoop(publicInstance, 'setState');
	    }
	  };
	
	  return ReactServerUpdateQueue;
	}();
	
	module.exports = ReactServerUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactCurrentOwner = __webpack_require__(10);
	var ReactInstanceMap = __webpack_require__(119);
	var ReactInstrumentation = __webpack_require__(62);
	var ReactUpdates = __webpack_require__(56);
	
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function formatUnexpectedArgument(arg) {
	  var type = typeof arg === 'undefined' ? 'undefined' : _typeof(arg);
	  if (type !== 'object') {
	    return type;
	  }
	  var displayName = arg.constructor && arg.constructor.name || type;
	  var keys = Object.keys(arg);
	  if (keys.length > 0 && keys.length < 20) {
	    return displayName + ' (keys: ' + keys.join(', ') + ')';
	  }
	  return displayName;
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var ctor = publicInstance.constructor;
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @param {string} callerName Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback, callerName) {
	    ReactUpdateQueue.validateCallback(callback, callerName);
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function enqueueCallbackInternal(internalInstance, callback) {
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onSetState();
	      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
	    }
	
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueElementInternal: function enqueueElementInternal(internalInstance, nextElement, nextContext) {
	    internalInstance._pendingElement = nextElement;
	    // TODO: introduce _pendingContext instead of setting it directly.
	    internalInstance._context = nextContext;
	    enqueueUpdate(internalInstance);
	  },
	
	  validateCallback: function validateCallback(callback, callerName) {
	    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var emptyFunction = __webpack_require__(12);
	var warning = __webpack_require__(11);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    current: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function updatedAncestorInfo(oldInfo, tag, instance) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.current = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function isTagValidWithParent(tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function findInvalidAncestorForTag(tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function findOwnerStack(instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    do {
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function validateDOMNesting(childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      var tagDisplayName = childTag;
	      if (childTag !== '#text') {
	        tagDisplayName = '<' + childTag + '>';
	      }
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>. ' + 'See %s.%s', tagDisplayName, ancestorTag, ownerInfo, info) : void 0;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
	      }
	    }
	  };
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMEmptyComponent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var DOMLazyTree = __webpack_require__(82);
	var ReactDOMComponentTree = __webpack_require__(36);
	
	var ReactDOMEmptyComponent = function ReactDOMEmptyComponent(instantiate) {
	  // ReactCompositeComponent uses this:
	  this._currentElement = null;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	  this._hostContainerInfo = null;
	  this._domID = 0;
	};
	_assign(ReactDOMEmptyComponent.prototype, {
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    var domID = hostContainerInfo._idCounter++;
	    this._domID = domID;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var nodeValue = ' react-empty: ' + this._domID + ' ';
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var node = ownerDocument.createComment(nodeValue);
	      ReactDOMComponentTree.precacheNode(this, node);
	      return DOMLazyTree(node);
	    } else {
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd insert a comment node, but since this is a situation
	        // where React won't take over (static pages), we can simply return
	        // nothing.
	        return '';
	      }
	      return '<!--' + nodeValue + '-->';
	    }
	  },
	  receiveComponent: function receiveComponent() {},
	  getHostNode: function getHostNode() {
	    return ReactDOMComponentTree.getNodeFromInstance(this);
	  },
	  unmountComponent: function unmountComponent() {
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});
	
	module.exports = ReactDOMEmptyComponent;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTreeTraversal
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var invariant = __webpack_require__(8);
	
	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
	    depthB++;
	  }
	
	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = instA._hostParent;
	    depthA--;
	  }
	
	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = instB._hostParent;
	    depthB--;
	  }
	
	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB) {
	      return instA;
	    }
	    instA = instA._hostParent;
	    instB = instB._hostParent;
	  }
	  return null;
	}
	
	/**
	 * Return if A is an ancestor of B.
	 */
	function isAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	
	  while (instB) {
	    if (instB === instA) {
	      return true;
	    }
	    instB = instB._hostParent;
	  }
	  return false;
	}
	
	/**
	 * Return the parent instance of the passed-in instance.
	 */
	function getParentInstance(inst) {
	  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
	
	  return inst._hostParent;
	}
	
	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = inst._hostParent;
	  }
	  var i;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], false, arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], true, arg);
	  }
	}
	
	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (from && from !== common) {
	    pathFrom.push(from);
	    from = from._hostParent;
	  }
	  var pathTo = [];
	  while (to && to !== common) {
	    pathTo.push(to);
	    to = to._hostParent;
	  }
	  var i;
	  for (i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], true, argFrom);
	  }
	  for (i = pathTo.length; i-- > 0;) {
	    fn(pathTo[i], false, argTo);
	  }
	}
	
	module.exports = {
	  isAncestor: isAncestor,
	  getLowestCommonAncestor: getLowestCommonAncestor,
	  getParentInstance: getParentInstance,
	  traverseTwoPhase: traverseTwoPhase,
	  traverseEnterLeave: traverseEnterLeave
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7),
	    _assign = __webpack_require__(4);
	
	var DOMChildrenOperations = __webpack_require__(81);
	var DOMLazyTree = __webpack_require__(82);
	var ReactDOMComponentTree = __webpack_require__(36);
	
	var escapeTextContentForBrowser = __webpack_require__(87);
	var invariant = __webpack_require__(8);
	var validateDOMNesting = __webpack_require__(132);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings between comment nodes so that they
	 * can undergo the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function ReactDOMTextComponent(text) {
	  // TODO: This is really a ReactText (ReactNode), not a ReactElement
	  this._currentElement = text;
	  this._stringText = '' + text;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	
	  // Properties
	  this._domID = 0;
	  this._mountIndex = 0;
	  this._closingComment = null;
	  this._commentNodes = null;
	};
	
	_assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo != null) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting('#text', this, parentInfo);
	      }
	    }
	
	    var domID = hostContainerInfo._idCounter++;
	    var openingValue = ' react-text: ' + domID + ' ';
	    var closingValue = ' /react-text ';
	    this._domID = domID;
	    this._hostParent = hostParent;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var openingComment = ownerDocument.createComment(openingValue);
	      var closingComment = ownerDocument.createComment(closingValue);
	      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
	      if (this._stringText) {
	        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
	      }
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
	      ReactDOMComponentTree.precacheNode(this, openingComment);
	      this._closingComment = closingComment;
	      return lazyTree;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this between comment nodes for the reasons stated
	        // above, but since this is a situation where React won't take over
	        // (static pages), we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function receiveComponent(nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var commentNodes = this.getHostNode();
	        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
	      }
	    }
	  },
	
	  getHostNode: function getHostNode() {
	    var hostNode = this._commentNodes;
	    if (hostNode) {
	      return hostNode;
	    }
	    if (!this._closingComment) {
	      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
	      var node = openingComment.nextSibling;
	      while (true) {
	        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
	        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
	          this._closingComment = node;
	          break;
	        }
	        node = node.nextSibling;
	      }
	    }
	    hostNode = [this._hostNode, this._closingComment];
	    this._commentNodes = hostNode;
	    return hostNode;
	  },
	
	  unmountComponent: function unmountComponent() {
	    this._closingComment = null;
	    this._commentNodes = null;
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var ReactUpdates = __webpack_require__(56);
	var Transaction = __webpack_require__(69);
	
	var emptyFunction = __webpack_require__(12);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function close() {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function batchedUpdates(callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var EventListener = __webpack_require__(138);
	var ExecutionEnvironment = __webpack_require__(49);
	var PooledClass = __webpack_require__(6);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactUpdates = __webpack_require__(56);
	
	var getEventTarget = __webpack_require__(70);
	var getUnboundedScrollPosition = __webpack_require__(139);
	
	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findParent(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst._hostParent) {
	    inst = inst._hostParent;
	  }
	  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
	  var container = rootNode.parentNode;
	  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	_assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function destructor() {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
	  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = ancestor && findParent(ancestor);
	  } while (ancestor);
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function setHandleTopLevel(handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function setEnabled(enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function isEnabled() {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function monitorScrollValue(refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function dispatchEvent(topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @typechecks
	 */
	
	var emptyFunction = __webpack_require__(12);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 139 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(37);
	var EventPluginHub = __webpack_require__(43);
	var EventPluginUtils = __webpack_require__(45);
	var ReactComponentEnvironment = __webpack_require__(118);
	var ReactClass = __webpack_require__(21);
	var ReactEmptyComponent = __webpack_require__(126);
	var ReactBrowserEventEmitter = __webpack_require__(107);
	var ReactHostComponent = __webpack_require__(127);
	var ReactUpdates = __webpack_require__(56);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventPluginUtils: EventPluginUtils.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  HostComponent: ReactHostComponent.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var CallbackQueue = __webpack_require__(57);
	var PooledClass = __webpack_require__(6);
	var ReactBrowserEventEmitter = __webpack_require__(107);
	var ReactInputSelection = __webpack_require__(142);
	var ReactInstrumentation = __webpack_require__(62);
	var Transaction = __webpack_require__(69);
	var ReactUpdateQueue = __webpack_require__(131);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function initialize() {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function close(previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function initialize() {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function close() {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(useCreateElement) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactDOMTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return this.reactMountReady;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function getUpdateQueue() {
	    return ReactUpdateQueue;
	  },
	
	  /**
	   * Save current transaction state -- if the return value from this method is
	   * passed to `rollback`, the transaction will be reset to that state.
	   */
	  checkpoint: function checkpoint() {
	    // reactMountReady is the our only stateful wrapper
	    return this.reactMountReady.checkpoint();
	  },
	
	  rollback: function rollback(checkpoint) {
	    this.reactMountReady.rollback(checkpoint);
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	_assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(143);
	
	var containsNode = __webpack_require__(145);
	var focusNode = __webpack_require__(96);
	var getActiveElement = __webpack_require__(148);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function hasSelectionCapabilities(elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function getSelectionInformation() {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function restoreSelection(priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function getSelection(input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function setSelection(input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (end === undefined) {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(49);
	
	var getNodeForCharacterOffset = __webpack_require__(144);
	var getTextContentAccessor = __webpack_require__(51);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (offsets.end === undefined) {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 144 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	var isTextNode = __webpack_require__(146);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var isNode = __webpack_require__(147);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 147 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 148 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 149 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */
	
	'use strict';
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	// We use attributes for everything SVG so let's avoid some duplication and run
	// code instead.
	// The following are all specified in the HTML config already so we exclude here.
	// - class (as className)
	// - color
	// - height
	// - id
	// - lang
	// - max
	// - media
	// - method
	// - min
	// - name
	// - style
	// - target
	// - type
	// - width
	var ATTRS = {
	  accentHeight: 'accent-height',
	  accumulate: 0,
	  additive: 0,
	  alignmentBaseline: 'alignment-baseline',
	  allowReorder: 'allowReorder',
	  alphabetic: 0,
	  amplitude: 0,
	  arabicForm: 'arabic-form',
	  ascent: 0,
	  attributeName: 'attributeName',
	  attributeType: 'attributeType',
	  autoReverse: 'autoReverse',
	  azimuth: 0,
	  baseFrequency: 'baseFrequency',
	  baseProfile: 'baseProfile',
	  baselineShift: 'baseline-shift',
	  bbox: 0,
	  begin: 0,
	  bias: 0,
	  by: 0,
	  calcMode: 'calcMode',
	  capHeight: 'cap-height',
	  clip: 0,
	  clipPath: 'clip-path',
	  clipRule: 'clip-rule',
	  clipPathUnits: 'clipPathUnits',
	  colorInterpolation: 'color-interpolation',
	  colorInterpolationFilters: 'color-interpolation-filters',
	  colorProfile: 'color-profile',
	  colorRendering: 'color-rendering',
	  contentScriptType: 'contentScriptType',
	  contentStyleType: 'contentStyleType',
	  cursor: 0,
	  cx: 0,
	  cy: 0,
	  d: 0,
	  decelerate: 0,
	  descent: 0,
	  diffuseConstant: 'diffuseConstant',
	  direction: 0,
	  display: 0,
	  divisor: 0,
	  dominantBaseline: 'dominant-baseline',
	  dur: 0,
	  dx: 0,
	  dy: 0,
	  edgeMode: 'edgeMode',
	  elevation: 0,
	  enableBackground: 'enable-background',
	  end: 0,
	  exponent: 0,
	  externalResourcesRequired: 'externalResourcesRequired',
	  fill: 0,
	  fillOpacity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  filter: 0,
	  filterRes: 'filterRes',
	  filterUnits: 'filterUnits',
	  floodColor: 'flood-color',
	  floodOpacity: 'flood-opacity',
	  focusable: 0,
	  fontFamily: 'font-family',
	  fontSize: 'font-size',
	  fontSizeAdjust: 'font-size-adjust',
	  fontStretch: 'font-stretch',
	  fontStyle: 'font-style',
	  fontVariant: 'font-variant',
	  fontWeight: 'font-weight',
	  format: 0,
	  from: 0,
	  fx: 0,
	  fy: 0,
	  g1: 0,
	  g2: 0,
	  glyphName: 'glyph-name',
	  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	  glyphOrientationVertical: 'glyph-orientation-vertical',
	  glyphRef: 'glyphRef',
	  gradientTransform: 'gradientTransform',
	  gradientUnits: 'gradientUnits',
	  hanging: 0,
	  horizAdvX: 'horiz-adv-x',
	  horizOriginX: 'horiz-origin-x',
	  ideographic: 0,
	  imageRendering: 'image-rendering',
	  'in': 0,
	  in2: 0,
	  intercept: 0,
	  k: 0,
	  k1: 0,
	  k2: 0,
	  k3: 0,
	  k4: 0,
	  kernelMatrix: 'kernelMatrix',
	  kernelUnitLength: 'kernelUnitLength',
	  kerning: 0,
	  keyPoints: 'keyPoints',
	  keySplines: 'keySplines',
	  keyTimes: 'keyTimes',
	  lengthAdjust: 'lengthAdjust',
	  letterSpacing: 'letter-spacing',
	  lightingColor: 'lighting-color',
	  limitingConeAngle: 'limitingConeAngle',
	  local: 0,
	  markerEnd: 'marker-end',
	  markerMid: 'marker-mid',
	  markerStart: 'marker-start',
	  markerHeight: 'markerHeight',
	  markerUnits: 'markerUnits',
	  markerWidth: 'markerWidth',
	  mask: 0,
	  maskContentUnits: 'maskContentUnits',
	  maskUnits: 'maskUnits',
	  mathematical: 0,
	  mode: 0,
	  numOctaves: 'numOctaves',
	  offset: 0,
	  opacity: 0,
	  operator: 0,
	  order: 0,
	  orient: 0,
	  orientation: 0,
	  origin: 0,
	  overflow: 0,
	  overlinePosition: 'overline-position',
	  overlineThickness: 'overline-thickness',
	  paintOrder: 'paint-order',
	  panose1: 'panose-1',
	  pathLength: 'pathLength',
	  patternContentUnits: 'patternContentUnits',
	  patternTransform: 'patternTransform',
	  patternUnits: 'patternUnits',
	  pointerEvents: 'pointer-events',
	  points: 0,
	  pointsAtX: 'pointsAtX',
	  pointsAtY: 'pointsAtY',
	  pointsAtZ: 'pointsAtZ',
	  preserveAlpha: 'preserveAlpha',
	  preserveAspectRatio: 'preserveAspectRatio',
	  primitiveUnits: 'primitiveUnits',
	  r: 0,
	  radius: 0,
	  refX: 'refX',
	  refY: 'refY',
	  renderingIntent: 'rendering-intent',
	  repeatCount: 'repeatCount',
	  repeatDur: 'repeatDur',
	  requiredExtensions: 'requiredExtensions',
	  requiredFeatures: 'requiredFeatures',
	  restart: 0,
	  result: 0,
	  rotate: 0,
	  rx: 0,
	  ry: 0,
	  scale: 0,
	  seed: 0,
	  shapeRendering: 'shape-rendering',
	  slope: 0,
	  spacing: 0,
	  specularConstant: 'specularConstant',
	  specularExponent: 'specularExponent',
	  speed: 0,
	  spreadMethod: 'spreadMethod',
	  startOffset: 'startOffset',
	  stdDeviation: 'stdDeviation',
	  stemh: 0,
	  stemv: 0,
	  stitchTiles: 'stitchTiles',
	  stopColor: 'stop-color',
	  stopOpacity: 'stop-opacity',
	  strikethroughPosition: 'strikethrough-position',
	  strikethroughThickness: 'strikethrough-thickness',
	  string: 0,
	  stroke: 0,
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeMiterlimit: 'stroke-miterlimit',
	  strokeOpacity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  surfaceScale: 'surfaceScale',
	  systemLanguage: 'systemLanguage',
	  tableValues: 'tableValues',
	  targetX: 'targetX',
	  targetY: 'targetY',
	  textAnchor: 'text-anchor',
	  textDecoration: 'text-decoration',
	  textRendering: 'text-rendering',
	  textLength: 'textLength',
	  to: 0,
	  transform: 0,
	  u1: 0,
	  u2: 0,
	  underlinePosition: 'underline-position',
	  underlineThickness: 'underline-thickness',
	  unicode: 0,
	  unicodeBidi: 'unicode-bidi',
	  unicodeRange: 'unicode-range',
	  unitsPerEm: 'units-per-em',
	  vAlphabetic: 'v-alphabetic',
	  vHanging: 'v-hanging',
	  vIdeographic: 'v-ideographic',
	  vMathematical: 'v-mathematical',
	  values: 0,
	  vectorEffect: 'vector-effect',
	  version: 0,
	  vertAdvY: 'vert-adv-y',
	  vertOriginX: 'vert-origin-x',
	  vertOriginY: 'vert-origin-y',
	  viewBox: 'viewBox',
	  viewTarget: 'viewTarget',
	  visibility: 0,
	  widths: 0,
	  wordSpacing: 'word-spacing',
	  writingMode: 'writing-mode',
	  x: 0,
	  xHeight: 'x-height',
	  x1: 0,
	  x2: 0,
	  xChannelSelector: 'xChannelSelector',
	  xlinkActuate: 'xlink:actuate',
	  xlinkArcrole: 'xlink:arcrole',
	  xlinkHref: 'xlink:href',
	  xlinkRole: 'xlink:role',
	  xlinkShow: 'xlink:show',
	  xlinkTitle: 'xlink:title',
	  xlinkType: 'xlink:type',
	  xmlBase: 'xml:base',
	  xmlns: 0,
	  xmlnsXlink: 'xmlns:xlink',
	  xmlLang: 'xml:lang',
	  xmlSpace: 'xml:space',
	  y: 0,
	  y1: 0,
	  y2: 0,
	  yChannelSelector: 'yChannelSelector',
	  z: 0,
	  zoomAndPan: 'zoomAndPan'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {},
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {}
	};
	
	Object.keys(ATTRS).forEach(function (key) {
	  SVGDOMPropertyConfig.Properties[key] = 0;
	  if (ATTRS[key]) {
	    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
	  }
	});
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(41);
	var EventPropagators = __webpack_require__(42);
	var ExecutionEnvironment = __webpack_require__(49);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactInputSelection = __webpack_require__(142);
	var SyntheticEvent = __webpack_require__(53);
	
	var getActiveElement = __webpack_require__(148);
	var isTextInputElement = __webpack_require__(72);
	var keyOf = __webpack_require__(25);
	var shallowEqual = __webpack_require__(124);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	var activeElement = null;
	var activeElementInst = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events. See #3639.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement = targetNode;
	          activeElementInst = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementInst = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function didPutListener(inst, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var EventConstants = __webpack_require__(41);
	var EventListener = __webpack_require__(138);
	var EventPropagators = __webpack_require__(42);
	var ReactDOMComponentTree = __webpack_require__(36);
	var SyntheticAnimationEvent = __webpack_require__(152);
	var SyntheticClipboardEvent = __webpack_require__(153);
	var SyntheticEvent = __webpack_require__(53);
	var SyntheticFocusEvent = __webpack_require__(154);
	var SyntheticKeyboardEvent = __webpack_require__(155);
	var SyntheticMouseEvent = __webpack_require__(75);
	var SyntheticDragEvent = __webpack_require__(158);
	var SyntheticTouchEvent = __webpack_require__(159);
	var SyntheticTransitionEvent = __webpack_require__(160);
	var SyntheticUIEvent = __webpack_require__(76);
	var SyntheticWheelEvent = __webpack_require__(161);
	
	var emptyFunction = __webpack_require__(12);
	var getEventCharCode = __webpack_require__(156);
	var invariant = __webpack_require__(8);
	var keyOf = __webpack_require__(25);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  animationEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationEnd: true }),
	      captured: keyOf({ onAnimationEndCapture: true })
	    }
	  },
	  animationIteration: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationIteration: true }),
	      captured: keyOf({ onAnimationIterationCapture: true })
	    }
	  },
	  animationStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationStart: true }),
	      captured: keyOf({ onAnimationStartCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  invalid: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInvalid: true }),
	      captured: keyOf({ onInvalidCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  transitionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTransitionEnd: true }),
	      captured: keyOf({ onTransitionEndCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};
	
	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topAnimationEnd: eventTypes.animationEnd,
	  topAnimationIteration: eventTypes.animationIteration,
	  topAnimationStart: eventTypes.animationStart,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topInvalid: eventTypes.invalid,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topTransitionEnd: eventTypes.transitionEnd,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};
	
	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}
	
	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};
	
	function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	}
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topInvalid:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topAnimationEnd:
	      case topLevelTypes.topAnimationIteration:
	      case topLevelTypes.topAnimationStart:
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case topLevelTypes.topTransitionEnd:
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function didPutListener(inst, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var key = getDictionaryKey(inst);
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      if (!onClickListeners[key]) {
	        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function willDeleteListener(inst, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      var key = getDictionaryKey(inst);
	      onClickListeners[key].remove();
	      delete onClickListeners[key];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticAnimationEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(53);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var AnimationEventInterface = {
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
	
	module.exports = SyntheticAnimationEvent;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(53);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function clipboardData(event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(76);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(76);
	
	var getEventCharCode = __webpack_require__(156);
	var getEventKey = __webpack_require__(157);
	var getEventModifierState = __webpack_require__(78);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function charCode(event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function keyCode(event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function which(event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 156 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(156);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(75);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(76);
	
	var getEventModifierState = __webpack_require__(78);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTransitionEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(53);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var TransitionEventInterface = {
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
	
	module.exports = SyntheticTransitionEvent;

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(75);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function deltaX(event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function deltaY(event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var DOMLazyTree = __webpack_require__(82);
	var DOMProperty = __webpack_require__(37);
	var ReactBrowserEventEmitter = __webpack_require__(107);
	var ReactCurrentOwner = __webpack_require__(10);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactDOMContainerInfo = __webpack_require__(163);
	var ReactDOMFeatureFlags = __webpack_require__(164);
	var ReactElement = __webpack_require__(9);
	var ReactFeatureFlags = __webpack_require__(58);
	var ReactInstanceMap = __webpack_require__(119);
	var ReactInstrumentation = __webpack_require__(62);
	var ReactMarkupChecksum = __webpack_require__(165);
	var ReactReconciler = __webpack_require__(59);
	var ReactUpdateQueue = __webpack_require__(131);
	var ReactUpdates = __webpack_require__(56);
	
	var emptyObject = __webpack_require__(19);
	var instantiateReactComponent = __webpack_require__(121);
	var invariant = __webpack_require__(8);
	var setInnerHTML = __webpack_require__(84);
	var shouldUpdateReactComponent = __webpack_require__(125);
	var warning = __webpack_require__(11);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var instancesByReactRootID = {};
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
	  var markerName;
	  if (ReactFeatureFlags.logTopLevelRenders) {
	    var wrappedElement = wrapperInstance._currentElement.props;
	    var type = wrappedElement.type;
	    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
	    console.time(markerName);
	  }
	
	  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
	  );
	
	  if (markerName) {
	    console.timeEnd(markerName);
	  }
	
	  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
	  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */
	  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container, safely) {
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onBeginFlush();
	  }
	  ReactReconciler.unmountComponent(instance, safely);
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onEndFlush();
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  if (rootEl) {
	    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
	    return !!(inst && inst._hostParent);
	  }
	}
	
	/**
	 * True if the supplied DOM node is a React DOM element and
	 * it has been rendered by another copy of React.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM has been rendered by another copy of React
	 * @internal
	 */
	function nodeIsRenderedByOtherInstance(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
	}
	
	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
	}
	
	/**
	 * True if the supplied DOM node is a valid React node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid React DOM node.
	 * @internal
	 */
	function isReactNode(node) {
	  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
	}
	
	function getHostRootInstanceInContainer(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
	  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
	}
	
	function getTopLevelWrapperInContainer(container) {
	  var root = getHostRootInstanceInContainer(container);
	  return root ? root._hostContainerInfo._topLevelWrapper : null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var topLevelRootCounter = 1;
	var TopLevelWrapper = function TopLevelWrapper() {
	  this.rootID = topLevelRootCounter++;
	};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /**
	   * Used by devtools. The keys are not important.
	   */
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function scrollMonitor(container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function _updateRootComponent(prevComponent, nextElement, nextContext, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    return prevComponent;
	  },
	
	  /**
	   * Render a new component into the DOM. Hooked by hooks!
	   *
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	    var componentInstance = instantiateReactComponent(nextElement, false);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
	
	    var wrapperID = componentInstance._instance.rootID;
	    instancesByReactRootID[wrapperID] = componentInstance;
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
	    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
	
	    var nextWrappedElement = ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
	
	    var nextContext;
	    if (parentComponent) {
	      var parentInst = ReactInstanceMap.get(parentComponent);
	      nextContext = parentInst._processChildContext(parentInst._context);
	    } else {
	      nextContext = emptyObject;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function render(nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function unmountComponentAtNode(container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	    if (!prevComponent) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }
	
	      return false;
	    }
	    delete instancesByReactRootID[prevComponent._instance.rootID];
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
	    return true;
	  },
	
	  _mountImageIntoNode: function _mountImageIntoNode(markup, container, instance, shouldReuseMarkup, transaction) {
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        ReactDOMComponentTree.precacheNode(instance, rootElement);
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      DOMLazyTree.insertTreeBefore(container, markup, null);
	    } else {
	      setInnerHTML(container, markup);
	      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
	      if (hostNode._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation(hostNode._debugID, 'mount', markup.toString());
	      }
	    }
	  }
	};
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMContainerInfo
	 */
	
	'use strict';
	
	var validateDOMNesting = __webpack_require__(132);
	
	var DOC_NODE_TYPE = 9;
	
	function ReactDOMContainerInfo(topLevelWrapper, node) {
	  var info = {
	    _topLevelWrapper: topLevelWrapper,
	    _idCounter: 1,
	    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
	    _node: node,
	    _tag: node ? node.nodeName.toLowerCase() : null,
	    _namespaceURI: node ? node.namespaceURI : null
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
	  }
	  return info;
	}
	
	module.exports = ReactDOMContainerInfo;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 164 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: true
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(166);
	
	var TAG_END = /\/?>/;
	var COMMENT_START = /^<\!\-\-/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function addChecksumToMarkup(markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags, comments and self-closing tags)
	    if (COMMENT_START.test(markup)) {
	      return markup;
	    } else {
	      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	    }
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function canReuseMarkup(markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 166 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 * 
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    var n = Math.min(i + 4096, m);
	    for (; i < n; i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(7);
	
	var ReactCurrentOwner = __webpack_require__(10);
	var ReactDOMComponentTree = __webpack_require__(36);
	var ReactInstanceMap = __webpack_require__(119);
	
	var getHostComponentFromComposite = __webpack_require__(168);
	var invariant = __webpack_require__(8);
	var warning = __webpack_require__(11);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	
	  var inst = ReactInstanceMap.get(componentOrElement);
	  if (inst) {
	    inst = getHostComponentFromComposite(inst);
	    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
	  }
	
	  if (typeof componentOrElement.render === 'function') {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
	  }
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getHostComponentFromComposite
	 */
	
	'use strict';
	
	var ReactNodeTypes = __webpack_require__(123);
	
	function getHostComponentFromComposite(inst) {
	  var type;
	
	  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
	    inst = inst._renderedComponent;
	  }
	
	  if (type === ReactNodeTypes.HOST) {
	    return inst._renderedComponent;
	  } else if (type === ReactNodeTypes.EMPTY) {
	    return null;
	  }
	}
	
	module.exports = getHostComponentFromComposite;

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/
	
	'use strict';
	
	var ReactMount = __webpack_require__(162);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMUnknownPropertyHook
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(37);
	var EventPluginRegistry = __webpack_require__(44);
	var ReactComponentTreeHook = __webpack_require__(28);
	
	var warning = __webpack_require__(11);
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true,
	
	    autoFocus: true,
	    defaultValue: true,
	    valueLink: true,
	    defaultChecked: true,
	    checkedLink: true,
	    innerHTML: true,
	    suppressContentEditableWarning: true,
	    onFocusIn: true,
	    onFocusOut: true
	  };
	  var warnedProperties = {};
	
	  var validateProperty = function validateProperty(tagName, name, debugID) {
	    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
	      return true;
	    }
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return true;
	    }
	    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
	      return true;
	    }
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
	
	    if (standardName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else if (registrationName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else {
	      // We were unable to guess which prop the user intended.
	      // It is likely that the user was just blindly spreading/forwarding props
	      // Components should be careful to only render valid props/attributes.
	      // Warning will be invoked in warnUnknownProperties to allow grouping.
	      return false;
	    }
	  };
	}
	
	var warnUnknownProperties = function warnUnknownProperties(debugID, element) {
	  var unknownProps = [];
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      unknownProps.push(key);
	    }
	  }
	
	  var unknownPropString = unknownProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (unknownProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (unknownProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	};
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	  warnUnknownProperties(debugID, element);
	}
	
	var ReactDOMUnknownPropertyHook = {
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMUnknownPropertyHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMNullInputValuePropHook
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(28);
	
	var warning = __webpack_require__(11);
	
	var didWarnValueNull = false;
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
	    return;
	  }
	  if (element.props != null && element.props.value === null && !didWarnValueNull) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	
	    didWarnValueNull = true;
	  }
	}
	
	var ReactDOMNullInputValuePropHook = {
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMNullInputValuePropHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.connect = exports.Provider = undefined;
	
	var _Provider = __webpack_require__(173);
	
	var _Provider2 = _interopRequireDefault(_Provider);
	
	var _connect = __webpack_require__(176);
	
	var _connect2 = _interopRequireDefault(_connect);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}
	
	exports.Provider = _Provider2["default"];
	exports.connect = _connect2["default"];

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	exports["default"] = undefined;
	
	var _react = __webpack_require__(1);
	
	var _storeShape = __webpack_require__(174);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _warning = __webpack_require__(175);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var didWarnAboutReceivingStore = false;
	function warnAboutReceivingStore() {
	  if (didWarnAboutReceivingStore) {
	    return;
	  }
	  didWarnAboutReceivingStore = true;
	
	  (0, _warning2["default"])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
	}
	
	var Provider = function (_Component) {
	  _inherits(Provider, _Component);
	
	  Provider.prototype.getChildContext = function getChildContext() {
	    return { store: this.store };
	  };
	
	  function Provider(props, context) {
	    _classCallCheck(this, Provider);
	
	    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	    _this.store = props.store;
	    return _this;
	  }
	
	  Provider.prototype.render = function render() {
	    var children = this.props.children;
	
	    return _react.Children.only(children);
	  };
	
	  return Provider;
	}(_react.Component);
	
	exports["default"] = Provider;
	
	if (process.env.NODE_ENV !== 'production') {
	  Provider.prototype.componentWillReceiveProps = function (nextProps) {
	    var store = this.store;
	    var nextStore = nextProps.store;
	
	    if (store !== nextStore) {
	      warnAboutReceivingStore();
	    }
	  };
	}
	
	Provider.propTypes = {
	  store: _storeShape2["default"].isRequired,
	  children: _react.PropTypes.element.isRequired
	};
	Provider.childContextTypes = {
	  store: _storeShape2["default"].isRequired
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(1);
	
	exports["default"] = _react.PropTypes.shape({
	  subscribe: _react.PropTypes.func.isRequired,
	  dispatch: _react.PropTypes.func.isRequired,
	  getState: _react.PropTypes.func.isRequired
	});

/***/ },
/* 175 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that you can use this stack
	    // to find the callsite that caused this warning to fire.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.__esModule = true;
	exports["default"] = connect;
	
	var _react = __webpack_require__(1);
	
	var _storeShape = __webpack_require__(174);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _shallowEqual = __webpack_require__(177);
	
	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);
	
	var _wrapActionCreators = __webpack_require__(178);
	
	var _wrapActionCreators2 = _interopRequireDefault(_wrapActionCreators);
	
	var _warning = __webpack_require__(175);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _isPlainObject = __webpack_require__(181);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _hoistNonReactStatics = __webpack_require__(194);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _invariant = __webpack_require__(195);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var defaultMapStateToProps = function defaultMapStateToProps(state) {
	  return {};
	}; // eslint-disable-line no-unused-vars
	var defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {
	  return { dispatch: dispatch };
	};
	var defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {
	  return _extends({}, parentProps, stateProps, dispatchProps);
	};
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	var errorObject = { value: null };
	function tryCatch(fn, ctx) {
	  try {
	    return fn.apply(ctx);
	  } catch (e) {
	    errorObject.value = e;
	    return errorObject;
	  }
	}
	
	// Helps track hot reloading.
	var nextVersion = 0;
	
	function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
	  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
	
	  var shouldSubscribe = Boolean(mapStateToProps);
	  var mapState = mapStateToProps || defaultMapStateToProps;
	
	  var mapDispatch = undefined;
	  if (typeof mapDispatchToProps === 'function') {
	    mapDispatch = mapDispatchToProps;
	  } else if (!mapDispatchToProps) {
	    mapDispatch = defaultMapDispatchToProps;
	  } else {
	    mapDispatch = (0, _wrapActionCreators2["default"])(mapDispatchToProps);
	  }
	
	  var finalMergeProps = mergeProps || defaultMergeProps;
	  var _options$pure = options.pure;
	  var pure = _options$pure === undefined ? true : _options$pure;
	  var _options$withRef = options.withRef;
	  var withRef = _options$withRef === undefined ? false : _options$withRef;
	
	  var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps;
	
	  // Helps track hot reloading.
	  var version = nextVersion++;
	
	  return function wrapWithConnect(WrappedComponent) {
	    var connectDisplayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';
	
	    function checkStateShape(props, methodName) {
	      if (!(0, _isPlainObject2["default"])(props)) {
	        (0, _warning2["default"])(methodName + '() in ' + connectDisplayName + ' must return a plain object. ' + ('Instead received ' + props + '.'));
	      }
	    }
	
	    function computeMergedProps(stateProps, dispatchProps, parentProps) {
	      var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);
	      if (process.env.NODE_ENV !== 'production') {
	        checkStateShape(mergedProps, 'mergeProps');
	      }
	      return mergedProps;
	    }
	
	    var Connect = function (_Component) {
	      _inherits(Connect, _Component);
	
	      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
	        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;
	      };
	
	      function Connect(props, context) {
	        _classCallCheck(this, Connect);
	
	        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	        _this.version = version;
	        _this.store = props.store || context.store;
	
	        (0, _invariant2["default"])(_this.store, 'Could not find "store" in either the context or ' + ('props of "' + connectDisplayName + '". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass "store" as a prop to "' + connectDisplayName + '".'));
	
	        var storeState = _this.store.getState();
	        _this.state = { storeState: storeState };
	        _this.clearCache();
	        return _this;
	      }
	
	      Connect.prototype.computeStateProps = function computeStateProps(store, props) {
	        if (!this.finalMapStateToProps) {
	          return this.configureFinalMapState(store, props);
	        }
	
	        var state = store.getState();
	        var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(stateProps, 'mapStateToProps');
	        }
	        return stateProps;
	      };
	
	      Connect.prototype.configureFinalMapState = function configureFinalMapState(store, props) {
	        var mappedState = mapState(store.getState(), props);
	        var isFactory = typeof mappedState === 'function';
	
	        this.finalMapStateToProps = isFactory ? mappedState : mapState;
	        this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeStateProps(store, props);
	        }
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(mappedState, 'mapStateToProps');
	        }
	        return mappedState;
	      };
	
	      Connect.prototype.computeDispatchProps = function computeDispatchProps(store, props) {
	        if (!this.finalMapDispatchToProps) {
	          return this.configureFinalMapDispatch(store, props);
	        }
	
	        var dispatch = store.dispatch;
	
	        var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(dispatchProps, 'mapDispatchToProps');
	        }
	        return dispatchProps;
	      };
	
	      Connect.prototype.configureFinalMapDispatch = function configureFinalMapDispatch(store, props) {
	        var mappedDispatch = mapDispatch(store.dispatch, props);
	        var isFactory = typeof mappedDispatch === 'function';
	
	        this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;
	        this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeDispatchProps(store, props);
	        }
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(mappedDispatch, 'mapDispatchToProps');
	        }
	        return mappedDispatch;
	      };
	
	      Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {
	        var nextStateProps = this.computeStateProps(this.store, this.props);
	        if (this.stateProps && (0, _shallowEqual2["default"])(nextStateProps, this.stateProps)) {
	          return false;
	        }
	
	        this.stateProps = nextStateProps;
	        return true;
	      };
	
	      Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {
	        var nextDispatchProps = this.computeDispatchProps(this.store, this.props);
	        if (this.dispatchProps && (0, _shallowEqual2["default"])(nextDispatchProps, this.dispatchProps)) {
	          return false;
	        }
	
	        this.dispatchProps = nextDispatchProps;
	        return true;
	      };
	
	      Connect.prototype.updateMergedPropsIfNeeded = function updateMergedPropsIfNeeded() {
	        var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);
	        if (this.mergedProps && checkMergedEquals && (0, _shallowEqual2["default"])(nextMergedProps, this.mergedProps)) {
	          return false;
	        }
	
	        this.mergedProps = nextMergedProps;
	        return true;
	      };
	
	      Connect.prototype.isSubscribed = function isSubscribed() {
	        return typeof this.unsubscribe === 'function';
	      };
	
	      Connect.prototype.trySubscribe = function trySubscribe() {
	        if (shouldSubscribe && !this.unsubscribe) {
	          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));
	          this.handleChange();
	        }
	      };
	
	      Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {
	        if (this.unsubscribe) {
	          this.unsubscribe();
	          this.unsubscribe = null;
	        }
	      };
	
	      Connect.prototype.componentDidMount = function componentDidMount() {
	        this.trySubscribe();
	      };
	
	      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        if (!pure || !(0, _shallowEqual2["default"])(nextProps, this.props)) {
	          this.haveOwnPropsChanged = true;
	        }
	      };
	
	      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
	        this.tryUnsubscribe();
	        this.clearCache();
	      };
	
	      Connect.prototype.clearCache = function clearCache() {
	        this.dispatchProps = null;
	        this.stateProps = null;
	        this.mergedProps = null;
	        this.haveOwnPropsChanged = true;
	        this.hasStoreStateChanged = true;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	        this.renderedElement = null;
	        this.finalMapDispatchToProps = null;
	        this.finalMapStateToProps = null;
	      };
	
	      Connect.prototype.handleChange = function handleChange() {
	        if (!this.unsubscribe) {
	          return;
	        }
	
	        var storeState = this.store.getState();
	        var prevStoreState = this.state.storeState;
	        if (pure && prevStoreState === storeState) {
	          return;
	        }
	
	        if (pure && !this.doStatePropsDependOnOwnProps) {
	          var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);
	          if (!haveStatePropsChanged) {
	            return;
	          }
	          if (haveStatePropsChanged === errorObject) {
	            this.statePropsPrecalculationError = errorObject.value;
	          }
	          this.haveStatePropsBeenPrecalculated = true;
	        }
	
	        this.hasStoreStateChanged = true;
	        this.setState({ storeState: storeState });
	      };
	
	      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
	        (0, _invariant2["default"])(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');
	
	        return this.refs.wrappedInstance;
	      };
	
	      Connect.prototype.render = function render() {
	        var haveOwnPropsChanged = this.haveOwnPropsChanged;
	        var hasStoreStateChanged = this.hasStoreStateChanged;
	        var haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated;
	        var statePropsPrecalculationError = this.statePropsPrecalculationError;
	        var renderedElement = this.renderedElement;
	
	        this.haveOwnPropsChanged = false;
	        this.hasStoreStateChanged = false;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	
	        if (statePropsPrecalculationError) {
	          throw statePropsPrecalculationError;
	        }
	
	        var shouldUpdateStateProps = true;
	        var shouldUpdateDispatchProps = true;
	        if (pure && renderedElement) {
	          shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;
	          shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;
	        }
	
	        var haveStatePropsChanged = false;
	        var haveDispatchPropsChanged = false;
	        if (haveStatePropsBeenPrecalculated) {
	          haveStatePropsChanged = true;
	        } else if (shouldUpdateStateProps) {
	          haveStatePropsChanged = this.updateStatePropsIfNeeded();
	        }
	        if (shouldUpdateDispatchProps) {
	          haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();
	        }
	
	        var haveMergedPropsChanged = true;
	        if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {
	          haveMergedPropsChanged = this.updateMergedPropsIfNeeded();
	        } else {
	          haveMergedPropsChanged = false;
	        }
	
	        if (!haveMergedPropsChanged && renderedElement) {
	          return renderedElement;
	        }
	
	        if (withRef) {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, _extends({}, this.mergedProps, {
	            ref: 'wrappedInstance'
	          }));
	        } else {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, this.mergedProps);
	        }
	
	        return this.renderedElement;
	      };
	
	      return Connect;
	    }(_react.Component);
	
	    Connect.displayName = connectDisplayName;
	    Connect.WrappedComponent = WrappedComponent;
	    Connect.contextTypes = {
	      store: _storeShape2["default"]
	    };
	    Connect.propTypes = {
	      store: _storeShape2["default"]
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
	        if (this.version === version) {
	          return;
	        }
	
	        // We are hot reloading!
	        this.version = version;
	        this.trySubscribe();
	        this.clearCache();
	      };
	    }
	
	    return (0, _hoistNonReactStatics2["default"])(Connect, WrappedComponent);
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 177 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = shallowEqual;
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var hasOwn = Object.prototype.hasOwnProperty;
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = wrapActionCreators;
	
	var _redux = __webpack_require__(179);
	
	function wrapActionCreators(actionCreators) {
	  return function (dispatch) {
	    return (0, _redux.bindActionCreators)(actionCreators, dispatch);
	  };
	}

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(180);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(189);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(191);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(192);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(193);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(190);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  (0, _warning2['default'])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2['default'];
	exports.combineReducers = _combineReducers2['default'];
	exports.bindActionCreators = _bindActionCreators2['default'];
	exports.applyMiddleware = _applyMiddleware2['default'];
	exports.compose = _compose2['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports['default'] = createStore;
	
	var _isPlainObject = __webpack_require__(181);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(186);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [preloadedState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, preloadedState, enhancer) {
	  var _ref2;
	
	  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = preloadedState;
	    preloadedState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, preloadedState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = preloadedState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing what changed. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2['default'])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	      subscribe: function subscribe(observer) {
	        if ((typeof observer === 'undefined' ? 'undefined' : _typeof(observer)) !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2['default']] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2['default']] = observable, _ref2;
	}

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var getPrototype = __webpack_require__(182),
	    isHostObject = __webpack_require__(184),
	    isObjectLike = __webpack_require__(185);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
	        return false;
	    }
	    var proto = getPrototype(value);
	    if (proto === null) {
	        return true;
	    }
	    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
	}
	
	module.exports = isPlainObject;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var overArg = __webpack_require__(183);
	
	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);
	
	module.exports = getPrototype;

/***/ },
/* 183 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function (arg) {
	    return func(transform(arg));
	  };
	}
	
	module.exports = overArg;

/***/ },
/* 184 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	module.exports = isHostObject;

/***/ },
/* 185 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
	}
	
	module.exports = isObjectLike;

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(187);

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _ponyfill = __webpack_require__(188);
	
	var _ponyfill2 = _interopRequireDefault(_ponyfill);
	
	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var root = undefined; /* global window */
	
	if (typeof global !== 'undefined') {
		root = global;
	} else if (typeof window !== 'undefined') {
		root = window;
	}
	
	var result = (0, _ponyfill2['default'])(root);
	exports['default'] = result;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 188 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports['default'] = symbolObservablePonyfill;
	function symbolObservablePonyfill(root) {
		var result;
		var _Symbol = root.Symbol;
	
		if (typeof _Symbol === 'function') {
			if (_Symbol.observable) {
				result = _Symbol.observable;
			} else {
				result = _Symbol('observable');
				_Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports['default'] = combineReducers;
	
	var _createStore = __webpack_require__(180);
	
	var _isPlainObject = __webpack_require__(181);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(190);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2['default'])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
	  });
	
	  unexpectedKeys.forEach(function (key) {
	    unexpectedKeyCache[key] = true;
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (typeof reducers[key] === 'undefined') {
	        (0, _warning2['default'])('No reducer provided for key "' + key + '"');
	      }
	    }
	
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  if (process.env.NODE_ENV !== 'production') {
	    var unexpectedKeyCache = {};
	  }
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
	      if (warningMessage) {
	        (0, _warning2['default'])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 190 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 191 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	exports['default'] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if ((typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports['default'] = applyMiddleware;
	
	var _compose = __webpack_require__(193);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, preloadedState, enhancer) {
	      var store = createStore(reducer, preloadedState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 193 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  }
	
	  if (funcs.length === 1) {
	    return funcs[0];
	  }
	
	  var last = funcs[funcs.length - 1];
	  var rest = funcs.slice(0, -1);
	  return function () {
	    return rest.reduceRight(function (composed, f) {
	      return f(composed);
	    }, last.apply(undefined, arguments));
	  };
	}

/***/ },
/* 194 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';
	
	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};
	
	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};
	
	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';
	
	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') {
	        // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);
	
	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }
	
	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {}
	            }
	        }
	    }
	
	    return targetComponent;
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 196 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	function createThunkMiddleware(extraArgument) {
	  return function (_ref) {
	    var dispatch = _ref.dispatch;
	    var getState = _ref.getState;
	    return function (next) {
	      return function (action) {
	        if (typeof action === 'function') {
	          return action(dispatch, getState, extraArgument);
	        }
	
	        return next(action);
	      };
	    };
	  };
	}
	
	var thunk = createThunkMiddleware();
	thunk.withExtraArgument = createThunkMiddleware;
	
	exports['default'] = thunk;

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(172);
	
	var _redux = __webpack_require__(179);
	
	var _SongList = __webpack_require__(198);
	
	var _SongList2 = _interopRequireDefault(_SongList);
	
	var _object = __webpack_require__(200);
	
	var _object2 = _interopRequireDefault(_object);
	
	var _actions = __webpack_require__(227);
	
	__webpack_require__(298);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var App = function (_Component) {
	  _inherits(App, _Component);
	
	  function App() {
	    _classCallCheck(this, App);
	
	    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));
	  }
	
	  _createClass(App, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      var _props = this.props;
	      var display = _props.display;
	      var dispatch = _props.dispatch;
	      var songs = _props.songs;
	
	
	      var upvote = (0, _redux.bindActionCreators)(_actions.upvoteSong, dispatch);
	
	      return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement(
	          'button',
	          { onClick: function onClick() {
	              return dispatch((0, _actions.connectSocket)());
	            } },
	          'Connect'
	        ),
	        _react2.default.createElement('br', null),
	        _react2.default.createElement('br', null),
	        _react2.default.createElement(
	          'button',
	          { onClick: function onClick() {
	              return dispatch((0, _actions.disconnectSocket)());
	            } },
	          'DisConnect'
	        ),
	        _react2.default.createElement('br', null),
	        _react2.default.createElement('br', null),
	        _react2.default.createElement('input', { ref: 'message' }),
	        _react2.default.createElement(
	          'button',
	          { onClick: function onClick() {
	              return dispatch((0, _actions.sendMessage)(_this2.refs.message.value));
	            } },
	          'Send Message'
	        ),
	        _react2.default.createElement(
	          'div',
	          null,
	          _react2.default.createElement(_SongList2.default, {
	            upvoteSong: upvote,
	            songs: songs })
	        )
	      );
	    }
	  }]);
	
	  return App;
	}(_react.Component);
	
	exports.default = (0, _reactRedux.connect)(function (state) {
	  return {
	    songs: (0, _object2.default)(state.songs)
	  };
	})(App);

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _sortUtil = __webpack_require__(199);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SongList = function (_Component) {
	  _inherits(SongList, _Component);
	
	  function SongList() {
	    _classCallCheck(this, SongList);
	
	    return _possibleConstructorReturn(this, (SongList.__proto__ || Object.getPrototypeOf(SongList)).apply(this, arguments));
	  }
	
	  _createClass(SongList, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      var songs = this.props.songs.sort(_sortUtil.sortByLikes).map(function (song, index) {
	        return _react2.default.createElement(
	          'div',
	          {
	            onClick: _this2.props.upvoteSong.bind(_this2, song.id),
	            key: index,
	            className: 'song' },
	          _react2.default.createElement(
	            'div',
	            { className: 'song-name' },
	            song.name
	          ),
	          _react2.default.createElement(
	            'div',
	            { className: 'song-likes' },
	            song.likes
	          )
	        );
	      });
	      return _react2.default.createElement(
	        'div',
	        { className: 'list' },
	        songs
	      );
	    }
	  }]);
	
	  return SongList;
	}(_react.Component);
	
	exports.default = SongList;

/***/ },
/* 199 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.sortByLikes = sortByLikes;
	function sortByLikes(a, b) {
	  if (a.likes > b.likes) {
	    return 1;
	  } else if (a.likes < b.likes) {
	    return -1;
	  } else {
	    return 0;
	  }
	}

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var define = __webpack_require__(201);
	
	var implementation = __webpack_require__(205);
	var getPolyfill = __webpack_require__(225);
	var shim = __webpack_require__(226);
	
	define(implementation, {
		getPolyfill: getPolyfill,
		implementation: implementation,
		shim: shim
	});
	
	module.exports = implementation;

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var keys = __webpack_require__(202);
	var foreach = __webpack_require__(204);
	var hasSymbols = typeof Symbol === 'function' && _typeof(Symbol()) === 'symbol';
	
	var toStr = Object.prototype.toString;
	
	var isFunction = function isFunction(fn) {
		return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
	};
	
	var arePropertyDescriptorsSupported = function arePropertyDescriptorsSupported() {
		var obj = {};
		try {
			Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
			/* eslint-disable no-unused-vars, no-restricted-syntax */
			for (var _ in obj) {
				return false;
			}
			/* eslint-enable no-unused-vars, no-restricted-syntax */
			return obj.x === obj;
		} catch (e) {
			/* this is IE 8. */
			return false;
		}
	};
	var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();
	
	var defineProperty = function defineProperty(object, name, value, predicate) {
		if (name in object && (!isFunction(predicate) || !predicate())) {
			return;
		}
		if (supportsDescriptors) {
			Object.defineProperty(object, name, {
				configurable: true,
				enumerable: false,
				value: value,
				writable: true
			});
		} else {
			object[name] = value;
		}
	};
	
	var defineProperties = function defineProperties(object, map) {
		var predicates = arguments.length > 2 ? arguments[2] : {};
		var props = keys(map);
		if (hasSymbols) {
			props = props.concat(Object.getOwnPropertySymbols(map));
		}
		foreach(props, function (name) {
			defineProperty(object, name, map[name], predicates[name]);
		});
	};
	
	defineProperties.supportsDescriptors = !!supportsDescriptors;
	
	module.exports = defineProperties;

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	// modified from https://github.com/es-shims/es5-shim
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var slice = Array.prototype.slice;
	var isArgs = __webpack_require__(203);
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
	var equalsConstructorPrototype = function equalsConstructorPrototype(o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = function () {
		/* global window */
		if (typeof window === 'undefined') {
			return false;
		}
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && _typeof(window[k]) === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}();
	var equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy(o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};
	
	var keysShim = function keys(object) {
		var isObject = object !== null && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];
	
		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}
	
		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}
	
		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}
	
		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
	
			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
	
	keysShim.shim = function shimObjectKeys() {
		if (Object.keys) {
			var keysWorksWithArguments = function () {
				// Safari 5.0 bug
				return (Object.keys(arguments) || '').length === 2;
			}(1, 2);
			if (!keysWorksWithArguments) {
				var originalKeys = Object.keys;
				Object.keys = function keys(object) {
					if (isArgs(object)) {
						return originalKeys(slice.call(object));
					} else {
						return originalKeys(object);
					}
				};
			}
		} else {
			Object.keys = keysShim;
		}
		return Object.keys || keysShim;
	};
	
	module.exports = keysShim;

/***/ },
/* 203 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var toStr = Object.prototype.toString;
	
	module.exports = function isArguments(value) {
		var str = toStr.call(value);
		var isArgs = str === '[object Arguments]';
		if (!isArgs) {
			isArgs = str !== '[object Array]' && value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
		}
		return isArgs;
	};

/***/ },
/* 204 */
/***/ function(module, exports) {

	'use strict';
	
	var hasOwn = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;
	
	module.exports = function forEach(obj, fn, ctx) {
	    if (toString.call(fn) !== '[object Function]') {
	        throw new TypeError('iterator must be a function');
	    }
	    var l = obj.length;
	    if (l === +l) {
	        for (var i = 0; i < l; i++) {
	            fn.call(ctx, obj[i], i, obj);
	        }
	    } else {
	        for (var k in obj) {
	            if (hasOwn.call(obj, k)) {
	                fn.call(ctx, obj[k], k, obj);
	            }
	        }
	    }
	};

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var ES = __webpack_require__(206);
	var has = __webpack_require__(224);
	var bind = __webpack_require__(219);
	var isEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);
	
	module.exports = function values(O) {
		var obj = ES.RequireObjectCoercible(O);
		var vals = [];
		for (var key in obj) {
			if (has(obj, key) && isEnumerable(obj, key)) {
				vals.push(obj[key]);
			}
		}
		return vals;
	};

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var ES6 = __webpack_require__(207);
	var assign = __webpack_require__(210);
	
	var ES7 = assign(ES6, {
		// https://github.com/tc39/ecma262/pull/60
		SameValueNonNumber: function SameValueNonNumber(x, y) {
			if (typeof x === 'number' || (typeof x === 'undefined' ? 'undefined' : _typeof(x)) !== (typeof y === 'undefined' ? 'undefined' : _typeof(y))) {
				throw new TypeError('SameValueNonNumber requires two non-number values of the same type.');
			}
			return this.SameValue(x, y);
		}
	});
	
	module.exports = ES7;

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var toStr = Object.prototype.toString;
	var hasSymbols = typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol';
	var symbolToStr = hasSymbols ? Symbol.prototype.toString : toStr;
	
	var $isNaN = __webpack_require__(208);
	var $isFinite = __webpack_require__(209);
	var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
	
	var assign = __webpack_require__(210);
	var sign = __webpack_require__(211);
	var mod = __webpack_require__(212);
	var isPrimitive = __webpack_require__(213);
	var toPrimitive = __webpack_require__(214);
	var parseInteger = parseInt;
	var bind = __webpack_require__(219);
	var strSlice = bind.call(Function.call, String.prototype.slice);
	var isBinary = bind.call(Function.call, RegExp.prototype.test, /^0b[01]+$/i);
	var isOctal = bind.call(Function.call, RegExp.prototype.test, /^0o[0-7]+$/i);
	var nonWS = ['', '', ''].join('');
	var nonWSregex = new RegExp('[' + nonWS + ']', 'g');
	var hasNonWS = bind.call(Function.call, RegExp.prototype.test, nonWSregex);
	var invalidHexLiteral = /^[\-\+]0x[0-9a-f]+$/i;
	var isInvalidHexLiteral = bind.call(Function.call, RegExp.prototype.test, invalidHexLiteral);
	
	// whitespace from: http://es5.github.io/#x15.5.4.20
	// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
	var ws = ['\t\n\u000b\f\r ', '\u2028', '\u2029'].join('');
	var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
	var replace = bind.call(Function.call, String.prototype.replace);
	var trim = function trim(value) {
		return replace(value, trimRegex, '');
	};
	
	var ES5 = __webpack_require__(221);
	
	var hasRegExpMatcher = __webpack_require__(223);
	
	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-abstract-operations
	var ES6 = assign(assign({}, ES5), {
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
		Call: function Call(F, V) {
			var args = arguments.length > 2 ? arguments[2] : [];
			if (!this.IsCallable(F)) {
				throw new TypeError(F + ' is not a function');
			}
			return F.apply(V, args);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
		ToPrimitive: toPrimitive,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toboolean
		// ToBoolean: ES5.ToBoolean,
	
		// http://www.ecma-international.org/ecma-262/6.0/#sec-tonumber
		ToNumber: function ToNumber(argument) {
			var value = isPrimitive(argument) ? argument : toPrimitive(argument, 'number');
			if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol') {
				throw new TypeError('Cannot convert a Symbol value to a number');
			}
			if (typeof value === 'string') {
				if (isBinary(value)) {
					return this.ToNumber(parseInteger(strSlice(value, 2), 2));
				} else if (isOctal(value)) {
					return this.ToNumber(parseInteger(strSlice(value, 2), 8));
				} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
					return NaN;
				} else {
					var trimmed = trim(value);
					if (trimmed !== value) {
						return this.ToNumber(trimmed);
					}
				}
			}
			return Number(value);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger
		// ToInteger: ES5.ToNumber,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint32
		// ToInt32: ES5.ToInt32,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint32
		// ToUint32: ES5.ToUint32,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint16
		ToInt16: function ToInt16(argument) {
			var int16bit = this.ToUint16(argument);
			return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint16
		// ToUint16: ES5.ToUint16,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint8
		ToInt8: function ToInt8(argument) {
			var int8bit = this.ToUint8(argument);
			return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8
		ToUint8: function ToUint8(argument) {
			var number = this.ToNumber(argument);
			if ($isNaN(number) || number === 0 || !$isFinite(number)) {
				return 0;
			}
			var posInt = sign(number) * Math.floor(Math.abs(number));
			return mod(posInt, 0x100);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8clamp
		ToUint8Clamp: function ToUint8Clamp(argument) {
			var number = this.ToNumber(argument);
			if ($isNaN(number) || number <= 0) {
				return 0;
			}
			if (number >= 0xFF) {
				return 0xFF;
			}
			var f = Math.floor(argument);
			if (f + 0.5 < number) {
				return f + 1;
			}
			if (number < f + 0.5) {
				return f;
			}
			if (f % 2 !== 0) {
				return f + 1;
			}
			return f;
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tostring
		ToString: function ToString(argument) {
			if ((typeof argument === 'undefined' ? 'undefined' : _typeof(argument)) === 'symbol') {
				throw new TypeError('Cannot convert a Symbol value to a string');
			}
			return String(argument);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toobject
		ToObject: function ToObject(value) {
			this.RequireObjectCoercible(value);
			return Object(value);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
		ToPropertyKey: function ToPropertyKey(argument) {
			var key = this.ToPrimitive(argument, String);
			return (typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'symbol' ? symbolToStr.call(key) : this.ToString(key);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
		ToLength: function ToLength(argument) {
			var len = this.ToInteger(argument);
			if (len <= 0) {
				return 0;
			} // includes converting -0 to +0
			if (len > MAX_SAFE_INTEGER) {
				return MAX_SAFE_INTEGER;
			}
			return len;
		},
	
		// http://www.ecma-international.org/ecma-262/6.0/#sec-canonicalnumericindexstring
		CanonicalNumericIndexString: function CanonicalNumericIndexString(argument) {
			if (toStr.call(argument) !== '[object String]') {
				throw new TypeError('must be a string');
			}
			if (argument === '-0') {
				return -0;
			}
			var n = this.ToNumber(argument);
			if (this.SameValue(this.ToString(n), argument)) {
				return n;
			}
			return void 0;
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-requireobjectcoercible
		RequireObjectCoercible: ES5.CheckObjectCoercible,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
		IsArray: Array.isArray || function IsArray(argument) {
			return toStr.call(argument) === '[object Array]';
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iscallable
		// IsCallable: ES5.IsCallable,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
		IsConstructor: function IsConstructor(argument) {
			return typeof argument === 'function' && !!argument.prototype; // unfortunately there's no way to truly check this without try/catch `new argument`
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isextensible-o
		IsExtensible: function IsExtensible(obj) {
			if (!Object.preventExtensions) {
				return true;
			}
			if (isPrimitive(obj)) {
				return false;
			}
			return Object.isExtensible(obj);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isinteger
		IsInteger: function IsInteger(argument) {
			if (typeof argument !== 'number' || $isNaN(argument) || !$isFinite(argument)) {
				return false;
			}
			var abs = Math.abs(argument);
			return Math.floor(abs) === abs;
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ispropertykey
		IsPropertyKey: function IsPropertyKey(argument) {
			return typeof argument === 'string' || (typeof argument === 'undefined' ? 'undefined' : _typeof(argument)) === 'symbol';
		},
	
		// http://www.ecma-international.org/ecma-262/6.0/#sec-isregexp
		IsRegExp: function IsRegExp(argument) {
			if (!argument || (typeof argument === 'undefined' ? 'undefined' : _typeof(argument)) !== 'object') {
				return false;
			}
			if (hasSymbols) {
				var isRegExp = argument[Symbol.match];
				if (typeof isRegExp !== 'undefined') {
					return ES5.ToBoolean(isRegExp);
				}
			}
			return hasRegExpMatcher(argument);
		},
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevalue
		// SameValue: ES5.SameValue,
	
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero
		SameValueZero: function SameValueZero(x, y) {
			return x === y || $isNaN(x) && $isNaN(y);
		},
	
		Type: function Type(x) {
			if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'symbol') {
				return 'Symbol';
			}
			return ES5.Type(x);
		},
	
		// http://www.ecma-international.org/ecma-262/6.0/#sec-speciesconstructor
		SpeciesConstructor: function SpeciesConstructor(O, defaultConstructor) {
			if (this.Type(O) !== 'Object') {
				throw new TypeError('Assertion failed: Type(O) is not Object');
			}
			var C = O.constructor;
			if (typeof C === 'undefined') {
				return defaultConstructor;
			}
			if (this.Type(C) !== 'Object') {
				throw new TypeError('O.constructor is not an Object');
			}
			var S = hasSymbols && Symbol.species ? C[Symbol.species] : undefined;
			if (S == null) {
				return defaultConstructor;
			}
			if (this.IsConstructor(S)) {
				return S;
			}
			throw new TypeError('no constructor found');
		}
	});
	
	delete ES6.CheckObjectCoercible; // renamed in ES6 to RequireObjectCoercible
	
	module.exports = ES6;

/***/ },
/* 208 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = Number.isNaN || function isNaN(a) {
		return a !== a;
	};

/***/ },
/* 209 */
/***/ function(module, exports) {

	'use strict';
	
	var $isNaN = Number.isNaN || function (a) {
	  return a !== a;
	};
	
	module.exports = Number.isFinite || function (x) {
	  return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity;
	};

/***/ },
/* 210 */
/***/ function(module, exports) {

	"use strict";
	
	var has = Object.prototype.hasOwnProperty;
	module.exports = Object.assign || function assign(target, source) {
		for (var key in source) {
			if (has.call(source, key)) {
				target[key] = source[key];
			}
		}
		return target;
	};

/***/ },
/* 211 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = function sign(number) {
		return number >= 0 ? 1 : -1;
	};

/***/ },
/* 212 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = function mod(number, modulo) {
		var remain = number % modulo;
		return Math.floor(remain >= 0 ? remain : remain + modulo);
	};

/***/ },
/* 213 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	module.exports = function isPrimitive(value) {
		return value === null || typeof value !== 'function' && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object';
	};

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var hasSymbols = typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol';
	
	var isPrimitive = __webpack_require__(215);
	var isCallable = __webpack_require__(216);
	var isDate = __webpack_require__(217);
	var isSymbol = __webpack_require__(218);
	
	var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
		if (typeof O === 'undefined' || O === null) {
			throw new TypeError('Cannot call method on ' + O);
		}
		if (typeof hint !== 'string' || hint !== 'number' && hint !== 'string') {
			throw new TypeError('hint must be "string" or "number"');
		}
		var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
		var method, result, i;
		for (i = 0; i < methodNames.length; ++i) {
			method = O[methodNames[i]];
			if (isCallable(method)) {
				result = method.call(O);
				if (isPrimitive(result)) {
					return result;
				}
			}
		}
		throw new TypeError('No default value');
	};
	
	var GetMethod = function GetMethod(O, P) {
		var func = O[P];
		if (func !== null && typeof func !== 'undefined') {
			if (!isCallable(func)) {
				throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
			}
			return func;
		}
	};
	
	// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
	module.exports = function ToPrimitive(input, PreferredType) {
		if (isPrimitive(input)) {
			return input;
		}
		var hint = 'default';
		if (arguments.length > 1) {
			if (PreferredType === String) {
				hint = 'string';
			} else if (PreferredType === Number) {
				hint = 'number';
			}
		}
	
		var exoticToPrim;
		if (hasSymbols) {
			if (Symbol.toPrimitive) {
				exoticToPrim = GetMethod(input, Symbol.toPrimitive);
			} else if (isSymbol(input)) {
				exoticToPrim = Symbol.prototype.valueOf;
			}
		}
		if (typeof exoticToPrim !== 'undefined') {
			var result = exoticToPrim.call(input, hint);
			if (isPrimitive(result)) {
				return result;
			}
			throw new TypeError('unable to convert exotic object to primitive');
		}
		if (hint === 'default' && (isDate(input) || isSymbol(input))) {
			hint = 'string';
		}
		return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
	};

/***/ },
/* 215 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	module.exports = function isPrimitive(value) {
		return value === null || typeof value !== 'function' && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object';
	};

/***/ },
/* 216 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var fnToStr = Function.prototype.toString;
	
	var constructorRegex = /^\s*class /;
	var isES6ClassFn = function isES6ClassFn(value) {
		try {
			var fnStr = fnToStr.call(value);
			var singleStripped = fnStr.replace(/\/\/.*\n/g, '');
			var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, '');
			var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' ');
			return constructorRegex.test(spaceStripped);
		} catch (e) {
			return false; // not a function
		}
	};
	
	var tryFunctionObject = function tryFunctionObject(value) {
		try {
			if (isES6ClassFn(value)) {
				return false;
			}
			fnToStr.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var fnClass = '[object Function]';
	var genClass = '[object GeneratorFunction]';
	var hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';
	
	module.exports = function isCallable(value) {
		if (!value) {
			return false;
		}
		if (typeof value !== 'function' && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') {
			return false;
		}
		if (hasToStringTag) {
			return tryFunctionObject(value);
		}
		if (isES6ClassFn(value)) {
			return false;
		}
		var strClass = toStr.call(value);
		return strClass === fnClass || strClass === genClass;
	};

/***/ },
/* 217 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var getDay = Date.prototype.getDay;
	var tryDateObject = function tryDateObject(value) {
		try {
			getDay.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	
	var toStr = Object.prototype.toString;
	var dateClass = '[object Date]';
	var hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';
	
	module.exports = function isDateObject(value) {
		if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' || value === null) {
			return false;
		}
		return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
	};

/***/ },
/* 218 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var toStr = Object.prototype.toString;
	var hasSymbols = typeof Symbol === 'function' && _typeof(Symbol()) === 'symbol';
	
	if (hasSymbols) {
		var symToStr = Symbol.prototype.toString;
		var symStringRegex = /^Symbol\(.*\)$/;
		var isSymbolObject = function isSymbolObject(value) {
			if (_typeof(value.valueOf()) !== 'symbol') {
				return false;
			}
			return symStringRegex.test(symToStr.call(value));
		};
		module.exports = function isSymbol(value) {
			if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol') {
				return true;
			}
			if (toStr.call(value) !== '[object Symbol]') {
				return false;
			}
			try {
				return isSymbolObject(value);
			} catch (e) {
				return false;
			}
		};
	} else {
		module.exports = function isSymbol(value) {
			// this environment does not support Symbols.
			return false;
		};
	}

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var implementation = __webpack_require__(220);
	
	module.exports = Function.prototype.bind || implementation;

/***/ },
/* 220 */
/***/ function(module, exports) {

	'use strict';
	
	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var slice = Array.prototype.slice;
	var toStr = Object.prototype.toString;
	var funcType = '[object Function]';
	
	module.exports = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slice.call(arguments, 1);
	
	    var bound;
	    var binder = function binder() {
	        if (this instanceof bound) {
	            var result = target.apply(this, args.concat(slice.call(arguments)));
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        } else {
	            return target.apply(that, args.concat(slice.call(arguments)));
	        }
	    };
	
	    var boundLength = Math.max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs.push('$' + i);
	    }
	
	    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);
	
	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }
	
	    return bound;
	};

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var $isNaN = __webpack_require__(208);
	var $isFinite = __webpack_require__(209);
	
	var sign = __webpack_require__(211);
	var mod = __webpack_require__(212);
	
	var IsCallable = __webpack_require__(216);
	var toPrimitive = __webpack_require__(222);
	
	// https://es5.github.io/#x9
	var ES5 = {
		ToPrimitive: toPrimitive,
	
		ToBoolean: function ToBoolean(value) {
			return Boolean(value);
		},
		ToNumber: function ToNumber(value) {
			return Number(value);
		},
		ToInteger: function ToInteger(value) {
			var number = this.ToNumber(value);
			if ($isNaN(number)) {
				return 0;
			}
			if (number === 0 || !$isFinite(number)) {
				return number;
			}
			return sign(number) * Math.floor(Math.abs(number));
		},
		ToInt32: function ToInt32(x) {
			return this.ToNumber(x) >> 0;
		},
		ToUint32: function ToUint32(x) {
			return this.ToNumber(x) >>> 0;
		},
		ToUint16: function ToUint16(value) {
			var number = this.ToNumber(value);
			if ($isNaN(number) || number === 0 || !$isFinite(number)) {
				return 0;
			}
			var posInt = sign(number) * Math.floor(Math.abs(number));
			return mod(posInt, 0x10000);
		},
		ToString: function ToString(value) {
			return String(value);
		},
		ToObject: function ToObject(value) {
			this.CheckObjectCoercible(value);
			return Object(value);
		},
		CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
			/* jshint eqnull:true */
			if (value == null) {
				throw new TypeError(optMessage || 'Cannot call method on ' + value);
			}
			return value;
		},
		IsCallable: IsCallable,
		SameValue: function SameValue(x, y) {
			if (x === y) {
				// 0 === -0, but they are not identical.
				if (x === 0) {
					return 1 / x === 1 / y;
				}
				return true;
			}
			return $isNaN(x) && $isNaN(y);
		},
	
		// http://www.ecma-international.org/ecma-262/5.1/#sec-8
		Type: function Type(x) {
			if (x === null) {
				return 'Null';
			}
			if (typeof x === 'undefined') {
				return 'Undefined';
			}
			if (typeof x === 'function' || (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object') {
				return 'Object';
			}
			if (typeof x === 'number') {
				return 'Number';
			}
			if (typeof x === 'boolean') {
				return 'Boolean';
			}
			if (typeof x === 'string') {
				return 'String';
			}
		}
	};
	
	module.exports = ES5;

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var toStr = Object.prototype.toString;
	
	var isPrimitive = __webpack_require__(215);
	
	var isCallable = __webpack_require__(216);
	
	// https://es5.github.io/#x8.12
	var ES5internalSlots = {
		'[[DefaultValue]]': function DefaultValue(O, hint) {
			var actualHint = hint || (toStr.call(O) === '[object Date]' ? String : Number);
	
			if (actualHint === String || actualHint === Number) {
				var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
				var value, i;
				for (i = 0; i < methods.length; ++i) {
					if (isCallable(O[methods[i]])) {
						value = O[methods[i]]();
						if (isPrimitive(value)) {
							return value;
						}
					}
				}
				throw new TypeError('No default value');
			}
			throw new TypeError('invalid [[DefaultValue]] hint supplied');
		}
	};
	
	// https://es5.github.io/#x9
	module.exports = function ToPrimitive(input, PreferredType) {
		if (isPrimitive(input)) {
			return input;
		}
		return ES5internalSlots['[[DefaultValue]]'](input, PreferredType);
	};

/***/ },
/* 223 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var regexExec = RegExp.prototype.exec;
	var tryRegexExec = function tryRegexExec(value) {
		try {
			regexExec.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var regexClass = '[object RegExp]';
	var hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';
	
	module.exports = function isRegex(value) {
		if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') {
			return false;
		}
		return hasToStringTag ? tryRegexExec(value) : toStr.call(value) === regexClass;
	};

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var bind = __webpack_require__(219);
	
	module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var implementation = __webpack_require__(205);
	
	module.exports = function getPolyfill() {
		return typeof Object.values === 'function' ? Object.values : implementation;
	};

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var getPolyfill = __webpack_require__(225);
	var define = __webpack_require__(201);
	
	module.exports = function shimValues() {
		var polyfill = getPolyfill();
		define(Object, { values: polyfill }, { values: function values() {
				return Object.values !== polyfill;
			} });
		return polyfill;
	};

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.connectSocket = connectSocket;
	exports.disconnectSocket = disconnectSocket;
	exports.receiveMessage = receiveMessage;
	exports.postMessage = postMessage;
	exports.sendMessage = sendMessage;
	exports.upvoteSong = upvoteSong;
	
	var _socket = __webpack_require__(228);
	
	var _socket2 = _interopRequireDefault(_socket);
	
	var _axios = __webpack_require__(275);
	
	var _axios2 = _interopRequireDefault(_axios);
	
	var _constants = __webpack_require__(297);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function connectSocket() {
	  return function (dispatch) {
	    var socket = (0, _socket2.default)();
	    socket.on('initialResult', function (data) {
	      dispatch({
	        type: _constants.INITIAL_RESULT,
	        result: data.result
	      });
	    });
	    socket.on('update', function (data) {
	      dispatch({
	        type: _constants.UPDATE,
	        song: data.result.new_val
	      });
	    });
	    dispatch({
	      type: _constants.CONNECT,
	      socket: socket
	    });
	  };
	}
	
	function disconnectSocket() {
	  return function (dispatch, state) {
	    var socket = state().socket;
	    Object.keys(socket).length > 0 ? socket.disconnect() : null;
	    dispatch({
	      type: _constants.DISCONNECT
	    });
	  };
	}
	
	function receiveMessage(message) {
	  return {
	    type: _constants.RECEIVE_MESSAGE,
	    message: message
	  };
	}
	
	function postMessage(text) {
	  return {
	    type: _constants.POST_MESSAGE,
	    text: text
	  };
	}
	
	function sendMessage(message) {
	  return function (dispatch, state) {
	    var socket = state().socket;
	    socket.emit('message', { message: message });
	  };
	}
	
	function upvoteSong(songId) {
	  return function (dispatch) {
	    _axios2.default.get('/upvote/' + songId).then(function (res) {
	      dispatch({
	        type: _constants.UPDATE,
	        song: res.data
	      });
	    });
	  };
	}

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/**
	 * Module dependencies.
	 */
	
	var url = __webpack_require__(229);
	var parser = __webpack_require__(234);
	var Manager = __webpack_require__(242);
	var debug = __webpack_require__(231)('socket.io-client');
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = lookup;
	
	/**
	 * Managers cache.
	 */
	
	var cache = exports.managers = {};
	
	/**
	 * Looks up an existing `Manager` for multiplexing.
	 * If the user summons:
	 *
	 *   `io('http://localhost/a');`
	 *   `io('http://localhost/b');`
	 *
	 * We reuse the existing instance based on same scheme/port/host,
	 * and we initialize sockets for each namespace.
	 *
	 * @api public
	 */
	
	function lookup(uri, opts) {
	  if ((typeof uri === 'undefined' ? 'undefined' : _typeof(uri)) == 'object') {
	    opts = uri;
	    uri = undefined;
	  }
	
	  opts = opts || {};
	
	  var parsed = url(uri);
	  var source = parsed.source;
	  var id = parsed.id;
	  var path = parsed.path;
	  var sameNamespace = cache[id] && path in cache[id].nsps;
	  var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;
	
	  var io;
	
	  if (newConnection) {
	    debug('ignoring socket cache for %s', source);
	    io = Manager(source, opts);
	  } else {
	    if (!cache[id]) {
	      debug('new io instance for %s', source);
	      cache[id] = Manager(source, opts);
	    }
	    io = cache[id];
	  }
	
	  return io.socket(parsed.path);
	}
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = parser.protocol;
	
	/**
	 * `connect`.
	 *
	 * @param {String} uri
	 * @api public
	 */
	
	exports.connect = lookup;
	
	/**
	 * Expose constructors for standalone build.
	 *
	 * @api public
	 */
	
	exports.Manager = __webpack_require__(242);
	exports.Socket = __webpack_require__(268);

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var parseuri = __webpack_require__(230);
	var debug = __webpack_require__(231)('socket.io-client:url');
	
	/**
	 * Module exports.
	 */
	
	module.exports = url;
	
	/**
	 * URL parser.
	 *
	 * @param {String} url
	 * @param {Object} An object meant to mimic window.location.
	 *                 Defaults to window.location.
	 * @api public
	 */
	
	function url(uri, loc) {
	  var obj = uri;
	
	  // default to window.location
	  var loc = loc || global.location;
	  if (null == uri) uri = loc.protocol + '//' + loc.host;
	
	  // relative path support
	  if ('string' == typeof uri) {
	    if ('/' == uri.charAt(0)) {
	      if ('/' == uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.host + uri;
	      }
	    }
	
	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      debug('protocol-less url %s', uri);
	      if ('undefined' != typeof loc) {
	        uri = loc.protocol + '//' + uri;
	      } else {
	        uri = 'https://' + uri;
	      }
	    }
	
	    // parse
	    debug('parse %s', uri);
	    obj = parseuri(uri);
	  }
	
	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = '80';
	    } else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = '443';
	    }
	  }
	
	  obj.path = obj.path || '/';
	
	  var ipv6 = obj.host.indexOf(':') !== -1;
	  var host = ipv6 ? '[' + obj.host + ']' : obj.host;
	
	  // define unique id
	  obj.id = obj.protocol + '://' + host + ':' + obj.port;
	  // define href
	  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : ':' + obj.port);
	
	  return obj;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 230 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */
	
	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
	
	var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
	
	module.exports = function parseuri(str) {
	    var src = str,
	        b = str.indexOf('['),
	        e = str.indexOf(']');
	
	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }
	
	    var m = re.exec(str || ''),
	        uri = {},
	        i = 14;
	
	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }
	
	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }
	
	    return uri;
	};

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(232);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return 'WebkitAppearance' in document.documentElement.style ||
	  // is firebug? http://stackoverflow.com/a/398120/376773
	  window.console && (console.firebug || console.exception && console.table) ||
	  // is firefox >= v31?
	  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function (v) {
	  return JSON.stringify(v);
	};
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function (match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch (e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch (e) {}
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(233);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {}
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}

/***/ },
/* 233 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function (val, options) {
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long ? long(val) : short(val);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function long(ms) {
	  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var debug = __webpack_require__(231)('socket.io-parser');
	var json = __webpack_require__(235);
	var isArray = __webpack_require__(238);
	var Emitter = __webpack_require__(239);
	var binary = __webpack_require__(240);
	var isBuf = __webpack_require__(241);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = 4;
	
	/**
	 * Packet types.
	 *
	 * @api public
	 */
	
	exports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'ACK', 'ERROR', 'BINARY_EVENT', 'BINARY_ACK'];
	
	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */
	
	exports.CONNECT = 0;
	
	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */
	
	exports.DISCONNECT = 1;
	
	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */
	
	exports.EVENT = 2;
	
	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */
	
	exports.ACK = 3;
	
	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */
	
	exports.ERROR = 4;
	
	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */
	
	exports.BINARY_EVENT = 5;
	
	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */
	
	exports.BINARY_ACK = 6;
	
	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */
	
	exports.Encoder = Encoder;
	
	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */
	
	exports.Decoder = Decoder;
	
	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */
	
	function Encoder() {}
	
	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */
	
	Encoder.prototype.encode = function (obj, callback) {
	  debug('encoding packet %j', obj);
	
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    encodeAsBinary(obj, callback);
	  } else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};
	
	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */
	
	function encodeAsString(obj) {
	  var str = '';
	  var nsp = false;
	
	  // first is type
	  str += obj.type;
	
	  // attachments if we have them
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    str += obj.attachments;
	    str += '-';
	  }
	
	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' != obj.nsp) {
	    nsp = true;
	    str += obj.nsp;
	  }
	
	  // immediately followed by the id
	  if (null != obj.id) {
	    if (nsp) {
	      str += ',';
	      nsp = false;
	    }
	    str += obj.id;
	  }
	
	  // json data
	  if (null != obj.data) {
	    if (nsp) str += ',';
	    str += json.stringify(obj.data);
	  }
	
	  debug('encoded %j as %s', obj, str);
	  return str;
	}
	
	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */
	
	function encodeAsBinary(obj, callback) {
	
	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;
	
	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }
	
	  binary.removeBlobs(obj, writeEncoding);
	}
	
	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */
	
	function Decoder() {
	  this.reconstructor = null;
	}
	
	/**
	 * Mix in `Emitter` with Decoder.
	 */
	
	Emitter(Decoder.prototype);
	
	/**
	 * Decodes an ecoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */
	
	Decoder.prototype.add = function (obj) {
	  var packet;
	  if ('string' == typeof obj) {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) {
	      // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);
	
	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments === 0) {
	        this.emit('decoded', packet);
	      }
	    } else {
	      // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  } else if (isBuf(obj) || obj.base64) {
	    // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) {
	        // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  } else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};
	
	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */
	
	function decodeString(str) {
	  var p = {};
	  var i = 0;
	
	  // look up type
	  p.type = Number(str.charAt(0));
	  if (null == exports.types[p.type]) return error();
	
	  // look up attachments if type binary
	  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
	    var buf = '';
	    while (str.charAt(++i) != '-') {
	      buf += str.charAt(i);
	      if (i == str.length) break;
	    }
	    if (buf != Number(buf) || str.charAt(i) != '-') {
	      throw new Error('Illegal attachments');
	    }
	    p.attachments = Number(buf);
	  }
	
	  // look up namespace (if any)
	  if ('/' == str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' == c) break;
	      p.nsp += c;
	      if (i == str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }
	
	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' !== next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i == str.length) break;
	    }
	    p.id = Number(p.id);
	  }
	
	  // look up json data
	  if (str.charAt(++i)) {
	    try {
	      p.data = json.parse(str.substr(i));
	    } catch (e) {
	      return error();
	    }
	  }
	
	  debug('decoded %s as %j', str, p);
	  return p;
	}
	
	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */
	
	Decoder.prototype.destroy = function () {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};
	
	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */
	
	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}
	
	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */
	
	BinaryReconstructor.prototype.takeBinaryData = function (binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length == this.reconPack.attachments) {
	    // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};
	
	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */
	
	BinaryReconstructor.prototype.finishedReconstruction = function () {
	  this.reconPack = null;
	  this.buffers = [];
	};
	
	function error(data) {
	  return {
	    type: exports.ERROR,
	    data: 'parser error'
	  };
	}

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
	;(function () {
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__(237);
	
	  // A set of types used to distinguish objects from primitives.
	  var objectTypes = {
	    "function": true,
	    "object": true
	  };
	
	  // Detect the `exports` object exposed by CommonJS implementations.
	  var freeExports = objectTypes[ false ? "undefined" : _typeof(exports)] && exports && !exports.nodeType && exports;
	
	  // Use the `global` object exposed by Node (including Browserify via
	  // `insert-module-globals`), Narwhal, and Ringo as the default context,
	  // and the `window` object in browsers. Rhino exports a `global` function
	  // instead.
	  var root = objectTypes[typeof window === "undefined" ? "undefined" : _typeof(window)] && window || this,
	      freeGlobal = freeExports && objectTypes[ false ? "undefined" : _typeof(module)] && module && !module.nodeType && (typeof global === "undefined" ? "undefined" : _typeof(global)) == "object" && global;
	
	  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
	    root = freeGlobal;
	  }
	
	  // Public: Initializes JSON 3 using the given `context` object, attaching the
	  // `stringify` and `parse` functions to the specified `exports` object.
	  function runInContext(context, exports) {
	    context || (context = root["Object"]());
	    exports || (exports = root["Object"]());
	
	    // Native constructor aliases.
	    var Number = context["Number"] || root["Number"],
	        String = context["String"] || root["String"],
	        Object = context["Object"] || root["Object"],
	        Date = context["Date"] || root["Date"],
	        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
	        TypeError = context["TypeError"] || root["TypeError"],
	        Math = context["Math"] || root["Math"],
	        nativeJSON = context["JSON"] || root["JSON"];
	
	    // Delegate to the native `stringify` and `parse` implementations.
	    if ((typeof nativeJSON === "undefined" ? "undefined" : _typeof(nativeJSON)) == "object" && nativeJSON) {
	      exports.stringify = nativeJSON.stringify;
	      exports.parse = nativeJSON.parse;
	    }
	
	    // Convenience aliases.
	    var objectProto = Object.prototype,
	        getClass = objectProto.toString,
	        _isProperty,
	        _forEach,
	        undef;
	
	    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	    var isExtended = new Date(-3509827334573292);
	    try {
	      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	      // results for certain dates in Opera >= 10.53.
	      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	      // Safari < 2.0.2 stores the internal millisecond time value correctly,
	      // but clips the values returned by the date methods to the range of
	      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	    } catch (exception) {}
	
	    // Internal: Determines whether the native `JSON.stringify` and `parse`
	    // implementations are spec-compliant. Based on work by Ken Snyder.
	    function has(name) {
	      if (has[name] !== undef) {
	        // Return cached feature test result.
	        return has[name];
	      }
	      var isSupported;
	      if (name == "bug-string-char-index") {
	        // IE <= 7 doesn't support accessing string characters using square
	        // bracket notation. IE 8 only supports this for primitives.
	        isSupported = "a"[0] != "a";
	      } else if (name == "json") {
	        // Indicates whether both `JSON.stringify` and `JSON.parse` are
	        // supported.
	        isSupported = has("json-stringify") && has("json-parse");
	      } else {
	        var value,
	            serialized = "{\"a\":[1,true,false,null,\"\\u0000\\b\\n\\f\\r\\t\"]}";
	        // Test `JSON.stringify`.
	        if (name == "json-stringify") {
	          var stringify = exports.stringify,
	              stringifySupported = typeof stringify == "function" && isExtended;
	          if (stringifySupported) {
	            // A test function object with a custom `toJSON` method.
	            (value = function value() {
	              return 1;
	            }).toJSON = value;
	            try {
	              stringifySupported =
	              // Firefox 3.1b1 and b2 serialize string, number, and boolean
	              // primitives as object literals.
	              stringify(0) === "0" &&
	              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	              // literals.
	              stringify(new Number()) === "0" && stringify(new String()) == '""' &&
	              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	              // does not define a canonical JSON representation (this applies to
	              // objects with `toJSON` properties as well, *unless* they are nested
	              // within an object or array).
	              stringify(getClass) === undef &&
	              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	              // FF 3.1b3 pass this test.
	              stringify(undef) === undef &&
	              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	              // respectively, if the value is omitted entirely.
	              stringify() === undef &&
	              // FF 3.1b1, 2 throw an error if the given value is not a number,
	              // string, array, object, Boolean, or `null` literal. This applies to
	              // objects with custom `toJSON` methods as well, unless they are nested
	              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	              // methods entirely.
	              stringify(value) === "1" && stringify([value]) == "[1]" &&
	              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	              // `"[null]"`.
	              stringify([undef]) == "[null]" &&
	              // YUI 3.0.0b1 fails to serialize `null` literals.
	              stringify(null) == "null" &&
	              // FF 3.1b1, 2 halts serialization if an array contains a function:
	              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	              // elides non-JSON values from objects and arrays, unless they
	              // define custom `toJSON` methods.
	              stringify([undef, getClass, null]) == "[null,null,null]" &&
	              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	              // where character escape codes are expected (e.g., `\b` => `\u0008`).
	              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	              stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	              // serialize extended years.
	              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	              // The milliseconds are optional in ES 5, but required in 5.1.
	              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	              // four-digit years instead of six-digit years. Credits: @Yaffle.
	              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	              // values less than 1000. Credits: @Yaffle.
	              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	            } catch (exception) {
	              stringifySupported = false;
	            }
	          }
	          isSupported = stringifySupported;
	        }
	        // Test `JSON.parse`.
	        if (name == "json-parse") {
	          var parse = exports.parse;
	          if (typeof parse == "function") {
	            try {
	              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	              // Conforming implementations should also coerce the initial argument to
	              // a string prior to parsing.
	              if (parse("0") === 0 && !parse(false)) {
	                // Simple parsing test.
	                value = parse(serialized);
	                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	                if (parseSupported) {
	                  try {
	                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                    parseSupported = !parse('"\t"');
	                  } catch (exception) {}
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                      // certain octal literals.
	                      parseSupported = parse("01") !== 1;
	                    } catch (exception) {}
	                  }
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                      // points. These environments, along with FF 3.1b1 and 2,
	                      // also allow trailing commas in JSON objects and arrays.
	                      parseSupported = parse("1.") !== 1;
	                    } catch (exception) {}
	                  }
	                }
	              }
	            } catch (exception) {
	              parseSupported = false;
	            }
	          }
	          isSupported = parseSupported;
	        }
	      }
	      return has[name] = !!isSupported;
	    }
	
	    if (!has("json")) {
	      // Common `[[Class]]` name aliases.
	      var functionClass = "[object Function]",
	          dateClass = "[object Date]",
	          numberClass = "[object Number]",
	          stringClass = "[object String]",
	          arrayClass = "[object Array]",
	          booleanClass = "[object Boolean]";
	
	      // Detect incomplete support for accessing string characters by index.
	      var charIndexBuggy = has("bug-string-char-index");
	
	      // Define additional utility methods if the `Date` methods are buggy.
	      if (!isExtended) {
	        var floor = Math.floor;
	        // A mapping between the months of the year and the number of days between
	        // January 1st and the first of the respective month.
	        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	        // Internal: Calculates the number of days between the Unix epoch and the
	        // first day of the given month.
	        var getDay = function getDay(year, month) {
	          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	        };
	      }
	
	      // Internal: Determines if a property is a direct property of the given
	      // object. Delegates to the native `Object#hasOwnProperty` method.
	      if (!(_isProperty = objectProto.hasOwnProperty)) {
	        _isProperty = function isProperty(property) {
	          var members = {},
	              constructor;
	          if ((members.__proto__ = null, members.__proto__ = {
	            // The *proto* property cannot be set multiple times in recent
	            // versions of Firefox and SeaMonkey.
	            "toString": 1
	          }, members).toString != getClass) {
	            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	            // supports the mutable *proto* property.
	            _isProperty = function isProperty(property) {
	              // Capture and break the object's prototype chain (see section 8.6.2
	              // of the ES 5.1 spec). The parenthesized expression prevents an
	              // unsafe transformation by the Closure Compiler.
	              var original = this.__proto__,
	                  result = property in (this.__proto__ = null, this);
	              // Restore the original prototype chain.
	              this.__proto__ = original;
	              return result;
	            };
	          } else {
	            // Capture a reference to the top-level `Object` constructor.
	            constructor = members.constructor;
	            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	            // other environments.
	            _isProperty = function isProperty(property) {
	              var parent = (this.constructor || constructor).prototype;
	              return property in this && !(property in parent && this[property] === parent[property]);
	            };
	          }
	          members = null;
	          return _isProperty.call(this, property);
	        };
	      }
	
	      // Internal: Normalizes the `for...in` iteration algorithm across
	      // environments. Each enumerated key is yielded to a `callback` function.
	      _forEach = function forEach(object, callback) {
	        var size = 0,
	            Properties,
	            members,
	            property;
	
	        // Tests for bugs in the current environment's `for...in` algorithm. The
	        // `valueOf` property inherits the non-enumerable flag from
	        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	        (Properties = function Properties() {
	          this.valueOf = 0;
	        }).prototype.valueOf = 0;
	
	        // Iterate over a new instance of the `Properties` class.
	        members = new Properties();
	        for (property in members) {
	          // Ignore all properties inherited from `Object.prototype`.
	          if (_isProperty.call(members, property)) {
	            size++;
	          }
	        }
	        Properties = members = null;
	
	        // Normalize the iteration algorithm.
	        if (!size) {
	          // A list of non-enumerable properties inherited from `Object.prototype`.
	          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	          // properties.
	          _forEach = function forEach(object, callback) {
	            var isFunction = getClass.call(object) == functionClass,
	                property,
	                length;
	            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[_typeof(object.hasOwnProperty)] && object.hasOwnProperty || _isProperty;
	            for (property in object) {
	              // Gecko <= 1.0 enumerates the `prototype` property of functions under
	              // certain conditions; IE does not.
	              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for each non-enumerable property.
	            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property)) {}
	          };
	        } else if (size == 2) {
	          // Safari <= 2.0.4 enumerates shadowed properties twice.
	          _forEach = function forEach(object, callback) {
	            // Create a set of iterated properties.
	            var members = {},
	                isFunction = getClass.call(object) == functionClass,
	                property;
	            for (property in object) {
	              // Store each property name to prevent double enumeration. The
	              // `prototype` property of functions is not enumerated due to cross-
	              // environment inconsistencies.
	              if (!(isFunction && property == "prototype") && !_isProperty.call(members, property) && (members[property] = 1) && _isProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	          };
	        } else {
	          // No bugs detected; use the standard `for...in` algorithm.
	          _forEach = function forEach(object, callback) {
	            var isFunction = getClass.call(object) == functionClass,
	                property,
	                isConstructor;
	            for (property in object) {
	              if (!(isFunction && property == "prototype") && _isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for the `constructor` property due to
	            // cross-environment inconsistencies.
	            if (isConstructor || _isProperty.call(object, property = "constructor")) {
	              callback(property);
	            }
	          };
	        }
	        return _forEach(object, callback);
	      };
	
	      // Public: Serializes a JavaScript `value` as a JSON string. The optional
	      // `filter` argument may specify either a function that alters how object and
	      // array members are serialized, or an array of strings and numbers that
	      // indicates which properties should be serialized. The optional `width`
	      // argument may be either a string or number that specifies the indentation
	      // level of the output.
	      if (!has("json-stringify")) {
	        // Internal: A map of control characters and their escaped equivalents.
	        var Escapes = {
	          92: "\\\\",
	          34: '\\"',
	          8: "\\b",
	          12: "\\f",
	          10: "\\n",
	          13: "\\r",
	          9: "\\t"
	        };
	
	        // Internal: Converts `value` into a zero-padded string such that its
	        // length is at least equal to `width`. The `width` must be <= 6.
	        var leadingZeroes = "000000";
	        var toPaddedString = function toPaddedString(width, value) {
	          // The `|| 0` expression is necessary to work around a bug in
	          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	          return (leadingZeroes + (value || 0)).slice(-width);
	        };
	
	        // Internal: Double-quotes a string `value`, replacing all ASCII control
	        // characters (characters with code unit values between 0 and 31) with
	        // their escaped equivalents. This is an implementation of the
	        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	        var unicodePrefix = "\\u00";
	        var quote = function quote(value) {
	          var result = '"',
	              index = 0,
	              length = value.length,
	              useCharIndex = !charIndexBuggy || length > 10;
	          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
	          for (; index < length; index++) {
	            var charCode = value.charCodeAt(index);
	            // If the character is a control character, append its Unicode or
	            // shorthand escape sequence; otherwise, append the character as-is.
	            switch (charCode) {
	              case 8:case 9:case 10:case 12:case 13:case 34:case 92:
	                result += Escapes[charCode];
	                break;
	              default:
	                if (charCode < 32) {
	                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                  break;
	                }
	                result += useCharIndex ? symbols[index] : value.charAt(index);
	            }
	          }
	          return result + '"';
	        };
	
	        // Internal: Recursively serializes an object. Implements the
	        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	        var serialize = function serialize(property, object, callback, properties, whitespace, indentation, stack) {
	          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	          try {
	            // Necessary for host object support.
	            value = object[property];
	          } catch (exception) {}
	          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
	            className = getClass.call(value);
	            if (className == dateClass && !_isProperty.call(value, "toJSON")) {
	              if (value > -1 / 0 && value < 1 / 0) {
	                // Dates are serialized according to the `Date#toJSON` method
	                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	                // for the ISO 8601 date time string format.
	                if (getDay) {
	                  // Manually compute the year, month, date, hours, minutes,
	                  // seconds, and milliseconds if the `getUTC*` methods are
	                  // buggy. Adapted from @Yaffle's `date-shim` project.
	                  date = floor(value / 864e5);
	                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) {}
	                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) {}
	                  date = 1 + date - getDay(year, month);
	                  // The `time` value specifies the time within the day (see ES
	                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                  // to compute `A modulo B`, as the `%` operator does not
	                  // correspond to the `modulo` operation for negative numbers.
	                  time = (value % 864e5 + 864e5) % 864e5;
	                  // The hours, minutes, seconds, and milliseconds are obtained by
	                  // decomposing the time within the day. See section 15.9.1.10.
	                  hours = floor(time / 36e5) % 24;
	                  minutes = floor(time / 6e4) % 60;
	                  seconds = floor(time / 1e3) % 60;
	                  milliseconds = time % 1e3;
	                } else {
	                  year = value.getUTCFullYear();
	                  month = value.getUTCMonth();
	                  date = value.getUTCDate();
	                  hours = value.getUTCHours();
	                  minutes = value.getUTCMinutes();
	                  seconds = value.getUTCSeconds();
	                  milliseconds = value.getUTCMilliseconds();
	                }
	                // Serialize extended years correctly.
	                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                // Months, dates, hours, minutes, and seconds should have two
	                // digits; milliseconds should have three.
	                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                // Milliseconds are optional in ES 5.0, but required in 5.1.
	                "." + toPaddedString(3, milliseconds) + "Z";
	              } else {
	                value = null;
	              }
	            } else if (typeof value.toJSON == "function" && (className != numberClass && className != stringClass && className != arrayClass || _isProperty.call(value, "toJSON"))) {
	              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	              // ignores all `toJSON` methods on these objects unless they are
	              // defined directly on an instance.
	              value = value.toJSON(property);
	            }
	          }
	          if (callback) {
	            // If a replacement function was provided, call it to obtain the value
	            // for serialization.
	            value = callback.call(object, property, value);
	          }
	          if (value === null) {
	            return "null";
	          }
	          className = getClass.call(value);
	          if (className == booleanClass) {
	            // Booleans are represented literally.
	            return "" + value;
	          } else if (className == numberClass) {
	            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	            // `"null"`.
	            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	          } else if (className == stringClass) {
	            // Strings are double-quoted and escaped.
	            return quote("" + value);
	          }
	          // Recursively serialize objects and arrays.
	          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object") {
	            // Check for cyclic structures. This is a linear search; performance
	            // is inversely proportional to the number of unique nested objects.
	            for (length = stack.length; length--;) {
	              if (stack[length] === value) {
	                // Cyclic structures cannot be serialized by `JSON.stringify`.
	                throw TypeError();
	              }
	            }
	            // Add the object to the stack of traversed objects.
	            stack.push(value);
	            results = [];
	            // Save the current indentation level and indent one additional level.
	            prefix = indentation;
	            indentation += whitespace;
	            if (className == arrayClass) {
	              // Recursively serialize array elements.
	              for (index = 0, length = value.length; index < length; index++) {
	                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	                results.push(element === undef ? "null" : element);
	              }
	              result = results.length ? whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : "[" + results.join(",") + "]" : "[]";
	            } else {
	              // Recursively serialize object members. Members are selected from
	              // either a user-specified list of property names, or the object
	              // itself.
	              _forEach(properties || value, function (property) {
	                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	                if (element !== undef) {
	                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                  // is not the empty string, let `member` {quote(property) + ":"}
	                  // be the concatenation of `member` and the `space` character."
	                  // The "`space` character" refers to the literal space
	                  // character, not the `space` {width} argument provided to
	                  // `JSON.stringify`.
	                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	                }
	              });
	              result = results.length ? whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : "{" + results.join(",") + "}" : "{}";
	            }
	            // Remove the object from the traversed object stack.
	            stack.pop();
	            return result;
	          }
	        };
	
	        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	        exports.stringify = function (source, filter, width) {
	          var whitespace, callback, properties, className;
	          if (objectTypes[typeof filter === "undefined" ? "undefined" : _typeof(filter)] && filter) {
	            if ((className = getClass.call(filter)) == functionClass) {
	              callback = filter;
	            } else if (className == arrayClass) {
	              // Convert the property names array into a makeshift set.
	              properties = {};
	              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], (className = getClass.call(value), className == stringClass || className == numberClass) && (properties[value] = 1)) {}
	            }
	          }
	          if (width) {
	            if ((className = getClass.call(width)) == numberClass) {
	              // Convert the `width` to an integer and create a string containing
	              // `width` number of space characters.
	              if ((width -= width % 1) > 0) {
	                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ") {}
	              }
	            } else if (className == stringClass) {
	              whitespace = width.length <= 10 ? width : width.slice(0, 10);
	            }
	          }
	          // Opera <= 7.54u2 discards the values associated with empty string keys
	          // (`""`) only if they are used directly within an object member list
	          // (e.g., `!("" in { "": 1})`).
	          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	        };
	      }
	
	      // Public: Parses a JSON source string.
	      if (!has("json-parse")) {
	        var fromCharCode = String.fromCharCode;
	
	        // Internal: A map of escaped control characters and their unescaped
	        // equivalents.
	        var Unescapes = {
	          92: "\\",
	          34: '"',
	          47: "/",
	          98: "\b",
	          116: "\t",
	          110: "\n",
	          102: "\f",
	          114: "\r"
	        };
	
	        // Internal: Stores the parser state.
	        var Index, Source;
	
	        // Internal: Resets the parser state and throws a `SyntaxError`.
	        var abort = function abort() {
	          Index = Source = null;
	          throw SyntaxError();
	        };
	
	        // Internal: Returns the next token, or `"$"` if the parser has reached
	        // the end of the source string. A token may be a string, number, `null`
	        // literal, or Boolean literal.
	        var lex = function lex() {
	          var source = Source,
	              length = source.length,
	              value,
	              begin,
	              position,
	              isSigned,
	              charCode;
	          while (Index < length) {
	            charCode = source.charCodeAt(Index);
	            switch (charCode) {
	              case 9:case 10:case 13:case 32:
	                // Skip whitespace tokens, including tabs, carriage returns, line
	                // feeds, and space characters.
	                Index++;
	                break;
	              case 123:case 125:case 91:case 93:case 58:case 44:
	                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	                // the current position.
	                value = charIndexBuggy ? source.charAt(Index) : source[Index];
	                Index++;
	                return value;
	              case 34:
	                // `"` delimits a JSON string; advance to the next character and
	                // begin parsing the string. String tokens are prefixed with the
	                // sentinel `@` character to distinguish them from punctuators and
	                // end-of-string tokens.
	                for (value = "@", Index++; Index < length;) {
	                  charCode = source.charCodeAt(Index);
	                  if (charCode < 32) {
	                    // Unescaped ASCII control characters (those with a code unit
	                    // less than the space character) are not permitted.
	                    abort();
	                  } else if (charCode == 92) {
	                    // A reverse solidus (`\`) marks the beginning of an escaped
	                    // control character (including `"`, `\`, and `/`) or Unicode
	                    // escape sequence.
	                    charCode = source.charCodeAt(++Index);
	                    switch (charCode) {
	                      case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:
	                        // Revive escaped control characters.
	                        value += Unescapes[charCode];
	                        Index++;
	                        break;
	                      case 117:
	                        // `\u` marks the beginning of a Unicode escape sequence.
	                        // Advance to the first character and validate the
	                        // four-digit code point.
	                        begin = ++Index;
	                        for (position = Index + 4; Index < position; Index++) {
	                          charCode = source.charCodeAt(Index);
	                          // A valid sequence comprises four hexdigits (case-
	                          // insensitive) that form a single hexadecimal value.
	                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                            // Invalid Unicode escape sequence.
	                            abort();
	                          }
	                        }
	                        // Revive the escaped character.
	                        value += fromCharCode("0x" + source.slice(begin, Index));
	                        break;
	                      default:
	                        // Invalid escape sequence.
	                        abort();
	                    }
	                  } else {
	                    if (charCode == 34) {
	                      // An unescaped double-quote character marks the end of the
	                      // string.
	                      break;
	                    }
	                    charCode = source.charCodeAt(Index);
	                    begin = Index;
	                    // Optimize for the common case where a string is valid.
	                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                      charCode = source.charCodeAt(++Index);
	                    }
	                    // Append the string as-is.
	                    value += source.slice(begin, Index);
	                  }
	                }
	                if (source.charCodeAt(Index) == 34) {
	                  // Advance to the next character and return the revived string.
	                  Index++;
	                  return value;
	                }
	                // Unterminated string.
	                abort();
	              default:
	                // Parse numbers and literals.
	                begin = Index;
	                // Advance past the negative sign, if one is specified.
	                if (charCode == 45) {
	                  isSigned = true;
	                  charCode = source.charCodeAt(++Index);
	                }
	                // Parse an integer or floating-point value.
	                if (charCode >= 48 && charCode <= 57) {
	                  // Leading zeroes are interpreted as octal literals.
	                  if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {
	                    // Illegal octal literal.
	                    abort();
	                  }
	                  isSigned = false;
	                  // Parse the integer component.
	                  for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++) {}
	                  // Floats cannot contain a leading decimal point; however, this
	                  // case is already accounted for by the parser.
	                  if (source.charCodeAt(Index) == 46) {
	                    position = ++Index;
	                    // Parse the decimal component.
	                    for (; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
	                    if (position == Index) {
	                      // Illegal trailing decimal.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Parse exponents. The `e` denoting the exponent is
	                  // case-insensitive.
	                  charCode = source.charCodeAt(Index);
	                  if (charCode == 101 || charCode == 69) {
	                    charCode = source.charCodeAt(++Index);
	                    // Skip past the sign following the exponent, if one is
	                    // specified.
	                    if (charCode == 43 || charCode == 45) {
	                      Index++;
	                    }
	                    // Parse the exponential component.
	                    for (position = Index; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
	                    if (position == Index) {
	                      // Illegal empty exponent.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Coerce the parsed value to a JavaScript number.
	                  return +source.slice(begin, Index);
	                }
	                // A negative sign may only precede numbers.
	                if (isSigned) {
	                  abort();
	                }
	                // `true`, `false`, and `null` literals.
	                if (source.slice(Index, Index + 4) == "true") {
	                  Index += 4;
	                  return true;
	                } else if (source.slice(Index, Index + 5) == "false") {
	                  Index += 5;
	                  return false;
	                } else if (source.slice(Index, Index + 4) == "null") {
	                  Index += 4;
	                  return null;
	                }
	                // Unrecognized token.
	                abort();
	            }
	          }
	          // Return the sentinel `$` character if the parser has reached the end
	          // of the source string.
	          return "$";
	        };
	
	        // Internal: Parses a JSON `value` token.
	        var get = function get(value) {
	          var results, hasMembers;
	          if (value == "$") {
	            // Unexpected end of input.
	            abort();
	          }
	          if (typeof value == "string") {
	            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	              // Remove the sentinel `@` character.
	              return value.slice(1);
	            }
	            // Parse object and array literals.
	            if (value == "[") {
	              // Parses a JSON array, returning a new JavaScript array.
	              results = [];
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing square bracket marks the end of the array literal.
	                if (value == "]") {
	                  break;
	                }
	                // If the array literal contains elements, the current token
	                // should be a comma separating the previous element from the
	                // next.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "]") {
	                      // Unexpected trailing `,` in array literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each array element.
	                    abort();
	                  }
	                }
	                // Elisions and leading commas are not permitted.
	                if (value == ",") {
	                  abort();
	                }
	                results.push(get(value));
	              }
	              return results;
	            } else if (value == "{") {
	              // Parses a JSON object, returning a new JavaScript object.
	              results = {};
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing curly brace marks the end of the object literal.
	                if (value == "}") {
	                  break;
	                }
	                // If the object literal contains members, the current token
	                // should be a comma separator.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "}") {
	                      // Unexpected trailing `,` in object literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each object member.
	                    abort();
	                  }
	                }
	                // Leading commas are not permitted, object property names must be
	                // double-quoted strings, and a `:` must separate each property
	                // name and value.
	                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                  abort();
	                }
	                results[value.slice(1)] = get(lex());
	              }
	              return results;
	            }
	            // Unexpected token encountered.
	            abort();
	          }
	          return value;
	        };
	
	        // Internal: Updates a traversed object member.
	        var update = function update(source, property, callback) {
	          var element = walk(source, property, callback);
	          if (element === undef) {
	            delete source[property];
	          } else {
	            source[property] = element;
	          }
	        };
	
	        // Internal: Recursively traverses a parsed JSON object, invoking the
	        // `callback` function for each value. This is an implementation of the
	        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	        var walk = function walk(source, property, callback) {
	          var value = source[property],
	              length;
	          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
	            // `forEach` can't be used to traverse an array in Opera <= 8.54
	            // because its `Object#hasOwnProperty` implementation returns `false`
	            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	            if (getClass.call(value) == arrayClass) {
	              for (length = value.length; length--;) {
	                update(value, length, callback);
	              }
	            } else {
	              _forEach(value, function (property) {
	                update(value, property, callback);
	              });
	            }
	          }
	          return callback.call(source, property, value);
	        };
	
	        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	        exports.parse = function (source, callback) {
	          var result, value;
	          Index = 0;
	          Source = "" + source;
	          result = get(lex());
	          // If a JSON string contains multiple tokens, it is invalid.
	          if (lex() != "$") {
	            abort();
	          }
	          // Reset the parser state.
	          Index = Source = null;
	          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	        };
	      }
	    }
	
	    exports["runInContext"] = runInContext;
	    return exports;
	  }
	
	  if (freeExports && !isLoader) {
	    // Export for CommonJS environments.
	    runInContext(root, freeExports);
	  } else {
	    // Export for web browsers and JavaScript engines.
	    var nativeJSON = root.JSON,
	        previousJSON = root["JSON3"],
	        isRestored = false;
	
	    var JSON3 = runInContext(root, root["JSON3"] = {
	      // Public: Restores the original value of the global `JSON` object and
	      // returns a reference to the `JSON3` object.
	      "noConflict": function noConflict() {
	        if (!isRestored) {
	          isRestored = true;
	          root.JSON = nativeJSON;
	          root["JSON3"] = previousJSON;
	          nativeJSON = previousJSON = null;
	        }
	        return JSON3;
	      }
	    });
	
	    root.JSON = {
	      "parse": JSON3.parse,
	      "stringify": JSON3.stringify
	    };
	  }
	
	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(236)(module), (function() { return this; }())))

/***/ },
/* 236 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ },
/* 237 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 238 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};

/***/ },
/* 239 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || []).push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function (event, fn) {
	  var self = this;
	  this._callbacks = this._callbacks || {};
	
	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function (event) {
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1),
	      callbacks = this._callbacks[event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function (event) {
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function (event) {
	  return !!this.listeners(event).length;
	};

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/*global Blob,File*/
	
	/**
	 * Module requirements
	 */
	
	var isArray = __webpack_require__(238);
	var isBuf = __webpack_require__(241);
	
	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */
	
	exports.deconstructPacket = function (packet) {
	  var buffers = [];
	  var packetData = packet.data;
	
	  function _deconstructPacket(data) {
	    if (!data) return data;
	
	    if (isBuf(data)) {
	      var placeholder = { _placeholder: true, num: buffers.length };
	      buffers.push(data);
	      return placeholder;
	    } else if (isArray(data)) {
	      var newData = new Array(data.length);
	      for (var i = 0; i < data.length; i++) {
	        newData[i] = _deconstructPacket(data[i]);
	      }
	      return newData;
	    } else if ('object' == (typeof data === 'undefined' ? 'undefined' : _typeof(data)) && !(data instanceof Date)) {
	      var newData = {};
	      for (var key in data) {
	        newData[key] = _deconstructPacket(data[key]);
	      }
	      return newData;
	    }
	    return data;
	  }
	
	  var pack = packet;
	  pack.data = _deconstructPacket(packetData);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return { packet: pack, buffers: buffers };
	};
	
	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */
	
	exports.reconstructPacket = function (packet, buffers) {
	  var curPlaceHolder = 0;
	
	  function _reconstructPacket(data) {
	    if (data && data._placeholder) {
	      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
	      return buf;
	    } else if (isArray(data)) {
	      for (var i = 0; i < data.length; i++) {
	        data[i] = _reconstructPacket(data[i]);
	      }
	      return data;
	    } else if (data && 'object' == (typeof data === 'undefined' ? 'undefined' : _typeof(data))) {
	      for (var key in data) {
	        data[key] = _reconstructPacket(data[key]);
	      }
	      return data;
	    }
	    return data;
	  }
	
	  packet.data = _reconstructPacket(packet.data);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};
	
	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */
	
	exports.removeBlobs = function (data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;
	
	    // convert any blob
	    if (global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
	      pendingBlobs++;
	
	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function () {
	        // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        } else {
	          bloblessData = this.result;
	        }
	
	        // if nothing pending its callback time
	        if (! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };
	
	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) {
	      // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (obj && 'object' == (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) && !isBuf(obj)) {
	      // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }
	
	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 241 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	module.exports = isBuf;
	
	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */
	
	function isBuf(obj) {
	  return global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/**
	 * Module dependencies.
	 */
	
	var eio = __webpack_require__(243);
	var Socket = __webpack_require__(268);
	var Emitter = __webpack_require__(269);
	var parser = __webpack_require__(234);
	var on = __webpack_require__(271);
	var bind = __webpack_require__(272);
	var debug = __webpack_require__(231)('socket.io-client:manager');
	var indexOf = __webpack_require__(266);
	var Backoff = __webpack_require__(274);
	
	/**
	 * IE6+ hasOwnProperty
	 */
	
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * Module exports
	 */
	
	module.exports = Manager;
	
	/**
	 * `Manager` constructor.
	 *
	 * @param {String} engine instance or engine uri/opts
	 * @param {Object} options
	 * @api public
	 */
	
	function Manager(uri, opts) {
	  if (!(this instanceof Manager)) return new Manager(uri, opts);
	  if (uri && 'object' == (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};
	
	  opts.path = opts.path || '/socket.io';
	  this.nsps = {};
	  this.subs = [];
	  this.opts = opts;
	  this.reconnection(opts.reconnection !== false);
	  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	  this.reconnectionDelay(opts.reconnectionDelay || 1000);
	  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	  this.randomizationFactor(opts.randomizationFactor || 0.5);
	  this.backoff = new Backoff({
	    min: this.reconnectionDelay(),
	    max: this.reconnectionDelayMax(),
	    jitter: this.randomizationFactor()
	  });
	  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	  this.readyState = 'closed';
	  this.uri = uri;
	  this.connecting = [];
	  this.lastPing = null;
	  this.encoding = false;
	  this.packetBuffer = [];
	  this.encoder = new parser.Encoder();
	  this.decoder = new parser.Decoder();
	  this.autoConnect = opts.autoConnect !== false;
	  if (this.autoConnect) this.open();
	}
	
	/**
	 * Propagate given event to sockets and emit on `this`
	 *
	 * @api private
	 */
	
	Manager.prototype.emitAll = function () {
	  this.emit.apply(this, arguments);
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
	    }
	  }
	};
	
	/**
	 * Update `socket.id` of all sockets
	 *
	 * @api private
	 */
	
	Manager.prototype.updateSocketIds = function () {
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].id = this.engine.id;
	    }
	  }
	};
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Manager.prototype);
	
	/**
	 * Sets the `reconnection` config.
	 *
	 * @param {Boolean} true/false if it should automatically reconnect
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnection = function (v) {
	  if (!arguments.length) return this._reconnection;
	  this._reconnection = !!v;
	  return this;
	};
	
	/**
	 * Sets the reconnection attempts config.
	 *
	 * @param {Number} max reconnection attempts before giving up
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionAttempts = function (v) {
	  if (!arguments.length) return this._reconnectionAttempts;
	  this._reconnectionAttempts = v;
	  return this;
	};
	
	/**
	 * Sets the delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelay = function (v) {
	  if (!arguments.length) return this._reconnectionDelay;
	  this._reconnectionDelay = v;
	  this.backoff && this.backoff.setMin(v);
	  return this;
	};
	
	Manager.prototype.randomizationFactor = function (v) {
	  if (!arguments.length) return this._randomizationFactor;
	  this._randomizationFactor = v;
	  this.backoff && this.backoff.setJitter(v);
	  return this;
	};
	
	/**
	 * Sets the maximum delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelayMax = function (v) {
	  if (!arguments.length) return this._reconnectionDelayMax;
	  this._reconnectionDelayMax = v;
	  this.backoff && this.backoff.setMax(v);
	  return this;
	};
	
	/**
	 * Sets the connection timeout. `false` to disable
	 *
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.timeout = function (v) {
	  if (!arguments.length) return this._timeout;
	  this._timeout = v;
	  return this;
	};
	
	/**
	 * Starts trying to reconnect if reconnection is enabled and we have not
	 * started reconnecting yet
	 *
	 * @api private
	 */
	
	Manager.prototype.maybeReconnectOnOpen = function () {
	  // Only try to reconnect if it's the first time we're connecting
	  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
	    // keeps reconnection from firing twice for the same reconnection loop
	    this.reconnect();
	  }
	};
	
	/**
	 * Sets the current transport `socket`.
	 *
	 * @param {Function} optional, callback
	 * @return {Manager} self
	 * @api public
	 */
	
	Manager.prototype.open = Manager.prototype.connect = function (fn) {
	  debug('readyState %s', this.readyState);
	  if (~this.readyState.indexOf('open')) return this;
	
	  debug('opening %s', this.uri);
	  this.engine = eio(this.uri, this.opts);
	  var socket = this.engine;
	  var self = this;
	  this.readyState = 'opening';
	  this.skipReconnect = false;
	
	  // emit `open`
	  var openSub = on(socket, 'open', function () {
	    self.onopen();
	    fn && fn();
	  });
	
	  // emit `connect_error`
	  var errorSub = on(socket, 'error', function (data) {
	    debug('connect_error');
	    self.cleanup();
	    self.readyState = 'closed';
	    self.emitAll('connect_error', data);
	    if (fn) {
	      var err = new Error('Connection error');
	      err.data = data;
	      fn(err);
	    } else {
	      // Only do this if there is no fn to handle the error
	      self.maybeReconnectOnOpen();
	    }
	  });
	
	  // emit `connect_timeout`
	  if (false !== this._timeout) {
	    var timeout = this._timeout;
	    debug('connect attempt will timeout after %d', timeout);
	
	    // set timer
	    var timer = setTimeout(function () {
	      debug('connect attempt timed out after %d', timeout);
	      openSub.destroy();
	      socket.close();
	      socket.emit('error', 'timeout');
	      self.emitAll('connect_timeout', timeout);
	    }, timeout);
	
	    this.subs.push({
	      destroy: function destroy() {
	        clearTimeout(timer);
	      }
	    });
	  }
	
	  this.subs.push(openSub);
	  this.subs.push(errorSub);
	
	  return this;
	};
	
	/**
	 * Called upon transport open.
	 *
	 * @api private
	 */
	
	Manager.prototype.onopen = function () {
	  debug('open');
	
	  // clear old subs
	  this.cleanup();
	
	  // mark as open
	  this.readyState = 'open';
	  this.emit('open');
	
	  // add new subs
	  var socket = this.engine;
	  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
	  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
	  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
	  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
	  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
	  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
	};
	
	/**
	 * Called upon a ping.
	 *
	 * @api private
	 */
	
	Manager.prototype.onping = function () {
	  this.lastPing = new Date();
	  this.emitAll('ping');
	};
	
	/**
	 * Called upon a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.onpong = function () {
	  this.emitAll('pong', new Date() - this.lastPing);
	};
	
	/**
	 * Called with data.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondata = function (data) {
	  this.decoder.add(data);
	};
	
	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondecoded = function (packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon socket error.
	 *
	 * @api private
	 */
	
	Manager.prototype.onerror = function (err) {
	  debug('error', err);
	  this.emitAll('error', err);
	};
	
	/**
	 * Creates a new socket for the given `nsp`.
	 *
	 * @return {Socket}
	 * @api public
	 */
	
	Manager.prototype.socket = function (nsp) {
	  var socket = this.nsps[nsp];
	  if (!socket) {
	    socket = new Socket(this, nsp);
	    this.nsps[nsp] = socket;
	    var self = this;
	    socket.on('connecting', onConnecting);
	    socket.on('connect', function () {
	      socket.id = self.engine.id;
	    });
	
	    if (this.autoConnect) {
	      // manually call here since connecting evnet is fired before listening
	      onConnecting();
	    }
	  }
	
	  function onConnecting() {
	    if (!~indexOf(self.connecting, socket)) {
	      self.connecting.push(socket);
	    }
	  }
	
	  return socket;
	};
	
	/**
	 * Called upon a socket close.
	 *
	 * @param {Socket} socket
	 */
	
	Manager.prototype.destroy = function (socket) {
	  var index = indexOf(this.connecting, socket);
	  if (~index) this.connecting.splice(index, 1);
	  if (this.connecting.length) return;
	
	  this.close();
	};
	
	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Manager.prototype.packet = function (packet) {
	  debug('writing packet %j', packet);
	  var self = this;
	
	  if (!self.encoding) {
	    // encode, then write to engine with result
	    self.encoding = true;
	    this.encoder.encode(packet, function (encodedPackets) {
	      for (var i = 0; i < encodedPackets.length; i++) {
	        self.engine.write(encodedPackets[i], packet.options);
	      }
	      self.encoding = false;
	      self.processPacketQueue();
	    });
	  } else {
	    // add packet to the queue
	    self.packetBuffer.push(packet);
	  }
	};
	
	/**
	 * If packet buffer is non-empty, begins encoding the
	 * next packet in line.
	 *
	 * @api private
	 */
	
	Manager.prototype.processPacketQueue = function () {
	  if (this.packetBuffer.length > 0 && !this.encoding) {
	    var pack = this.packetBuffer.shift();
	    this.packet(pack);
	  }
	};
	
	/**
	 * Clean up transport subscriptions and packet buffer.
	 *
	 * @api private
	 */
	
	Manager.prototype.cleanup = function () {
	  debug('cleanup');
	
	  var sub;
	  while (sub = this.subs.shift()) {
	    sub.destroy();
	  }this.packetBuffer = [];
	  this.encoding = false;
	  this.lastPing = null;
	
	  this.decoder.destroy();
	};
	
	/**
	 * Close the current socket.
	 *
	 * @api private
	 */
	
	Manager.prototype.close = Manager.prototype.disconnect = function () {
	  debug('disconnect');
	  this.skipReconnect = true;
	  this.reconnecting = false;
	  if ('opening' == this.readyState) {
	    // `onclose` will not fire because
	    // an open event never happened
	    this.cleanup();
	  }
	  this.backoff.reset();
	  this.readyState = 'closed';
	  if (this.engine) this.engine.close();
	};
	
	/**
	 * Called upon engine close.
	 *
	 * @api private
	 */
	
	Manager.prototype.onclose = function (reason) {
	  debug('onclose');
	
	  this.cleanup();
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.emit('close', reason);
	
	  if (this._reconnection && !this.skipReconnect) {
	    this.reconnect();
	  }
	};
	
	/**
	 * Attempt a reconnection.
	 *
	 * @api private
	 */
	
	Manager.prototype.reconnect = function () {
	  if (this.reconnecting || this.skipReconnect) return this;
	
	  var self = this;
	
	  if (this.backoff.attempts >= this._reconnectionAttempts) {
	    debug('reconnect failed');
	    this.backoff.reset();
	    this.emitAll('reconnect_failed');
	    this.reconnecting = false;
	  } else {
	    var delay = this.backoff.duration();
	    debug('will wait %dms before reconnect attempt', delay);
	
	    this.reconnecting = true;
	    var timer = setTimeout(function () {
	      if (self.skipReconnect) return;
	
	      debug('attempting reconnect');
	      self.emitAll('reconnect_attempt', self.backoff.attempts);
	      self.emitAll('reconnecting', self.backoff.attempts);
	
	      // check again for the case socket closed in above events
	      if (self.skipReconnect) return;
	
	      self.open(function (err) {
	        if (err) {
	          debug('reconnect attempt error');
	          self.reconnecting = false;
	          self.reconnect();
	          self.emitAll('reconnect_error', err.data);
	        } else {
	          debug('reconnect success');
	          self.onreconnect();
	        }
	      });
	    }, delay);
	
	    this.subs.push({
	      destroy: function destroy() {
	        clearTimeout(timer);
	      }
	    });
	  }
	};
	
	/**
	 * Called upon successful reconnect.
	 *
	 * @api private
	 */
	
	Manager.prototype.onreconnect = function () {
	  var attempt = this.backoff.attempts;
	  this.reconnecting = false;
	  this.backoff.reset();
	  this.updateSocketIds();
	  this.emitAll('reconnect', attempt);
	};

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(244);

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(245);
	
	/**
	 * Exports parser
	 *
	 * @api public
	 *
	 */
	module.exports.parser = __webpack_require__(252);

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/**
	 * Module dependencies.
	 */
	
	var transports = __webpack_require__(246);
	var Emitter = __webpack_require__(239);
	var debug = __webpack_require__(231)('engine.io-client:socket');
	var index = __webpack_require__(266);
	var parser = __webpack_require__(252);
	var parseuri = __webpack_require__(230);
	var parsejson = __webpack_require__(267);
	var parseqs = __webpack_require__(260);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Socket;
	
	/**
	 * Noop function.
	 *
	 * @api private
	 */
	
	function noop() {}
	
	/**
	 * Socket constructor.
	 *
	 * @param {String|Object} uri or options
	 * @param {Object} options
	 * @api public
	 */
	
	function Socket(uri, opts) {
	  if (!(this instanceof Socket)) return new Socket(uri, opts);
	
	  opts = opts || {};
	
	  if (uri && 'object' == (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) {
	    opts = uri;
	    uri = null;
	  }
	
	  if (uri) {
	    uri = parseuri(uri);
	    opts.hostname = uri.host;
	    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
	    opts.port = uri.port;
	    if (uri.query) opts.query = uri.query;
	  } else if (opts.host) {
	    opts.hostname = parseuri(opts.host).host;
	  }
	
	  this.secure = null != opts.secure ? opts.secure : global.location && 'https:' == location.protocol;
	
	  if (opts.hostname && !opts.port) {
	    // if no port is specified manually, use the protocol default
	    opts.port = this.secure ? '443' : '80';
	  }
	
	  this.agent = opts.agent || false;
	  this.hostname = opts.hostname || (global.location ? location.hostname : 'localhost');
	  this.port = opts.port || (global.location && location.port ? location.port : this.secure ? 443 : 80);
	  this.query = opts.query || {};
	  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
	  this.upgrade = false !== opts.upgrade;
	  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
	  this.forceJSONP = !!opts.forceJSONP;
	  this.jsonp = false !== opts.jsonp;
	  this.forceBase64 = !!opts.forceBase64;
	  this.enablesXDR = !!opts.enablesXDR;
	  this.timestampParam = opts.timestampParam || 't';
	  this.timestampRequests = opts.timestampRequests;
	  this.transports = opts.transports || ['polling', 'websocket'];
	  this.readyState = '';
	  this.writeBuffer = [];
	  this.policyPort = opts.policyPort || 843;
	  this.rememberUpgrade = opts.rememberUpgrade || false;
	  this.binaryType = null;
	  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
	  this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || {} : false;
	
	  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
	  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
	    this.perMessageDeflate.threshold = 1024;
	  }
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx || null;
	  this.key = opts.key || null;
	  this.passphrase = opts.passphrase || null;
	  this.cert = opts.cert || null;
	  this.ca = opts.ca || null;
	  this.ciphers = opts.ciphers || null;
	  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	  if (freeGlobal.global === freeGlobal) {
	    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
	      this.extraHeaders = opts.extraHeaders;
	    }
	  }
	
	  this.open();
	}
	
	Socket.priorWebsocketSuccess = false;
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	Socket.protocol = parser.protocol; // this is an int
	
	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */
	
	Socket.Socket = Socket;
	Socket.Transport = __webpack_require__(251);
	Socket.transports = __webpack_require__(246);
	Socket.parser = __webpack_require__(252);
	
	/**
	 * Creates transport of the given type.
	 *
	 * @param {String} transport name
	 * @return {Transport}
	 * @api private
	 */
	
	Socket.prototype.createTransport = function (name) {
	  debug('creating transport "%s"', name);
	  var query = clone(this.query);
	
	  // append engine.io protocol identifier
	  query.EIO = parser.protocol;
	
	  // transport name
	  query.transport = name;
	
	  // session id if we already have one
	  if (this.id) query.sid = this.id;
	
	  var transport = new transports[name]({
	    agent: this.agent,
	    hostname: this.hostname,
	    port: this.port,
	    secure: this.secure,
	    path: this.path,
	    query: query,
	    forceJSONP: this.forceJSONP,
	    jsonp: this.jsonp,
	    forceBase64: this.forceBase64,
	    enablesXDR: this.enablesXDR,
	    timestampRequests: this.timestampRequests,
	    timestampParam: this.timestampParam,
	    policyPort: this.policyPort,
	    socket: this,
	    pfx: this.pfx,
	    key: this.key,
	    passphrase: this.passphrase,
	    cert: this.cert,
	    ca: this.ca,
	    ciphers: this.ciphers,
	    rejectUnauthorized: this.rejectUnauthorized,
	    perMessageDeflate: this.perMessageDeflate,
	    extraHeaders: this.extraHeaders
	  });
	
	  return transport;
	};
	
	function clone(obj) {
	  var o = {};
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}
	
	/**
	 * Initializes transport to use and starts probe.
	 *
	 * @api private
	 */
	Socket.prototype.open = function () {
	  var transport;
	  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
	    transport = 'websocket';
	  } else if (0 === this.transports.length) {
	    // Emit error on next tick so it can be listened to
	    var self = this;
	    setTimeout(function () {
	      self.emit('error', 'No transports available');
	    }, 0);
	    return;
	  } else {
	    transport = this.transports[0];
	  }
	  this.readyState = 'opening';
	
	  // Retry with the next transport if the transport is disabled (jsonp: false)
	  try {
	    transport = this.createTransport(transport);
	  } catch (e) {
	    this.transports.shift();
	    this.open();
	    return;
	  }
	
	  transport.open();
	  this.setTransport(transport);
	};
	
	/**
	 * Sets the current transport. Disables the existing one (if any).
	 *
	 * @api private
	 */
	
	Socket.prototype.setTransport = function (transport) {
	  debug('setting transport %s', transport.name);
	  var self = this;
	
	  if (this.transport) {
	    debug('clearing existing transport %s', this.transport.name);
	    this.transport.removeAllListeners();
	  }
	
	  // set up transport
	  this.transport = transport;
	
	  // set up transport listeners
	  transport.on('drain', function () {
	    self.onDrain();
	  }).on('packet', function (packet) {
	    self.onPacket(packet);
	  }).on('error', function (e) {
	    self.onError(e);
	  }).on('close', function () {
	    self.onClose('transport close');
	  });
	};
	
	/**
	 * Probes a transport.
	 *
	 * @param {String} transport name
	 * @api private
	 */
	
	Socket.prototype.probe = function (name) {
	  debug('probing transport "%s"', name);
	  var transport = this.createTransport(name, { probe: 1 }),
	      failed = false,
	      self = this;
	
	  Socket.priorWebsocketSuccess = false;
	
	  function onTransportOpen() {
	    if (self.onlyBinaryUpgrades) {
	      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
	      failed = failed || upgradeLosesBinary;
	    }
	    if (failed) return;
	
	    debug('probe transport "%s" opened', name);
	    transport.send([{ type: 'ping', data: 'probe' }]);
	    transport.once('packet', function (msg) {
	      if (failed) return;
	      if ('pong' == msg.type && 'probe' == msg.data) {
	        debug('probe transport "%s" pong', name);
	        self.upgrading = true;
	        self.emit('upgrading', transport);
	        if (!transport) return;
	        Socket.priorWebsocketSuccess = 'websocket' == transport.name;
	
	        debug('pausing current transport "%s"', self.transport.name);
	        self.transport.pause(function () {
	          if (failed) return;
	          if ('closed' == self.readyState) return;
	          debug('changing transport and sending upgrade packet');
	
	          cleanup();
	
	          self.setTransport(transport);
	          transport.send([{ type: 'upgrade' }]);
	          self.emit('upgrade', transport);
	          transport = null;
	          self.upgrading = false;
	          self.flush();
	        });
	      } else {
	        debug('probe transport "%s" failed', name);
	        var err = new Error('probe error');
	        err.transport = transport.name;
	        self.emit('upgradeError', err);
	      }
	    });
	  }
	
	  function freezeTransport() {
	    if (failed) return;
	
	    // Any callback called by transport should be ignored since now
	    failed = true;
	
	    cleanup();
	
	    transport.close();
	    transport = null;
	  }
	
	  //Handle any error that happens while probing
	  function onerror(err) {
	    var error = new Error('probe error: ' + err);
	    error.transport = transport.name;
	
	    freezeTransport();
	
	    debug('probe transport "%s" failed because of error: %s', name, err);
	
	    self.emit('upgradeError', error);
	  }
	
	  function onTransportClose() {
	    onerror("transport closed");
	  }
	
	  //When the socket is closed while we're probing
	  function onclose() {
	    onerror("socket closed");
	  }
	
	  //When the socket is upgraded while we're probing
	  function onupgrade(to) {
	    if (transport && to.name != transport.name) {
	      debug('"%s" works - aborting "%s"', to.name, transport.name);
	      freezeTransport();
	    }
	  }
	
	  //Remove all listeners on the transport and on self
	  function cleanup() {
	    transport.removeListener('open', onTransportOpen);
	    transport.removeListener('error', onerror);
	    transport.removeListener('close', onTransportClose);
	    self.removeListener('close', onclose);
	    self.removeListener('upgrading', onupgrade);
	  }
	
	  transport.once('open', onTransportOpen);
	  transport.once('error', onerror);
	  transport.once('close', onTransportClose);
	
	  this.once('close', onclose);
	  this.once('upgrading', onupgrade);
	
	  transport.open();
	};
	
	/**
	 * Called when connection is deemed open.
	 *
	 * @api public
	 */
	
	Socket.prototype.onOpen = function () {
	  debug('socket open');
	  this.readyState = 'open';
	  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
	  this.emit('open');
	  this.flush();
	
	  // we check for `readyState` in case an `open`
	  // listener already closed the socket
	  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
	    debug('starting upgrade probes');
	    for (var i = 0, l = this.upgrades.length; i < l; i++) {
	      this.probe(this.upgrades[i]);
	    }
	  }
	};
	
	/**
	 * Handles a packet.
	 *
	 * @api private
	 */
	
	Socket.prototype.onPacket = function (packet) {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
	
	    this.emit('packet', packet);
	
	    // Socket is live - any packet counts
	    this.emit('heartbeat');
	
	    switch (packet.type) {
	      case 'open':
	        this.onHandshake(parsejson(packet.data));
	        break;
	
	      case 'pong':
	        this.setPing();
	        this.emit('pong');
	        break;
	
	      case 'error':
	        var err = new Error('server error');
	        err.code = packet.data;
	        this.onError(err);
	        break;
	
	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug('packet received with socket readyState "%s"', this.readyState);
	  }
	};
	
	/**
	 * Called upon handshake completion.
	 *
	 * @param {Object} handshake obj
	 * @api private
	 */
	
	Socket.prototype.onHandshake = function (data) {
	  this.emit('handshake', data);
	  this.id = data.sid;
	  this.transport.query.sid = data.sid;
	  this.upgrades = this.filterUpgrades(data.upgrades);
	  this.pingInterval = data.pingInterval;
	  this.pingTimeout = data.pingTimeout;
	  this.onOpen();
	  // In case open handler closes socket
	  if ('closed' == this.readyState) return;
	  this.setPing();
	
	  // Prolong liveness of socket on heartbeat
	  this.removeListener('heartbeat', this.onHeartbeat);
	  this.on('heartbeat', this.onHeartbeat);
	};
	
	/**
	 * Resets ping timeout.
	 *
	 * @api private
	 */
	
	Socket.prototype.onHeartbeat = function (timeout) {
	  clearTimeout(this.pingTimeoutTimer);
	  var self = this;
	  self.pingTimeoutTimer = setTimeout(function () {
	    if ('closed' == self.readyState) return;
	    self.onClose('ping timeout');
	  }, timeout || self.pingInterval + self.pingTimeout);
	};
	
	/**
	 * Pings server every `this.pingInterval` and expects response
	 * within `this.pingTimeout` or closes connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.setPing = function () {
	  var self = this;
	  clearTimeout(self.pingIntervalTimer);
	  self.pingIntervalTimer = setTimeout(function () {
	    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
	    self.ping();
	    self.onHeartbeat(self.pingTimeout);
	  }, self.pingInterval);
	};
	
	/**
	* Sends a ping packet.
	*
	* @api private
	*/
	
	Socket.prototype.ping = function () {
	  var self = this;
	  this.sendPacket('ping', function () {
	    self.emit('ping');
	  });
	};
	
	/**
	 * Called on `drain` event
	 *
	 * @api private
	 */
	
	Socket.prototype.onDrain = function () {
	  this.writeBuffer.splice(0, this.prevBufferLen);
	
	  // setting prevBufferLen = 0 is very important
	  // for example, when upgrading, upgrade packet is sent over,
	  // and a nonzero prevBufferLen could cause problems on `drain`
	  this.prevBufferLen = 0;
	
	  if (0 === this.writeBuffer.length) {
	    this.emit('drain');
	  } else {
	    this.flush();
	  }
	};
	
	/**
	 * Flush write buffers.
	 *
	 * @api private
	 */
	
	Socket.prototype.flush = function () {
	  if ('closed' != this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
	    debug('flushing %d packets in socket', this.writeBuffer.length);
	    this.transport.send(this.writeBuffer);
	    // keep track of current length of writeBuffer
	    // splice writeBuffer and callbackBuffer on `drain`
	    this.prevBufferLen = this.writeBuffer.length;
	    this.emit('flush');
	  }
	};
	
	/**
	 * Sends a message.
	 *
	 * @param {String} message.
	 * @param {Function} callback function.
	 * @param {Object} options.
	 * @return {Socket} for chaining.
	 * @api public
	 */
	
	Socket.prototype.write = Socket.prototype.send = function (msg, options, fn) {
	  this.sendPacket('message', msg, options, fn);
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type.
	 * @param {String} data.
	 * @param {Object} options.
	 * @param {Function} callback function.
	 * @api private
	 */
	
	Socket.prototype.sendPacket = function (type, data, options, fn) {
	  if ('function' == typeof data) {
	    fn = data;
	    data = undefined;
	  }
	
	  if ('function' == typeof options) {
	    fn = options;
	    options = null;
	  }
	
	  if ('closing' == this.readyState || 'closed' == this.readyState) {
	    return;
	  }
	
	  options = options || {};
	  options.compress = false !== options.compress;
	
	  var packet = {
	    type: type,
	    data: data,
	    options: options
	  };
	  this.emit('packetCreate', packet);
	  this.writeBuffer.push(packet);
	  if (fn) this.once('flush', fn);
	  this.flush();
	};
	
	/**
	 * Closes the connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.readyState = 'closing';
	
	    var self = this;
	
	    if (this.writeBuffer.length) {
	      this.once('drain', function () {
	        if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      });
	    } else if (this.upgrading) {
	      waitForUpgrade();
	    } else {
	      close();
	    }
	  }
	
	  function close() {
	    self.onClose('forced close');
	    debug('socket closing - telling transport to close');
	    self.transport.close();
	  }
	
	  function cleanupAndClose() {
	    self.removeListener('upgrade', cleanupAndClose);
	    self.removeListener('upgradeError', cleanupAndClose);
	    close();
	  }
	
	  function waitForUpgrade() {
	    // wait for upgrade to finish since we can't send packets while pausing a transport
	    self.once('upgrade', cleanupAndClose);
	    self.once('upgradeError', cleanupAndClose);
	  }
	
	  return this;
	};
	
	/**
	 * Called upon transport error
	 *
	 * @api private
	 */
	
	Socket.prototype.onError = function (err) {
	  debug('socket error %j', err);
	  Socket.priorWebsocketSuccess = false;
	  this.emit('error', err);
	  this.onClose('transport error', err);
	};
	
	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */
	
	Socket.prototype.onClose = function (reason, desc) {
	  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
	    debug('socket close with reason: "%s"', reason);
	    var self = this;
	
	    // clear timers
	    clearTimeout(this.pingIntervalTimer);
	    clearTimeout(this.pingTimeoutTimer);
	
	    // stop event from firing again for transport
	    this.transport.removeAllListeners('close');
	
	    // ensure transport won't stay open
	    this.transport.close();
	
	    // ignore further transport communication
	    this.transport.removeAllListeners();
	
	    // set ready state
	    this.readyState = 'closed';
	
	    // clear session id
	    this.id = null;
	
	    // emit close event
	    this.emit('close', reason, desc);
	
	    // clean buffers after, so users can still
	    // grab the buffers on `close` event
	    self.writeBuffer = [];
	    self.prevBufferLen = 0;
	  }
	};
	
	/**
	 * Filters upgrades, returning only those matching client transports.
	 *
	 * @param {Array} server upgrades
	 * @api private
	 *
	 */
	
	Socket.prototype.filterUpgrades = function (upgrades) {
	  var filteredUpgrades = [];
	  for (var i = 0, j = upgrades.length; i < j; i++) {
	    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
	  }
	  return filteredUpgrades;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * Module dependencies
	 */
	
	var XMLHttpRequest = __webpack_require__(247);
	var XHR = __webpack_require__(249);
	var JSONP = __webpack_require__(263);
	var websocket = __webpack_require__(264);
	
	/**
	 * Export transports.
	 */
	
	exports.polling = polling;
	exports.websocket = websocket;
	
	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */
	
	function polling(opts) {
	  var xhr;
	  var xd = false;
	  var xs = false;
	  var jsonp = false !== opts.jsonp;
	
	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    xd = opts.hostname != location.hostname || port != opts.port;
	    xs = opts.secure != isSSL;
	  }
	
	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new XMLHttpRequest(opts);
	
	  if ('open' in xhr && !opts.forceJSONP) {
	    return new XHR(opts);
	  } else {
	    if (!jsonp) throw new Error('JSONP disabled');
	    return new JSONP(opts);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	// browser shim for xmlhttprequest module
	var hasCORS = __webpack_require__(248);
	
	module.exports = function (opts) {
	  var xdomain = opts.xdomain;
	
	  // scheme must be same when usign XDomainRequest
	  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
	  var xscheme = opts.xscheme;
	
	  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
	  // https://github.com/Automattic/engine.io-client/pull/217
	  var enablesXDR = opts.enablesXDR;
	
	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) {}
	
	  // Use XDomainRequest for IE8 if enablesXDR is true
	  // because loading bar keeps flashing when using jsonp-polling
	  // https://github.com/yujiosaka/socke.io-ie8-loading-example
	  try {
	    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
	      return new XDomainRequest();
	    }
	  } catch (e) {}
	
	  if (!xdomain) {
	    try {
	      return new ActiveXObject('Microsoft.XMLHTTP');
	    } catch (e) {}
	  }
	};

/***/ },
/* 248 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Module exports.
	 *
	 * Logic borrowed from Modernizr:
	 *
	 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
	 */
	
	try {
	  module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
	} catch (err) {
	  // if XMLHttp support is disabled in IE then it will throw
	  // when trying to create
	  module.exports = false;
	}

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * Module requirements.
	 */
	
	var XMLHttpRequest = __webpack_require__(247);
	var Polling = __webpack_require__(250);
	var Emitter = __webpack_require__(239);
	var inherit = __webpack_require__(261);
	var debug = __webpack_require__(231)('engine.io-client:polling-xhr');
	
	/**
	 * Module exports.
	 */
	
	module.exports = XHR;
	module.exports.Request = Request;
	
	/**
	 * Empty function
	 */
	
	function empty() {}
	
	/**
	 * XHR Polling constructor.
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function XHR(opts) {
	  Polling.call(this, opts);
	
	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    this.xd = opts.hostname != global.location.hostname || port != opts.port;
	    this.xs = opts.secure != isSSL;
	  } else {
	    this.extraHeaders = opts.extraHeaders;
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(XHR, Polling);
	
	/**
	 * XHR supports binary
	 */
	
	XHR.prototype.supportsBinary = true;
	
	/**
	 * Creates a request.
	 *
	 * @param {String} method
	 * @api private
	 */
	
	XHR.prototype.request = function (opts) {
	  opts = opts || {};
	  opts.uri = this.uri();
	  opts.xd = this.xd;
	  opts.xs = this.xs;
	  opts.agent = this.agent || false;
	  opts.supportsBinary = this.supportsBinary;
	  opts.enablesXDR = this.enablesXDR;
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  // other options for Node.js client
	  opts.extraHeaders = this.extraHeaders;
	
	  return new Request(opts);
	};
	
	/**
	 * Sends data.
	 *
	 * @param {String} data to send.
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	XHR.prototype.doWrite = function (data, fn) {
	  var isBinary = typeof data !== 'string' && data !== undefined;
	  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
	  var self = this;
	  req.on('success', fn);
	  req.on('error', function (err) {
	    self.onError('xhr post error', err);
	  });
	  this.sendXhr = req;
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	XHR.prototype.doPoll = function () {
	  debug('xhr poll');
	  var req = this.request();
	  var self = this;
	  req.on('data', function (data) {
	    self.onData(data);
	  });
	  req.on('error', function (err) {
	    self.onError('xhr poll error', err);
	  });
	  this.pollXhr = req;
	};
	
	/**
	 * Request constructor
	 *
	 * @param {Object} options
	 * @api public
	 */
	
	function Request(opts) {
	  this.method = opts.method || 'GET';
	  this.uri = opts.uri;
	  this.xd = !!opts.xd;
	  this.xs = !!opts.xs;
	  this.async = false !== opts.async;
	  this.data = undefined != opts.data ? opts.data : null;
	  this.agent = opts.agent;
	  this.isBinary = opts.isBinary;
	  this.supportsBinary = opts.supportsBinary;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	
	  this.create();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Request.prototype);
	
	/**
	 * Creates the XHR object and sends the request.
	 *
	 * @api private
	 */
	
	Request.prototype.create = function () {
	  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  var xhr = this.xhr = new XMLHttpRequest(opts);
	  var self = this;
	
	  try {
	    debug('xhr open %s: %s', this.method, this.uri);
	    xhr.open(this.method, this.uri, this.async);
	    try {
	      if (this.extraHeaders) {
	        xhr.setDisableHeaderCheck(true);
	        for (var i in this.extraHeaders) {
	          if (this.extraHeaders.hasOwnProperty(i)) {
	            xhr.setRequestHeader(i, this.extraHeaders[i]);
	          }
	        }
	      }
	    } catch (e) {}
	    if (this.supportsBinary) {
	      // This has to be done after open because Firefox is stupid
	      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
	      xhr.responseType = 'arraybuffer';
	    }
	
	    if ('POST' == this.method) {
	      try {
	        if (this.isBinary) {
	          xhr.setRequestHeader('Content-type', 'application/octet-stream');
	        } else {
	          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        }
	      } catch (e) {}
	    }
	
	    // ie6 check
	    if ('withCredentials' in xhr) {
	      xhr.withCredentials = true;
	    }
	
	    if (this.hasXDR()) {
	      xhr.onload = function () {
	        self.onLoad();
	      };
	      xhr.onerror = function () {
	        self.onError(xhr.responseText);
	      };
	    } else {
	      xhr.onreadystatechange = function () {
	        if (4 != xhr.readyState) return;
	        if (200 == xhr.status || 1223 == xhr.status) {
	          self.onLoad();
	        } else {
	          // make sure the `error` event handler that's user-set
	          // does not throw in the same tick and gets caught here
	          setTimeout(function () {
	            self.onError(xhr.status);
	          }, 0);
	        }
	      };
	    }
	
	    debug('xhr data %s', this.data);
	    xhr.send(this.data);
	  } catch (e) {
	    // Need to defer since .create() is called directly fhrom the constructor
	    // and thus the 'error' event can only be only bound *after* this exception
	    // occurs.  Therefore, also, we cannot throw here at all.
	    setTimeout(function () {
	      self.onError(e);
	    }, 0);
	    return;
	  }
	
	  if (global.document) {
	    this.index = Request.requestsCount++;
	    Request.requests[this.index] = this;
	  }
	};
	
	/**
	 * Called upon successful response.
	 *
	 * @api private
	 */
	
	Request.prototype.onSuccess = function () {
	  this.emit('success');
	  this.cleanup();
	};
	
	/**
	 * Called if we have data.
	 *
	 * @api private
	 */
	
	Request.prototype.onData = function (data) {
	  this.emit('data', data);
	  this.onSuccess();
	};
	
	/**
	 * Called upon error.
	 *
	 * @api private
	 */
	
	Request.prototype.onError = function (err) {
	  this.emit('error', err);
	  this.cleanup(true);
	};
	
	/**
	 * Cleans up house.
	 *
	 * @api private
	 */
	
	Request.prototype.cleanup = function (fromError) {
	  if ('undefined' == typeof this.xhr || null === this.xhr) {
	    return;
	  }
	  // xmlhttprequest
	  if (this.hasXDR()) {
	    this.xhr.onload = this.xhr.onerror = empty;
	  } else {
	    this.xhr.onreadystatechange = empty;
	  }
	
	  if (fromError) {
	    try {
	      this.xhr.abort();
	    } catch (e) {}
	  }
	
	  if (global.document) {
	    delete Request.requests[this.index];
	  }
	
	  this.xhr = null;
	};
	
	/**
	 * Called upon load.
	 *
	 * @api private
	 */
	
	Request.prototype.onLoad = function () {
	  var data;
	  try {
	    var contentType;
	    try {
	      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
	    } catch (e) {}
	    if (contentType === 'application/octet-stream') {
	      data = this.xhr.response;
	    } else {
	      if (!this.supportsBinary) {
	        data = this.xhr.responseText;
	      } else {
	        try {
	          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
	        } catch (e) {
	          var ui8Arr = new Uint8Array(this.xhr.response);
	          var dataArray = [];
	          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
	            dataArray.push(ui8Arr[idx]);
	          }
	
	          data = String.fromCharCode.apply(null, dataArray);
	        }
	      }
	    }
	  } catch (e) {
	    this.onError(e);
	  }
	  if (null != data) {
	    this.onData(data);
	  }
	};
	
	/**
	 * Check if it has XDomainRequest.
	 *
	 * @api private
	 */
	
	Request.prototype.hasXDR = function () {
	  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
	};
	
	/**
	 * Aborts the request.
	 *
	 * @api public
	 */
	
	Request.prototype.abort = function () {
	  this.cleanup();
	};
	
	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */
	
	if (global.document) {
	  Request.requestsCount = 0;
	  Request.requests = {};
	  if (global.attachEvent) {
	    global.attachEvent('onunload', unloadHandler);
	  } else if (global.addEventListener) {
	    global.addEventListener('beforeunload', unloadHandler, false);
	  }
	}
	
	function unloadHandler() {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(251);
	var parseqs = __webpack_require__(260);
	var parser = __webpack_require__(252);
	var inherit = __webpack_require__(261);
	var yeast = __webpack_require__(262);
	var debug = __webpack_require__(231)('engine.io-client:polling');
	
	/**
	 * Module exports.
	 */
	
	module.exports = Polling;
	
	/**
	 * Is XHR2 supported?
	 */
	
	var hasXHR2 = function () {
	  var XMLHttpRequest = __webpack_require__(247);
	  var xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	}();
	
	/**
	 * Polling interface.
	 *
	 * @param {Object} opts
	 * @api private
	 */
	
	function Polling(opts) {
	  var forceBase64 = opts && opts.forceBase64;
	  if (!hasXHR2 || forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(Polling, Transport);
	
	/**
	 * Transport name.
	 */
	
	Polling.prototype.name = 'polling';
	
	/**
	 * Opens the socket (triggers polling). We write a PING message to determine
	 * when the transport is open.
	 *
	 * @api private
	 */
	
	Polling.prototype.doOpen = function () {
	  this.poll();
	};
	
	/**
	 * Pauses polling.
	 *
	 * @param {Function} callback upon buffers are flushed and transport is paused
	 * @api private
	 */
	
	Polling.prototype.pause = function (onPause) {
	  var pending = 0;
	  var self = this;
	
	  this.readyState = 'pausing';
	
	  function pause() {
	    debug('paused');
	    self.readyState = 'paused';
	    onPause();
	  }
	
	  if (this.polling || !this.writable) {
	    var total = 0;
	
	    if (this.polling) {
	      debug('we are currently polling - waiting to pause');
	      total++;
	      this.once('pollComplete', function () {
	        debug('pre-pause polling complete');
	        --total || pause();
	      });
	    }
	
	    if (!this.writable) {
	      debug('we are currently writing - waiting to pause');
	      total++;
	      this.once('drain', function () {
	        debug('pre-pause writing complete');
	        --total || pause();
	      });
	    }
	  } else {
	    pause();
	  }
	};
	
	/**
	 * Starts polling cycle.
	 *
	 * @api public
	 */
	
	Polling.prototype.poll = function () {
	  debug('polling');
	  this.polling = true;
	  this.doPoll();
	  this.emit('poll');
	};
	
	/**
	 * Overloads onData to detect payloads.
	 *
	 * @api private
	 */
	
	Polling.prototype.onData = function (data) {
	  var self = this;
	  debug('polling got data %s', data);
	  var callback = function callback(packet, index, total) {
	    // if its the first message we consider the transport open
	    if ('opening' == self.readyState) {
	      self.onOpen();
	    }
	
	    // if its a close packet, we close the ongoing requests
	    if ('close' == packet.type) {
	      self.onClose();
	      return false;
	    }
	
	    // otherwise bypass onData and handle the message
	    self.onPacket(packet);
	  };
	
	  // decode payload
	  parser.decodePayload(data, this.socket.binaryType, callback);
	
	  // if an event did not trigger closing
	  if ('closed' != this.readyState) {
	    // if we got data we're not polling
	    this.polling = false;
	    this.emit('pollComplete');
	
	    if ('open' == this.readyState) {
	      this.poll();
	    } else {
	      debug('ignoring poll - transport state "%s"', this.readyState);
	    }
	  }
	};
	
	/**
	 * For polling, send a close packet.
	 *
	 * @api private
	 */
	
	Polling.prototype.doClose = function () {
	  var self = this;
	
	  function close() {
	    debug('writing close packet');
	    self.write([{ type: 'close' }]);
	  }
	
	  if ('open' == this.readyState) {
	    debug('transport open - closing');
	    close();
	  } else {
	    // in case we're trying to close while
	    // handshaking is in progress (GH-164)
	    debug('transport not open - deferring close');
	    this.once('open', close);
	  }
	};
	
	/**
	 * Writes a packets payload.
	 *
	 * @param {Array} data packets
	 * @param {Function} drain callback
	 * @api private
	 */
	
	Polling.prototype.write = function (packets) {
	  var self = this;
	  this.writable = false;
	  var callbackfn = function callbackfn() {
	    self.writable = true;
	    self.emit('drain');
	  };
	
	  var self = this;
	  parser.encodePayload(packets, this.supportsBinary, function (data) {
	    self.doWrite(data, callbackfn);
	  });
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	Polling.prototype.uri = function () {
	  var query = this.query || {};
	  var schema = this.secure ? 'https' : 'http';
	  var port = '';
	
	  // cache busting is forced
	  if (false !== this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }
	
	  if (!this.supportsBinary && !query.sid) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // avoid port if default for schema
	  if (this.port && ('https' == schema && this.port != 443 || 'http' == schema && this.port != 80)) {
	    port = ':' + this.port;
	  }
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(252);
	var Emitter = __webpack_require__(239);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Transport;
	
	/**
	 * Transport abstract constructor.
	 *
	 * @param {Object} options.
	 * @api private
	 */
	
	function Transport(opts) {
	  this.path = opts.path;
	  this.hostname = opts.hostname;
	  this.port = opts.port;
	  this.secure = opts.secure;
	  this.query = opts.query;
	  this.timestampParam = opts.timestampParam;
	  this.timestampRequests = opts.timestampRequests;
	  this.readyState = '';
	  this.agent = opts.agent || false;
	  this.socket = opts.socket;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Transport.prototype);
	
	/**
	 * Emits an error.
	 *
	 * @param {String} str
	 * @return {Transport} for chaining
	 * @api public
	 */
	
	Transport.prototype.onError = function (msg, desc) {
	  var err = new Error(msg);
	  err.type = 'TransportError';
	  err.description = desc;
	  this.emit('error', err);
	  return this;
	};
	
	/**
	 * Opens the transport.
	 *
	 * @api public
	 */
	
	Transport.prototype.open = function () {
	  if ('closed' == this.readyState || '' == this.readyState) {
	    this.readyState = 'opening';
	    this.doOpen();
	  }
	
	  return this;
	};
	
	/**
	 * Closes the transport.
	 *
	 * @api private
	 */
	
	Transport.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.doClose();
	    this.onClose();
	  }
	
	  return this;
	};
	
	/**
	 * Sends multiple packets.
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	Transport.prototype.send = function (packets) {
	  if ('open' == this.readyState) {
	    this.write(packets);
	  } else {
	    throw new Error('Transport not open');
	  }
	};
	
	/**
	 * Called upon open
	 *
	 * @api private
	 */
	
	Transport.prototype.onOpen = function () {
	  this.readyState = 'open';
	  this.writable = true;
	  this.emit('open');
	};
	
	/**
	 * Called with data.
	 *
	 * @param {String} data
	 * @api private
	 */
	
	Transport.prototype.onData = function (data) {
	  var packet = parser.decodePacket(data, this.socket.binaryType);
	  this.onPacket(packet);
	};
	
	/**
	 * Called with a decoded packet.
	 */
	
	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon close.
	 *
	 * @api private
	 */
	
	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var keys = __webpack_require__(253);
	var hasBinary = __webpack_require__(254);
	var sliceBuffer = __webpack_require__(255);
	var base64encoder = __webpack_require__(256);
	var after = __webpack_require__(257);
	var utf8 = __webpack_require__(258);
	
	/**
	 * Check if we are running an android browser. That requires us to use
	 * ArrayBuffer with polling transports...
	 *
	 * http://ghinda.net/jpeg-blob-ajax-android/
	 */
	
	var isAndroid = navigator.userAgent.match(/Android/i);
	
	/**
	 * Check if we are running in PhantomJS.
	 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
	 * https://github.com/ariya/phantomjs/issues/11395
	 * @type boolean
	 */
	var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);
	
	/**
	 * When true, avoids using Blobs to encode payloads.
	 * @type boolean
	 */
	var dontSendBlobs = isAndroid || isPhantomJS;
	
	/**
	 * Current protocol version.
	 */
	
	exports.protocol = 3;
	
	/**
	 * Packet types.
	 */
	
	var packets = exports.packets = {
	  open: 0 // non-ws
	  , close: 1 // non-ws
	  , ping: 2,
	  pong: 3,
	  message: 4,
	  upgrade: 5,
	  noop: 6
	};
	
	var packetslist = keys(packets);
	
	/**
	 * Premade error packet.
	 */
	
	var err = { type: 'error', data: 'parser error' };
	
	/**
	 * Create a blob api even for blob builder when vendor prefixes exist
	 */
	
	var Blob = __webpack_require__(259);
	
	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */
	
	exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	  if ('function' == typeof supportsBinary) {
	    callback = supportsBinary;
	    supportsBinary = false;
	  }
	
	  if ('function' == typeof utf8encode) {
	    callback = utf8encode;
	    utf8encode = null;
	  }
	
	  var data = packet.data === undefined ? undefined : packet.data.buffer || packet.data;
	
	  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
	    return encodeArrayBuffer(packet, supportsBinary, callback);
	  } else if (Blob && data instanceof global.Blob) {
	    return encodeBlob(packet, supportsBinary, callback);
	  }
	
	  // might be an object with { base64: true, data: dataAsBase64String }
	  if (data && data.base64) {
	    return encodeBase64Object(packet, callback);
	  }
	
	  // Sending data as a utf-8 string
	  var encoded = packets[packet.type];
	
	  // data fragment is optional
	  if (undefined !== packet.data) {
	    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
	  }
	
	  return callback('' + encoded);
	};
	
	function encodeBase64Object(packet, callback) {
	  // packet data is an object { base64: true, data: dataAsBase64String }
	  var message = 'b' + exports.packets[packet.type] + packet.data.data;
	  return callback(message);
	}
	
	/**
	 * Encode packet helpers for binary types
	 */
	
	function encodeArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var data = packet.data;
	  var contentArray = new Uint8Array(data);
	  var resultBuffer = new Uint8Array(1 + data.byteLength);
	
	  resultBuffer[0] = packets[packet.type];
	  for (var i = 0; i < contentArray.length; i++) {
	    resultBuffer[i + 1] = contentArray[i];
	  }
	
	  return callback(resultBuffer.buffer);
	}
	
	function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var fr = new FileReader();
	  fr.onload = function () {
	    packet.data = fr.result;
	    exports.encodePacket(packet, supportsBinary, true, callback);
	  };
	  return fr.readAsArrayBuffer(packet.data);
	}
	
	function encodeBlob(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  if (dontSendBlobs) {
	    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
	  }
	
	  var length = new Uint8Array(1);
	  length[0] = packets[packet.type];
	  var blob = new Blob([length.buffer, packet.data]);
	
	  return callback(blob);
	}
	
	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */
	
	exports.encodeBase64Packet = function (packet, callback) {
	  var message = 'b' + exports.packets[packet.type];
	  if (Blob && packet.data instanceof global.Blob) {
	    var fr = new FileReader();
	    fr.onload = function () {
	      var b64 = fr.result.split(',')[1];
	      callback(message + b64);
	    };
	    return fr.readAsDataURL(packet.data);
	  }
	
	  var b64data;
	  try {
	    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
	  } catch (e) {
	    // iPhone Safari doesn't let you apply with typed arrays
	    var typed = new Uint8Array(packet.data);
	    var basic = new Array(typed.length);
	    for (var i = 0; i < typed.length; i++) {
	      basic[i] = typed[i];
	    }
	    b64data = String.fromCharCode.apply(null, basic);
	  }
	  message += global.btoa(b64data);
	  return callback(message);
	};
	
	/**
	 * Decodes a packet. Changes format to Blob if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */
	
	exports.decodePacket = function (data, binaryType, utf8decode) {
	  // String data
	  if (typeof data == 'string' || data === undefined) {
	    if (data.charAt(0) == 'b') {
	      return exports.decodeBase64Packet(data.substr(1), binaryType);
	    }
	
	    if (utf8decode) {
	      try {
	        data = utf8.decode(data);
	      } catch (e) {
	        return err;
	      }
	    }
	    var type = data.charAt(0);
	
	    if (Number(type) != type || !packetslist[type]) {
	      return err;
	    }
	
	    if (data.length > 1) {
	      return { type: packetslist[type], data: data.substring(1) };
	    } else {
	      return { type: packetslist[type] };
	    }
	  }
	
	  var asArray = new Uint8Array(data);
	  var type = asArray[0];
	  var rest = sliceBuffer(data, 1);
	  if (Blob && binaryType === 'blob') {
	    rest = new Blob([rest]);
	  }
	  return { type: packetslist[type], data: rest };
	};
	
	/**
	 * Decodes a packet encoded in a base64 string
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */
	
	exports.decodeBase64Packet = function (msg, binaryType) {
	  var type = packetslist[msg.charAt(0)];
	  if (!global.ArrayBuffer) {
	    return { type: type, data: { base64: true, data: msg.substr(1) } };
	  }
	
	  var data = base64encoder.decode(msg.substr(1));
	
	  if (binaryType === 'blob' && Blob) {
	    data = new Blob([data]);
	  }
	
	  return { type: type, data: data };
	};
	
	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	exports.encodePayload = function (packets, supportsBinary, callback) {
	  if (typeof supportsBinary == 'function') {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }
	
	  var isBinary = hasBinary(packets);
	
	  if (supportsBinary && isBinary) {
	    if (Blob && !dontSendBlobs) {
	      return exports.encodePayloadAsBlob(packets, callback);
	    }
	
	    return exports.encodePayloadAsArrayBuffer(packets, callback);
	  }
	
	  if (!packets.length) {
	    return callback('0:');
	  }
	
	  function setLengthHeader(message) {
	    return message.length + ':' + message;
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function (message) {
	      doneCallback(null, setLengthHeader(message));
	    });
	  }
	
	  map(packets, encodeOne, function (err, results) {
	    return callback(results.join(''));
	  });
	};
	
	/**
	 * Async array map using after
	 */
	
	function map(ary, each, done) {
	  var result = new Array(ary.length);
	  var next = after(ary.length, done);
	
	  var eachWithIndex = function eachWithIndex(i, el, cb) {
	    each(el, function (error, msg) {
	      result[i] = msg;
	      cb(error, result);
	    });
	  };
	
	  for (var i = 0; i < ary.length; i++) {
	    eachWithIndex(i, ary[i], next);
	  }
	}
	
	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */
	
	exports.decodePayload = function (data, binaryType, callback) {
	  if (typeof data != 'string') {
	    return exports.decodePayloadAsBinary(data, binaryType, callback);
	  }
	
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var packet;
	  if (data == '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	  var length = '',
	      n,
	      msg;
	
	  for (var i = 0, l = data.length; i < l; i++) {
	    var chr = data.charAt(i);
	
	    if (':' != chr) {
	      length += chr;
	    } else {
	      if ('' == length || length != (n = Number(length))) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      msg = data.substr(i + 1, n);
	
	      if (length != msg.length) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      if (msg.length) {
	        packet = exports.decodePacket(msg, binaryType, true);
	
	        if (err.type == packet.type && err.data == packet.data) {
	          // parser error in individual packet - ignoring payload
	          return callback(err, 0, 1);
	        }
	
	        var ret = callback(packet, i + n, l);
	        if (false === ret) return;
	      }
	
	      // advance cursor
	      i += n;
	      length = '';
	    }
	  }
	
	  if (length != '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	};
	
	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {ArrayBuffer} encoded payload
	 * @api private
	 */
	
	exports.encodePayloadAsArrayBuffer = function (packets, callback) {
	  if (!packets.length) {
	    return callback(new ArrayBuffer(0));
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function (data) {
	      return doneCallback(null, data);
	    });
	  }
	
	  map(packets, encodeOne, function (err, encodedPackets) {
	    var totalLength = encodedPackets.reduce(function (acc, p) {
	      var len;
	      if (typeof p === 'string') {
	        len = p.length;
	      } else {
	        len = p.byteLength;
	      }
	      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
	    }, 0);
	
	    var resultArray = new Uint8Array(totalLength);
	
	    var bufferIndex = 0;
	    encodedPackets.forEach(function (p) {
	      var isString = typeof p === 'string';
	      var ab = p;
	      if (isString) {
	        var view = new Uint8Array(p.length);
	        for (var i = 0; i < p.length; i++) {
	          view[i] = p.charCodeAt(i);
	        }
	        ab = view.buffer;
	      }
	
	      if (isString) {
	        // not true binary
	        resultArray[bufferIndex++] = 0;
	      } else {
	        // true binary
	        resultArray[bufferIndex++] = 1;
	      }
	
	      var lenStr = ab.byteLength.toString();
	      for (var i = 0; i < lenStr.length; i++) {
	        resultArray[bufferIndex++] = parseInt(lenStr[i]);
	      }
	      resultArray[bufferIndex++] = 255;
	
	      var view = new Uint8Array(ab);
	      for (var i = 0; i < view.length; i++) {
	        resultArray[bufferIndex++] = view[i];
	      }
	    });
	
	    return callback(resultArray.buffer);
	  });
	};
	
	/**
	 * Encode as Blob
	 */
	
	exports.encodePayloadAsBlob = function (packets, callback) {
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function (encoded) {
	      var binaryIdentifier = new Uint8Array(1);
	      binaryIdentifier[0] = 1;
	      if (typeof encoded === 'string') {
	        var view = new Uint8Array(encoded.length);
	        for (var i = 0; i < encoded.length; i++) {
	          view[i] = encoded.charCodeAt(i);
	        }
	        encoded = view.buffer;
	        binaryIdentifier[0] = 0;
	      }
	
	      var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;
	
	      var lenStr = len.toString();
	      var lengthAry = new Uint8Array(lenStr.length + 1);
	      for (var i = 0; i < lenStr.length; i++) {
	        lengthAry[i] = parseInt(lenStr[i]);
	      }
	      lengthAry[lenStr.length] = 255;
	
	      if (Blob) {
	        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
	        doneCallback(null, blob);
	      }
	    });
	  }
	
	  map(packets, encodeOne, function (err, results) {
	    return callback(new Blob(results));
	  });
	};
	
	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary
	 *
	 * @param {ArrayBuffer} data, callback method
	 * @api public
	 */
	
	exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var bufferTail = data;
	  var buffers = [];
	
	  var numberTooLong = false;
	  while (bufferTail.byteLength > 0) {
	    var tailArray = new Uint8Array(bufferTail);
	    var isString = tailArray[0] === 0;
	    var msgLength = '';
	
	    for (var i = 1;; i++) {
	      if (tailArray[i] == 255) break;
	
	      if (msgLength.length > 310) {
	        numberTooLong = true;
	        break;
	      }
	
	      msgLength += tailArray[i];
	    }
	
	    if (numberTooLong) return callback(err, 0, 1);
	
	    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
	    msgLength = parseInt(msgLength);
	
	    var msg = sliceBuffer(bufferTail, 0, msgLength);
	    if (isString) {
	      try {
	        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
	      } catch (e) {
	        // iPhone Safari doesn't let you apply to typed arrays
	        var typed = new Uint8Array(msg);
	        msg = '';
	        for (var i = 0; i < typed.length; i++) {
	          msg += String.fromCharCode(typed[i]);
	        }
	      }
	    }
	
	    buffers.push(msg);
	    bufferTail = sliceBuffer(bufferTail, msgLength);
	  }
	
	  var total = buffers.length;
	  buffers.forEach(function (buffer, i) {
	    callback(exports.decodePacket(buffer, binaryType, true), i, total);
	  });
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 253 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */
	
	module.exports = Object.keys || function keys(obj) {
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;
	
	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/*
	 * Module requirements.
	 */
	
	var isArray = __webpack_require__(238);
	
	/**
	 * Module exports.
	 */
	
	module.exports = hasBinary;
	
	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */
	
	function hasBinary(data) {
	
	  function _hasBinary(obj) {
	    if (!obj) return false;
	
	    if (global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer || global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
	      return true;
	    }
	
	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	        if (_hasBinary(obj[i])) {
	          return true;
	        }
	      }
	    } else if (obj && 'object' == (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) {
	      if (obj.toJSON) {
	        obj = obj.toJSON();
	      }
	
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  }
	
	  return _hasBinary(data);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 255 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * An abstraction for slicing an arraybuffer even when
	 * ArrayBuffer.prototype.slice is not supported
	 *
	 * @api public
	 */
	
	module.exports = function (arraybuffer, start, end) {
	  var bytes = arraybuffer.byteLength;
	  start = start || 0;
	  end = end || bytes;
	
	  if (arraybuffer.slice) {
	    return arraybuffer.slice(start, end);
	  }
	
	  if (start < 0) {
	    start += bytes;
	  }
	  if (end < 0) {
	    end += bytes;
	  }
	  if (end > bytes) {
	    end = bytes;
	  }
	
	  if (start >= bytes || start >= end || bytes === 0) {
	    return new ArrayBuffer(0);
	  }
	
	  var abv = new Uint8Array(arraybuffer);
	  var result = new Uint8Array(end - start);
	  for (var i = start, ii = 0; i < end; i++, ii++) {
	    result[ii] = abv[i];
	  }
	  return result.buffer;
	};

/***/ },
/* 256 */
/***/ function(module, exports) {

	"use strict";
	
	/*
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */
	(function (chars) {
	  "use strict";
	
	  exports.encode = function (arraybuffer) {
	    var bytes = new Uint8Array(arraybuffer),
	        i,
	        len = bytes.length,
	        base64 = "";
	
	    for (i = 0; i < len; i += 3) {
	      base64 += chars[bytes[i] >> 2];
	      base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
	      base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
	      base64 += chars[bytes[i + 2] & 63];
	    }
	
	    if (len % 3 === 2) {
	      base64 = base64.substring(0, base64.length - 1) + "=";
	    } else if (len % 3 === 1) {
	      base64 = base64.substring(0, base64.length - 2) + "==";
	    }
	
	    return base64;
	  };
	
	  exports.decode = function (base64) {
	    var bufferLength = base64.length * 0.75,
	        len = base64.length,
	        i,
	        p = 0,
	        encoded1,
	        encoded2,
	        encoded3,
	        encoded4;
	
	    if (base64[base64.length - 1] === "=") {
	      bufferLength--;
	      if (base64[base64.length - 2] === "=") {
	        bufferLength--;
	      }
	    }
	
	    var arraybuffer = new ArrayBuffer(bufferLength),
	        bytes = new Uint8Array(arraybuffer);
	
	    for (i = 0; i < len; i += 4) {
	      encoded1 = chars.indexOf(base64[i]);
	      encoded2 = chars.indexOf(base64[i + 1]);
	      encoded3 = chars.indexOf(base64[i + 2]);
	      encoded4 = chars.indexOf(base64[i + 3]);
	
	      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
	      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
	      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
	    }
	
	    return arraybuffer;
	  };
	})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

/***/ },
/* 257 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = after;
	
	function after(count, callback, err_cb) {
	    var bail = false;
	    err_cb = err_cb || noop;
	    proxy.count = count;
	
	    return count === 0 ? callback() : proxy;
	
	    function proxy(err, result) {
	        if (proxy.count <= 0) {
	            throw new Error('after called too many times');
	        }
	        --proxy.count;
	
	        // after first error, rest are passed to err_cb
	        if (err) {
	            bail = true;
	            callback(err);
	            // future error callbacks will go to error handler
	            callback = err_cb;
	        } else if (proxy.count === 0 && !bail) {
	            callback(null, result);
	        }
	    }
	}
	
	function noop() {}

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function (root) {
	
		// Detect free variables `exports`
		var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports;
	
		// Detect free variable `module`
		var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && module.exports == freeExports && module;
	
		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}
	
		/*--------------------------------------------------------------------------*/
	
		var stringFromCharCode = String.fromCharCode;
	
		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) {
						// low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}
	
		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
			}
		}
		/*--------------------------------------------------------------------------*/
	
		function createByte(codePoint, shift) {
			return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
		}
	
		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) {
				// 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) {
				// 2-byte sequence
				symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
			} else if ((codePoint & 0xFFFF0000) == 0) {
				// 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
				symbol += createByte(codePoint, 6);
			} else if ((codePoint & 0xFFE00000) == 0) {
				// 4-byte sequence
				symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
			return symbol;
		}
	
		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}
	
		/*--------------------------------------------------------------------------*/
	
		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}
	
			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}
	
			// If we end up here, its not a continuation byte
			throw Error('Invalid continuation byte');
		}
	
		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;
	
			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}
	
			if (byteIndex == byteCount) {
				return false;
			}
	
			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}
	
			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = (byte1 & 0x1F) << 6 | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = (byte1 & 0x0F) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}
	
			throw Error('Invalid UTF-8 detected');
		}
	
		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}
	
		/*--------------------------------------------------------------------------*/
	
		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};
	
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if ("function" == 'function' && _typeof(__webpack_require__(237)) == 'object' && __webpack_require__(237)) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && !freeExports.nodeType) {
			if (freeModule) {
				// in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.utf8 = utf8;
		}
	})(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(236)(module), (function() { return this; }())))

/***/ },
/* 259 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * Create a blob builder even when vendor prefixes exist
	 */
	
	var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder;
	
	/**
	 * Check if Blob constructor is supported
	 */
	
	var blobSupported = function () {
	  try {
	    var a = new Blob(['hi']);
	    return a.size === 2;
	  } catch (e) {
	    return false;
	  }
	}();
	
	/**
	 * Check if Blob constructor supports ArrayBufferViews
	 * Fails in Safari 6, so we need to map to ArrayBuffers there.
	 */
	
	var blobSupportsArrayBufferView = blobSupported && function () {
	  try {
	    var b = new Blob([new Uint8Array([1, 2])]);
	    return b.size === 2;
	  } catch (e) {
	    return false;
	  }
	}();
	
	/**
	 * Check if BlobBuilder is supported
	 */
	
	var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;
	
	/**
	 * Helper function that maps ArrayBufferViews to ArrayBuffers
	 * Used by BlobBuilder constructor and old browsers that didn't
	 * support it in the Blob constructor.
	 */
	
	function mapArrayBufferViews(ary) {
	  for (var i = 0; i < ary.length; i++) {
	    var chunk = ary[i];
	    if (chunk.buffer instanceof ArrayBuffer) {
	      var buf = chunk.buffer;
	
	      // if this is a subarray, make a copy so we only
	      // include the subarray region from the underlying buffer
	      if (chunk.byteLength !== buf.byteLength) {
	        var copy = new Uint8Array(chunk.byteLength);
	        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
	        buf = copy.buffer;
	      }
	
	      ary[i] = buf;
	    }
	  }
	}
	
	function BlobBuilderConstructor(ary, options) {
	  options = options || {};
	
	  var bb = new BlobBuilder();
	  mapArrayBufferViews(ary);
	
	  for (var i = 0; i < ary.length; i++) {
	    bb.append(ary[i]);
	  }
	
	  return options.type ? bb.getBlob(options.type) : bb.getBlob();
	};
	
	function BlobConstructor(ary, options) {
	  mapArrayBufferViews(ary);
	  return new Blob(ary, options || {});
	};
	
	module.exports = function () {
	  if (blobSupported) {
	    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
	  } else if (blobBuilderSupported) {
	    return BlobBuilderConstructor;
	  } else {
	    return undefined;
	  }
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 260 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */
	
	exports.encode = function (obj) {
	  var str = '';
	
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }
	
	  return str;
	};
	
	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */
	
	exports.decode = function (qs) {
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	};

/***/ },
/* 261 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = function (a, b) {
	  var fn = function fn() {};
	  fn.prototype = b.prototype;
	  a.prototype = new fn();
	  a.prototype.constructor = a;
	};

/***/ },
/* 262 */
/***/ function(module, exports) {

	'use strict';
	
	var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
	    length = 64,
	    map = {},
	    seed = 0,
	    i = 0,
	    prev;
	
	/**
	 * Return a string representing the specified number.
	 *
	 * @param {Number} num The number to convert.
	 * @returns {String} The string representation of the number.
	 * @api public
	 */
	function encode(num) {
	  var encoded = '';
	
	  do {
	    encoded = alphabet[num % length] + encoded;
	    num = Math.floor(num / length);
	  } while (num > 0);
	
	  return encoded;
	}
	
	/**
	 * Return the integer value specified by the given string.
	 *
	 * @param {String} str The string to convert.
	 * @returns {Number} The integer value represented by the string.
	 * @api public
	 */
	function decode(str) {
	  var decoded = 0;
	
	  for (i = 0; i < str.length; i++) {
	    decoded = decoded * length + map[str.charAt(i)];
	  }
	
	  return decoded;
	}
	
	/**
	 * Yeast: A tiny growing id generator.
	 *
	 * @returns {String} A unique id.
	 * @api public
	 */
	function yeast() {
	  var now = encode(+new Date());
	
	  if (now !== prev) return seed = 0, prev = now;
	  return now + '.' + encode(seed++);
	}
	
	//
	// Map each character to its index.
	//
	for (; i < length; i++) {
	  map[alphabet[i]] = i;
	} //
	// Expose the `yeast`, `encode` and `decode` functions.
	//
	yeast.encode = encode;
	yeast.decode = decode;
	module.exports = yeast;

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * Module requirements.
	 */
	
	var Polling = __webpack_require__(250);
	var inherit = __webpack_require__(261);
	
	/**
	 * Module exports.
	 */
	
	module.exports = JSONPPolling;
	
	/**
	 * Cached regular expressions.
	 */
	
	var rNewline = /\n/g;
	var rEscapedNewline = /\\n/g;
	
	/**
	 * Global JSONP callbacks.
	 */
	
	var callbacks;
	
	/**
	 * Callbacks count.
	 */
	
	var index = 0;
	
	/**
	 * Noop.
	 */
	
	function empty() {}
	
	/**
	 * JSONP Polling constructor.
	 *
	 * @param {Object} opts.
	 * @api public
	 */
	
	function JSONPPolling(opts) {
	  Polling.call(this, opts);
	
	  this.query = this.query || {};
	
	  // define global callbacks array if not present
	  // we do this here (lazily) to avoid unneeded global pollution
	  if (!callbacks) {
	    // we need to consider multiple engines in the same page
	    if (!global.___eio) global.___eio = [];
	    callbacks = global.___eio;
	  }
	
	  // callback identifier
	  this.index = callbacks.length;
	
	  // add callback to jsonp global
	  var self = this;
	  callbacks.push(function (msg) {
	    self.onData(msg);
	  });
	
	  // append to query string
	  this.query.j = this.index;
	
	  // prevent spurious errors from being emitted when the window is unloaded
	  if (global.document && global.addEventListener) {
	    global.addEventListener('beforeunload', function () {
	      if (self.script) self.script.onerror = empty;
	    }, false);
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(JSONPPolling, Polling);
	
	/*
	 * JSONP only supports binary as base64 encoded strings
	 */
	
	JSONPPolling.prototype.supportsBinary = false;
	
	/**
	 * Closes the socket.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doClose = function () {
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  if (this.form) {
	    this.form.parentNode.removeChild(this.form);
	    this.form = null;
	    this.iframe = null;
	  }
	
	  Polling.prototype.doClose.call(this);
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doPoll = function () {
	  var self = this;
	  var script = document.createElement('script');
	
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  script.async = true;
	  script.src = this.uri();
	  script.onerror = function (e) {
	    self.onError('jsonp poll error', e);
	  };
	
	  var insertAt = document.getElementsByTagName('script')[0];
	  if (insertAt) {
	    insertAt.parentNode.insertBefore(script, insertAt);
	  } else {
	    (document.head || document.body).appendChild(script);
	  }
	  this.script = script;
	
	  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
	
	  if (isUAgecko) {
	    setTimeout(function () {
	      var iframe = document.createElement('iframe');
	      document.body.appendChild(iframe);
	      document.body.removeChild(iframe);
	    }, 100);
	  }
	};
	
	/**
	 * Writes with a hidden iframe.
	 *
	 * @param {String} data to send
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	JSONPPolling.prototype.doWrite = function (data, fn) {
	  var self = this;
	
	  if (!this.form) {
	    var form = document.createElement('form');
	    var area = document.createElement('textarea');
	    var id = this.iframeId = 'eio_iframe_' + this.index;
	    var iframe;
	
	    form.className = 'socketio';
	    form.style.position = 'absolute';
	    form.style.top = '-1000px';
	    form.style.left = '-1000px';
	    form.target = id;
	    form.method = 'POST';
	    form.setAttribute('accept-charset', 'utf-8');
	    area.name = 'd';
	    form.appendChild(area);
	    document.body.appendChild(form);
	
	    this.form = form;
	    this.area = area;
	  }
	
	  this.form.action = this.uri();
	
	  function complete() {
	    initIframe();
	    fn();
	  }
	
	  function initIframe() {
	    if (self.iframe) {
	      try {
	        self.form.removeChild(self.iframe);
	      } catch (e) {
	        self.onError('jsonp polling iframe removal error', e);
	      }
	    }
	
	    try {
	      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
	      iframe = document.createElement(html);
	    } catch (e) {
	      iframe = document.createElement('iframe');
	      iframe.name = self.iframeId;
	      iframe.src = 'javascript:0';
	    }
	
	    iframe.id = self.iframeId;
	
	    self.form.appendChild(iframe);
	    self.iframe = iframe;
	  }
	
	  initIframe();
	
	  // escape \n to prevent it from being converted into \r\n by some UAs
	  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	  data = data.replace(rEscapedNewline, '\\\n');
	  this.area.value = data.replace(rNewline, '\\n');
	
	  try {
	    this.form.submit();
	  } catch (e) {}
	
	  if (this.iframe.attachEvent) {
	    this.iframe.onreadystatechange = function () {
	      if (self.iframe.readyState == 'complete') {
	        complete();
	      }
	    };
	  } else {
	    this.iframe.onload = complete;
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(251);
	var parser = __webpack_require__(252);
	var parseqs = __webpack_require__(260);
	var inherit = __webpack_require__(261);
	var yeast = __webpack_require__(262);
	var debug = __webpack_require__(231)('engine.io-client:websocket');
	var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
	
	/**
	 * Get either the `WebSocket` or `MozWebSocket` globals
	 * in the browser or try to resolve WebSocket-compatible
	 * interface exposed by `ws` for Node-like environment.
	 */
	
	var WebSocket = BrowserWebSocket;
	if (!WebSocket && typeof window === 'undefined') {
	  try {
	    WebSocket = __webpack_require__(265);
	  } catch (e) {}
	}
	
	/**
	 * Module exports.
	 */
	
	module.exports = WS;
	
	/**
	 * WebSocket transport constructor.
	 *
	 * @api {Object} connection options
	 * @api public
	 */
	
	function WS(opts) {
	  var forceBase64 = opts && opts.forceBase64;
	  if (forceBase64) {
	    this.supportsBinary = false;
	  }
	  this.perMessageDeflate = opts.perMessageDeflate;
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(WS, Transport);
	
	/**
	 * Transport name.
	 *
	 * @api public
	 */
	
	WS.prototype.name = 'websocket';
	
	/*
	 * WebSockets support binary
	 */
	
	WS.prototype.supportsBinary = true;
	
	/**
	 * Opens socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doOpen = function () {
	  if (!this.check()) {
	    // let probe timeout
	    return;
	  }
	
	  var self = this;
	  var uri = this.uri();
	  var protocols = void 0;
	  var opts = {
	    agent: this.agent,
	    perMessageDeflate: this.perMessageDeflate
	  };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  if (this.extraHeaders) {
	    opts.headers = this.extraHeaders;
	  }
	
	  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);
	
	  if (this.ws.binaryType === undefined) {
	    this.supportsBinary = false;
	  }
	
	  if (this.ws.supports && this.ws.supports.binary) {
	    this.supportsBinary = true;
	    this.ws.binaryType = 'buffer';
	  } else {
	    this.ws.binaryType = 'arraybuffer';
	  }
	
	  this.addEventListeners();
	};
	
	/**
	 * Adds event listeners to the socket
	 *
	 * @api private
	 */
	
	WS.prototype.addEventListeners = function () {
	  var self = this;
	
	  this.ws.onopen = function () {
	    self.onOpen();
	  };
	  this.ws.onclose = function () {
	    self.onClose();
	  };
	  this.ws.onmessage = function (ev) {
	    self.onData(ev.data);
	  };
	  this.ws.onerror = function (e) {
	    self.onError('websocket error', e);
	  };
	};
	
	/**
	 * Override `onData` to use a timer on iOS.
	 * See: https://gist.github.com/mloughran/2052006
	 *
	 * @api private
	 */
	
	if ('undefined' != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
	  WS.prototype.onData = function (data) {
	    var self = this;
	    setTimeout(function () {
	      Transport.prototype.onData.call(self, data);
	    }, 0);
	  };
	}
	
	/**
	 * Writes data to socket.
	 *
	 * @param {Array} array of packets.
	 * @api private
	 */
	
	WS.prototype.write = function (packets) {
	  var self = this;
	  this.writable = false;
	
	  // encodePacket efficient as it uses WS framing
	  // no need for encodePayload
	  var total = packets.length;
	  for (var i = 0, l = total; i < l; i++) {
	    (function (packet) {
	      parser.encodePacket(packet, self.supportsBinary, function (data) {
	        if (!BrowserWebSocket) {
	          // always create a new object (GH-437)
	          var opts = {};
	          if (packet.options) {
	            opts.compress = packet.options.compress;
	          }
	
	          if (self.perMessageDeflate) {
	            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
	            if (len < self.perMessageDeflate.threshold) {
	              opts.compress = false;
	            }
	          }
	        }
	
	        //Sometimes the websocket has already been closed but the browser didn't
	        //have a chance of informing us about it yet, in that case send will
	        //throw an error
	        try {
	          if (BrowserWebSocket) {
	            // TypeError is thrown when passing the second argument on Safari
	            self.ws.send(data);
	          } else {
	            self.ws.send(data, opts);
	          }
	        } catch (e) {
	          debug('websocket closed before onclose event');
	        }
	
	        --total || done();
	      });
	    })(packets[i]);
	  }
	
	  function done() {
	    self.emit('flush');
	
	    // fake drain
	    // defer to next tick to allow Socket to clear writeBuffer
	    setTimeout(function () {
	      self.writable = true;
	      self.emit('drain');
	    }, 0);
	  }
	};
	
	/**
	 * Called upon close
	 *
	 * @api private
	 */
	
	WS.prototype.onClose = function () {
	  Transport.prototype.onClose.call(this);
	};
	
	/**
	 * Closes socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doClose = function () {
	  if (typeof this.ws !== 'undefined') {
	    this.ws.close();
	  }
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	WS.prototype.uri = function () {
	  var query = this.query || {};
	  var schema = this.secure ? 'wss' : 'ws';
	  var port = '';
	
	  // avoid port if default for schema
	  if (this.port && ('wss' == schema && this.port != 443 || 'ws' == schema && this.port != 80)) {
	    port = ':' + this.port;
	  }
	
	  // append timestamp to URI
	  if (this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }
	
	  // communicate binary support capabilities
	  if (!this.supportsBinary) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};
	
	/**
	 * Feature detection for WebSocket.
	 *
	 * @return {Boolean} whether this transport is available.
	 * @api public
	 */
	
	WS.prototype.check = function () {
	  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 265 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 266 */
/***/ function(module, exports) {

	"use strict";
	
	var indexOf = [].indexOf;
	
	module.exports = function (arr, obj) {
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 267 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	/**
	 * JSON parse.
	 *
	 * @see Based on jQuery#parseJSON (MIT) and JSON2
	 * @api private
	 */
	
	var rvalidchars = /^[\],:{}\s]*$/;
	var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
	var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
	var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
	var rtrimLeft = /^\s+/;
	var rtrimRight = /\s+$/;
	
	module.exports = function parsejson(data) {
	  if ('string' != typeof data || !data) {
	    return null;
	  }
	
	  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');
	
	  // Attempt to parse using the native JSON parser first
	  if (global.JSON && JSON.parse) {
	    return JSON.parse(data);
	  }
	
	  if (rvalidchars.test(data.replace(rvalidescape, '@').replace(rvalidtokens, ']').replace(rvalidbraces, ''))) {
	    return new Function('return ' + data)();
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(234);
	var Emitter = __webpack_require__(269);
	var toArray = __webpack_require__(270);
	var on = __webpack_require__(271);
	var bind = __webpack_require__(272);
	var debug = __webpack_require__(231)('socket.io-client:socket');
	var hasBin = __webpack_require__(273);
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = Socket;
	
	/**
	 * Internal events (blacklisted).
	 * These events can't be emitted by the user.
	 *
	 * @api private
	 */
	
	var events = {
	  connect: 1,
	  connect_error: 1,
	  connect_timeout: 1,
	  connecting: 1,
	  disconnect: 1,
	  error: 1,
	  reconnect: 1,
	  reconnect_attempt: 1,
	  reconnect_failed: 1,
	  reconnect_error: 1,
	  reconnecting: 1,
	  ping: 1,
	  pong: 1
	};
	
	/**
	 * Shortcut to `Emitter#emit`.
	 */
	
	var emit = Emitter.prototype.emit;
	
	/**
	 * `Socket` constructor.
	 *
	 * @api public
	 */
	
	function Socket(io, nsp) {
	  this.io = io;
	  this.nsp = nsp;
	  this.json = this; // compat
	  this.ids = 0;
	  this.acks = {};
	  this.receiveBuffer = [];
	  this.sendBuffer = [];
	  this.connected = false;
	  this.disconnected = true;
	  if (this.io.autoConnect) this.open();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Subscribe to open, close and packet events
	 *
	 * @api private
	 */
	
	Socket.prototype.subEvents = function () {
	  if (this.subs) return;
	
	  var io = this.io;
	  this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];
	};
	
	/**
	 * "Opens" the socket.
	 *
	 * @api public
	 */
	
	Socket.prototype.open = Socket.prototype.connect = function () {
	  if (this.connected) return this;
	
	  this.subEvents();
	  this.io.open(); // ensure open
	  if ('open' == this.io.readyState) this.onopen();
	  this.emit('connecting');
	  return this;
	};
	
	/**
	 * Sends a `message` event.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.send = function () {
	  var args = toArray(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};
	
	/**
	 * Override `emit`.
	 * If the event is in `events`, it's emitted normally.
	 *
	 * @param {String} event name
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.emit = function (ev) {
	  if (events.hasOwnProperty(ev)) {
	    emit.apply(this, arguments);
	    return this;
	  }
	
	  var args = toArray(arguments);
	  var parserType = parser.EVENT; // default
	  if (hasBin(args)) {
	    parserType = parser.BINARY_EVENT;
	  } // binary
	  var packet = { type: parserType, data: args };
	
	  packet.options = {};
	  packet.options.compress = !this.flags || false !== this.flags.compress;
	
	  // event ack callback
	  if ('function' == typeof args[args.length - 1]) {
	    debug('emitting packet with ack id %d', this.ids);
	    this.acks[this.ids] = args.pop();
	    packet.id = this.ids++;
	  }
	
	  if (this.connected) {
	    this.packet(packet);
	  } else {
	    this.sendBuffer.push(packet);
	  }
	
	  delete this.flags;
	
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.packet = function (packet) {
	  packet.nsp = this.nsp;
	  this.io.packet(packet);
	};
	
	/**
	 * Called upon engine `open`.
	 *
	 * @api private
	 */
	
	Socket.prototype.onopen = function () {
	  debug('transport is open - connecting');
	
	  // write connect packet if necessary
	  if ('/' != this.nsp) {
	    this.packet({ type: parser.CONNECT });
	  }
	};
	
	/**
	 * Called upon engine `close`.
	 *
	 * @param {String} reason
	 * @api private
	 */
	
	Socket.prototype.onclose = function (reason) {
	  debug('close (%s)', reason);
	  this.connected = false;
	  this.disconnected = true;
	  delete this.id;
	  this.emit('disconnect', reason);
	};
	
	/**
	 * Called with socket packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onpacket = function (packet) {
	  if (packet.nsp != this.nsp) return;
	
	  switch (packet.type) {
	    case parser.CONNECT:
	      this.onconnect();
	      break;
	
	    case parser.EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.BINARY_EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.ACK:
	      this.onack(packet);
	      break;
	
	    case parser.BINARY_ACK:
	      this.onack(packet);
	      break;
	
	    case parser.DISCONNECT:
	      this.ondisconnect();
	      break;
	
	    case parser.ERROR:
	      this.emit('error', packet.data);
	      break;
	  }
	};
	
	/**
	 * Called upon a server event.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onevent = function (packet) {
	  var args = packet.data || [];
	  debug('emitting event %j', args);
	
	  if (null != packet.id) {
	    debug('attaching ack callback to event');
	    args.push(this.ack(packet.id));
	  }
	
	  if (this.connected) {
	    emit.apply(this, args);
	  } else {
	    this.receiveBuffer.push(args);
	  }
	};
	
	/**
	 * Produces an ack callback to emit with an event.
	 *
	 * @api private
	 */
	
	Socket.prototype.ack = function (id) {
	  var self = this;
	  var sent = false;
	  return function () {
	    // prevent double callbacks
	    if (sent) return;
	    sent = true;
	    var args = toArray(arguments);
	    debug('sending ack %j', args);
	
	    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
	    self.packet({
	      type: type,
	      id: id,
	      data: args
	    });
	  };
	};
	
	/**
	 * Called upon a server acknowlegement.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onack = function (packet) {
	  var ack = this.acks[packet.id];
	  if ('function' == typeof ack) {
	    debug('calling ack %s with %j', packet.id, packet.data);
	    ack.apply(this, packet.data);
	    delete this.acks[packet.id];
	  } else {
	    debug('bad ack %s', packet.id);
	  }
	};
	
	/**
	 * Called upon server connect.
	 *
	 * @api private
	 */
	
	Socket.prototype.onconnect = function () {
	  this.connected = true;
	  this.disconnected = false;
	  this.emit('connect');
	  this.emitBuffered();
	};
	
	/**
	 * Emit buffered events (received and emitted).
	 *
	 * @api private
	 */
	
	Socket.prototype.emitBuffered = function () {
	  var i;
	  for (i = 0; i < this.receiveBuffer.length; i++) {
	    emit.apply(this, this.receiveBuffer[i]);
	  }
	  this.receiveBuffer = [];
	
	  for (i = 0; i < this.sendBuffer.length; i++) {
	    this.packet(this.sendBuffer[i]);
	  }
	  this.sendBuffer = [];
	};
	
	/**
	 * Called upon server disconnect.
	 *
	 * @api private
	 */
	
	Socket.prototype.ondisconnect = function () {
	  debug('server disconnect (%s)', this.nsp);
	  this.destroy();
	  this.onclose('io server disconnect');
	};
	
	/**
	 * Called upon forced client/server side disconnections,
	 * this method ensures the manager stops tracking us and
	 * that reconnections don't get triggered for this.
	 *
	 * @api private.
	 */
	
	Socket.prototype.destroy = function () {
	  if (this.subs) {
	    // clean subscriptions to avoid reconnections
	    for (var i = 0; i < this.subs.length; i++) {
	      this.subs[i].destroy();
	    }
	    this.subs = null;
	  }
	
	  this.io.destroy(this);
	};
	
	/**
	 * Disconnects the socket manually.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.close = Socket.prototype.disconnect = function () {
	  if (this.connected) {
	    debug('performing disconnect (%s)', this.nsp);
	    this.packet({ type: parser.DISCONNECT });
	  }
	
	  // remove socket from pool
	  this.destroy();
	
	  if (this.connected) {
	    // fire events
	    this.onclose('io client disconnect');
	  }
	  return this;
	};
	
	/**
	 * Sets the compress flag.
	 *
	 * @param {Boolean} if `true`, compresses the sending data
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.compress = function (compress) {
	  this.flags = this.flags || {};
	  this.flags.compress = compress;
	  return this;
	};

/***/ },
/* 269 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function (event, fn) {
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function (event) {
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1),
	      callbacks = this._callbacks['$' + event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function (event) {
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function (event) {
	  return !!this.listeners(event).length;
	};

/***/ },
/* 270 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = toArray;
	
	function toArray(list, index) {
	    var array = [];
	
	    index = index || 0;
	
	    for (var i = index || 0; i < list.length; i++) {
	        array[i - index] = list[i];
	    }
	
	    return array;
	}

/***/ },
/* 271 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Module exports.
	 */
	
	module.exports = on;
	
	/**
	 * Helper for subscriptions.
	 *
	 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
	 * @param {String} event name
	 * @param {Function} callback
	 * @api public
	 */
	
	function on(obj, ev, fn) {
	  obj.on(ev, fn);
	  return {
	    destroy: function destroy() {
	      obj.removeListener(ev, fn);
	    }
	  };
	}

/***/ },
/* 272 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Slice reference.
	 */
	
	var slice = [].slice;
	
	/**
	 * Bind `obj` to `fn`.
	 *
	 * @param {Object} obj
	 * @param {Function|String} fn or string
	 * @return {Function}
	 * @api public
	 */
	
	module.exports = function (obj, fn) {
	  if ('string' == typeof fn) fn = obj[fn];
	  if ('function' != typeof fn) throw new Error('bind() requires a function');
	  var args = slice.call(arguments, 2);
	  return function () {
	    return fn.apply(obj, args.concat(slice.call(arguments)));
	  };
	};

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/*
	 * Module requirements.
	 */
	
	var isArray = __webpack_require__(238);
	
	/**
	 * Module exports.
	 */
	
	module.exports = hasBinary;
	
	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */
	
	function hasBinary(data) {
	
	  function _hasBinary(obj) {
	    if (!obj) return false;
	
	    if (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer || global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
	      return true;
	    }
	
	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	        if (_hasBinary(obj[i])) {
	          return true;
	        }
	      }
	    } else if (obj && 'object' == (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) {
	      // see: https://github.com/Automattic/has-binary/pull/4
	      if (obj.toJSON && 'function' == typeof obj.toJSON) {
	        obj = obj.toJSON();
	      }
	
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  }
	
	  return _hasBinary(data);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 274 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Expose `Backoff`.
	 */
	
	module.exports = Backoff;
	
	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}
	
	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */
	
	Backoff.prototype.duration = function () {
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand = Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};
	
	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */
	
	Backoff.prototype.reset = function () {
	  this.attempts = 0;
	};
	
	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMin = function (min) {
	  this.ms = min;
	};
	
	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMax = function (max) {
	  this.max = max;
	};
	
	/**
	 * Set the jitter
	 *
	 * @api public
	 */
	
	Backoff.prototype.setJitter = function (jitter) {
	  this.jitter = jitter;
	};

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(276);

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(277);
	var bind = __webpack_require__(278);
	var Axios = __webpack_require__(279);
	
	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios(defaultConfig);
	  var instance = bind(Axios.prototype.request, context);
	
	  // Copy axios.prototype to instance
	  utils.extend(instance, Axios.prototype, context);
	
	  // Copy context to instance
	  utils.extend(instance, context);
	
	  return instance;
	}
	
	// Create the default instance to be exported
	var axios = createInstance();
	
	// Expose Axios class to allow class inheritance
	axios.Axios = Axios;
	
	// Factory for creating new instances
	axios.create = function create(defaultConfig) {
	  return createInstance(defaultConfig);
	};
	
	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = __webpack_require__(296);
	
	module.exports = axios;
	
	// Allow use of default import syntax in TypeScript
	module.exports.default = axios;

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var bind = __webpack_require__(278);
	
	/*global toString:true*/
	
	// utils is a library of generic helper functions non-specific to axios
	
	var toString = Object.prototype.toString;
	
	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray(val) {
	  return toString.call(val) === '[object Array]';
	}
	
	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString.call(val) === '[object ArrayBuffer]';
	}
	
	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return typeof FormData !== 'undefined' && val instanceof FormData;
	}
	
	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
	  }
	  return result;
	}
	
	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}
	
	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}
	
	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}
	
	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject(val) {
	  return val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';
	}
	
	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString.call(val) === '[object Date]';
	}
	
	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString.call(val) === '[object File]';
	}
	
	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString.call(val) === '[object Blob]';
	}
	
	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction(val) {
	  return toString.call(val) === '[object Function]';
	}
	
	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject(val) && isFunction(val.pipe);
	}
	
	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}
	
	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}
	
	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  typeof document.createElement -> undefined
	 */
	function isStandardBrowserEnv() {
	  return typeof window !== 'undefined' && typeof document !== 'undefined' && typeof document.createElement === 'function';
	}
	
	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }
	
	  // Force an array if not already something iterable
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && !isArray(obj)) {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }
	
	  if (isArray(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}
	
	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge() /* obj1, obj2, obj3, ... */{
	  var result = {};
	  function assignValue(val, key) {
	    if (_typeof(result[key]) === 'object' && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
	      result[key] = merge(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }
	
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}
	
	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}
	
	module.exports = {
	  isArray: isArray,
	  isArrayBuffer: isArrayBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  extend: extend,
	  trim: trim
	};

/***/ },
/* 278 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var defaults = __webpack_require__(280);
	var utils = __webpack_require__(277);
	var InterceptorManager = __webpack_require__(282);
	var dispatchRequest = __webpack_require__(283);
	var isAbsoluteURL = __webpack_require__(294);
	var combineURLs = __webpack_require__(295);
	
	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 */
	function Axios(defaultConfig) {
	  this.defaults = utils.merge(defaults, defaultConfig);
	  this.interceptors = {
	    request: new InterceptorManager(),
	    response: new InterceptorManager()
	  };
	}
	
	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = utils.merge({
	      url: arguments[0]
	    }, arguments[1]);
	  }
	
	  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
	
	  // Support baseURL config
	  if (config.baseURL && !isAbsoluteURL(config.url)) {
	    config.url = combineURLs(config.baseURL, config.url);
	  }
	
	  // Hook up interceptors middleware
	  var chain = [dispatchRequest, undefined];
	  var promise = Promise.resolve(config);
	
	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });
	
	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    chain.push(interceptor.fulfilled, interceptor.rejected);
	  });
	
	  while (chain.length) {
	    promise = promise.then(chain.shift(), chain.shift());
	  }
	
	  return promise;
	};
	
	// Provide aliases for supported request methods
	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function (url, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url
	    }));
	  };
	});
	
	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function (url, data, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});
	
	module.exports = Axios;

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(277);
	var normalizeHeaderName = __webpack_require__(281);
	
	var PROTECTION_PREFIX = /^\)\]\}',?\n/;
	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};
	
	function setContentTypeIfUnset(headers, value) {
	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}
	
	module.exports = {
	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Content-Type');
	    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
	      return data;
	    }
	    if (utils.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils.isObject(data)) {
	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
	      return JSON.stringify(data);
	    }
	    return data;
	  }],
	
	  transformResponse: [function transformResponse(data) {
	    /*eslint no-param-reassign:0*/
	    if (typeof data === 'string') {
	      data = data.replace(PROTECTION_PREFIX, '');
	      try {
	        data = JSON.parse(data);
	      } catch (e) {/* Ignore */}
	    }
	    return data;
	  }],
	
	  headers: {
	    common: {
	      'Accept': 'application/json, text/plain, */*'
	    },
	    patch: utils.merge(DEFAULT_CONTENT_TYPE),
	    post: utils.merge(DEFAULT_CONTENT_TYPE),
	    put: utils.merge(DEFAULT_CONTENT_TYPE)
	  },
	
	  timeout: 0,
	
	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',
	
	  maxContentLength: -1,
	
	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(277);
	
	module.exports = function normalizeHeaderName(headers, normalizedName) {
	  utils.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(277);
	
	function InterceptorManager() {
	  this.handlers = [];
	}
	
	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected
	  });
	  return this.handlers.length - 1;
	};
	
	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};
	
	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};
	
	module.exports = InterceptorManager;

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var utils = __webpack_require__(277);
	var transformData = __webpack_require__(284);
	
	/**
	 * Dispatch a request to the server using whichever adapter
	 * is supported by the current environment.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	module.exports = function dispatchRequest(config) {
	  // Ensure headers exist
	  config.headers = config.headers || {};
	
	  // Transform request data
	  config.data = transformData(config.data, config.headers, config.transformRequest);
	
	  // Flatten headers
	  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});
	
	  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
	    delete config.headers[method];
	  });
	
	  var adapter;
	
	  if (typeof config.adapter === 'function') {
	    // For custom adapter support
	    adapter = config.adapter;
	  } else if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = __webpack_require__(285);
	  } else if (typeof process !== 'undefined') {
	    // For node use HTTP adapter
	    adapter = __webpack_require__(285);
	  }
	
	  return Promise.resolve(config)
	  // Wrap synchronous adapter errors and pass configuration
	  .then(adapter).then(function onFulfilled(response) {
	    // Transform response data
	    response.data = transformData(response.data, response.headers, config.transformResponse);
	
	    return response;
	  }, function onRejected(error) {
	    // Transform response data
	    if (error && error.response) {
	      error.response.data = transformData(error.response.data, error.response.headers, config.transformResponse);
	    }
	
	    return Promise.reject(error);
	  });
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(277);
	
	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	module.exports = function transformData(data, headers, fns) {
	  /*eslint no-param-reassign:0*/
	  utils.forEach(fns, function transform(fn) {
	    data = fn(data, headers);
	  });
	
	  return data;
	};

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var utils = __webpack_require__(277);
	var settle = __webpack_require__(286);
	var buildURL = __webpack_require__(289);
	var parseHeaders = __webpack_require__(290);
	var isURLSameOrigin = __webpack_require__(291);
	var createError = __webpack_require__(287);
	var btoa = typeof window !== 'undefined' && window.btoa || __webpack_require__(292);
	
	module.exports = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;
	
	    if (utils.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }
	
	    var request = new XMLHttpRequest();
	    var loadEvent = 'onreadystatechange';
	    var xDomain = false;
	
	    // For IE 8/9 CORS support
	    // Only supports POST and GET calls and doesn't returns the response headers.
	    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
	    if (process.env.NODE_ENV !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
	      request = new window.XDomainRequest();
	      loadEvent = 'onload';
	      xDomain = true;
	      request.onprogress = function handleProgress() {};
	      request.ontimeout = function handleTimeout() {};
	    }
	
	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }
	
	    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);
	
	    // Set the request timeout in MS
	    request.timeout = config.timeout;
	
	    // Listen for ready state
	    request[loadEvent] = function handleLoad() {
	      if (!request || request.readyState !== 4 && !xDomain) {
	        return;
	      }
	
	      // The request errored out and we didn't get a response, this will be
	      // handled by onerror instead
	      if (request.status === 0) {
	        return;
	      }
	
	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
	      var response = {
	        data: responseData,
	        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
	        status: request.status === 1223 ? 204 : request.status,
	        statusText: request.status === 1223 ? 'No Content' : request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };
	
	      settle(resolve, reject, response);
	
	      // Clean up request
	      request = null;
	    };
	
	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config));
	
	      // Clean up request
	      request = null;
	    };
	
	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED'));
	
	      // Clean up request
	      request = null;
	    };
	
	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      var cookies = __webpack_require__(293);
	
	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;
	
	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }
	
	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }
	
	    // Add withCredentials to request if needed
	    if (config.withCredentials) {
	      request.withCredentials = true;
	    }
	
	    // Add responseType to request if needed
	    if (config.responseType) {
	      try {
	        request.responseType = config.responseType;
	      } catch (e) {
	        if (request.responseType !== 'json') {
	          throw e;
	        }
	      }
	    }
	
	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }
	
	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }
	
	    if (requestData === undefined) {
	      requestData = null;
	    }
	
	    // Send the request
	    request.send(requestData);
	  });
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var createError = __webpack_require__(287);
	
	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	module.exports = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  // Note: status is not exposed by XDomainRequest
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError('Request failed with status code ' + response.status, response.config, null, response));
	  }
	};

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var enhanceError = __webpack_require__(288);
	
	/**
	 * Create an Error with the specified message, config, error code, and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	module.exports = function createError(message, config, code, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, response);
	};

/***/ },
/* 288 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */
	
	module.exports = function enhanceError(error, config, code, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }
	  error.response = response;
	  return error;
	};

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(277);
	
	function encode(val) {
	  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
	}
	
	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	module.exports = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }
	
	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];
	
	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }
	
	      if (utils.isArray(val)) {
	        key = key + '[]';
	      }
	
	      if (!utils.isArray(val)) {
	        val = [val];
	      }
	
	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });
	
	    serializedParams = parts.join('&');
	  }
	
	  if (serializedParams) {
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }
	
	  return url;
	};

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(277);
	
	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	module.exports = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;
	
	  if (!headers) {
	    return parsed;
	  }
	
	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));
	
	    if (key) {
	      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    }
	  });
	
	  return parsed;
	};

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(277);
	
	module.exports = utils.isStandardBrowserEnv() ?
	
	// Standard browser envs have full support of the APIs needed to test
	// whether the request URL is of the same origin as current location.
	function standardBrowserEnv() {
	  var msie = /(msie|trident)/i.test(navigator.userAgent);
	  var urlParsingNode = document.createElement('a');
	  var originURL;
	
	  /**
	  * Parse a URL to discover it's components
	  *
	  * @param {String} url The URL to be parsed
	  * @returns {Object}
	  */
	  function resolveURL(url) {
	    var href = url;
	
	    if (msie) {
	      // IE needs attribute set twice to normalize properties
	      urlParsingNode.setAttribute('href', href);
	      href = urlParsingNode.href;
	    }
	
	    urlParsingNode.setAttribute('href', href);
	
	    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	    return {
	      href: urlParsingNode.href,
	      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	      host: urlParsingNode.host,
	      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	      hostname: urlParsingNode.hostname,
	      port: urlParsingNode.port,
	      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
	    };
	  }
	
	  originURL = resolveURL(window.location.href);
	
	  /**
	  * Determine if a URL shares the same origin as the current location
	  *
	  * @param {String} requestURL The URL to test
	  * @returns {boolean} True if URL shares the same origin, otherwise false
	  */
	  return function isURLSameOrigin(requestURL) {
	    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
	    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
	  };
	}() :
	
	// Non standard browser envs (web workers, react-native) lack needed support.
	function nonStandardBrowserEnv() {
	  return function isURLSameOrigin() {
	    return true;
	  };
	}();

/***/ },
/* 292 */
/***/ function(module, exports) {

	'use strict';
	
	// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js
	
	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	
	function E() {
	  this.message = 'String contains an invalid character';
	}
	E.prototype = new Error();
	E.prototype.code = 5;
	E.prototype.name = 'InvalidCharacterError';
	
	function btoa(input) {
	  var str = String(input);
	  var output = '';
	  for (
	  // initialize result and counter
	  var block, charCode, idx = 0, map = chars;
	  // if the next str index does not exist:
	  //   change the mapping table to "="
	  //   check if d has no fractional digits
	  str.charAt(idx | 0) || (map = '=', idx % 1);
	  // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
	    charCode = str.charCodeAt(idx += 3 / 4);
	    if (charCode > 0xFF) {
	      throw new E();
	    }
	    block = block << 8 | charCode;
	  }
	  return output;
	}
	
	module.exports = btoa;

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(277);
	
	module.exports = utils.isStandardBrowserEnv() ?
	
	// Standard browser envs support document.cookie
	function standardBrowserEnv() {
	  return {
	    write: function write(name, value, expires, path, domain, secure) {
	      var cookie = [];
	      cookie.push(name + '=' + encodeURIComponent(value));
	
	      if (utils.isNumber(expires)) {
	        cookie.push('expires=' + new Date(expires).toGMTString());
	      }
	
	      if (utils.isString(path)) {
	        cookie.push('path=' + path);
	      }
	
	      if (utils.isString(domain)) {
	        cookie.push('domain=' + domain);
	      }
	
	      if (secure === true) {
	        cookie.push('secure');
	      }
	
	      document.cookie = cookie.join('; ');
	    },
	
	    read: function read(name) {
	      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	      return match ? decodeURIComponent(match[3]) : null;
	    },
	
	    remove: function remove(name) {
	      this.write(name, '', Date.now() - 86400000);
	    }
	  };
	}() :
	
	// Non standard browser env (web workers, react-native) lack needed support.
	function nonStandardBrowserEnv() {
	  return {
	    write: function write() {},
	    read: function read() {
	      return null;
	    },
	    remove: function remove() {}
	  };
	}();

/***/ },
/* 294 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	
	module.exports = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return (/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
	  );
	};

/***/ },
/* 295 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	
	module.exports = function combineURLs(baseURL, relativeURL) {
	  return baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '');
	};

/***/ },
/* 296 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	
	module.exports = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};

/***/ },
/* 297 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var CONNECT = exports.CONNECT = 'CONNECT';
	var DISCONNECT = exports.DISCONNECT = 'DISCONNECT';
	var INITIAL_RESULT = exports.INITIAL_RESULT = 'INITIAL_RESULT';
	var POST_MESSAGE = exports.POST_MESSAGE = 'POST_MESSAGE';
	var RECEIVE_MESSAGE = exports.RECEIVE_MESSAGE = 'RECEIVE_MESSAGE';
	var UPDATE = exports.UPDATE = 'UPDATE';

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(299);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(301)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./node_modules/css-loader/index.js!./app.css", function() {
				var newContent = require("!!./node_modules/css-loader/index.js!./app.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(300)();
	// imports
	
	
	// module
	exports.push([module.id, ".list {\n  display: flex;\n  flex-direction: column;\n}\n.song {\n  cursor: pointer;\n  padding: 10px 0;\n}\n.song:hover {\n  background: #bfbfbf;\n}\n.song-name {\n  display: inline-block;\n  width: 250px;\n}\n.song-likes {\n  display: inline-block;\n}\n", ""]);
	
	// exports


/***/ },
/* 300 */
/***/ function(module, exports) {

	"use strict";
	
	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function () {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for (var i = 0; i < this.length; i++) {
				var item = this[i];
				if (item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function (modules, mediaQuery) {
			if (typeof modules === "string") modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for (var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if (typeof id === "number") alreadyImportedModules[id] = true;
			}
			for (i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if (mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if (mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _redux = __webpack_require__(179);
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function socket() {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var action = arguments[1];
	
	  switch (action.type) {
	    case 'CONNECT':
	      return action.socket;
	    case 'DISCONNECT':
	      return {};
	    default:
	      return state;
	  }
	}
	
	function songs() {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	  var action = arguments[1];
	
	  switch (action.type) {
	    case 'INITIAL_RESULT':
	      return action.result;
	    case 'UPDATE':
	      return _extends({}, state, _defineProperty({}, action.song.id, action.song));
	    default:
	      return state;
	  }
	}
	
	exports.default = (0, _redux.combineReducers)({
	  songs: songs,
	  socket: socket
	});

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNTdmNDQ5YTQ3Yzc0Mzk0MTlhM2MiLCJ3ZWJwYWNrOi8vLy4vYXBwLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvcmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9LZXlFc2NhcGVVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHVyZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENsYXNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9rZXlNaXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9rZXlPZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnRGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRJbmplY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9FdmVudENvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVycm9yVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvYWNjdW11bGF0ZUludG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DYWxsYmFja1F1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFJlZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE93bmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5zdHJ1bWVudGF0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RGVidWdUb29sLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3BlcmZvcm1hbmNlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50VGFyZ2V0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2lzRXZlbnRTdXBwb3J0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvaXNUZXh0SW5wdXRFbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY1VJRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvVmlld3BvcnRNZXRyaWNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0RPTUxhenlUcmVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0RPTU5hbWVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2V0SW5uZXJIVE1MLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2V0VGV4dENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0Rhbmdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvZ2V0TWFya3VwV3JhcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9BdXRvRm9jdXNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NhbWVsaXplLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01CdXR0b24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRGlzYWJsZWRJbnB1dFV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NSW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvTGlua2VkVmFsdWVVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTU9wdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTVNlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTVRleHRhcmVhLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TXVsdGlDaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE5vZGVUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SG9zdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9mbGF0dGVuQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01UcmVlVHJhdmVyc2FsLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5wdXRTZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NWR0RPTVByb3BlcnR5Q29uZmlnLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljS2V5Ym9hcmRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudENoYXJDb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50S2V5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNUb3VjaEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TW91bnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NRmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TWFya3VwQ2hlY2tzdW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvYWRsZXIzMi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9maW5kRE9NTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvbGliL2NvbXBvbmVudHMvUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvc3RvcmVTaGFwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvbGliL2NvbXBvbmVudHMvY29ubmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy9zaGFsbG93RXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvd3JhcEFjdGlvbkNyZWF0b3JzLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2NyZWF0ZVN0b3JlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNIb3N0T2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc3ltYm9sLW9ic2VydmFibGUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc3ltYm9sLW9ic2VydmFibGUvbGliL3BvbnlmaWxsLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2NvbWJpbmVSZWR1Y2Vycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2JpbmRBY3Rpb25DcmVhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9hcHBseU1pZGRsZXdhcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvY29tcG9zZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vaW52YXJpYW50L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC10aHVuay9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9BcHAuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9Tb25nTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zb3J0LnV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vYmplY3QudmFsdWVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZGVmaW5lLXByb3BlcnRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9vYmplY3Qta2V5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L29iamVjdC1rZXlzL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL34vZm9yZWFjaC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L29iamVjdC52YWx1ZXMvaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9lcy1hYnN0cmFjdC9lczcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lcy1hYnN0cmFjdC9lczYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lcy1hYnN0cmFjdC9oZWxwZXJzL2lzTmFOLmpzIiwid2VicGFjazovLy8uL34vZXMtYWJzdHJhY3QvaGVscGVycy9pc0Zpbml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzLWFic3RyYWN0L2hlbHBlcnMvYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vZXMtYWJzdHJhY3QvaGVscGVycy9zaWduLmpzIiwid2VicGFjazovLy8uL34vZXMtYWJzdHJhY3QvaGVscGVycy9tb2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lcy1hYnN0cmFjdC9oZWxwZXJzL2lzUHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vZXMtdG8tcHJpbWl0aXZlL2VzNi5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzLXRvLXByaW1pdGl2ZS9oZWxwZXJzL2lzUHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vaXMtY2FsbGFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pcy1kYXRlLW9iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzLXN5bWJvbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Z1bmN0aW9uLWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovLy8uL34vZXMtYWJzdHJhY3QvZXM1LmpzIiwid2VicGFjazovLy8uL34vZXMtdG8tcHJpbWl0aXZlL2VzNS5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vaGFzL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L29iamVjdC52YWx1ZXMvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vYmplY3QudmFsdWVzL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzIiwid2VicGFjazovLy8uL34vcGFyc2V1cmkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9kZWJ1Zy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZGVidWcvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1wYXJzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tcGFyc2VyL34vanNvbjMvbGliL2pzb24zLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzIiwid2VicGFjazovLy8uL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tcGFyc2VyL2lzLWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvbGliL21hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oYXMtY29ycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy14aHIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1wYXJzZXIvfi9oYXMtYmluYXJ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FmdGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdXRmOC91dGY4LmpzIiwid2VicGFjazovLy8uL34vYmxvYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlcXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3llYXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanMiLCJ3ZWJwYWNrOi8vL3dzIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vLi9+L2luZGV4b2YvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZWpzb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi90by1hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzIiwid2VicGFjazovLy8uL34vY29tcG9uZW50LWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oYXMtYmluYXJ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYmFja28yL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL2FwcC5jc3M/MzFlOCIsIndlYnBhY2s6Ly8vLi9hcHAuY3NzIiwid2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL3JlZHVjZXJzLmpzIl0sIm5hbWVzIjpbInN0b3JlIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiX2Fzc2lnbiIsIlJlYWN0Q2hpbGRyZW4iLCJSZWFjdENvbXBvbmVudCIsIlJlYWN0UHVyZUNvbXBvbmVudCIsIlJlYWN0Q2xhc3MiLCJSZWFjdERPTUZhY3RvcmllcyIsIlJlYWN0RWxlbWVudCIsIlJlYWN0UHJvcFR5cGVzIiwiUmVhY3RWZXJzaW9uIiwib25seUNoaWxkIiwid2FybmluZyIsImNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVGYWN0b3J5IiwiY2xvbmVFbGVtZW50IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiUmVhY3RFbGVtZW50VmFsaWRhdG9yIiwiX19zcHJlYWQiLCJ3YXJuZWQiLCJhcHBseSIsImFyZ3VtZW50cyIsIlJlYWN0IiwiQ2hpbGRyZW4iLCJtYXAiLCJmb3JFYWNoIiwiY291bnQiLCJ0b0FycmF5Iiwib25seSIsIkNvbXBvbmVudCIsIlB1cmVDb21wb25lbnQiLCJpc1ZhbGlkRWxlbWVudCIsIlByb3BUeXBlcyIsImNyZWF0ZUNsYXNzIiwiY3JlYXRlTWl4aW4iLCJtaXhpbiIsIkRPTSIsInZlcnNpb24iLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImxlbmd0aCIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiQXJyYXkiLCJpIiwicHVzaCIsIkl0ZW0iLCJhcnJheSIsInByb3RvdHlwZSIsInRpdGxlIiwiYnJvd3NlciIsImFyZ3YiLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsImJpbmRpbmciLCJuYW1lIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsImhhc093blByb3BlcnR5IiwiT2JqZWN0IiwicHJvcElzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwidG9PYmplY3QiLCJ2YWwiLCJ1bmRlZmluZWQiLCJUeXBlRXJyb3IiLCJzaG91bGRVc2VOYXRpdmUiLCJhc3NpZ24iLCJ0ZXN0MSIsIlN0cmluZyIsImdldE93blByb3BlcnR5TmFtZXMiLCJ0ZXN0MiIsImZyb21DaGFyQ29kZSIsIm9yZGVyMiIsIm4iLCJqb2luIiwidGVzdDMiLCJzcGxpdCIsImxldHRlciIsImtleXMiLCJ0YXJnZXQiLCJzb3VyY2UiLCJmcm9tIiwidG8iLCJzeW1ib2xzIiwicyIsImtleSIsImdldE93blByb3BlcnR5U3ltYm9scyIsIlBvb2xlZENsYXNzIiwiZW1wdHlGdW5jdGlvbiIsInRyYXZlcnNlQWxsQ2hpbGRyZW4iLCJ0d29Bcmd1bWVudFBvb2xlciIsImZvdXJBcmd1bWVudFBvb2xlciIsInVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4IiwiZXNjYXBlVXNlclByb3ZpZGVkS2V5IiwidGV4dCIsInJlcGxhY2UiLCJGb3JFYWNoQm9va0tlZXBpbmciLCJmb3JFYWNoRnVuY3Rpb24iLCJmb3JFYWNoQ29udGV4dCIsImZ1bmMiLCJjb250ZXh0IiwiZGVzdHJ1Y3RvciIsImFkZFBvb2xpbmdUbyIsImZvckVhY2hTaW5nbGVDaGlsZCIsImJvb2tLZWVwaW5nIiwiY2hpbGQiLCJmb3JFYWNoQ2hpbGRyZW4iLCJjaGlsZHJlbiIsImZvckVhY2hGdW5jIiwidHJhdmVyc2VDb250ZXh0IiwiZ2V0UG9vbGVkIiwicmVsZWFzZSIsIk1hcEJvb2tLZWVwaW5nIiwibWFwUmVzdWx0Iiwia2V5UHJlZml4IiwibWFwRnVuY3Rpb24iLCJtYXBDb250ZXh0IiwicmVzdWx0IiwibWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCIsImNoaWxkS2V5IiwibWFwcGVkQ2hpbGQiLCJpc0FycmF5IiwibWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCIsInRoYXRSZXR1cm5zQXJndW1lbnQiLCJjbG9uZUFuZFJlcGxhY2VLZXkiLCJwcmVmaXgiLCJlc2NhcGVkUHJlZml4IiwibWFwQ2hpbGRyZW4iLCJmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSIsImNvdW50Q2hpbGRyZW4iLCJfcHJvZEludmFyaWFudCIsImludmFyaWFudCIsIm9uZUFyZ3VtZW50UG9vbGVyIiwiY29weUZpZWxkc0Zyb20iLCJLbGFzcyIsImluc3RhbmNlUG9vbCIsImluc3RhbmNlIiwicG9wIiwiYTEiLCJhMiIsInRocmVlQXJndW1lbnRQb29sZXIiLCJhMyIsImE0IiwiZml2ZUFyZ3VtZW50UG9vbGVyIiwiYTUiLCJzdGFuZGFyZFJlbGVhc2VyIiwicG9vbFNpemUiLCJERUZBVUxUX1BPT0xfU0laRSIsIkRFRkFVTFRfUE9PTEVSIiwiQ29weUNvbnN0cnVjdG9yIiwicG9vbGVyIiwiTmV3S2xhc3MiLCJyZWFjdFByb2RJbnZhcmlhbnQiLCJjb2RlIiwiYXJnQ291bnQiLCJtZXNzYWdlIiwiYXJnSWR4IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZXJyb3IiLCJmcmFtZXNUb1BvcCIsImNvbmRpdGlvbiIsImZvcm1hdCIsImEiLCJiIiwiYyIsImQiLCJmIiwiYXJnSW5kZXgiLCJSZWFjdEN1cnJlbnRPd25lciIsImNhbkRlZmluZVByb3BlcnR5IiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiUkVTRVJWRURfUFJPUFMiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJoYXNWYWxpZFJlZiIsImNvbmZpZyIsImdldHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsImlzUmVhY3RXYXJuaW5nIiwiaGFzVmFsaWRLZXkiLCJkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlciIsInByb3BzIiwiZGlzcGxheU5hbWUiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdLZXkiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nUmVmIiwidHlwZSIsInNlbGYiLCJvd25lciIsImVsZW1lbnQiLCIkJHR5cGVvZiIsIl9vd25lciIsIl9zdG9yZSIsInNoYWRvd0NoaWxkcmVuIiwic2xpY2UiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsInZhbGlkYXRlZCIsIl9zZWxmIiwiX3NoYWRvd0NoaWxkcmVuIiwiX3NvdXJjZSIsImZyZWV6ZSIsInByb3BOYW1lIiwiX19wcm90b19fIiwiY2hpbGRyZW5MZW5ndGgiLCJjaGlsZEFycmF5IiwiZGVmYXVsdFByb3BzIiwiY3VycmVudCIsImZhY3RvcnkiLCJiaW5kIiwib2xkRWxlbWVudCIsIm5ld0tleSIsIm5ld0VsZW1lbnQiLCJvYmplY3QiLCJwcmludFdhcm5pbmciLCJfbGVuIiwiX2tleSIsImNvbnNvbGUiLCJ4IiwiaW5kZXhPZiIsIl9sZW4yIiwiX2tleTIiLCJtYWtlRW1wdHlGdW5jdGlvbiIsImFyZyIsInRoYXRSZXR1cm5zIiwidGhhdFJldHVybnNGYWxzZSIsInRoYXRSZXR1cm5zVHJ1ZSIsInRoYXRSZXR1cm5zTnVsbCIsInRoYXRSZXR1cm5zVGhpcyIsImdldEl0ZXJhdG9yRm4iLCJLZXlFc2NhcGVVdGlscyIsIlNFUEFSQVRPUiIsIlNVQlNFUEFSQVRPUiIsImRpZFdhcm5BYm91dE1hcHMiLCJnZXRDb21wb25lbnRLZXkiLCJjb21wb25lbnQiLCJpbmRleCIsImVzY2FwZSIsInRvU3RyaW5nIiwidHJhdmVyc2VBbGxDaGlsZHJlbkltcGwiLCJuYW1lU29GYXIiLCJjYWxsYmFjayIsIm5leHROYW1lIiwic3VidHJlZUNvdW50IiwibmV4dE5hbWVQcmVmaXgiLCJpdGVyYXRvckZuIiwiaXRlcmF0b3IiLCJzdGVwIiwiZW50cmllcyIsImlpIiwibmV4dCIsImRvbmUiLCJtYXBzQXNDaGlsZHJlbkFkZGVuZHVtIiwibWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUiLCJnZXROYW1lIiwiZW50cnkiLCJhZGRlbmR1bSIsIl9pc1JlYWN0RWxlbWVudCIsImNoaWxkcmVuU3RyaW5nIiwiSVRFUkFUT1JfU1lNQk9MIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJtYXliZUl0ZXJhYmxlIiwiZXNjYXBlUmVnZXgiLCJlc2NhcGVyTG9va3VwIiwiZXNjYXBlZFN0cmluZyIsIm1hdGNoIiwidW5lc2NhcGUiLCJ1bmVzY2FwZVJlZ2V4IiwidW5lc2NhcGVyTG9va3VwIiwia2V5U3Vic3RyaW5nIiwic3Vic3RyaW5nIiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJlbXB0eU9iamVjdCIsInVwZGF0ZXIiLCJyZWZzIiwiaXNSZWFjdENvbXBvbmVudCIsInNldFN0YXRlIiwicGFydGlhbFN0YXRlIiwiZW5xdWV1ZVNldFN0YXRlIiwiZW5xdWV1ZUNhbGxiYWNrIiwiZm9yY2VVcGRhdGUiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJkZXByZWNhdGVkQVBJcyIsImlzTW91bnRlZCIsInJlcGxhY2VTdGF0ZSIsImRlZmluZURlcHJlY2F0aW9uV2FybmluZyIsIm1ldGhvZE5hbWUiLCJpbmZvIiwiZm5OYW1lIiwid2Fybk5vb3AiLCJwdWJsaWNJbnN0YW5jZSIsImNhbGxlck5hbWUiLCJjb25zdHJ1Y3RvciIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJjb21wbGV0ZVN0YXRlIiwiQ29tcG9uZW50RHVtbXkiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsIlJlYWN0UHJvcFR5cGVMb2NhdGlvbnMiLCJSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyIsImtleU1pcnJvciIsImtleU9mIiwiTUlYSU5TX0tFWSIsIm1peGlucyIsIlNwZWNQb2xpY3kiLCJERUZJTkVfT05DRSIsIkRFRklORV9NQU5ZIiwiT1ZFUlJJREVfQkFTRSIsIkRFRklORV9NQU5ZX01FUkdFRCIsImluamVjdGVkTWl4aW5zIiwiUmVhY3RDbGFzc0ludGVyZmFjZSIsInN0YXRpY3MiLCJwcm9wVHlwZXMiLCJjb250ZXh0VHlwZXMiLCJjaGlsZENvbnRleHRUeXBlcyIsImdldERlZmF1bHRQcm9wcyIsImdldEluaXRpYWxTdGF0ZSIsImdldENoaWxkQ29udGV4dCIsInJlbmRlciIsImNvbXBvbmVudFdpbGxNb3VudCIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInVwZGF0ZUNvbXBvbmVudCIsIlJFU0VSVkVEX1NQRUNfS0VZUyIsIkNvbnN0cnVjdG9yIiwibWl4U3BlY0ludG9Db21wb25lbnQiLCJ2YWxpZGF0ZVR5cGVEZWYiLCJjaGlsZENvbnRleHQiLCJjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbiIsInByb3AiLCJtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudCIsImF1dG9iaW5kIiwidHlwZURlZiIsImxvY2F0aW9uIiwidmFsaWRhdGVNZXRob2RPdmVycmlkZSIsImlzQWxyZWFkeURlZmluZWQiLCJzcGVjUG9saWN5IiwiUmVhY3RDbGFzc01peGluIiwic3BlYyIsInR5cGVvZlNwZWMiLCJpc01peGluVmFsaWQiLCJwcm90byIsImF1dG9CaW5kUGFpcnMiLCJfX3JlYWN0QXV0b0JpbmRQYWlycyIsInByb3BlcnR5IiwiaXNSZWFjdENsYXNzTWV0aG9kIiwiaXNGdW5jdGlvbiIsInNob3VsZEF1dG9CaW5kIiwiY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uIiwiaXNSZXNlcnZlZCIsImlzSW5oZXJpdGVkIiwibWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyIsIm9uZSIsInR3byIsIm1lcmdlZFJlc3VsdCIsImNoYWluZWRGdW5jdGlvbiIsImJpbmRBdXRvQmluZE1ldGhvZCIsIm1ldGhvZCIsImJvdW5kTWV0aG9kIiwiX19yZWFjdEJvdW5kQ29udGV4dCIsIl9fcmVhY3RCb3VuZE1ldGhvZCIsIl9fcmVhY3RCb3VuZEFyZ3VtZW50cyIsImNvbXBvbmVudE5hbWUiLCJfYmluZCIsIm5ld1RoaXMiLCJyZWJvdW5kTWV0aG9kIiwiYmluZEF1dG9CaW5kTWV0aG9kcyIsInBhaXJzIiwiYXV0b0JpbmRLZXkiLCJuZXdTdGF0ZSIsIlJlYWN0Q2xhc3NDb21wb25lbnQiLCJzdGF0ZSIsImluaXRpYWxTdGF0ZSIsIl9pc01vY2tGdW5jdGlvbiIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImluamVjdGlvbiIsImluamVjdE1peGluIiwib2JqIiwicmV0Iiwib25lS2V5T2JqIiwiY3JlYXRlRE9NRmFjdG9yeSIsImFiYnIiLCJhZGRyZXNzIiwiYXJlYSIsImFydGljbGUiLCJhc2lkZSIsImF1ZGlvIiwiYmFzZSIsImJkaSIsImJkbyIsImJpZyIsImJsb2NrcXVvdGUiLCJib2R5IiwiYnIiLCJidXR0b24iLCJjYW52YXMiLCJjYXB0aW9uIiwiY2l0ZSIsImNvbCIsImNvbGdyb3VwIiwiZGF0YSIsImRhdGFsaXN0IiwiZGQiLCJkZWwiLCJkZXRhaWxzIiwiZGZuIiwiZGlhbG9nIiwiZGl2IiwiZGwiLCJkdCIsImVtIiwiZW1iZWQiLCJmaWVsZHNldCIsImZpZ2NhcHRpb24iLCJmaWd1cmUiLCJmb290ZXIiLCJmb3JtIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwiaGVhZCIsImhlYWRlciIsImhncm91cCIsImhyIiwiaHRtbCIsImlmcmFtZSIsImltZyIsImlucHV0IiwiaW5zIiwia2JkIiwia2V5Z2VuIiwibGFiZWwiLCJsZWdlbmQiLCJsaSIsImxpbmsiLCJtYWluIiwibWFyayIsIm1lbnUiLCJtZW51aXRlbSIsIm1ldGEiLCJtZXRlciIsIm5hdiIsIm5vc2NyaXB0Iiwib2wiLCJvcHRncm91cCIsIm9wdGlvbiIsIm91dHB1dCIsInAiLCJwYXJhbSIsInBpY3R1cmUiLCJwcmUiLCJwcm9ncmVzcyIsInEiLCJycCIsInJ0IiwicnVieSIsInNhbXAiLCJzY3JpcHQiLCJzZWN0aW9uIiwic2VsZWN0Iiwic21hbGwiLCJzcGFuIiwic3Ryb25nIiwic3R5bGUiLCJzdWIiLCJzdW1tYXJ5Iiwic3VwIiwidGFibGUiLCJ0Ym9keSIsInRkIiwidGV4dGFyZWEiLCJ0Zm9vdCIsInRoIiwidGhlYWQiLCJ0aW1lIiwidHIiLCJ0cmFjayIsInUiLCJ1bCIsInZpZGVvIiwid2JyIiwiY2lyY2xlIiwiY2xpcFBhdGgiLCJkZWZzIiwiZWxsaXBzZSIsImciLCJpbWFnZSIsImxpbmUiLCJsaW5lYXJHcmFkaWVudCIsIm1hc2siLCJwYXRoIiwicGF0dGVybiIsInBvbHlnb24iLCJwb2x5bGluZSIsInJhZGlhbEdyYWRpZW50IiwicmVjdCIsInN0b3AiLCJzdmciLCJ0c3BhbiIsIlJlYWN0Q29tcG9uZW50VHJlZUhvb2siLCJjaGVja1JlYWN0VHlwZVNwZWMiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwibWVtb2l6ZXIiLCJ1bmlxdWVLZXkiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lciIsImdldEN1cnJlbnRTdGFja0FkZGVuZHVtIiwidmFsaWRhdGVDaGlsZEtleXMiLCJub2RlIiwidmFsaWRhdGVQcm9wVHlwZXMiLCJjb21wb25lbnRDbGFzcyIsInZhbGlkVHlwZSIsInZhbGlkYXRlZEZhY3RvcnkiLCJpc05hdGl2ZSIsImZuIiwiZnVuY1RvU3RyaW5nIiwiRnVuY3Rpb24iLCJyZUlzTmF0aXZlIiwiUmVnRXhwIiwidGVzdCIsImVyciIsImNhblVzZUNvbGxlY3Rpb25zIiwiTWFwIiwiU2V0IiwiaXRlbU1hcCIsInJvb3RJRFNldCIsIml0ZW1CeUtleSIsInJvb3RCeUtleSIsInVubW91bnRlZElEcyIsImdldEtleUZyb21JRCIsImlkIiwiZ2V0SURGcm9tS2V5IiwicGFyc2VJbnQiLCJzdWJzdHIiLCJyZW1vdmUiLCJjcmVhdGUiLCJwYXJlbnRJRCIsIml0ZW0iLCJjaGlsZElEcyIsInVwZGF0ZUNvdW50Iiwic2V0IiwiYWRkUm9vdCIsImFkZCIsInJlbW92ZVJvb3QiLCJnZXRSZWdpc3RlcmVkSURzIiwiZ2V0Um9vdElEcyIsInB1cmdlRGVlcCIsImRlc2NyaWJlQ29tcG9uZW50RnJhbWUiLCJvd25lck5hbWUiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJnZXREaXNwbGF5TmFtZSIsImRlc2NyaWJlSUQiLCJnZXRFbGVtZW50Iiwib3duZXJJRCIsImdldE93bmVySUQiLCJvblNldENoaWxkcmVuIiwibmV4dENoaWxkSURzIiwibmV4dENoaWxkSUQiLCJuZXh0Q2hpbGQiLCJvbkJlZm9yZU1vdW50Q29tcG9uZW50Iiwib25CZWZvcmVVcGRhdGVDb21wb25lbnQiLCJvbk1vdW50Q29tcG9uZW50IiwiaXNSb290Iiwib25VcGRhdGVDb21wb25lbnQiLCJvblVubW91bnRDb21wb25lbnQiLCJwdXJnZVVubW91bnRlZENvbXBvbmVudHMiLCJfcHJldmVudFB1cmdpbmciLCJ0b3BFbGVtZW50IiwiY3VycmVudE93bmVyIiwiX2RlYnVnSUQiLCJnZXRTdGFja0FkZGVuZHVtQnlJRCIsImdldFBhcmVudElEIiwiZ2V0Q2hpbGRJRHMiLCJnZXRTb3VyY2UiLCJnZXRUZXh0IiwiZ2V0VXBkYXRlQ291bnQiLCJSZWFjdFByb3BUeXBlc1NlY3JldCIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsInR5cGVTcGVjcyIsInZhbHVlcyIsImRlYnVnSUQiLCJ0eXBlU3BlY05hbWUiLCJleCIsImNvbXBvbmVudFN0YWNrSW5mbyIsIkFOT05ZTU9VUyIsImNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyIiwiYm9vbCIsIm51bWJlciIsInN0cmluZyIsInN5bWJvbCIsImFueSIsImNyZWF0ZUFueVR5cGVDaGVja2VyIiwiYXJyYXlPZiIsImNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlciIsImNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlciIsImluc3RhbmNlT2YiLCJjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyIiwiY3JlYXRlTm9kZUNoZWNrZXIiLCJvYmplY3RPZiIsImNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIiLCJvbmVPZiIsImNyZWF0ZUVudW1UeXBlQ2hlY2tlciIsIm9uZU9mVHlwZSIsImNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIiLCJzaGFwZSIsImNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIiLCJpcyIsInkiLCJQcm9wVHlwZUVycm9yIiwic3RhY2siLCJjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlciIsInZhbGlkYXRlIiwibWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUiLCJjaGVja1R5cGUiLCJpc1JlcXVpcmVkIiwicHJvcEZ1bGxOYW1lIiwic2VjcmV0IiwiY2FjaGVLZXkiLCJsb2NhdGlvbk5hbWUiLCJjaGFpbmVkQ2hlY2tUeXBlIiwiZXhwZWN0ZWRUeXBlIiwicHJvcFZhbHVlIiwicHJvcFR5cGUiLCJnZXRQcm9wVHlwZSIsInByZWNpc2VUeXBlIiwiZ2V0UHJlY2lzZVR5cGUiLCJ0eXBlQ2hlY2tlciIsImV4cGVjdGVkQ2xhc3MiLCJleHBlY3RlZENsYXNzTmFtZSIsImFjdHVhbENsYXNzTmFtZSIsImdldENsYXNzTmFtZSIsImV4cGVjdGVkVmFsdWVzIiwidmFsdWVzU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsImFycmF5T2ZUeXBlQ2hlY2tlcnMiLCJjaGVja2VyIiwiaXNOb2RlIiwic2hhcGVUeXBlcyIsImV2ZXJ5IiwiaXNTeW1ib2wiLCJEYXRlIiwiUmVhY3RET01Db21wb25lbnRUcmVlIiwiUmVhY3REZWZhdWx0SW5qZWN0aW9uIiwiUmVhY3RNb3VudCIsIlJlYWN0UmVjb25jaWxlciIsIlJlYWN0VXBkYXRlcyIsImZpbmRET01Ob2RlIiwiZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUiLCJyZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsImluamVjdCIsIlJlYWN0RE9NIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwiYmF0Y2hlZFVwZGF0ZXMiLCJ1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsIkNvbXBvbmVudFRyZWUiLCJnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSIsImdldE5vZGVGcm9tSW5zdGFuY2UiLCJpbnN0IiwiX3JlbmRlcmVkQ29tcG9uZW50IiwiTW91bnQiLCJSZWNvbmNpbGVyIiwiRXhlY3V0aW9uRW52aXJvbm1lbnQiLCJjYW5Vc2VET00iLCJ3aW5kb3ciLCJ0b3AiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJzaG93RmlsZVVybE1lc3NhZ2UiLCJwcm90b2NvbCIsImRlYnVnIiwidGVzdEZ1bmMiLCJ0ZXN0Rm4iLCJpZUNvbXBhdGliaWxpdHlNb2RlIiwiZG9jdW1lbnRNb2RlIiwiZXhwZWN0ZWRGZWF0dXJlcyIsIm5vdyIsInRyaW0iLCJSZWFjdEluc3RydW1lbnRhdGlvbiIsIlJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayIsIlJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayIsImRlYnVnVG9vbCIsImFkZEhvb2siLCJET01Qcm9wZXJ0eSIsIlJlYWN0RE9NQ29tcG9uZW50RmxhZ3MiLCJBVFRSX05BTUUiLCJJRF9BVFRSSUJVVEVfTkFNRSIsIkZsYWdzIiwiaW50ZXJuYWxJbnN0YW5jZUtleSIsIk1hdGgiLCJyYW5kb20iLCJnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50IiwicmVuZGVyZWQiLCJwcmVjYWNoZU5vZGUiLCJob3N0SW5zdCIsIl9ob3N0Tm9kZSIsInVuY2FjaGVOb2RlIiwicHJlY2FjaGVDaGlsZE5vZGVzIiwiX2ZsYWdzIiwiaGFzQ2FjaGVkQ2hpbGROb2RlcyIsIl9yZW5kZXJlZENoaWxkcmVuIiwiY2hpbGROb2RlIiwiZmlyc3RDaGlsZCIsIm91dGVyIiwiY2hpbGRJbnN0IiwiY2hpbGRJRCIsIl9kb21JRCIsIm5leHRTaWJsaW5nIiwibm9kZVR5cGUiLCJnZXRBdHRyaWJ1dGUiLCJub2RlVmFsdWUiLCJwYXJlbnRzIiwicGFyZW50Tm9kZSIsImNsb3Nlc3QiLCJnZXRJbnN0YW5jZUZyb21Ob2RlIiwiX2hvc3RQYXJlbnQiLCJjaGVja01hc2siLCJiaXRtYXNrIiwiRE9NUHJvcGVydHlJbmplY3Rpb24iLCJNVVNUX1VTRV9QUk9QRVJUWSIsIkhBU19CT09MRUFOX1ZBTFVFIiwiSEFTX05VTUVSSUNfVkFMVUUiLCJIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSIsIkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUiLCJpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyIsImRvbVByb3BlcnR5Q29uZmlnIiwiSW5qZWN0aW9uIiwiUHJvcGVydGllcyIsIkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXMiLCJET01BdHRyaWJ1dGVOYW1lcyIsIkRPTVByb3BlcnR5TmFtZXMiLCJET01NdXRhdGlvbk1ldGhvZHMiLCJpc0N1c3RvbUF0dHJpYnV0ZSIsIl9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucyIsInByb3BlcnRpZXMiLCJsb3dlckNhc2VkIiwidG9Mb3dlckNhc2UiLCJwcm9wQ29uZmlnIiwicHJvcGVydHlJbmZvIiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZU5hbWVzcGFjZSIsInByb3BlcnR5TmFtZSIsIm11dGF0aW9uTWV0aG9kIiwibXVzdFVzZVByb3BlcnR5IiwiaGFzQm9vbGVhblZhbHVlIiwiaGFzTnVtZXJpY1ZhbHVlIiwiaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUiLCJoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIiwiZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUiLCJBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSIiwiUk9PVF9BVFRSSUJVVEVfTkFNRSIsIkFUVFJJQlVURV9OQU1FX0NIQVIiLCJpc0N1c3RvbUF0dHJpYnV0ZUZuIiwiQmVmb3JlSW5wdXRFdmVudFBsdWdpbiIsIkNoYW5nZUV2ZW50UGx1Z2luIiwiRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIiLCJFbnRlckxlYXZlRXZlbnRQbHVnaW4iLCJIVE1MRE9NUHJvcGVydHlDb25maWciLCJSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCIsIlJlYWN0RE9NQ29tcG9uZW50IiwiUmVhY3RET01FbXB0eUNvbXBvbmVudCIsIlJlYWN0RE9NVHJlZVRyYXZlcnNhbCIsIlJlYWN0RE9NVGV4dENvbXBvbmVudCIsIlJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kiLCJSZWFjdEV2ZW50TGlzdGVuZXIiLCJSZWFjdEluamVjdGlvbiIsIlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24iLCJTVkdET01Qcm9wZXJ0eUNvbmZpZyIsIlNlbGVjdEV2ZW50UGx1Z2luIiwiU2ltcGxlRXZlbnRQbHVnaW4iLCJhbHJlYWR5SW5qZWN0ZWQiLCJFdmVudEVtaXR0ZXIiLCJpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIiLCJFdmVudFBsdWdpbkh1YiIsImluamVjdEV2ZW50UGx1Z2luT3JkZXIiLCJFdmVudFBsdWdpblV0aWxzIiwiaW5qZWN0Q29tcG9uZW50VHJlZSIsImluamVjdFRyZWVUcmF2ZXJzYWwiLCJpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUiLCJIb3N0Q29tcG9uZW50IiwiaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzIiwiaW5qZWN0VGV4dENvbXBvbmVudENsYXNzIiwiRW1wdHlDb21wb25lbnQiLCJpbmplY3RFbXB0eUNvbXBvbmVudEZhY3RvcnkiLCJpbnN0YW50aWF0ZSIsIlVwZGF0ZXMiLCJpbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiIsImluamVjdEJhdGNoaW5nU3RyYXRlZ3kiLCJpbmplY3RFbnZpcm9ubWVudCIsIkV2ZW50Q29uc3RhbnRzIiwiRXZlbnRQcm9wYWdhdG9ycyIsIkZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSIsIlN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQiLCJTeW50aGV0aWNJbnB1dEV2ZW50IiwiRU5EX0tFWUNPREVTIiwiU1RBUlRfS0VZQ09ERSIsImNhblVzZUNvbXBvc2l0aW9uRXZlbnQiLCJjYW5Vc2VUZXh0SW5wdXRFdmVudCIsImlzUHJlc3RvIiwidXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEiLCJvcGVyYSIsIlNQQUNFQkFSX0NPREUiLCJTUEFDRUJBUl9DSEFSIiwidG9wTGV2ZWxUeXBlcyIsImV2ZW50VHlwZXMiLCJiZWZvcmVJbnB1dCIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzIiwiYnViYmxlZCIsIm9uQmVmb3JlSW5wdXQiLCJjYXB0dXJlZCIsIm9uQmVmb3JlSW5wdXRDYXB0dXJlIiwiZGVwZW5kZW5jaWVzIiwidG9wQ29tcG9zaXRpb25FbmQiLCJ0b3BLZXlQcmVzcyIsInRvcFRleHRJbnB1dCIsInRvcFBhc3RlIiwiY29tcG9zaXRpb25FbmQiLCJvbkNvbXBvc2l0aW9uRW5kIiwib25Db21wb3NpdGlvbkVuZENhcHR1cmUiLCJ0b3BCbHVyIiwidG9wS2V5RG93biIsInRvcEtleVVwIiwidG9wTW91c2VEb3duIiwiY29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25TdGFydENhcHR1cmUiLCJ0b3BDb21wb3NpdGlvblN0YXJ0IiwiY29tcG9zaXRpb25VcGRhdGUiLCJvbkNvbXBvc2l0aW9uVXBkYXRlIiwib25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmUiLCJ0b3BDb21wb3NpdGlvblVwZGF0ZSIsImhhc1NwYWNlS2V5cHJlc3MiLCJpc0tleXByZXNzQ29tbWFuZCIsIm5hdGl2ZUV2ZW50IiwiY3RybEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSIsInRvcExldmVsVHlwZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0Iiwia2V5Q29kZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCIsImdldERhdGFGcm9tQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJjdXJyZW50Q29tcG9zaXRpb24iLCJleHRyYWN0Q29tcG9zaXRpb25FdmVudCIsInRhcmdldEluc3QiLCJuYXRpdmVFdmVudFRhcmdldCIsImV2ZW50VHlwZSIsImZhbGxiYWNrRGF0YSIsImdldERhdGEiLCJldmVudCIsImN1c3RvbURhdGEiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzIiwiZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyIsIndoaWNoIiwiY2hhcnMiLCJnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMiLCJleHRyYWN0QmVmb3JlSW5wdXRFdmVudCIsImV4dHJhY3RFdmVudHMiLCJQcm9wYWdhdGlvblBoYXNlcyIsInRvcEFib3J0IiwidG9wQW5pbWF0aW9uRW5kIiwidG9wQW5pbWF0aW9uSXRlcmF0aW9uIiwidG9wQW5pbWF0aW9uU3RhcnQiLCJ0b3BDYW5QbGF5IiwidG9wQ2FuUGxheVRocm91Z2giLCJ0b3BDaGFuZ2UiLCJ0b3BDbGljayIsInRvcENvbnRleHRNZW51IiwidG9wQ29weSIsInRvcEN1dCIsInRvcERvdWJsZUNsaWNrIiwidG9wRHJhZyIsInRvcERyYWdFbmQiLCJ0b3BEcmFnRW50ZXIiLCJ0b3BEcmFnRXhpdCIsInRvcERyYWdMZWF2ZSIsInRvcERyYWdPdmVyIiwidG9wRHJhZ1N0YXJ0IiwidG9wRHJvcCIsInRvcER1cmF0aW9uQ2hhbmdlIiwidG9wRW1wdGllZCIsInRvcEVuY3J5cHRlZCIsInRvcEVuZGVkIiwidG9wRXJyb3IiLCJ0b3BGb2N1cyIsInRvcElucHV0IiwidG9wSW52YWxpZCIsInRvcExvYWQiLCJ0b3BMb2FkZWREYXRhIiwidG9wTG9hZGVkTWV0YWRhdGEiLCJ0b3BMb2FkU3RhcnQiLCJ0b3BNb3VzZU1vdmUiLCJ0b3BNb3VzZU91dCIsInRvcE1vdXNlT3ZlciIsInRvcE1vdXNlVXAiLCJ0b3BQYXVzZSIsInRvcFBsYXkiLCJ0b3BQbGF5aW5nIiwidG9wUHJvZ3Jlc3MiLCJ0b3BSYXRlQ2hhbmdlIiwidG9wUmVzZXQiLCJ0b3BTY3JvbGwiLCJ0b3BTZWVrZWQiLCJ0b3BTZWVraW5nIiwidG9wU2VsZWN0aW9uQ2hhbmdlIiwidG9wU3RhbGxlZCIsInRvcFN1Ym1pdCIsInRvcFN1c3BlbmQiLCJ0b3BUaW1lVXBkYXRlIiwidG9wVG91Y2hDYW5jZWwiLCJ0b3BUb3VjaEVuZCIsInRvcFRvdWNoTW92ZSIsInRvcFRvdWNoU3RhcnQiLCJ0b3BUcmFuc2l0aW9uRW5kIiwidG9wVm9sdW1lQ2hhbmdlIiwidG9wV2FpdGluZyIsInRvcFdoZWVsIiwiYWNjdW11bGF0ZUludG8iLCJmb3JFYWNoQWNjdW11bGF0ZWQiLCJnZXRMaXN0ZW5lciIsImxpc3RlbmVyQXRQaGFzZSIsInByb3BhZ2F0aW9uUGhhc2UiLCJyZWdpc3RyYXRpb25OYW1lIiwiZGlzcGF0Y2hDb25maWciLCJhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzIiwidXB3YXJkcyIsInBoYXNlIiwibGlzdGVuZXIiLCJfZGlzcGF0Y2hMaXN0ZW5lcnMiLCJfZGlzcGF0Y2hJbnN0YW5jZXMiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlIiwidHJhdmVyc2VUd29QaGFzZSIsIl90YXJnZXRJbnN0IiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQiLCJwYXJlbnRJbnN0IiwiZ2V0UGFyZW50SW5zdGFuY2UiLCJhY2N1bXVsYXRlRGlzcGF0Y2hlcyIsImlnbm9yZWREaXJlY3Rpb24iLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSIsImV2ZW50cyIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0IiwiYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzIiwibGVhdmUiLCJlbnRlciIsInRyYXZlcnNlRW50ZXJMZWF2ZSIsImFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzIiwiRXZlbnRQbHVnaW5SZWdpc3RyeSIsIlJlYWN0RXJyb3JVdGlscyIsImxpc3RlbmVyQmFuayIsImV2ZW50UXVldWUiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UiLCJzaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIiLCJpc1BlcnNpc3RlbnQiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCIsImdldERpY3Rpb25hcnlLZXkiLCJfcm9vdE5vZGVJRCIsInB1dExpc3RlbmVyIiwiYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUiLCJQbHVnaW5Nb2R1bGUiLCJyZWdpc3RyYXRpb25OYW1lTW9kdWxlcyIsImRpZFB1dExpc3RlbmVyIiwiZGVsZXRlTGlzdGVuZXIiLCJ3aWxsRGVsZXRlTGlzdGVuZXIiLCJkZWxldGVBbGxMaXN0ZW5lcnMiLCJwbHVnaW5zIiwicG9zc2libGVQbHVnaW4iLCJleHRyYWN0ZWRFdmVudHMiLCJlbnF1ZXVlRXZlbnRzIiwicHJvY2Vzc0V2ZW50UXVldWUiLCJwcm9jZXNzaW5nRXZlbnRRdWV1ZSIsInJldGhyb3dDYXVnaHRFcnJvciIsIl9fcHVyZ2UiLCJfX2dldExpc3RlbmVyQmFuayIsIkV2ZW50UGx1Z2luT3JkZXIiLCJuYW1lc1RvUGx1Z2lucyIsInJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nIiwicGx1Z2luTmFtZSIsInBsdWdpbkluZGV4IiwicHVibGlzaGVkRXZlbnRzIiwiZXZlbnROYW1lIiwicHVibGlzaEV2ZW50Rm9yUGx1Z2luIiwiZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzIiwicGhhc2VOYW1lIiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZSIsInB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lIiwicmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyIsImxvd2VyQ2FzZWROYW1lIiwicG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyIsIm9uZGJsY2xpY2siLCJJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIiLCJpbmplY3RlZE5hbWVzVG9QbHVnaW5zIiwiaXNPcmRlcmluZ0RpcnR5IiwiZ2V0UGx1Z2luTW9kdWxlRm9yRXZlbnQiLCJfcmVzZXRFdmVudFBsdWdpbnMiLCJUcmVlVHJhdmVyc2FsIiwiSW5qZWN0ZWQiLCJpc0FuY2VzdG9yIiwiZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IiLCJpc0VuZGlzaCIsImlzTW92ZWlzaCIsImlzU3RhcnRpc2giLCJ2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyIsImRpc3BhdGNoTGlzdGVuZXJzIiwiZGlzcGF0Y2hJbnN0YW5jZXMiLCJsaXN0ZW5lcnNJc0FyciIsImxpc3RlbmVyc0xlbiIsImluc3RhbmNlc0lzQXJyIiwiaW5zdGFuY2VzTGVuIiwiZXhlY3V0ZURpc3BhdGNoIiwiY3VycmVudFRhcmdldCIsImludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaCIsImludm9rZUd1YXJkZWRDYWxsYmFjayIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwiLCJleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlIiwiZXhlY3V0ZURpcmVjdERpc3BhdGNoIiwiZGlzcGF0Y2hMaXN0ZW5lciIsImRpc3BhdGNoSW5zdGFuY2UiLCJyZXMiLCJoYXNEaXNwYXRjaGVzIiwiYXJnRnJvbSIsImFyZ1RvIiwiY2F1Z2h0RXJyb3IiLCJkaXNwYXRjaEV2ZW50IiwiY3JlYXRlRXZlbnQiLCJmYWtlTm9kZSIsImJvdW5kRnVuYyIsImV2dFR5cGUiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZ0IiwiaW5pdEV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFyciIsImNiIiwic2NvcGUiLCJjYW5Vc2VXb3JrZXJzIiwiV29ya2VyIiwiY2FuVXNlRXZlbnRMaXN0ZW5lcnMiLCJhdHRhY2hFdmVudCIsImNhblVzZVZpZXdwb3J0Iiwic2NyZWVuIiwiaXNJbldvcmtlciIsImdldFRleHRDb250ZW50QWNjZXNzb3IiLCJyb290IiwiX3Jvb3QiLCJfc3RhcnRUZXh0IiwiX2ZhbGxiYWNrVGV4dCIsInN0YXJ0Iiwic3RhcnRWYWx1ZSIsInN0YXJ0TGVuZ3RoIiwiZW5kIiwiZW5kVmFsdWUiLCJlbmRMZW5ndGgiLCJtaW5FbmQiLCJzbGljZVRhaWwiLCJjb250ZW50S2V5IiwiZG9jdW1lbnRFbGVtZW50IiwiU3ludGhldGljRXZlbnQiLCJDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlIiwiZGlzcGF0Y2hNYXJrZXIiLCJhdWdtZW50Q2xhc3MiLCJkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSIsImlzUHJveHlTdXBwb3J0ZWQiLCJQcm94eSIsInNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzIiwiRXZlbnRJbnRlcmZhY2UiLCJldmVudFBoYXNlIiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJ0aW1lU3RhbXAiLCJkZWZhdWx0UHJldmVudGVkIiwiaXNUcnVzdGVkIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJJbnRlcmZhY2UiLCJub3JtYWxpemUiLCJyZXR1cm5WYWx1ZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsImNhbmNlbEJ1YmJsZSIsInBlcnNpc3QiLCJnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uIiwiY29uc3RydWN0IiwidGhhdCIsIkNsYXNzIiwiU3VwZXIiLCJFIiwiZ2V0VmFsIiwiYWN0aW9uIiwid2FybiIsIndhcm5pbmdDb25kaXRpb24iLCJJbnB1dEV2ZW50SW50ZXJmYWNlIiwiZ2V0RXZlbnRUYXJnZXQiLCJpc0V2ZW50U3VwcG9ydGVkIiwiaXNUZXh0SW5wdXRFbGVtZW50IiwiY2hhbmdlIiwib25DaGFuZ2UiLCJvbkNoYW5nZUNhcHR1cmUiLCJhY3RpdmVFbGVtZW50IiwiYWN0aXZlRWxlbWVudEluc3QiLCJhY3RpdmVFbGVtZW50VmFsdWUiLCJhY3RpdmVFbGVtZW50VmFsdWVQcm9wIiwic2hvdWxkVXNlQ2hhbmdlRXZlbnQiLCJlbGVtIiwibm9kZU5hbWUiLCJkb2VzQ2hhbmdlRXZlbnRCdWJibGUiLCJtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50IiwicnVuRXZlbnRJbkJhdGNoIiwic3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4Iiwic3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgiLCJkZXRhY2hFdmVudCIsImdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCIsImhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4IiwiaXNJbnB1dEV2ZW50U3VwcG9ydGVkIiwibmV3VmFsdWVQcm9wIiwic3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwiaGFuZGxlUHJvcGVydHlDaGFuZ2UiLCJzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSIsInNyY0VsZW1lbnQiLCJnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudCIsImhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSIsImdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50SUUiLCJzaG91bGRVc2VDbGlja0V2ZW50IiwiZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQiLCJ0YXJnZXROb2RlIiwiZ2V0VGFyZ2V0SW5zdEZ1bmMiLCJoYW5kbGVFdmVudEZ1bmMiLCJDYWxsYmFja1F1ZXVlIiwiUmVhY3RGZWF0dXJlRmxhZ3MiLCJUcmFuc2FjdGlvbiIsImRpcnR5Q29tcG9uZW50cyIsInVwZGF0ZUJhdGNoTnVtYmVyIiwiYXNhcENhbGxiYWNrUXVldWUiLCJhc2FwRW5xdWV1ZWQiLCJiYXRjaGluZ1N0cmF0ZWd5IiwiZW5zdXJlSW5qZWN0ZWQiLCJORVNURURfVVBEQVRFUyIsImluaXRpYWxpemUiLCJkaXJ0eUNvbXBvbmVudHNMZW5ndGgiLCJjbG9zZSIsInNwbGljZSIsImZsdXNoQmF0Y2hlZFVwZGF0ZXMiLCJVUERBVEVfUVVFVUVJTkciLCJjYWxsYmFja1F1ZXVlIiwicmVzZXQiLCJub3RpZnlBbGwiLCJUUkFOU0FDVElPTl9XUkFQUEVSUyIsIlJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24iLCJyZWluaXRpYWxpemVUcmFuc2FjdGlvbiIsInJlY29uY2lsZVRyYW5zYWN0aW9uIiwiTWl4aW4iLCJnZXRUcmFuc2FjdGlvbldyYXBwZXJzIiwicGVyZm9ybSIsIm1vdW50T3JkZXJDb21wYXJhdG9yIiwiYzEiLCJjMiIsIl9tb3VudE9yZGVyIiwicnVuQmF0Y2hlZFVwZGF0ZXMiLCJ0cmFuc2FjdGlvbiIsInNvcnQiLCJjYWxsYmFja3MiLCJfcGVuZGluZ0NhbGxiYWNrcyIsIm1hcmtlck5hbWUiLCJsb2dUb3BMZXZlbFJlbmRlcnMiLCJuYW1lZENvbXBvbmVudCIsIl9jdXJyZW50RWxlbWVudCIsInBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSIsInRpbWVFbmQiLCJqIiwiZW5xdWV1ZSIsImdldFB1YmxpY0luc3RhbmNlIiwiZW5xdWV1ZVVwZGF0ZSIsImlzQmF0Y2hpbmdVcGRhdGVzIiwiX3VwZGF0ZUJhdGNoTnVtYmVyIiwiYXNhcCIsIlJlYWN0VXBkYXRlc0luamVjdGlvbiIsIlJlY29uY2lsZVRyYW5zYWN0aW9uIiwiX2JhdGNoaW5nU3RyYXRlZ3kiLCJfY2FsbGJhY2tzIiwiX2NvbnRleHRzIiwiY29udGV4dHMiLCJjaGVja3BvaW50Iiwicm9sbGJhY2siLCJSZWFjdFJlZiIsImF0dGFjaFJlZnMiLCJtb3VudENvbXBvbmVudCIsImludGVybmFsSW5zdGFuY2UiLCJob3N0UGFyZW50IiwiaG9zdENvbnRhaW5lckluZm8iLCJwYXJlbnREZWJ1Z0lEIiwibWFya3VwIiwiZ2V0UmVhY3RNb3VudFJlYWR5IiwiZ2V0SG9zdE5vZGUiLCJ1bm1vdW50Q29tcG9uZW50Iiwic2FmZWx5Iiwib25CZWZvcmVVbm1vdW50Q29tcG9uZW50IiwiZGV0YWNoUmVmcyIsInJlY2VpdmVDb21wb25lbnQiLCJuZXh0RWxlbWVudCIsInByZXZFbGVtZW50IiwiX2NvbnRleHQiLCJyZWZzQ2hhbmdlZCIsInNob3VsZFVwZGF0ZVJlZnMiLCJSZWFjdE93bmVyIiwiYXR0YWNoUmVmIiwiYWRkQ29tcG9uZW50QXNSZWZUbyIsImRldGFjaFJlZiIsInJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbSIsInByZXZFbXB0eSIsIm5leHRFbXB0eSIsImlzVmFsaWRPd25lciIsIm93bmVyUHVibGljSW5zdGFuY2UiLCJSZWFjdERlYnVnVG9vbCIsIlJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2siLCJSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayIsIlJlYWN0Q2hpbGRyZW5NdXRhdGlvbldhcm5pbmdIb29rIiwicGVyZm9ybWFuY2VOb3ciLCJob29rcyIsImRpZEhvb2tUaHJvd0ZvckV2ZW50IiwiY2FsbEhvb2siLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJhcmc0IiwiYXJnNSIsImVtaXRFdmVudCIsImhvb2siLCJpc1Byb2ZpbGluZyIsImZsdXNoSGlzdG9yeSIsImxpZmVDeWNsZVRpbWVyU3RhY2siLCJjdXJyZW50Rmx1c2hOZXN0aW5nIiwiY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzIiwiY3VycmVudEZsdXNoU3RhcnRUaW1lIiwiY3VycmVudFRpbWVyRGVidWdJRCIsImN1cnJlbnRUaW1lclN0YXJ0VGltZSIsImN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24iLCJjdXJyZW50VGltZXJUeXBlIiwibGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQiLCJjbGVhckhpc3RvcnkiLCJnZXRUcmVlU25hcHNob3QiLCJyZWdpc3RlcmVkSURzIiwicmVkdWNlIiwidHJlZSIsInJlc2V0TWVhc3VyZW1lbnRzIiwicHJldmlvdXNTdGFydFRpbWUiLCJwcmV2aW91c01lYXN1cmVtZW50cyIsInByZXZpb3VzT3BlcmF0aW9ucyIsImdldEhpc3RvcnkiLCJkdXJhdGlvbiIsIm1lYXN1cmVtZW50cyIsIm9wZXJhdGlvbnMiLCJ0cmVlU25hcHNob3QiLCJjaGVja0RlYnVnSUQiLCJhbGxvd1Jvb3QiLCJiZWdpbkxpZmVDeWNsZVRpbWVyIiwidGltZXJUeXBlIiwiZW5kTGlmZUN5Y2xlVGltZXIiLCJpbnN0YW5jZUlEIiwicGF1c2VDdXJyZW50TGlmZUN5Y2xlVGltZXIiLCJjdXJyZW50VGltZXIiLCJzdGFydFRpbWUiLCJuZXN0ZWRGbHVzaFN0YXJ0VGltZSIsInJlc3VtZUN1cnJlbnRMaWZlQ3ljbGVUaW1lciIsIl9saWZlQ3ljbGVUaW1lclN0YWNrJCIsIm5lc3RlZEZsdXNoRHVyYXRpb24iLCJyZW1vdmVIb29rIiwiYmVnaW5Qcm9maWxpbmciLCJlbmRQcm9maWxpbmciLCJnZXRGbHVzaEhpc3RvcnkiLCJvbkJlZ2luRmx1c2giLCJvbkVuZEZsdXNoIiwib25CZWdpbkxpZmVDeWNsZVRpbWVyIiwib25FbmRMaWZlQ3ljbGVUaW1lciIsIm9uRXJyb3IiLCJvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCIsIm9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCIsIm9uSG9zdE9wZXJhdGlvbiIsInBheWxvYWQiLCJvblNldFN0YXRlIiwiY2hpbGREZWJ1Z0lEcyIsIm9uVGVzdEV2ZW50IiwiYWRkRGV2dG9vbCIsInJlbW92ZURldnRvb2wiLCJ1cmwiLCJocmVmIiwicHJvY2Vzc2luZ0NoaWxkQ29udGV4dCIsIndhcm5JbnZhbGlkU2V0U3RhdGUiLCJoaXN0b3J5IiwiX3ByZXZlbnRDbGVhcmluZyIsImhhbmRsZUVsZW1lbnQiLCJpc011dGF0ZWQiLCJwZXJmb3JtYW5jZSIsIm1zUGVyZm9ybWFuY2UiLCJ3ZWJraXRQZXJmb3JtYW5jZSIsInRyYW5zYWN0aW9uV3JhcHBlcnMiLCJ3cmFwcGVySW5pdERhdGEiLCJfaXNJblRyYW5zYWN0aW9uIiwiaXNJblRyYW5zYWN0aW9uIiwiZXJyb3JUaHJvd24iLCJpbml0aWFsaXplQWxsIiwiY2xvc2VBbGwiLCJzdGFydEluZGV4Iiwid3JhcHBlciIsIk9CU0VSVkVEX0VSUk9SIiwiaW5pdERhdGEiLCJjb3JyZXNwb25kaW5nVXNlRWxlbWVudCIsInVzZUhhc0ZlYXR1cmUiLCJpbXBsZW1lbnRhdGlvbiIsImhhc0ZlYXR1cmUiLCJldmVudE5hbWVTdWZmaXgiLCJjYXB0dXJlIiwiaXNTdXBwb3J0ZWQiLCJzZXRBdHRyaWJ1dGUiLCJzdXBwb3J0ZWRJbnB1dFR5cGVzIiwiUmVzcG9uZGVyRXZlbnRQbHVnaW4iLCJUYXBFdmVudFBsdWdpbiIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJtb3VzZUVudGVyIiwib25Nb3VzZUVudGVyIiwibW91c2VMZWF2ZSIsIm9uTW91c2VMZWF2ZSIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tRWxlbWVudCIsIndpbiIsImRvYyIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsInBhcmVudFdpbmRvdyIsInJlbGF0ZWQiLCJ0b0VsZW1lbnQiLCJmcm9tTm9kZSIsInRvTm9kZSIsIlN5bnRoZXRpY1VJRXZlbnQiLCJWaWV3cG9ydE1ldHJpY3MiLCJnZXRFdmVudE1vZGlmaWVyU3RhdGUiLCJNb3VzZUV2ZW50SW50ZXJmYWNlIiwic2NyZWVuWCIsInNjcmVlblkiLCJjbGllbnRYIiwiY2xpZW50WSIsInNoaWZ0S2V5IiwiZ2V0TW9kaWZpZXJTdGF0ZSIsImJ1dHRvbnMiLCJwYWdlWCIsImN1cnJlbnRTY3JvbGxMZWZ0IiwicGFnZVkiLCJjdXJyZW50U2Nyb2xsVG9wIiwiVUlFdmVudEludGVyZmFjZSIsInZpZXciLCJyZWZyZXNoU2Nyb2xsVmFsdWVzIiwic2Nyb2xsUG9zaXRpb24iLCJtb2RpZmllcktleVRvUHJvcCIsIm1vZGlmaWVyU3RhdGVHZXR0ZXIiLCJrZXlBcmciLCJzeW50aGV0aWNFdmVudCIsImtleVByb3AiLCJhY2NlcHQiLCJhY2NlcHRDaGFyc2V0IiwiYWNjZXNzS2V5IiwiYWxsb3dGdWxsU2NyZWVuIiwiYWxsb3dUcmFuc3BhcmVuY3kiLCJhbHQiLCJhc3luYyIsImF1dG9Db21wbGV0ZSIsImF1dG9QbGF5IiwiY2VsbFBhZGRpbmciLCJjZWxsU3BhY2luZyIsImNoYXJTZXQiLCJjaGFsbGVuZ2UiLCJjaGVja2VkIiwiY2xhc3NJRCIsImNsYXNzTmFtZSIsImNvbHMiLCJjb2xTcGFuIiwiY29udGVudCIsImNvbnRlbnRFZGl0YWJsZSIsImNvbnRleHRNZW51IiwiY29udHJvbHMiLCJjb29yZHMiLCJjcm9zc09yaWdpbiIsImRhdGVUaW1lIiwiZGVmZXIiLCJkaXNhYmxlZCIsImRvd25sb2FkIiwiZHJhZ2dhYmxlIiwiZW5jVHlwZSIsImZvcm1BY3Rpb24iLCJmb3JtRW5jVHlwZSIsImZvcm1NZXRob2QiLCJmb3JtTm9WYWxpZGF0ZSIsImZvcm1UYXJnZXQiLCJmcmFtZUJvcmRlciIsImhlYWRlcnMiLCJoZWlnaHQiLCJoaWRkZW4iLCJoaWdoIiwiaHJlZkxhbmciLCJodG1sRm9yIiwiaHR0cEVxdWl2IiwiaWNvbiIsImlucHV0TW9kZSIsImludGVncml0eSIsImtleVBhcmFtcyIsImtleVR5cGUiLCJraW5kIiwibGFuZyIsImxpc3QiLCJsb29wIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW5IZWlnaHQiLCJtYXJnaW5XaWR0aCIsIm1heCIsIm1heExlbmd0aCIsIm1lZGlhIiwibWVkaWFHcm91cCIsIm1pbiIsIm1pbkxlbmd0aCIsIm11bHRpcGxlIiwibXV0ZWQiLCJub25jZSIsIm5vVmFsaWRhdGUiLCJvcGVuIiwib3B0aW11bSIsInBsYWNlaG9sZGVyIiwicG9zdGVyIiwicHJlbG9hZCIsInByb2ZpbGUiLCJyYWRpb0dyb3VwIiwicmVhZE9ubHkiLCJyZWZlcnJlclBvbGljeSIsInJlbCIsInJlcXVpcmVkIiwicmV2ZXJzZWQiLCJyb2xlIiwicm93cyIsInJvd1NwYW4iLCJzYW5kYm94Iiwic2NvcGVkIiwic2Nyb2xsaW5nIiwic2VhbWxlc3MiLCJzZWxlY3RlZCIsInNpemUiLCJzaXplcyIsInNwZWxsQ2hlY2siLCJzcmMiLCJzcmNEb2MiLCJzcmNMYW5nIiwic3JjU2V0IiwidGFiSW5kZXgiLCJ1c2VNYXAiLCJ3aWR0aCIsIndtb2RlIiwid3JhcCIsImFib3V0IiwiZGF0YXR5cGUiLCJpbmxpc3QiLCJyZXNvdXJjZSIsInZvY2FiIiwiYXV0b0NhcGl0YWxpemUiLCJhdXRvQ29ycmVjdCIsImF1dG9TYXZlIiwiY29sb3IiLCJpdGVtUHJvcCIsIml0ZW1TY29wZSIsIml0ZW1UeXBlIiwiaXRlbUlEIiwiaXRlbVJlZiIsInJlc3VsdHMiLCJzZWN1cml0eSIsInVuc2VsZWN0YWJsZSIsIkRPTUNoaWxkcmVuT3BlcmF0aW9ucyIsIlJlYWN0RE9NSURPcGVyYXRpb25zIiwicHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyIsImRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyIsInJlcGxhY2VOb2RlV2l0aE1hcmt1cCIsImRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwIiwiRE9NTGF6eVRyZWUiLCJEYW5nZXIiLCJSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyIsImNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24iLCJzZXRJbm5lckhUTUwiLCJzZXRUZXh0Q29udGVudCIsImdldE5vZGVBZnRlciIsImluc2VydENoaWxkQXQiLCJyZWZlcmVuY2VOb2RlIiwiaW5zZXJ0QmVmb3JlIiwiaW5zZXJ0TGF6eVRyZWVDaGlsZEF0IiwiY2hpbGRUcmVlIiwiaW5zZXJ0VHJlZUJlZm9yZSIsIm1vdmVDaGlsZCIsIm1vdmVEZWxpbWl0ZWRUZXh0IiwicmVtb3ZlQ2hpbGQiLCJjbG9zaW5nQ29tbWVudCIsInJlbW92ZURlbGltaXRlZFRleHQiLCJvcGVuaW5nQ29tbWVudCIsIm5leHROb2RlIiwic3RhcnROb2RlIiwicmVwbGFjZURlbGltaXRlZFRleHQiLCJzdHJpbmdUZXh0Iiwibm9kZUFmdGVyQ29tbWVudCIsImNyZWF0ZVRleHROb2RlIiwib2xkQ2hpbGQiLCJwcmV2SW5zdGFuY2UiLCJuZXh0SW5zdGFuY2UiLCJwcm9jZXNzVXBkYXRlcyIsInVwZGF0ZXMiLCJwYXJlbnROb2RlRGVidWdJRCIsImsiLCJ1cGRhdGUiLCJJTlNFUlRfTUFSS1VQIiwiYWZ0ZXJOb2RlIiwidG9JbmRleCIsIk1PVkVfRVhJU1RJTkciLCJmcm9tSW5kZXgiLCJTRVRfTUFSS1VQIiwiVEVYVF9DT05URU5UIiwiUkVNT1ZFX05PREUiLCJET01OYW1lc3BhY2VzIiwiRUxFTUVOVF9OT0RFX1RZUEUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUiLCJlbmFibGVMYXp5IiwiaW5zZXJ0VHJlZUNoaWxkcmVuIiwibmFtZXNwYWNlVVJJIiwicmVwbGFjZUNoaWxkV2l0aFRyZWUiLCJvbGROb2RlIiwibmV3VHJlZSIsInJlcGxhY2VDaGlsZCIsInF1ZXVlQ2hpbGQiLCJwYXJlbnRUcmVlIiwiYXBwZW5kQ2hpbGQiLCJxdWV1ZUhUTUwiLCJxdWV1ZVRleHQiLCJtYXRobWwiLCJXSElURVNQQUNFX1RFU1QiLCJOT05WSVNJQkxFX1RFU1QiLCJyZXVzYWJsZVNWR0NvbnRhaW5lciIsImlubmVySFRNTCIsIm5ld05vZGVzIiwiY2hpbGROb2RlcyIsInRlc3RFbGVtZW50IiwidGV4dE5vZGUiLCJkZWxldGVEYXRhIiwiTVNBcHAiLCJleGVjVW5zYWZlTG9jYWxGdW5jdGlvbiIsImFyZzAiLCJlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIiLCJsYXN0Q2hpbGQiLCJ0ZXh0Q29udGVudCIsIm1hdGNoSHRtbFJlZ0V4cCIsImVzY2FwZUh0bWwiLCJzdHIiLCJleGVjIiwibGFzdEluZGV4IiwiY2hhckNvZGVBdCIsImNyZWF0ZU5vZGVzRnJvbU1hcmt1cCIsIm5ld0NoaWxkIiwiY3JlYXRlQXJyYXlGcm9tTWl4ZWQiLCJnZXRNYXJrdXBXcmFwIiwiZHVtbXlOb2RlIiwibm9kZU5hbWVQYXR0ZXJuIiwiZ2V0Tm9kZU5hbWUiLCJub2RlTmFtZU1hdGNoIiwiaGFuZGxlU2NyaXB0Iiwid3JhcERlcHRoIiwic2NyaXB0cyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwibm9kZXMiLCJjYWxsZWUiLCJoYXNBcnJheU5hdHVyZSIsInNob3VsZFdyYXAiLCJzZWxlY3RXcmFwIiwidGFibGVXcmFwIiwidHJXcmFwIiwic3ZnV3JhcCIsIm1hcmt1cFdyYXAiLCJzdmdFbGVtZW50cyIsIkF1dG9Gb2N1c1V0aWxzIiwiQ1NTUHJvcGVydHlPcGVyYXRpb25zIiwiRE9NUHJvcGVydHlPcGVyYXRpb25zIiwiUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyIiwiUmVhY3RET01CdXR0b24iLCJSZWFjdERPTUlucHV0IiwiUmVhY3RET01PcHRpb24iLCJSZWFjdERPTVNlbGVjdCIsIlJlYWN0RE9NVGV4dGFyZWEiLCJSZWFjdE11bHRpQ2hpbGQiLCJSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uIiwic2hhbGxvd0VxdWFsIiwidmFsaWRhdGVET01OZXN0aW5nIiwiZ2V0Tm9kZSIsImxpc3RlblRvIiwiQ09OVEVOVF9UWVBFUyIsIlNUWUxFIiwiSFRNTCIsIl9faHRtbCIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiwiRE9DX0ZSQUdNRU5UX1RZUEUiLCJmcmllbmRseVN0cmluZ2lmeSIsImtleUVzY2FwZWQiLCJzdHlsZU11dGF0aW9uV2FybmluZyIsImNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZSIsInN0eWxlMSIsInN0eWxlMiIsIl90YWciLCJoYXNoIiwiYXNzZXJ0VmFsaWRQcm9wcyIsInZvaWRFbGVtZW50VGFncyIsIm9uRm9jdXNJbiIsIm9uRm9jdXNPdXQiLCJlbnF1ZXVlUHV0TGlzdGVuZXIiLCJjb250YWluZXJJbmZvIiwiX2hvc3RDb250YWluZXJJbmZvIiwiaXNEb2N1bWVudEZyYWdtZW50IiwiX25vZGUiLCJfb3duZXJEb2N1bWVudCIsImxpc3RlbmVyVG9QdXQiLCJpbnB1dFBvc3RNb3VudCIsInBvc3RNb3VudFdyYXBwZXIiLCJ0ZXh0YXJlYVBvc3RNb3VudCIsIm9wdGlvblBvc3RNb3VudCIsInNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbiIsImhhc0V4aXN0aW5nQ29udGVudCIsIl9jb250ZW50RGVidWdJRCIsImNvbnRlbnREZWJ1Z0lEIiwibWVkaWFFdmVudHMiLCJ0cmFwQnViYmxlZEV2ZW50c0xvY2FsIiwiX3dyYXBwZXJTdGF0ZSIsImxpc3RlbmVycyIsInRyYXBCdWJibGVkRXZlbnQiLCJwb3N0VXBkYXRlU2VsZWN0V3JhcHBlciIsInBvc3RVcGRhdGVXcmFwcGVyIiwib21pdHRlZENsb3NlVGFncyIsIm5ld2xpbmVFYXRpbmdUYWdzIiwiVkFMSURfVEFHX1JFR0VYIiwidmFsaWRhdGVkVGFnQ2FjaGUiLCJ2YWxpZGF0ZURhbmdlcm91c1RhZyIsInRhZyIsImlzQ3VzdG9tQ29tcG9uZW50IiwidGFnTmFtZSIsImdsb2JhbElkQ291bnRlciIsIl9uYW1lc3BhY2VVUkkiLCJfcHJldmlvdXNTdHlsZSIsIl9wcmV2aW91c1N0eWxlQ29weSIsIl90b3BMZXZlbFdyYXBwZXIiLCJfYW5jZXN0b3JJbmZvIiwiX2lkQ291bnRlciIsImdldEhvc3RQcm9wcyIsIm1vdW50V3JhcHBlciIsInBhcmVudFRhZyIsInBhcmVudEluZm8iLCJ1cGRhdGVkQW5jZXN0b3JJbmZvIiwibW91bnRJbWFnZSIsInVzZUNyZWF0ZUVsZW1lbnQiLCJlbCIsImNyZWF0ZUVsZW1lbnROUyIsInNldEF0dHJpYnV0ZUZvclJvb3QiLCJfdXBkYXRlRE9NUHJvcGVydGllcyIsImxhenlUcmVlIiwiX2NyZWF0ZUluaXRpYWxDaGlsZHJlbiIsInRhZ09wZW4iLCJfY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyIsInRhZ0NvbnRlbnQiLCJfY3JlYXRlQ29udGVudE1hcmt1cCIsImF1dG9Gb2N1cyIsImZvY3VzRE9NQ29tcG9uZW50IiwicHJvcEtleSIsImNyZWF0ZU1hcmt1cEZvclN0eWxlcyIsImNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZSIsImNyZWF0ZU1hcmt1cEZvclByb3BlcnR5IiwicmVuZGVyVG9TdGF0aWNNYXJrdXAiLCJjcmVhdGVNYXJrdXBGb3JSb290IiwiY3JlYXRlTWFya3VwRm9ySUQiLCJjb250ZW50VG9Vc2UiLCJjaGlsZHJlblRvVXNlIiwibW91bnRJbWFnZXMiLCJtb3VudENoaWxkcmVuIiwiY2hhckF0IiwibGFzdFByb3BzIiwibmV4dFByb3BzIiwiX3VwZGF0ZURPTUNoaWxkcmVuIiwidXBkYXRlV3JhcHBlciIsInN0eWxlTmFtZSIsInN0eWxlVXBkYXRlcyIsImxhc3RTdHlsZSIsImRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlIiwiZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSIsIm5leHRQcm9wIiwibGFzdFByb3AiLCJzZXRWYWx1ZUZvckF0dHJpYnV0ZSIsInNldFZhbHVlRm9yUHJvcGVydHkiLCJzZXRWYWx1ZUZvclN0eWxlcyIsImxhc3RDb250ZW50IiwibmV4dENvbnRlbnQiLCJsYXN0SHRtbCIsIm5leHRIdG1sIiwibGFzdENoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwibGFzdEhhc0NvbnRlbnRPckh0bWwiLCJuZXh0SGFzQ29udGVudE9ySHRtbCIsInVwZGF0ZUNoaWxkcmVuIiwidXBkYXRlVGV4dENvbnRlbnQiLCJ1cGRhdGVNYXJrdXAiLCJ1bm1vdW50Q2hpbGRyZW4iLCJmb2N1c05vZGUiLCJmb2N1cyIsIkNTU1Byb3BlcnR5IiwiY2FtZWxpemVTdHlsZU5hbWUiLCJkYW5nZXJvdXNTdHlsZVZhbHVlIiwiaHlwaGVuYXRlU3R5bGVOYW1lIiwibWVtb2l6ZVN0cmluZ09ubHkiLCJwcm9jZXNzU3R5bGVOYW1lIiwiaGFzU2hvcnRoYW5kUHJvcGVydHlCdWciLCJzdHlsZUZsb2F0QWNjZXNzb3IiLCJ0ZW1wU3R5bGUiLCJmb250IiwiY3NzRmxvYXQiLCJiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4iLCJiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4iLCJ3YXJuZWRTdHlsZU5hbWVzIiwid2FybmVkU3R5bGVWYWx1ZXMiLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsIndhcm5IeXBoZW5hdGVkU3R5bGVOYW1lIiwiY2hlY2tSZW5kZXJNZXNzYWdlIiwid2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lIiwidG9VcHBlckNhc2UiLCJ3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24iLCJ3YXJuU3R5bGVWYWx1ZUlzTmFOIiwid2FyblZhbGlkU3R5bGUiLCJpc05hTiIsInN0eWxlcyIsInNlcmlhbGl6ZWQiLCJzdHlsZVZhbHVlIiwiZXhwYW5zaW9uIiwic2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zIiwiaW5kaXZpZHVhbFN0eWxlTmFtZSIsImlzVW5pdGxlc3NOdW1iZXIiLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImJvcmRlckltYWdlT3V0c2V0IiwiYm9yZGVySW1hZ2VTbGljZSIsImJvcmRlckltYWdlV2lkdGgiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJmbGV4IiwiZmxleEdyb3ciLCJmbGV4UG9zaXRpdmUiLCJmbGV4U2hyaW5rIiwiZmxleE5lZ2F0aXZlIiwiZmxleE9yZGVyIiwiZ3JpZFJvdyIsImdyaWRDb2x1bW4iLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsInByZWZpeEtleSIsInByZWZpeGVzIiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRBdHRhY2htZW50IiwiYmFja2dyb3VuZENvbG9yIiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZFBvc2l0aW9uWCIsImJhY2tncm91bmRQb3NpdGlvblkiLCJiYWNrZ3JvdW5kUmVwZWF0IiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYm9yZGVyIiwiYm9yZGVyV2lkdGgiLCJib3JkZXJTdHlsZSIsImJvcmRlckNvbG9yIiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJib3JkZXJCb3R0b21TdHlsZSIsImJvcmRlckJvdHRvbUNvbG9yIiwiYm9yZGVyTGVmdCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlckxlZnRTdHlsZSIsImJvcmRlckxlZnRDb2xvciIsImJvcmRlclJpZ2h0IiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlclJpZ2h0U3R5bGUiLCJib3JkZXJSaWdodENvbG9yIiwiYm9yZGVyVG9wIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJUb3BTdHlsZSIsImJvcmRlclRvcENvbG9yIiwiZm9udFN0eWxlIiwiZm9udFZhcmlhbnQiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJvdXRsaW5lIiwib3V0bGluZVdpZHRoIiwib3V0bGluZVN0eWxlIiwib3V0bGluZUNvbG9yIiwiY2FtZWxpemUiLCJtc1BhdHRlcm4iLCJfaHlwaGVuUGF0dGVybiIsIl8iLCJjaGFyYWN0ZXIiLCJzdHlsZVdhcm5pbmdzIiwiaXNFbXB0eSIsImlzTm9uTnVtZXJpYyIsIndhcm5pbmdzIiwiaHlwaGVuYXRlIiwiX3VwcGVyY2FzZVBhdHRlcm4iLCJjYWNoZSIsInF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwidmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlIiwiaXNBdHRyaWJ1dGVOYW1lU2FmZSIsInNob3VsZElnbm9yZVZhbHVlIiwic2V0QXR0cmlidXRlRm9ySUQiLCJuYW1lc3BhY2UiLCJzZXRBdHRyaWJ1dGVOUyIsInJlbW92ZUF0dHJpYnV0ZSIsIlJlYWN0RXZlbnRFbWl0dGVyTWl4aW4iLCJnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSIsImhhc0V2ZW50UGFnZVhZIiwiYWxyZWFkeUxpc3RlbmluZ1RvIiwiaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUiLCJyZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIiLCJ0b3BFdmVudE1hcHBpbmciLCJ0b3BMaXN0ZW5lcnNJREtleSIsImdldExpc3RlbmluZ0ZvckRvY3VtZW50IiwibW91bnRBdCIsInNldEhhbmRsZVRvcExldmVsIiwiaGFuZGxlVG9wTGV2ZWwiLCJzZXRFbmFibGVkIiwiZW5hYmxlZCIsImlzRW5hYmxlZCIsImNvbnRlbnREb2N1bWVudEhhbmRsZSIsImlzTGlzdGVuaW5nIiwiZGVwZW5kZW5jeSIsInRyYXBDYXB0dXJlZEV2ZW50IiwiV0lORE9XX0hBTkRMRSIsImhhbmRsZXJCYXNlTmFtZSIsImhhbmRsZSIsImVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZyIsInJlZnJlc2giLCJtb25pdG9yU2Nyb2xsVmFsdWUiLCJydW5FdmVudFF1ZXVlSW5CYXRjaCIsIm1ha2VQcmVmaXhNYXAiLCJzdHlsZVByb3AiLCJ2ZW5kb3JQcmVmaXhlcyIsImFuaW1hdGlvbmVuZCIsImFuaW1hdGlvbml0ZXJhdGlvbiIsImFuaW1hdGlvbnN0YXJ0IiwidHJhbnNpdGlvbmVuZCIsInByZWZpeGVkRXZlbnROYW1lcyIsImFuaW1hdGlvbiIsInRyYW5zaXRpb24iLCJwcmVmaXhNYXAiLCJEaXNhYmxlZElucHV0VXRpbHMiLCJkaXNhYmxlYWJsZU1vdXNlTGlzdGVuZXJOYW1lcyIsIm9uQ2xpY2siLCJvbkRvdWJsZUNsaWNrIiwib25Nb3VzZURvd24iLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VVcCIsIm9uQ2xpY2tDYXB0dXJlIiwib25Eb3VibGVDbGlja0NhcHR1cmUiLCJvbk1vdXNlRG93bkNhcHR1cmUiLCJvbk1vdXNlTW92ZUNhcHR1cmUiLCJvbk1vdXNlVXBDYXB0dXJlIiwiaG9zdFByb3BzIiwiTGlua2VkVmFsdWVVdGlscyIsImRpZFdhcm5WYWx1ZUxpbmsiLCJkaWRXYXJuQ2hlY2tlZExpbmsiLCJkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUiLCJkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkIiwiZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCIsImRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQiLCJmb3JjZVVwZGF0ZUlmTW91bnRlZCIsImlzQ29udHJvbGxlZCIsInVzZXNDaGVja2VkIiwiZ2V0VmFsdWUiLCJnZXRDaGVja2VkIiwiZGVmYXVsdENoZWNrZWQiLCJkZWZhdWx0VmFsdWUiLCJpbml0aWFsVmFsdWUiLCJpbml0aWFsQ2hlY2tlZCIsImNoZWNrUHJvcFR5cGVzIiwidmFsdWVMaW5rIiwiY2hlY2tlZExpbmsiLCJfaGFuZGxlQ2hhbmdlIiwiY29udHJvbGxlZCIsIm5ld1ZhbHVlIiwiZXhlY3V0ZU9uQ2hhbmdlIiwicm9vdE5vZGUiLCJxdWVyeVJvb3QiLCJncm91cCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJvdGhlck5vZGUiLCJvdGhlckluc3RhbmNlIiwiaGFzUmVhZE9ubHlWYWx1ZSIsIl9hc3NlcnRTaW5nbGVMaW5rIiwiaW5wdXRQcm9wcyIsIl9hc3NlcnRWYWx1ZUxpbmsiLCJfYXNzZXJ0Q2hlY2tlZExpbmsiLCJyZXF1ZXN0Q2hhbmdlIiwiZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiIsImZsYXR0ZW5DaGlsZHJlbiIsInNlbGVjdFZhbHVlIiwic2VsZWN0UGFyZW50IiwiZ2V0U2VsZWN0VmFsdWVDb250ZXh0IiwidXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQiLCJwZW5kaW5nVXBkYXRlIiwidXBkYXRlT3B0aW9ucyIsIkJvb2xlYW4iLCJ2YWx1ZVByb3BOYW1lcyIsImNoZWNrU2VsZWN0UHJvcFR5cGVzIiwic2VsZWN0ZWRWYWx1ZSIsIm9wdGlvbnMiLCJ3YXNNdWx0aXBsZSIsImRpZFdhcm5WYWxEZWZhdWx0VmFsIiwiUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCIsIlJlYWN0SW5zdGFuY2VNYXAiLCJSZWFjdENoaWxkUmVjb25jaWxlciIsIm1ha2VJbnNlcnRNYXJrdXAiLCJtYWtlTW92ZSIsIl9tb3VudEluZGV4IiwibWFrZVJlbW92ZSIsIm1ha2VTZXRNYXJrdXAiLCJtYWtlVGV4dENvbnRlbnQiLCJwcm9jZXNzUXVldWUiLCJ1cGRhdGVRdWV1ZSIsInNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uIiwiZ2V0RGVidWdJRCIsImludGVybmFsIiwiX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuIiwibmVzdGVkQ2hpbGRyZW4iLCJzZWxmRGVidWdJRCIsImluc3RhbnRpYXRlQ2hpbGRyZW4iLCJfcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuIiwicHJldkNoaWxkcmVuIiwibmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMiLCJyZW1vdmVkTm9kZXMiLCJuZXh0TWFya3VwIiwiX3VwZGF0ZUNoaWxkcmVuIiwibmV4dEluZGV4IiwibmV4dE1vdW50SW5kZXgiLCJsYXN0UGxhY2VkTm9kZSIsInByZXZDaGlsZCIsIl9tb3VudENoaWxkQXRJbmRleCIsIl91bm1vdW50Q2hpbGQiLCJyZW5kZXJlZENoaWxkcmVuIiwiY3JlYXRlQ2hpbGQiLCJpbmplY3RlZCIsImVudmlyb25tZW50IiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsImhhcyIsImluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQiLCJzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCIsImluc3RhbnRpYXRlQ2hpbGQiLCJjaGlsZEluc3RhbmNlcyIsImtleVVuaXF1ZSIsIm5lc3RlZENoaWxkTm9kZXMiLCJjaGlsZEluc3RzIiwibmV4dENoaWxkSW5zdGFuY2UiLCJuZXh0Q2hpbGRNb3VudEltYWdlIiwicmVuZGVyZWRDaGlsZCIsIlJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IiwiUmVhY3RFbXB0eUNvbXBvbmVudCIsIlJlYWN0SG9zdENvbXBvbmVudCIsIlJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciIsIl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IiwiaXNJbnRlcm5hbENvbXBvbmVudFR5cGUiLCJuZXh0RGVidWdJRCIsInNob3VsZEhhdmVEZWJ1Z0lEIiwiY3JlYXRlSW50ZXJuYWxDb21wb25lbnQiLCJnZXROYXRpdmVOb2RlIiwiY3JlYXRlSW5zdGFuY2VGb3JUZXh0IiwiX21vdW50SW1hZ2UiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsIlJlYWN0Tm9kZVR5cGVzIiwiQ29tcG9zaXRlVHlwZXMiLCJJbXB1cmVDbGFzcyIsIlB1cmVDbGFzcyIsIlN0YXRlbGVzc0Z1bmN0aW9uYWwiLCJTdGF0ZWxlc3NDb21wb25lbnQiLCJ3YXJuSWZJbnZhbGlkRWxlbWVudCIsImludm9rZUNvbXBvbmVudERpZE1vdW50V2l0aFRpbWVyIiwiX2luc3RhbmNlIiwiaW52b2tlQ29tcG9uZW50RGlkVXBkYXRlV2l0aFRpbWVyIiwicHJldlByb3BzIiwicHJldlN0YXRlIiwicHJldkNvbnRleHQiLCJzaG91bGRDb25zdHJ1Y3QiLCJpc1B1cmVDb21wb25lbnQiLCJuZXh0TW91bnRJRCIsIlJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4iLCJfY29tcG9zaXRlVHlwZSIsIl9wZW5kaW5nRWxlbWVudCIsIl9wZW5kaW5nU3RhdGVRdWV1ZSIsIl9wZW5kaW5nUmVwbGFjZVN0YXRlIiwiX3BlbmRpbmdGb3JjZVVwZGF0ZSIsIl9yZW5kZXJlZE5vZGVUeXBlIiwiX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50IiwiX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyIiwicHVibGljUHJvcHMiLCJwdWJsaWNDb250ZXh0IiwiX3Byb2Nlc3NDb250ZXh0IiwiZ2V0VXBkYXRlUXVldWUiLCJkb0NvbnN0cnVjdCIsIl9jb25zdHJ1Y3RDb21wb25lbnQiLCJyZW5kZXJlZEVsZW1lbnQiLCJwcm9wc011dGF0ZWQiLCJjb21wb25lbnREaWRVbm1vdW50IiwidW5zdGFibGVfaGFuZGxlRXJyb3IiLCJwZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmciLCJwZXJmb3JtSW5pdGlhbE1vdW50IiwiX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lciIsImluc3RhbmNlT3JFbGVtZW50IiwiX3Byb2Nlc3NQZW5kaW5nU3RhdGUiLCJfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50IiwiZ2V0VHlwZSIsIkVNUFRZIiwiX3Byb2Nlc3NDaGlsZENvbnRleHQiLCJfbWFza0NvbnRleHQiLCJtYXNrZWRDb250ZXh0IiwiY29udGV4dE5hbWUiLCJfY2hlY2tDb250ZXh0VHlwZXMiLCJjdXJyZW50Q29udGV4dCIsIm5leHRDb250ZXh0IiwicHJldlBhcmVudEVsZW1lbnQiLCJuZXh0UGFyZW50RWxlbWVudCIsInByZXZVbm1hc2tlZENvbnRleHQiLCJuZXh0VW5tYXNrZWRDb250ZXh0Iiwid2lsbFJlY2VpdmUiLCJuZXh0U3RhdGUiLCJzaG91bGRVcGRhdGUiLCJfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZSIsInBhcnRpYWwiLCJ1bm1hc2tlZENvbnRleHQiLCJoYXNDb21wb25lbnREaWRVcGRhdGUiLCJfdXBkYXRlUmVuZGVyZWRDb21wb25lbnQiLCJwcmV2Q29tcG9uZW50SW5zdGFuY2UiLCJwcmV2UmVuZGVyZWRFbGVtZW50IiwibmV4dFJlbmRlcmVkRWxlbWVudCIsIm9sZEhvc3ROb2RlIiwiX3JlcGxhY2VOb2RlV2l0aE1hcmt1cCIsIl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQiLCJyZW5kZXJlZENvbXBvbmVudCIsInB1YmxpY0NvbXBvbmVudEluc3RhbmNlIiwiSE9TVCIsIkNPTVBPU0lURSIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzQiIsInByZXZUeXBlIiwibmV4dFR5cGUiLCJlbXB0eUNvbXBvbmVudEZhY3RvcnkiLCJSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uIiwiZ2VuZXJpY0NvbXBvbmVudENsYXNzIiwidGFnVG9Db21wb25lbnRDbGFzcyIsInRleHRDb21wb25lbnRDbGFzcyIsIlJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvbiIsImluamVjdENvbXBvbmVudENsYXNzZXMiLCJjb21wb25lbnRDbGFzc2VzIiwiaXNUZXh0Q29tcG9uZW50IiwiZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlIiwibm9vcENhbGxiYWNrUXVldWUiLCJfY2xhc3NDYWxsQ2hlY2siLCJSZWFjdFVwZGF0ZVF1ZXVlIiwiZm9ybWF0VW5leHBlY3RlZEFyZ3VtZW50IiwiZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlIiwiY3RvciIsInZhbGlkYXRlQ2FsbGJhY2siLCJlbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbCIsImVucXVldWVFbGVtZW50SW50ZXJuYWwiLCJzcGVjaWFsVGFncyIsImluU2NvcGVUYWdzIiwiYnV0dG9uU2NvcGVUYWdzIiwiaW1wbGllZEVuZFRhZ3MiLCJlbXB0eUFuY2VzdG9ySW5mbyIsImZvcm1UYWciLCJhVGFnSW5TY29wZSIsImJ1dHRvblRhZ0luU2NvcGUiLCJub2JyVGFnSW5TY29wZSIsInBUYWdJbkJ1dHRvblNjb3BlIiwibGlzdEl0ZW1UYWdBdXRvY2xvc2luZyIsImRsSXRlbVRhZ0F1dG9jbG9zaW5nIiwib2xkSW5mbyIsImFuY2VzdG9ySW5mbyIsImlzVGFnVmFsaWRXaXRoUGFyZW50IiwiZmluZEludmFsaWRBbmNlc3RvckZvclRhZyIsImZpbmRPd25lclN0YWNrIiwicmV2ZXJzZSIsImRpZFdhcm4iLCJjaGlsZFRhZyIsImNoaWxkSW5zdGFuY2UiLCJpbnZhbGlkUGFyZW50IiwiaW52YWxpZEFuY2VzdG9yIiwicHJvYmxlbWF0aWMiLCJhbmNlc3RvclRhZyIsImFuY2VzdG9ySW5zdGFuY2UiLCJhbmNlc3Rvck93bmVyIiwiY2hpbGRPd25lcnMiLCJhbmNlc3Rvck93bmVycyIsIm1pblN0YWNrTGVuIiwiZGVlcGVzdENvbW1vbiIsIlVOS05PV04iLCJjaGlsZE93bmVyTmFtZXMiLCJhbmNlc3Rvck93bmVyTmFtZXMiLCJvd25lckluZm8iLCJ3YXJuS2V5IiwidGFnRGlzcGxheU5hbWUiLCJpc1RhZ1ZhbGlkSW5Db250ZXh0IiwiZG9tSUQiLCJjcmVhdGVDb21tZW50IiwiaW5zdEEiLCJpbnN0QiIsImRlcHRoQSIsInRlbXBBIiwiZGVwdGhCIiwidGVtcEIiLCJkZXB0aCIsImNvbW1vbiIsInBhdGhGcm9tIiwicGF0aFRvIiwiX3N0cmluZ1RleHQiLCJfY2xvc2luZ0NvbW1lbnQiLCJfY29tbWVudE5vZGVzIiwib3BlbmluZ1ZhbHVlIiwiY2xvc2luZ1ZhbHVlIiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImVzY2FwZWRUZXh0IiwibmV4dFRleHQiLCJuZXh0U3RyaW5nVGV4dCIsImNvbW1lbnROb2RlcyIsImhvc3ROb2RlIiwiUkVTRVRfQkFUQ0hFRF9VUERBVEVTIiwiRkxVU0hfQkFUQ0hFRF9VUERBVEVTIiwiUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uIiwiYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyIsIkV2ZW50TGlzdGVuZXIiLCJnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbiIsImZpbmRQYXJlbnQiLCJjb250YWluZXIiLCJUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmciLCJhbmNlc3RvcnMiLCJoYW5kbGVUb3BMZXZlbEltcGwiLCJhbmNlc3RvciIsIl9oYW5kbGVUb3BMZXZlbCIsInNjcm9sbFZhbHVlTW9uaXRvciIsIl9lbmFibGVkIiwibGlzdGVuIiwicmVnaXN0ZXJEZWZhdWx0Iiwic2Nyb2xsYWJsZSIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsTGVmdCIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwiUmVhY3RJbnB1dFNlbGVjdGlvbiIsIlNFTEVDVElPTl9SRVNUT1JBVElPTiIsImdldFNlbGVjdGlvbkluZm9ybWF0aW9uIiwicmVzdG9yZVNlbGVjdGlvbiIsIkVWRU5UX1NVUFBSRVNTSU9OIiwiY3VycmVudGx5RW5hYmxlZCIsInByZXZpb3VzbHlFbmFibGVkIiwiT05fRE9NX1JFQURZX1FVRVVFSU5HIiwicmVhY3RNb3VudFJlYWR5IiwiUmVhY3RET01TZWxlY3Rpb24iLCJjb250YWluc05vZGUiLCJnZXRBY3RpdmVFbGVtZW50IiwiaXNJbkRvY3VtZW50IiwiaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzIiwiZm9jdXNlZEVsZW0iLCJzZWxlY3Rpb25SYW5nZSIsImdldFNlbGVjdGlvbiIsInByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24iLCJjdXJGb2N1c2VkRWxlbSIsInByaW9yRm9jdXNlZEVsZW0iLCJwcmlvclNlbGVjdGlvblJhbmdlIiwic2V0U2VsZWN0aW9uIiwic2VsZWN0aW9uIiwic2VsZWN0aW9uU3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJyYW5nZSIsImNyZWF0ZVJhbmdlIiwicGFyZW50RWxlbWVudCIsIm1vdmVTdGFydCIsIm1vdmVFbmQiLCJnZXRPZmZzZXRzIiwib2Zmc2V0cyIsImNyZWF0ZVRleHRSYW5nZSIsImNvbGxhcHNlIiwic2V0T2Zmc2V0cyIsImdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQiLCJpc0NvbGxhcHNlZCIsImFuY2hvck5vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c09mZnNldCIsImdldElFT2Zmc2V0cyIsInNlbGVjdGVkUmFuZ2UiLCJzZWxlY3RlZExlbmd0aCIsImZyb21TdGFydCIsImR1cGxpY2F0ZSIsIm1vdmVUb0VsZW1lbnRUZXh0Iiwic2V0RW5kUG9pbnQiLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsImdldE1vZGVybk9mZnNldHMiLCJyYW5nZUNvdW50IiwiY3VycmVudFJhbmdlIiwiZ2V0UmFuZ2VBdCIsInN0YXJ0Q29udGFpbmVyIiwiZW5kQ29udGFpbmVyIiwiaXNTZWxlY3Rpb25Db2xsYXBzZWQiLCJyYW5nZUxlbmd0aCIsInRlbXBSYW5nZSIsImNsb25lUmFuZ2UiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJzZXRFbmQiLCJpc1RlbXBSYW5nZUNvbGxhcHNlZCIsImRldGVjdGlvblJhbmdlIiwic2V0U3RhcnQiLCJpc0JhY2t3YXJkIiwiY29sbGFwc2VkIiwic2V0SUVPZmZzZXRzIiwic2V0TW9kZXJuT2Zmc2V0cyIsImV4dGVuZCIsInRlbXAiLCJzdGFydE1hcmtlciIsImVuZE1hcmtlciIsIm9mZnNldCIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwidXNlSUVPZmZzZXRzIiwiZ2V0TGVhZk5vZGUiLCJnZXRTaWJsaW5nTm9kZSIsIm5vZGVTdGFydCIsIm5vZGVFbmQiLCJpc1RleHROb2RlIiwib3V0ZXJOb2RlIiwiaW5uZXJOb2RlIiwiY29udGFpbnMiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsIk5vZGUiLCJOUyIsInhsaW5rIiwieG1sIiwiQVRUUlMiLCJhY2NlbnRIZWlnaHQiLCJhY2N1bXVsYXRlIiwiYWRkaXRpdmUiLCJhbGlnbm1lbnRCYXNlbGluZSIsImFsbG93UmVvcmRlciIsImFscGhhYmV0aWMiLCJhbXBsaXR1ZGUiLCJhcmFiaWNGb3JtIiwiYXNjZW50IiwiYXR0cmlidXRlVHlwZSIsImF1dG9SZXZlcnNlIiwiYXppbXV0aCIsImJhc2VGcmVxdWVuY3kiLCJiYXNlUHJvZmlsZSIsImJhc2VsaW5lU2hpZnQiLCJiYm94IiwiYmVnaW4iLCJiaWFzIiwiYnkiLCJjYWxjTW9kZSIsImNhcEhlaWdodCIsImNsaXAiLCJjbGlwUnVsZSIsImNsaXBQYXRoVW5pdHMiLCJjb2xvckludGVycG9sYXRpb24iLCJjb2xvckludGVycG9sYXRpb25GaWx0ZXJzIiwiY29sb3JQcm9maWxlIiwiY29sb3JSZW5kZXJpbmciLCJjb250ZW50U2NyaXB0VHlwZSIsImNvbnRlbnRTdHlsZVR5cGUiLCJjdXJzb3IiLCJjeCIsImN5IiwiZGVjZWxlcmF0ZSIsImRlc2NlbnQiLCJkaWZmdXNlQ29uc3RhbnQiLCJkaXJlY3Rpb24iLCJkaXNwbGF5IiwiZGl2aXNvciIsImRvbWluYW50QmFzZWxpbmUiLCJkdXIiLCJkeCIsImR5IiwiZWRnZU1vZGUiLCJlbGV2YXRpb24iLCJlbmFibGVCYWNrZ3JvdW5kIiwiZXhwb25lbnQiLCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkIiwiZmlsbCIsImZpbGxSdWxlIiwiZmlsdGVyIiwiZmlsdGVyUmVzIiwiZmlsdGVyVW5pdHMiLCJmbG9vZENvbG9yIiwiZm9jdXNhYmxlIiwiZm9udFNpemVBZGp1c3QiLCJmb250U3RyZXRjaCIsImZ4IiwiZnkiLCJnMSIsImcyIiwiZ2x5cGhOYW1lIiwiZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwiLCJnbHlwaE9yaWVudGF0aW9uVmVydGljYWwiLCJnbHlwaFJlZiIsImdyYWRpZW50VHJhbnNmb3JtIiwiZ3JhZGllbnRVbml0cyIsImhhbmdpbmciLCJob3JpekFkdlgiLCJob3Jpek9yaWdpblgiLCJpZGVvZ3JhcGhpYyIsImltYWdlUmVuZGVyaW5nIiwiaW4yIiwiaW50ZXJjZXB0IiwiazEiLCJrMiIsImszIiwiazQiLCJrZXJuZWxNYXRyaXgiLCJrZXJuZWxVbml0TGVuZ3RoIiwia2VybmluZyIsImtleVBvaW50cyIsImtleVNwbGluZXMiLCJrZXlUaW1lcyIsImxlbmd0aEFkanVzdCIsImxldHRlclNwYWNpbmciLCJsaWdodGluZ0NvbG9yIiwibGltaXRpbmdDb25lQW5nbGUiLCJsb2NhbCIsIm1hcmtlckVuZCIsIm1hcmtlck1pZCIsIm1hcmtlclN0YXJ0IiwibWFya2VySGVpZ2h0IiwibWFya2VyVW5pdHMiLCJtYXJrZXJXaWR0aCIsIm1hc2tDb250ZW50VW5pdHMiLCJtYXNrVW5pdHMiLCJtYXRoZW1hdGljYWwiLCJtb2RlIiwibnVtT2N0YXZlcyIsIm9wZXJhdG9yIiwib3JpZW50Iiwib3JpZW50YXRpb24iLCJvcmlnaW4iLCJvdmVyZmxvdyIsIm92ZXJsaW5lUG9zaXRpb24iLCJvdmVybGluZVRoaWNrbmVzcyIsInBhaW50T3JkZXIiLCJwYW5vc2UxIiwicGF0aExlbmd0aCIsInBhdHRlcm5Db250ZW50VW5pdHMiLCJwYXR0ZXJuVHJhbnNmb3JtIiwicGF0dGVyblVuaXRzIiwicG9pbnRlckV2ZW50cyIsInBvaW50cyIsInBvaW50c0F0WCIsInBvaW50c0F0WSIsInBvaW50c0F0WiIsInByZXNlcnZlQWxwaGEiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwicHJpbWl0aXZlVW5pdHMiLCJyIiwicmFkaXVzIiwicmVmWCIsInJlZlkiLCJyZW5kZXJpbmdJbnRlbnQiLCJyZXBlYXRDb3VudCIsInJlcGVhdER1ciIsInJlcXVpcmVkRXh0ZW5zaW9ucyIsInJlcXVpcmVkRmVhdHVyZXMiLCJyZXN0YXJ0Iiwicm90YXRlIiwicngiLCJyeSIsInNjYWxlIiwic2VlZCIsInNoYXBlUmVuZGVyaW5nIiwic2xvcGUiLCJzcGFjaW5nIiwic3BlY3VsYXJDb25zdGFudCIsInNwZWN1bGFyRXhwb25lbnQiLCJzcGVlZCIsInNwcmVhZE1ldGhvZCIsInN0ZERldmlhdGlvbiIsInN0ZW1oIiwic3RlbXYiLCJzdGl0Y2hUaWxlcyIsInN0b3BDb2xvciIsInN0cmlrZXRocm91Z2hQb3NpdGlvbiIsInN0cmlrZXRocm91Z2hUaGlja25lc3MiLCJzdHJva2UiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iLCJzdXJmYWNlU2NhbGUiLCJzeXN0ZW1MYW5ndWFnZSIsInRhYmxlVmFsdWVzIiwidGFyZ2V0WCIsInRhcmdldFkiLCJ0ZXh0QW5jaG9yIiwidGV4dERlY29yYXRpb24iLCJ0ZXh0UmVuZGVyaW5nIiwidGV4dExlbmd0aCIsInRyYW5zZm9ybSIsInUxIiwidTIiLCJ1bmRlcmxpbmVQb3NpdGlvbiIsInVuZGVybGluZVRoaWNrbmVzcyIsInVuaWNvZGUiLCJ1bmljb2RlQmlkaSIsInVuaWNvZGVSYW5nZSIsInVuaXRzUGVyRW0iLCJ2QWxwaGFiZXRpYyIsInZIYW5naW5nIiwidklkZW9ncmFwaGljIiwidk1hdGhlbWF0aWNhbCIsInZlY3RvckVmZmVjdCIsInZlcnRBZHZZIiwidmVydE9yaWdpblgiLCJ2ZXJ0T3JpZ2luWSIsInZpZXdCb3giLCJ2aWV3VGFyZ2V0IiwidmlzaWJpbGl0eSIsIndpZHRocyIsIndvcmRTcGFjaW5nIiwid3JpdGluZ01vZGUiLCJ4SGVpZ2h0IiwieDEiLCJ4MiIsInhDaGFubmVsU2VsZWN0b3IiLCJ4bGlua0FjdHVhdGUiLCJ4bGlua0FyY3JvbGUiLCJ4bGlua0hyZWYiLCJ4bGlua1JvbGUiLCJ4bGlua1Nob3ciLCJ4bGlua1RpdGxlIiwieGxpbmtUeXBlIiwieG1sQmFzZSIsInhtbG5zIiwieG1sbnNYbGluayIsInhtbExhbmciLCJ4bWxTcGFjZSIsInkxIiwieTIiLCJ5Q2hhbm5lbFNlbGVjdG9yIiwieiIsInpvb21BbmRQYW4iLCJza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQiLCJvblNlbGVjdCIsIm9uU2VsZWN0Q2FwdHVyZSIsImxhc3RTZWxlY3Rpb24iLCJtb3VzZURvd24iLCJoYXNMaXN0ZW5lciIsIk9OX1NFTEVDVF9LRVkiLCJib3VuZGluZ1RvcCIsImxlZnQiLCJib3VuZGluZ0xlZnQiLCJjb25zdHJ1Y3RTZWxlY3RFdmVudCIsImN1cnJlbnRTZWxlY3Rpb24iLCJTeW50aGV0aWNBbmltYXRpb25FdmVudCIsIlN5bnRoZXRpY0NsaXBib2FyZEV2ZW50IiwiU3ludGhldGljRm9jdXNFdmVudCIsIlN5bnRoZXRpY0tleWJvYXJkRXZlbnQiLCJTeW50aGV0aWNEcmFnRXZlbnQiLCJTeW50aGV0aWNUb3VjaEV2ZW50IiwiU3ludGhldGljVHJhbnNpdGlvbkV2ZW50IiwiU3ludGhldGljV2hlZWxFdmVudCIsImdldEV2ZW50Q2hhckNvZGUiLCJhYm9ydCIsIm9uQWJvcnQiLCJvbkFib3J0Q2FwdHVyZSIsImFuaW1hdGlvbkVuZCIsIm9uQW5pbWF0aW9uRW5kIiwib25BbmltYXRpb25FbmRDYXB0dXJlIiwiYW5pbWF0aW9uSXRlcmF0aW9uIiwib25BbmltYXRpb25JdGVyYXRpb24iLCJvbkFuaW1hdGlvbkl0ZXJhdGlvbkNhcHR1cmUiLCJhbmltYXRpb25TdGFydCIsIm9uQW5pbWF0aW9uU3RhcnQiLCJvbkFuaW1hdGlvblN0YXJ0Q2FwdHVyZSIsImJsdXIiLCJvbkJsdXIiLCJvbkJsdXJDYXB0dXJlIiwiY2FuUGxheSIsIm9uQ2FuUGxheSIsIm9uQ2FuUGxheUNhcHR1cmUiLCJjYW5QbGF5VGhyb3VnaCIsIm9uQ2FuUGxheVRocm91Z2giLCJvbkNhblBsYXlUaHJvdWdoQ2FwdHVyZSIsImNsaWNrIiwib25Db250ZXh0TWVudSIsIm9uQ29udGV4dE1lbnVDYXB0dXJlIiwiY29weSIsIm9uQ29weSIsIm9uQ29weUNhcHR1cmUiLCJjdXQiLCJvbkN1dCIsIm9uQ3V0Q2FwdHVyZSIsImRvdWJsZUNsaWNrIiwiZHJhZyIsIm9uRHJhZyIsIm9uRHJhZ0NhcHR1cmUiLCJkcmFnRW5kIiwib25EcmFnRW5kIiwib25EcmFnRW5kQ2FwdHVyZSIsImRyYWdFbnRlciIsIm9uRHJhZ0VudGVyIiwib25EcmFnRW50ZXJDYXB0dXJlIiwiZHJhZ0V4aXQiLCJvbkRyYWdFeGl0Iiwib25EcmFnRXhpdENhcHR1cmUiLCJkcmFnTGVhdmUiLCJvbkRyYWdMZWF2ZSIsIm9uRHJhZ0xlYXZlQ2FwdHVyZSIsImRyYWdPdmVyIiwib25EcmFnT3ZlciIsIm9uRHJhZ092ZXJDYXB0dXJlIiwiZHJhZ1N0YXJ0Iiwib25EcmFnU3RhcnQiLCJvbkRyYWdTdGFydENhcHR1cmUiLCJkcm9wIiwib25Ecm9wIiwib25Ecm9wQ2FwdHVyZSIsImR1cmF0aW9uQ2hhbmdlIiwib25EdXJhdGlvbkNoYW5nZSIsIm9uRHVyYXRpb25DaGFuZ2VDYXB0dXJlIiwiZW1wdGllZCIsIm9uRW1wdGllZCIsIm9uRW1wdGllZENhcHR1cmUiLCJlbmNyeXB0ZWQiLCJvbkVuY3J5cHRlZCIsIm9uRW5jcnlwdGVkQ2FwdHVyZSIsImVuZGVkIiwib25FbmRlZCIsIm9uRW5kZWRDYXB0dXJlIiwib25FcnJvckNhcHR1cmUiLCJvbkZvY3VzIiwib25Gb2N1c0NhcHR1cmUiLCJvbklucHV0Iiwib25JbnB1dENhcHR1cmUiLCJpbnZhbGlkIiwib25JbnZhbGlkIiwib25JbnZhbGlkQ2FwdHVyZSIsImtleURvd24iLCJvbktleURvd24iLCJvbktleURvd25DYXB0dXJlIiwia2V5UHJlc3MiLCJvbktleVByZXNzIiwib25LZXlQcmVzc0NhcHR1cmUiLCJrZXlVcCIsIm9uS2V5VXAiLCJvbktleVVwQ2FwdHVyZSIsImxvYWQiLCJvbkxvYWQiLCJvbkxvYWRDYXB0dXJlIiwibG9hZGVkRGF0YSIsIm9uTG9hZGVkRGF0YSIsIm9uTG9hZGVkRGF0YUNhcHR1cmUiLCJsb2FkZWRNZXRhZGF0YSIsIm9uTG9hZGVkTWV0YWRhdGEiLCJvbkxvYWRlZE1ldGFkYXRhQ2FwdHVyZSIsImxvYWRTdGFydCIsIm9uTG9hZFN0YXJ0Iiwib25Mb2FkU3RhcnRDYXB0dXJlIiwibW91c2VNb3ZlIiwibW91c2VPdXQiLCJvbk1vdXNlT3V0Iiwib25Nb3VzZU91dENhcHR1cmUiLCJtb3VzZU92ZXIiLCJvbk1vdXNlT3ZlciIsIm9uTW91c2VPdmVyQ2FwdHVyZSIsIm1vdXNlVXAiLCJwYXN0ZSIsIm9uUGFzdGUiLCJvblBhc3RlQ2FwdHVyZSIsInBhdXNlIiwib25QYXVzZSIsIm9uUGF1c2VDYXB0dXJlIiwicGxheSIsIm9uUGxheSIsIm9uUGxheUNhcHR1cmUiLCJwbGF5aW5nIiwib25QbGF5aW5nIiwib25QbGF5aW5nQ2FwdHVyZSIsIm9uUHJvZ3Jlc3MiLCJvblByb2dyZXNzQ2FwdHVyZSIsInJhdGVDaGFuZ2UiLCJvblJhdGVDaGFuZ2UiLCJvblJhdGVDaGFuZ2VDYXB0dXJlIiwib25SZXNldCIsIm9uUmVzZXRDYXB0dXJlIiwic2Nyb2xsIiwib25TY3JvbGwiLCJvblNjcm9sbENhcHR1cmUiLCJzZWVrZWQiLCJvblNlZWtlZCIsIm9uU2Vla2VkQ2FwdHVyZSIsInNlZWtpbmciLCJvblNlZWtpbmciLCJvblNlZWtpbmdDYXB0dXJlIiwic3RhbGxlZCIsIm9uU3RhbGxlZCIsIm9uU3RhbGxlZENhcHR1cmUiLCJzdWJtaXQiLCJvblN1Ym1pdCIsIm9uU3VibWl0Q2FwdHVyZSIsInN1c3BlbmQiLCJvblN1c3BlbmQiLCJvblN1c3BlbmRDYXB0dXJlIiwidGltZVVwZGF0ZSIsIm9uVGltZVVwZGF0ZSIsIm9uVGltZVVwZGF0ZUNhcHR1cmUiLCJ0b3VjaENhbmNlbCIsIm9uVG91Y2hDYW5jZWwiLCJvblRvdWNoQ2FuY2VsQ2FwdHVyZSIsInRvdWNoRW5kIiwib25Ub3VjaEVuZCIsIm9uVG91Y2hFbmRDYXB0dXJlIiwidG91Y2hNb3ZlIiwib25Ub3VjaE1vdmUiLCJvblRvdWNoTW92ZUNhcHR1cmUiLCJ0b3VjaFN0YXJ0Iiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaFN0YXJ0Q2FwdHVyZSIsInRyYW5zaXRpb25FbmQiLCJvblRyYW5zaXRpb25FbmQiLCJvblRyYW5zaXRpb25FbmRDYXB0dXJlIiwidm9sdW1lQ2hhbmdlIiwib25Wb2x1bWVDaGFuZ2UiLCJvblZvbHVtZUNoYW5nZUNhcHR1cmUiLCJ3YWl0aW5nIiwib25XYWl0aW5nIiwib25XYWl0aW5nQ2FwdHVyZSIsIndoZWVsIiwib25XaGVlbCIsIm9uV2hlZWxDYXB0dXJlIiwidG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnIiwiT05fQ0xJQ0tfS0VZIiwib25DbGlja0xpc3RlbmVycyIsIkV2ZW50Q29uc3RydWN0b3IiLCJBbmltYXRpb25FdmVudEludGVyZmFjZSIsImFuaW1hdGlvbk5hbWUiLCJlbGFwc2VkVGltZSIsInBzZXVkb0VsZW1lbnQiLCJDbGlwYm9hcmRFdmVudEludGVyZmFjZSIsImNsaXBib2FyZERhdGEiLCJGb2N1c0V2ZW50SW50ZXJmYWNlIiwiZ2V0RXZlbnRLZXkiLCJLZXlib2FyZEV2ZW50SW50ZXJmYWNlIiwicmVwZWF0IiwibG9jYWxlIiwiY2hhckNvZGUiLCJub3JtYWxpemVLZXkiLCJ0cmFuc2xhdGVUb0tleSIsIkRyYWdFdmVudEludGVyZmFjZSIsImRhdGFUcmFuc2ZlciIsIlRvdWNoRXZlbnRJbnRlcmZhY2UiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwiVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlIiwiV2hlZWxFdmVudEludGVyZmFjZSIsImRlbHRhWCIsIndoZWVsRGVsdGFYIiwiZGVsdGFZIiwid2hlZWxEZWx0YVkiLCJ3aGVlbERlbHRhIiwiZGVsdGFaIiwiZGVsdGFNb2RlIiwiUmVhY3RET01Db250YWluZXJJbmZvIiwiUmVhY3RET01GZWF0dXJlRmxhZ3MiLCJSZWFjdE1hcmt1cENoZWNrc3VtIiwiUk9PVF9BVFRSX05BTUUiLCJET0NfTk9ERV9UWVBFIiwiaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCIsImZpcnN0RGlmZmVyZW5jZUluZGV4Iiwic3RyaW5nMSIsInN0cmluZzIiLCJtaW5MZW4iLCJnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIiLCJpbnRlcm5hbEdldElEIiwibW91bnRDb21wb25lbnRJbnRvTm9kZSIsIndyYXBwZXJJbnN0YW5jZSIsInNob3VsZFJldXNlTWFya3VwIiwid3JhcHBlZEVsZW1lbnQiLCJfbW91bnRJbWFnZUludG9Ob2RlIiwiYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUiLCJjb21wb25lbnRJbnN0YW5jZSIsInVubW91bnRDb21wb25lbnRGcm9tTm9kZSIsImhhc05vblJvb3RSZWFjdENoaWxkIiwicm9vdEVsIiwibm9kZUlzUmVuZGVyZWRCeU90aGVySW5zdGFuY2UiLCJpc1JlYWN0Tm9kZSIsImlzVmFsaWRDb250YWluZXIiLCJoYXNBdHRyaWJ1dGUiLCJnZXRIb3N0Um9vdEluc3RhbmNlSW5Db250YWluZXIiLCJwcmV2SG9zdEluc3RhbmNlIiwiZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIiLCJ0b3BMZXZlbFJvb3RDb3VudGVyIiwiVG9wTGV2ZWxXcmFwcGVyIiwicm9vdElEIiwiX2luc3RhbmNlc0J5UmVhY3RSb290SUQiLCJzY3JvbGxNb25pdG9yIiwicmVuZGVyQ2FsbGJhY2siLCJfdXBkYXRlUm9vdENvbXBvbmVudCIsInByZXZDb21wb25lbnQiLCJfcmVuZGVyTmV3Um9vdENvbXBvbmVudCIsIndyYXBwZXJJRCIsInBhcmVudENvbXBvbmVudCIsIl9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsIm5leHRXcmFwcGVkRWxlbWVudCIsInByZXZXcmFwcGVkRWxlbWVudCIsInB1YmxpY0luc3QiLCJ1cGRhdGVkQ2FsbGJhY2siLCJyZWFjdFJvb3RFbGVtZW50IiwiY29udGFpbmVySGFzUmVhY3RNYXJrdXAiLCJjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCIsInJvb3RFbGVtZW50U2libGluZyIsImlzQ29udGFpbmVyUmVhY3RSb290Iiwicm9vdEVsZW1lbnQiLCJjYW5SZXVzZU1hcmt1cCIsImNoZWNrc3VtIiwiQ0hFQ0tTVU1fQVRUUl9OQU1FIiwicm9vdE1hcmt1cCIsIm91dGVySFRNTCIsIm5vcm1hbGl6ZWRNYXJrdXAiLCJub3JtYWxpemVyIiwiY29udGVudERvY3VtZW50Iiwid3JpdGUiLCJkaWZmSW5kZXgiLCJkaWZmZXJlbmNlIiwidG9wTGV2ZWxXcmFwcGVyIiwiYWRsZXIzMiIsIlRBR19FTkQiLCJDT01NRU5UX1NUQVJUIiwiYWRkQ2hlY2tzdW1Ub01hcmt1cCIsImV4aXN0aW5nQ2hlY2tzdW0iLCJtYXJrdXBDaGVja3N1bSIsIk1PRCIsImwiLCJtIiwiY29tcG9uZW50T3JFbGVtZW50IiwicmVhY3RQcm9wcyIsIndhcm5lZFByb3BlcnRpZXMiLCJ2YWxpZGF0ZVByb3BlcnR5Iiwic3RhbmRhcmROYW1lIiwid2FyblVua25vd25Qcm9wZXJ0aWVzIiwidW5rbm93blByb3BzIiwiaXNWYWxpZCIsInVua25vd25Qcm9wU3RyaW5nIiwiZGlkV2FyblZhbHVlTnVsbCIsIl9fZXNNb2R1bGUiLCJjb25uZWN0IiwiUHJvdmlkZXIiLCJfUHJvdmlkZXIiLCJfUHJvdmlkZXIyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9jb25uZWN0IiwiX2Nvbm5lY3QyIiwiX3JlYWN0IiwiX3N0b3JlU2hhcGUiLCJfc3RvcmVTaGFwZTIiLCJfd2FybmluZyIsIl93YXJuaW5nMiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiUmVmZXJlbmNlRXJyb3IiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJzZXRQcm90b3R5cGVPZiIsImRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlIiwid2FybkFib3V0UmVjZWl2aW5nU3RvcmUiLCJfQ29tcG9uZW50IiwiX3RoaXMiLCJuZXh0U3RvcmUiLCJzdWJzY3JpYmUiLCJkaXNwYXRjaCIsImdldFN0YXRlIiwiX2V4dGVuZHMiLCJfc2hhbGxvd0VxdWFsIiwiX3NoYWxsb3dFcXVhbDIiLCJfd3JhcEFjdGlvbkNyZWF0b3JzIiwiX3dyYXBBY3Rpb25DcmVhdG9yczIiLCJfaXNQbGFpbk9iamVjdCIsIl9pc1BsYWluT2JqZWN0MiIsIl9ob2lzdE5vblJlYWN0U3RhdGljcyIsIl9ob2lzdE5vblJlYWN0U3RhdGljczIiLCJfaW52YXJpYW50IiwiX2ludmFyaWFudDIiLCJkZWZhdWx0TWFwU3RhdGVUb1Byb3BzIiwiZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wcyIsImRlZmF1bHRNZXJnZVByb3BzIiwic3RhdGVQcm9wcyIsImRpc3BhdGNoUHJvcHMiLCJwYXJlbnRQcm9wcyIsIldyYXBwZWRDb21wb25lbnQiLCJlcnJvck9iamVjdCIsInRyeUNhdGNoIiwiY3R4IiwibmV4dFZlcnNpb24iLCJtYXBTdGF0ZVRvUHJvcHMiLCJtYXBEaXNwYXRjaFRvUHJvcHMiLCJtZXJnZVByb3BzIiwic2hvdWxkU3Vic2NyaWJlIiwibWFwU3RhdGUiLCJtYXBEaXNwYXRjaCIsImZpbmFsTWVyZ2VQcm9wcyIsIl9vcHRpb25zJHB1cmUiLCJwdXJlIiwiX29wdGlvbnMkd2l0aFJlZiIsIndpdGhSZWYiLCJjaGVja01lcmdlZEVxdWFscyIsIndyYXBXaXRoQ29ubmVjdCIsImNvbm5lY3REaXNwbGF5TmFtZSIsImNoZWNrU3RhdGVTaGFwZSIsImNvbXB1dGVNZXJnZWRQcm9wcyIsIm1lcmdlZFByb3BzIiwiQ29ubmVjdCIsImhhdmVPd25Qcm9wc0NoYW5nZWQiLCJoYXNTdG9yZVN0YXRlQ2hhbmdlZCIsInN0b3JlU3RhdGUiLCJjbGVhckNhY2hlIiwiY29tcHV0ZVN0YXRlUHJvcHMiLCJmaW5hbE1hcFN0YXRlVG9Qcm9wcyIsImNvbmZpZ3VyZUZpbmFsTWFwU3RhdGUiLCJkb1N0YXRlUHJvcHNEZXBlbmRPbk93blByb3BzIiwibWFwcGVkU3RhdGUiLCJpc0ZhY3RvcnkiLCJjb21wdXRlRGlzcGF0Y2hQcm9wcyIsImZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzIiwiY29uZmlndXJlRmluYWxNYXBEaXNwYXRjaCIsImRvRGlzcGF0Y2hQcm9wc0RlcGVuZE9uT3duUHJvcHMiLCJtYXBwZWREaXNwYXRjaCIsInVwZGF0ZVN0YXRlUHJvcHNJZk5lZWRlZCIsIm5leHRTdGF0ZVByb3BzIiwidXBkYXRlRGlzcGF0Y2hQcm9wc0lmTmVlZGVkIiwibmV4dERpc3BhdGNoUHJvcHMiLCJ1cGRhdGVNZXJnZWRQcm9wc0lmTmVlZGVkIiwibmV4dE1lcmdlZFByb3BzIiwiaXNTdWJzY3JpYmVkIiwidW5zdWJzY3JpYmUiLCJ0cnlTdWJzY3JpYmUiLCJoYW5kbGVDaGFuZ2UiLCJ0cnlVbnN1YnNjcmliZSIsImhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQiLCJzdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvciIsInByZXZTdG9yZVN0YXRlIiwiaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkIiwiZ2V0V3JhcHBlZEluc3RhbmNlIiwid3JhcHBlZEluc3RhbmNlIiwic2hvdWxkVXBkYXRlU3RhdGVQcm9wcyIsInNob3VsZFVwZGF0ZURpc3BhdGNoUHJvcHMiLCJoYXZlRGlzcGF0Y2hQcm9wc0NoYW5nZWQiLCJoYXZlTWVyZ2VkUHJvcHNDaGFuZ2VkIiwiaGFzT3duIiwid3JhcEFjdGlvbkNyZWF0b3JzIiwiX3JlZHV4IiwiYWN0aW9uQ3JlYXRvcnMiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJjb21wb3NlIiwiYXBwbHlNaWRkbGV3YXJlIiwiY29tYmluZVJlZHVjZXJzIiwiY3JlYXRlU3RvcmUiLCJfY3JlYXRlU3RvcmUiLCJfY3JlYXRlU3RvcmUyIiwiX2NvbWJpbmVSZWR1Y2VycyIsIl9jb21iaW5lUmVkdWNlcnMyIiwiX2JpbmRBY3Rpb25DcmVhdG9ycyIsIl9iaW5kQWN0aW9uQ3JlYXRvcnMyIiwiX2FwcGx5TWlkZGxld2FyZSIsIl9hcHBseU1pZGRsZXdhcmUyIiwiX2NvbXBvc2UiLCJfY29tcG9zZTIiLCJpc0NydXNoZWQiLCJBY3Rpb25UeXBlcyIsIl9zeW1ib2xPYnNlcnZhYmxlIiwiX3N5bWJvbE9ic2VydmFibGUyIiwiSU5JVCIsInJlZHVjZXIiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VyIiwiX3JlZjIiLCJjdXJyZW50UmVkdWNlciIsImN1cnJlbnRTdGF0ZSIsImN1cnJlbnRMaXN0ZW5lcnMiLCJuZXh0TGlzdGVuZXJzIiwiaXNEaXNwYXRjaGluZyIsImVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMiLCJyZXBsYWNlUmVkdWNlciIsIm5leHRSZWR1Y2VyIiwib2JzZXJ2YWJsZSIsIl9yZWYiLCJvdXRlclN1YnNjcmliZSIsIm9ic2VydmVyIiwib2JzZXJ2ZVN0YXRlIiwiZ2V0UHJvdG90eXBlIiwiaXNIb3N0T2JqZWN0IiwiaXNPYmplY3RMaWtlIiwib2JqZWN0VGFnIiwiZnVuY1Byb3RvIiwib2JqZWN0UHJvdG8iLCJvYmplY3RDdG9yU3RyaW5nIiwib2JqZWN0VG9TdHJpbmciLCJpc1BsYWluT2JqZWN0IiwiQ3RvciIsIm92ZXJBcmciLCJnZXRQcm90b3R5cGVPZiIsIl9wb255ZmlsbCIsIl9wb255ZmlsbDIiLCJnbG9iYWwiLCJzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwiLCJfU3ltYm9sIiwiZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2UiLCJhY3Rpb25UeXBlIiwiYWN0aW9uTmFtZSIsImdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2UiLCJpbnB1dFN0YXRlIiwicmVkdWNlcnMiLCJ1bmV4cGVjdGVkS2V5Q2FjaGUiLCJyZWR1Y2VyS2V5cyIsImFyZ3VtZW50TmFtZSIsInVuZXhwZWN0ZWRLZXlzIiwiYXNzZXJ0UmVkdWNlclNhbml0eSIsImZpbmFsUmVkdWNlcnMiLCJmaW5hbFJlZHVjZXJLZXlzIiwic2FuaXR5RXJyb3IiLCJjb21iaW5hdGlvbiIsIndhcm5pbmdNZXNzYWdlIiwiaGFzQ2hhbmdlZCIsInByZXZpb3VzU3RhdGVGb3JLZXkiLCJuZXh0U3RhdGVGb3JLZXkiLCJlcnJvck1lc3NhZ2UiLCJiaW5kQWN0aW9uQ3JlYXRvciIsImFjdGlvbkNyZWF0b3IiLCJib3VuZEFjdGlvbkNyZWF0b3JzIiwibWlkZGxld2FyZXMiLCJfZGlzcGF0Y2giLCJjaGFpbiIsIm1pZGRsZXdhcmVBUEkiLCJtaWRkbGV3YXJlIiwiZnVuY3MiLCJsYXN0IiwicmVzdCIsInJlZHVjZVJpZ2h0IiwiY29tcG9zZWQiLCJSRUFDVF9TVEFUSUNTIiwiS05PV05fU1RBVElDUyIsImNhbGxlciIsImFyaXR5IiwiaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUiLCJob2lzdE5vblJlYWN0U3RhdGljcyIsInRhcmdldENvbXBvbmVudCIsInNvdXJjZUNvbXBvbmVudCIsImN1c3RvbVN0YXRpY3MiLCJjcmVhdGVUaHVua01pZGRsZXdhcmUiLCJleHRyYUFyZ3VtZW50IiwidGh1bmsiLCJ3aXRoRXh0cmFBcmd1bWVudCIsIkFwcCIsInNvbmdzIiwidXB2b3RlIiwiU29uZ0xpc3QiLCJzb25nIiwidXB2b3RlU29uZyIsImxpa2VzIiwic29ydEJ5TGlrZXMiLCJkZWZpbmUiLCJnZXRQb2x5ZmlsbCIsInNoaW0iLCJmb3JlYWNoIiwiaGFzU3ltYm9scyIsInRvU3RyIiwiYXJlUHJvcGVydHlEZXNjcmlwdG9yc1N1cHBvcnRlZCIsInN1cHBvcnRzRGVzY3JpcHRvcnMiLCJwcmVkaWNhdGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJlZGljYXRlcyIsImlzQXJncyIsImlzRW51bWVyYWJsZSIsImhhc0RvbnRFbnVtQnVnIiwiaGFzUHJvdG9FbnVtQnVnIiwiZG9udEVudW1zIiwiZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUiLCJvIiwiZXhjbHVkZWRLZXlzIiwiJGNvbnNvbGUiLCIkZXh0ZXJuYWwiLCIkZnJhbWUiLCIkZnJhbWVFbGVtZW50IiwiJGZyYW1lcyIsIiRpbm5lckhlaWdodCIsIiRpbm5lcldpZHRoIiwiJG91dGVySGVpZ2h0IiwiJG91dGVyV2lkdGgiLCIkcGFnZVhPZmZzZXQiLCIkcGFnZVlPZmZzZXQiLCIkcGFyZW50IiwiJHNjcm9sbExlZnQiLCIkc2Nyb2xsVG9wIiwiJHNjcm9sbFgiLCIkc2Nyb2xsWSIsIiRzZWxmIiwiJHdlYmtpdEluZGV4ZWREQiIsIiR3ZWJraXRTdG9yYWdlSW5mbyIsIiR3aW5kb3ciLCJoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWciLCJlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kiLCJrZXlzU2hpbSIsImlzT2JqZWN0IiwiaXNBcmd1bWVudHMiLCJpc1N0cmluZyIsInRoZUtleXMiLCJza2lwUHJvdG8iLCJza2lwQ29uc3RydWN0b3IiLCJzaGltT2JqZWN0S2V5cyIsImtleXNXb3Jrc1dpdGhBcmd1bWVudHMiLCJvcmlnaW5hbEtleXMiLCJFUyIsIk8iLCJSZXF1aXJlT2JqZWN0Q29lcmNpYmxlIiwidmFscyIsIkVTNiIsIkVTNyIsIlNhbWVWYWx1ZU5vbk51bWJlciIsIlNhbWVWYWx1ZSIsInN5bWJvbFRvU3RyIiwiJGlzTmFOIiwiJGlzRmluaXRlIiwiTUFYX1NBRkVfSU5URUdFUiIsIk51bWJlciIsInBvdyIsInNpZ24iLCJtb2QiLCJpc1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwicGFyc2VJbnRlZ2VyIiwic3RyU2xpY2UiLCJpc0JpbmFyeSIsImlzT2N0YWwiLCJub25XUyIsIm5vbldTcmVnZXgiLCJoYXNOb25XUyIsImludmFsaWRIZXhMaXRlcmFsIiwiaXNJbnZhbGlkSGV4TGl0ZXJhbCIsIndzIiwidHJpbVJlZ2V4IiwiRVM1IiwiaGFzUmVnRXhwTWF0Y2hlciIsIkNhbGwiLCJGIiwiViIsIklzQ2FsbGFibGUiLCJUb1ByaW1pdGl2ZSIsIlRvTnVtYmVyIiwiYXJndW1lbnQiLCJOYU4iLCJ0cmltbWVkIiwiVG9JbnQxNiIsImludDE2Yml0IiwiVG9VaW50MTYiLCJUb0ludDgiLCJpbnQ4Yml0IiwiVG9VaW50OCIsInBvc0ludCIsImZsb29yIiwiYWJzIiwiVG9VaW50OENsYW1wIiwiVG9TdHJpbmciLCJUb09iamVjdCIsIlRvUHJvcGVydHlLZXkiLCJUb0xlbmd0aCIsIlRvSW50ZWdlciIsIkNhbm9uaWNhbE51bWVyaWNJbmRleFN0cmluZyIsIkNoZWNrT2JqZWN0Q29lcmNpYmxlIiwiSXNBcnJheSIsIklzQ29uc3RydWN0b3IiLCJJc0V4dGVuc2libGUiLCJpc0V4dGVuc2libGUiLCJJc0ludGVnZXIiLCJJc1Byb3BlcnR5S2V5IiwiSXNSZWdFeHAiLCJpc1JlZ0V4cCIsIlRvQm9vbGVhbiIsIlNhbWVWYWx1ZVplcm8iLCJUeXBlIiwiU3BlY2llc0NvbnN0cnVjdG9yIiwiZGVmYXVsdENvbnN0cnVjdG9yIiwiQyIsIlMiLCJzcGVjaWVzIiwiaXNGaW5pdGUiLCJJbmZpbml0eSIsIm1vZHVsbyIsInJlbWFpbiIsImlzQ2FsbGFibGUiLCJpc0RhdGUiLCJvcmRpbmFyeVRvUHJpbWl0aXZlIiwiT3JkaW5hcnlUb1ByaW1pdGl2ZSIsImhpbnQiLCJtZXRob2ROYW1lcyIsIkdldE1ldGhvZCIsIlAiLCJQcmVmZXJyZWRUeXBlIiwiZXhvdGljVG9QcmltIiwidmFsdWVPZiIsImZuVG9TdHIiLCJjb25zdHJ1Y3RvclJlZ2V4IiwiaXNFUzZDbGFzc0ZuIiwiZm5TdHIiLCJzaW5nbGVTdHJpcHBlZCIsIm11bHRpU3RyaXBwZWQiLCJzcGFjZVN0cmlwcGVkIiwidHJ5RnVuY3Rpb25PYmplY3QiLCJmbkNsYXNzIiwiZ2VuQ2xhc3MiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwic3RyQ2xhc3MiLCJnZXREYXkiLCJ0cnlEYXRlT2JqZWN0IiwiZGF0ZUNsYXNzIiwiaXNEYXRlT2JqZWN0Iiwic3ltVG9TdHIiLCJzeW1TdHJpbmdSZWdleCIsImlzU3ltYm9sT2JqZWN0IiwiRVJST1JfTUVTU0FHRSIsImZ1bmNUeXBlIiwiYm91bmQiLCJiaW5kZXIiLCJib3VuZExlbmd0aCIsImJvdW5kQXJncyIsIkVtcHR5IiwiVG9JbnQzMiIsIlRvVWludDMyIiwib3B0TWVzc2FnZSIsIkVTNWludGVybmFsU2xvdHMiLCJhY3R1YWxIaW50IiwibWV0aG9kcyIsInJlZ2V4RXhlYyIsInRyeVJlZ2V4RXhlYyIsInJlZ2V4Q2xhc3MiLCJpc1JlZ2V4Iiwic2hpbVZhbHVlcyIsInBvbHlmaWxsIiwiY29ubmVjdFNvY2tldCIsImRpc2Nvbm5lY3RTb2NrZXQiLCJyZWNlaXZlTWVzc2FnZSIsInBvc3RNZXNzYWdlIiwic2VuZE1lc3NhZ2UiLCJzb2NrZXQiLCJuZXdfdmFsIiwiZGlzY29ubmVjdCIsInNvbmdJZCIsInRoZW4iLCJwYXJzZXIiLCJNYW5hZ2VyIiwibG9va3VwIiwibWFuYWdlcnMiLCJ1cmkiLCJvcHRzIiwicGFyc2VkIiwic2FtZU5hbWVzcGFjZSIsIm5zcHMiLCJuZXdDb25uZWN0aW9uIiwiZm9yY2VOZXciLCJtdWx0aXBsZXgiLCJpbyIsIlNvY2tldCIsInBhcnNldXJpIiwibG9jIiwiaG9zdCIsInBvcnQiLCJpcHY2IiwicmUiLCJwYXJ0cyIsImF1dGhvcml0eSIsImlwdjZ1cmkiLCJsb2ciLCJmb3JtYXRBcmdzIiwic2F2ZSIsInVzZUNvbG9ycyIsInN0b3JhZ2UiLCJjaHJvbWUiLCJsb2NhbHN0b3JhZ2UiLCJjb2xvcnMiLCJmaXJlYnVnIiwiZXhjZXB0aW9uIiwiJDEiLCJmb3JtYXR0ZXJzIiwidiIsImh1bWFuaXplIiwiZGlmZiIsImxhc3RDIiwibmFtZXNwYWNlcyIsInJlbW92ZUl0ZW0iLCJlbmFibGUiLCJsb2NhbFN0b3JhZ2UiLCJjb2VyY2UiLCJkaXNhYmxlIiwibmFtZXMiLCJza2lwcyIsInByZXZDb2xvciIsInByZXZUaW1lIiwic2VsZWN0Q29sb3IiLCJjdXJyIiwibXMiLCJwcmV2IiwiZm9ybWF0dGVyIiwibG9nRm4iLCJoIiwicGFyc2UiLCJsb25nIiwic2hvcnQiLCJwYXJzZUZsb2F0Iiwicm91bmQiLCJwbHVyYWwiLCJjZWlsIiwianNvbiIsIkVtaXR0ZXIiLCJiaW5hcnkiLCJpc0J1ZiIsInR5cGVzIiwiQ09OTkVDVCIsIkRJU0NPTk5FQ1QiLCJFVkVOVCIsIkFDSyIsIkVSUk9SIiwiQklOQVJZX0VWRU5UIiwiQklOQVJZX0FDSyIsIkVuY29kZXIiLCJEZWNvZGVyIiwiZW5jb2RlIiwiZW5jb2RlQXNCaW5hcnkiLCJlbmNvZGluZyIsImVuY29kZUFzU3RyaW5nIiwibnNwIiwiYXR0YWNobWVudHMiLCJ3cml0ZUVuY29kaW5nIiwiYmxvYmxlc3NEYXRhIiwiZGVjb25zdHJ1Y3Rpb24iLCJkZWNvbnN0cnVjdFBhY2tldCIsInBhY2siLCJwYWNrZXQiLCJidWZmZXJzIiwidW5zaGlmdCIsInJlbW92ZUJsb2JzIiwicmVjb25zdHJ1Y3RvciIsImRlY29kZVN0cmluZyIsIkJpbmFyeVJlY29uc3RydWN0b3IiLCJyZWNvblBhY2siLCJiYXNlNjQiLCJ0YWtlQmluYXJ5RGF0YSIsImJ1ZiIsImRlc3Ryb3kiLCJmaW5pc2hlZFJlY29uc3RydWN0aW9uIiwiYmluRGF0YSIsInJlY29uc3RydWN0UGFja2V0IiwiaXNMb2FkZXIiLCJvYmplY3RUeXBlcyIsImZyZWVFeHBvcnRzIiwiZnJlZUdsb2JhbCIsInJ1bkluQ29udGV4dCIsIlN5bnRheEVycm9yIiwibmF0aXZlSlNPTiIsImdldENsYXNzIiwiaXNQcm9wZXJ0eSIsInVuZGVmIiwiaXNFeHRlbmRlZCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsImdldFVUQ01pbGxpc2Vjb25kcyIsInN0cmluZ2lmeVN1cHBvcnRlZCIsInRvSlNPTiIsInBhcnNlU3VwcG9ydGVkIiwiZnVuY3Rpb25DbGFzcyIsIm51bWJlckNsYXNzIiwic3RyaW5nQ2xhc3MiLCJhcnJheUNsYXNzIiwiYm9vbGVhbkNsYXNzIiwiY2hhckluZGV4QnVnZ3kiLCJNb250aHMiLCJ5ZWFyIiwibW9udGgiLCJtZW1iZXJzIiwib3JpZ2luYWwiLCJwYXJlbnQiLCJoYXNQcm9wZXJ0eSIsImlzQ29uc3RydWN0b3IiLCJFc2NhcGVzIiwibGVhZGluZ1plcm9lcyIsInRvUGFkZGVkU3RyaW5nIiwidW5pY29kZVByZWZpeCIsInF1b3RlIiwidXNlQ2hhckluZGV4Iiwic2VyaWFsaXplIiwid2hpdGVzcGFjZSIsImluZGVudGF0aW9uIiwiZGF0ZSIsImhvdXJzIiwibWludXRlcyIsInNlY29uZHMiLCJtaWxsaXNlY29uZHMiLCJVbmVzY2FwZXMiLCJJbmRleCIsIlNvdXJjZSIsImxleCIsInBvc2l0aW9uIiwiaXNTaWduZWQiLCJoYXNNZW1iZXJzIiwid2FsayIsInByZXZpb3VzSlNPTiIsImlzUmVzdG9yZWQiLCJKU09OMyIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiaGFzTGlzdGVuZXJzIiwicGFja2V0RGF0YSIsIl9kZWNvbnN0cnVjdFBhY2tldCIsIl9wbGFjZWhvbGRlciIsIm51bSIsIm5ld0RhdGEiLCJjdXJQbGFjZUhvbGRlciIsIl9yZWNvbnN0cnVjdFBhY2tldCIsIl9yZW1vdmVCbG9icyIsImN1cktleSIsImNvbnRhaW5pbmdPYmplY3QiLCJCbG9iIiwiRmlsZSIsInBlbmRpbmdCbG9icyIsImZpbGVSZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJCdWZmZXIiLCJpc0J1ZmZlciIsIkFycmF5QnVmZmVyIiwiZWlvIiwiQmFja29mZiIsInN1YnMiLCJyZWNvbm5lY3Rpb24iLCJyZWNvbm5lY3Rpb25BdHRlbXB0cyIsInJlY29ubmVjdGlvbkRlbGF5IiwicmVjb25uZWN0aW9uRGVsYXlNYXgiLCJyYW5kb21pemF0aW9uRmFjdG9yIiwiYmFja29mZiIsImppdHRlciIsInJlYWR5U3RhdGUiLCJjb25uZWN0aW5nIiwibGFzdFBpbmciLCJwYWNrZXRCdWZmZXIiLCJlbmNvZGVyIiwiZGVjb2RlciIsImF1dG9Db25uZWN0IiwiZW1pdEFsbCIsInVwZGF0ZVNvY2tldElkcyIsImVuZ2luZSIsIl9yZWNvbm5lY3Rpb24iLCJfcmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJfcmVjb25uZWN0aW9uRGVsYXkiLCJzZXRNaW4iLCJfcmFuZG9taXphdGlvbkZhY3RvciIsInNldEppdHRlciIsIl9yZWNvbm5lY3Rpb25EZWxheU1heCIsInNldE1heCIsIl90aW1lb3V0IiwibWF5YmVSZWNvbm5lY3RPbk9wZW4iLCJyZWNvbm5lY3RpbmciLCJhdHRlbXB0cyIsInJlY29ubmVjdCIsInNraXBSZWNvbm5lY3QiLCJvcGVuU3ViIiwib25vcGVuIiwiZXJyb3JTdWIiLCJjbGVhbnVwIiwidGltZXIiLCJvbnBpbmciLCJvbnBvbmciLCJvbmRhdGEiLCJvbmRlY29kZWQiLCJvbmVycm9yIiwib25Db25uZWN0aW5nIiwiZW5jb2RlZFBhY2tldHMiLCJwcm9jZXNzUGFja2V0UXVldWUiLCJzaGlmdCIsIm9uY2xvc2UiLCJyZWFzb24iLCJkZWxheSIsIm9ucmVjb25uZWN0IiwiYXR0ZW1wdCIsInRyYW5zcG9ydHMiLCJwYXJzZWpzb24iLCJwYXJzZXFzIiwiaG9zdG5hbWUiLCJzZWN1cmUiLCJxdWVyeSIsImFnZW50IiwiZGVjb2RlIiwidXBncmFkZSIsImZvcmNlSlNPTlAiLCJqc29ucCIsImZvcmNlQmFzZTY0IiwiZW5hYmxlc1hEUiIsInRpbWVzdGFtcFBhcmFtIiwidGltZXN0YW1wUmVxdWVzdHMiLCJ3cml0ZUJ1ZmZlciIsInBvbGljeVBvcnQiLCJyZW1lbWJlclVwZ3JhZGUiLCJiaW5hcnlUeXBlIiwib25seUJpbmFyeVVwZ3JhZGVzIiwicGVyTWVzc2FnZURlZmxhdGUiLCJ0aHJlc2hvbGQiLCJwZngiLCJwYXNzcGhyYXNlIiwiY2VydCIsImNhIiwiY2lwaGVycyIsInJlamVjdFVuYXV0aG9yaXplZCIsImV4dHJhSGVhZGVycyIsInByaW9yV2Vic29ja2V0U3VjY2VzcyIsIlRyYW5zcG9ydCIsImNyZWF0ZVRyYW5zcG9ydCIsImNsb25lIiwiRUlPIiwidHJhbnNwb3J0Iiwic2lkIiwic2V0VHJhbnNwb3J0Iiwib25EcmFpbiIsIm9uUGFja2V0Iiwib25DbG9zZSIsInByb2JlIiwiZmFpbGVkIiwib25UcmFuc3BvcnRPcGVuIiwidXBncmFkZUxvc2VzQmluYXJ5Iiwic3VwcG9ydHNCaW5hcnkiLCJzZW5kIiwibXNnIiwidXBncmFkaW5nIiwiZmx1c2giLCJmcmVlemVUcmFuc3BvcnQiLCJvblRyYW5zcG9ydENsb3NlIiwib251cGdyYWRlIiwib25PcGVuIiwidXBncmFkZXMiLCJvbkhhbmRzaGFrZSIsInNldFBpbmciLCJmaWx0ZXJVcGdyYWRlcyIsInBpbmdJbnRlcnZhbCIsInBpbmdUaW1lb3V0Iiwib25IZWFydGJlYXQiLCJwaW5nVGltZW91dFRpbWVyIiwicGluZ0ludGVydmFsVGltZXIiLCJwaW5nIiwic2VuZFBhY2tldCIsInByZXZCdWZmZXJMZW4iLCJjb21wcmVzcyIsIndhaXRGb3JVcGdyYWRlIiwiY2xlYW51cEFuZENsb3NlIiwiZGVzYyIsImZpbHRlcmVkVXBncmFkZXMiLCJYTUxIdHRwUmVxdWVzdCIsIlhIUiIsIkpTT05QIiwid2Vic29ja2V0IiwicG9sbGluZyIsInhociIsInhkIiwieHMiLCJpc1NTTCIsInhkb21haW4iLCJ4c2NoZW1lIiwiaGFzQ09SUyIsIlhEb21haW5SZXF1ZXN0IiwiQWN0aXZlWE9iamVjdCIsIlBvbGxpbmciLCJpbmhlcml0IiwiUmVxdWVzdCIsImVtcHR5IiwicmVxdWVzdCIsImRvV3JpdGUiLCJyZXEiLCJzZW5kWGhyIiwiZG9Qb2xsIiwib25EYXRhIiwicG9sbFhociIsInNldERpc2FibGVIZWFkZXJDaGVjayIsInNldFJlcXVlc3RIZWFkZXIiLCJyZXNwb25zZVR5cGUiLCJ3aXRoQ3JlZGVudGlhbHMiLCJoYXNYRFIiLCJyZXNwb25zZVRleHQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJzdGF0dXMiLCJyZXF1ZXN0c0NvdW50IiwicmVxdWVzdHMiLCJvblN1Y2Nlc3MiLCJmcm9tRXJyb3IiLCJjb250ZW50VHlwZSIsImdldFJlc3BvbnNlSGVhZGVyIiwicmVzcG9uc2UiLCJVaW50OEFycmF5IiwidWk4QXJyIiwiZGF0YUFycmF5IiwiaWR4IiwidW5sb2FkSGFuZGxlciIsInllYXN0IiwiaGFzWEhSMiIsImRvT3BlbiIsInBvbGwiLCJwZW5kaW5nIiwidG90YWwiLCJkZWNvZGVQYXlsb2FkIiwiZG9DbG9zZSIsInBhY2tldHMiLCJjYWxsYmFja2ZuIiwiZW5jb2RlUGF5bG9hZCIsInNjaGVtYSIsImI2NCIsImRlc2NyaXB0aW9uIiwiZGVjb2RlUGFja2V0IiwiaGFzQmluYXJ5Iiwic2xpY2VCdWZmZXIiLCJiYXNlNjRlbmNvZGVyIiwiYWZ0ZXIiLCJ1dGY4IiwiaXNBbmRyb2lkIiwiaXNQaGFudG9tSlMiLCJkb250U2VuZEJsb2JzIiwicG9uZyIsInBhY2tldHNsaXN0IiwiZW5jb2RlUGFja2V0IiwidXRmOGVuY29kZSIsImJ1ZmZlciIsImVuY29kZUFycmF5QnVmZmVyIiwiZW5jb2RlQmxvYiIsImVuY29kZUJhc2U2NE9iamVjdCIsImVuY29kZWQiLCJlbmNvZGVCYXNlNjRQYWNrZXQiLCJjb250ZW50QXJyYXkiLCJyZXN1bHRCdWZmZXIiLCJieXRlTGVuZ3RoIiwiZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIiLCJmciIsImJsb2IiLCJyZWFkQXNEYXRhVVJMIiwiYjY0ZGF0YSIsInR5cGVkIiwiYmFzaWMiLCJidG9hIiwidXRmOGRlY29kZSIsImRlY29kZUJhc2U2NFBhY2tldCIsImFzQXJyYXkiLCJlbmNvZGVQYXlsb2FkQXNCbG9iIiwiZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIiLCJzZXRMZW5ndGhIZWFkZXIiLCJlbmNvZGVPbmUiLCJkb25lQ2FsbGJhY2siLCJhcnkiLCJlYWNoIiwiZWFjaFdpdGhJbmRleCIsImRlY29kZVBheWxvYWRBc0JpbmFyeSIsImNociIsInRvdGFsTGVuZ3RoIiwiYWNjIiwicmVzdWx0QXJyYXkiLCJidWZmZXJJbmRleCIsImFiIiwibGVuU3RyIiwiYmluYXJ5SWRlbnRpZmllciIsImxlbmd0aEFyeSIsImJ1ZmZlclRhaWwiLCJudW1iZXJUb29Mb25nIiwidGFpbEFycmF5IiwibXNnTGVuZ3RoIiwiX2hhc0JpbmFyeSIsImFycmF5YnVmZmVyIiwiYnl0ZXMiLCJhYnYiLCJidWZmZXJMZW5ndGgiLCJlbmNvZGVkMSIsImVuY29kZWQyIiwiZW5jb2RlZDMiLCJlbmNvZGVkNCIsImVycl9jYiIsImJhaWwiLCJwcm94eSIsImZyZWVNb2R1bGUiLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJ1Y3MyZGVjb2RlIiwiY291bnRlciIsImV4dHJhIiwidWNzMmVuY29kZSIsImNoZWNrU2NhbGFyVmFsdWUiLCJjb2RlUG9pbnQiLCJjcmVhdGVCeXRlIiwiZW5jb2RlQ29kZVBvaW50IiwiY29kZVBvaW50cyIsImJ5dGVTdHJpbmciLCJyZWFkQ29udGludWF0aW9uQnl0ZSIsImJ5dGVJbmRleCIsImJ5dGVDb3VudCIsImNvbnRpbnVhdGlvbkJ5dGUiLCJieXRlQXJyYXkiLCJkZWNvZGVTeW1ib2wiLCJieXRlMSIsImJ5dGUyIiwiYnl0ZTMiLCJieXRlNCIsInRtcCIsIkJsb2JCdWlsZGVyIiwiV2ViS2l0QmxvYkJ1aWxkZXIiLCJNU0Jsb2JCdWlsZGVyIiwiTW96QmxvYkJ1aWxkZXIiLCJibG9iU3VwcG9ydGVkIiwiYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3IiwiYmxvYkJ1aWxkZXJTdXBwb3J0ZWQiLCJhcHBlbmQiLCJnZXRCbG9iIiwibWFwQXJyYXlCdWZmZXJWaWV3cyIsImNodW5rIiwiYnl0ZU9mZnNldCIsIkJsb2JCdWlsZGVyQ29uc3RydWN0b3IiLCJiYiIsIkJsb2JDb25zdHJ1Y3RvciIsInFzIiwicXJ5IiwicGFpciIsImRlY29kZVVSSUNvbXBvbmVudCIsImFscGhhYmV0IiwiZGVjb2RlZCIsIkpTT05QUG9sbGluZyIsInJOZXdsaW5lIiwickVzY2FwZWROZXdsaW5lIiwiX19fZWlvIiwiaW5zZXJ0QXQiLCJpc1VBZ2Vja28iLCJpZnJhbWVJZCIsImNvbXBsZXRlIiwiaW5pdElmcmFtZSIsIkJyb3dzZXJXZWJTb2NrZXQiLCJXZWJTb2NrZXQiLCJNb3pXZWJTb2NrZXQiLCJXUyIsImNoZWNrIiwicHJvdG9jb2xzIiwic3VwcG9ydHMiLCJhZGRFdmVudExpc3RlbmVycyIsIm9ubWVzc2FnZSIsImV2IiwicnZhbGlkY2hhcnMiLCJydmFsaWRlc2NhcGUiLCJydmFsaWR0b2tlbnMiLCJydmFsaWRicmFjZXMiLCJydHJpbUxlZnQiLCJydHJpbVJpZ2h0IiwiaGFzQmluIiwiY29ubmVjdF9lcnJvciIsImNvbm5lY3RfdGltZW91dCIsInJlY29ubmVjdF9hdHRlbXB0IiwicmVjb25uZWN0X2ZhaWxlZCIsInJlY29ubmVjdF9lcnJvciIsImlkcyIsImFja3MiLCJyZWNlaXZlQnVmZmVyIiwic2VuZEJ1ZmZlciIsImNvbm5lY3RlZCIsImRpc2Nvbm5lY3RlZCIsInN1YkV2ZW50cyIsInBhcnNlclR5cGUiLCJmbGFncyIsIm9ucGFja2V0Iiwib25jb25uZWN0Iiwib25ldmVudCIsIm9uYWNrIiwib25kaXNjb25uZWN0IiwiYWNrIiwic2VudCIsImVtaXRCdWZmZXJlZCIsImZhY3RvciIsInJhbmQiLCJkZXZpYXRpb24iLCJ1dGlscyIsIkF4aW9zIiwiY3JlYXRlSW5zdGFuY2UiLCJkZWZhdWx0Q29uZmlnIiwiYXhpb3MiLCJhbGwiLCJwcm9taXNlcyIsIlByb21pc2UiLCJzcHJlYWQiLCJkZWZhdWx0IiwiaXNBcnJheUJ1ZmZlciIsImlzRm9ybURhdGEiLCJGb3JtRGF0YSIsImlzQXJyYXlCdWZmZXJWaWV3IiwiaXNWaWV3IiwiaXNOdW1iZXIiLCJpc1VuZGVmaW5lZCIsImlzRmlsZSIsImlzQmxvYiIsImlzU3RyZWFtIiwicGlwZSIsImlzVVJMU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiaXNTdGFuZGFyZEJyb3dzZXJFbnYiLCJtZXJnZSIsImFzc2lnblZhbHVlIiwidGhpc0FyZyIsImRlZmF1bHRzIiwiSW50ZXJjZXB0b3JNYW5hZ2VyIiwiZGlzcGF0Y2hSZXF1ZXN0IiwiaXNBYnNvbHV0ZVVSTCIsImNvbWJpbmVVUkxzIiwiaW50ZXJjZXB0b3JzIiwiYmFzZVVSTCIsInByb21pc2UiLCJyZXNvbHZlIiwidW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMiLCJpbnRlcmNlcHRvciIsImZ1bGZpbGxlZCIsInJlamVjdGVkIiwicHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzIiwiZm9yRWFjaE1ldGhvZE5vRGF0YSIsImZvckVhY2hNZXRob2RXaXRoRGF0YSIsIm5vcm1hbGl6ZUhlYWRlck5hbWUiLCJQUk9URUNUSU9OX1BSRUZJWCIsIkRFRkFVTFRfQ09OVEVOVF9UWVBFIiwic2V0Q29udGVudFR5cGVJZlVuc2V0IiwidHJhbnNmb3JtUmVxdWVzdCIsInRyYW5zZm9ybVJlc3BvbnNlIiwicGF0Y2giLCJwb3N0IiwicHV0IiwieHNyZkNvb2tpZU5hbWUiLCJ4c3JmSGVhZGVyTmFtZSIsIm1heENvbnRlbnRMZW5ndGgiLCJ2YWxpZGF0ZVN0YXR1cyIsIm5vcm1hbGl6ZWROYW1lIiwicHJvY2Vzc0hlYWRlciIsImhhbmRsZXJzIiwidXNlIiwiZWplY3QiLCJmb3JFYWNoSGFuZGxlciIsInRyYW5zZm9ybURhdGEiLCJjbGVhbkhlYWRlckNvbmZpZyIsImFkYXB0ZXIiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJyZWplY3QiLCJmbnMiLCJzZXR0bGUiLCJidWlsZFVSTCIsInBhcnNlSGVhZGVycyIsImlzVVJMU2FtZU9yaWdpbiIsImNyZWF0ZUVycm9yIiwieGhyQWRhcHRlciIsImRpc3BhdGNoWGhyUmVxdWVzdCIsInJlcXVlc3REYXRhIiwicmVxdWVzdEhlYWRlcnMiLCJsb2FkRXZlbnQiLCJ4RG9tYWluIiwib25wcm9ncmVzcyIsImhhbmRsZVByb2dyZXNzIiwib250aW1lb3V0IiwiaGFuZGxlVGltZW91dCIsImF1dGgiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiQXV0aG9yaXphdGlvbiIsInBhcmFtcyIsInBhcmFtc1NlcmlhbGl6ZXIiLCJoYW5kbGVMb2FkIiwicmVzcG9uc2VIZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwicmVzcG9uc2VEYXRhIiwic3RhdHVzVGV4dCIsImhhbmRsZUVycm9yIiwiY29va2llcyIsInhzcmZWYWx1ZSIsInJlYWQiLCJvbkRvd25sb2FkUHJvZ3Jlc3MiLCJvblVwbG9hZFByb2dyZXNzIiwidXBsb2FkIiwiZW5oYW5jZUVycm9yIiwic2VyaWFsaXplZFBhcmFtcyIsInBhcnNlVmFsdWUiLCJ0b0lTT1N0cmluZyIsInN0YW5kYXJkQnJvd3NlckVudiIsIm1zaWUiLCJ1cmxQYXJzaW5nTm9kZSIsIm9yaWdpblVSTCIsInJlc29sdmVVUkwiLCJzZWFyY2giLCJwYXRobmFtZSIsInJlcXVlc3RVUkwiLCJub25TdGFuZGFyZEJyb3dzZXJFbnYiLCJibG9jayIsImV4cGlyZXMiLCJkb21haW4iLCJjb29raWUiLCJ0b0dNVFN0cmluZyIsInJlbGF0aXZlVVJMIiwiSU5JVElBTF9SRVNVTFQiLCJQT1NUX01FU1NBR0UiLCJSRUNFSVZFX01FU1NBR0UiLCJVUERBVEUiLCJtb2R1bGVzIiwibWVkaWFRdWVyeSIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7QUMxQkE7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7OztBQUVBLEtBQUlBLFFBQVEsNENBRVYsaURBRlUsQ0FBWixDLENBckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFpQkEsdUJBQ0U7QUFBQTtBQUFBLEtBQVUsT0FBT0EsS0FBakI7QUFDRTtBQURGLEVBREYsRUFJRUMsU0FBU0MsY0FBVCxDQUF3QixLQUF4QixDQUpGLEU7Ozs7OztBQzFCQTs7QUFFQUMsUUFBT0MsT0FBUCxHQUFpQixtQkFBQUMsQ0FBUSxDQUFSLENBQWpCLEM7Ozs7OztBQ0ZBOzs7Ozs7Ozs7OztBQVdBOztBQUVBLEtBQUlDLFVBQVUsbUJBQUFELENBQVEsQ0FBUixDQUFkOztBQUVBLEtBQUlFLGdCQUFnQixtQkFBQUYsQ0FBUSxDQUFSLENBQXBCO0FBQ0EsS0FBSUcsaUJBQWlCLG1CQUFBSCxDQUFRLEVBQVIsQ0FBckI7QUFDQSxLQUFJSSxxQkFBcUIsbUJBQUFKLENBQVEsRUFBUixDQUF6QjtBQUNBLEtBQUlLLGFBQWEsbUJBQUFMLENBQVEsRUFBUixDQUFqQjtBQUNBLEtBQUlNLG9CQUFvQixtQkFBQU4sQ0FBUSxFQUFSLENBQXhCO0FBQ0EsS0FBSU8sZUFBZSxtQkFBQVAsQ0FBUSxDQUFSLENBQW5CO0FBQ0EsS0FBSVEsaUJBQWlCLG1CQUFBUixDQUFRLEVBQVIsQ0FBckI7QUFD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QixJQUFkO0FBQ0UsVUFBSyxnQkFBTDtBQUNFLGNBQU8wNUIsT0FBT3QrQixNQUFkO0FBQ0YsVUFBSyxRQUFMO0FBQ0UsMkJBQ0t5USxLQURMLHNCQUVHNnRCLE9BQU91MkQsSUFBUCxDQUFZMzVFLEVBRmYsRUFFcUJvakIsT0FBT3UyRCxJQUY1QjtBQUlGO0FBQ0UsY0FBT3BrRixLQUFQO0FBVEo7QUFXRDs7bUJBRWMsNEJBQWdCO0FBQzdCaWtGLGVBRDZCO0FBRTdCOEw7QUFGNkIsRUFBaEIsQyIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDU3ZjQ0OWE0N2M3NDM5NDE5YTNjXG4gKiovIiwiLy8gaW1wb3J0IGlvIGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xuLy9cbi8vIGxldCBzb2NrZXQgPSBpbygpO1xuLy9cbi8vIHNvY2tldC5vbignY29ubmVjdGlvbicsIHMgPT4ge1xuLy8gICBjb25zb2xlLmxvZygnYSB1c2VyIGNvbm5lY3RlZCcpO1xuLy8gICBzLm9uKCdkaXNjb25uZWN0JywgZnVuY3Rpb24oKXtcbi8vICAgICBjb25zb2xlLmxvZygndXNlciBkaXNjb25uZWN0ZWQnKTtcbi8vICAgfSk7XG4vLyB9KTtcblxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgY3JlYXRlU3RvcmUsIGFwcGx5TWlkZGxld2FyZSB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB0aHVua01pZGRsZXdhcmUgZnJvbSAncmVkdXgtdGh1bmsnO1xuXG5pbXBvcnQgQXBwIGZyb20gJy4vY29tcG9uZW50cy9BcHAnO1xuaW1wb3J0IHJlZHVjZXIgZnJvbSAnLi9yZWR1Y2Vycyc7XG5cbmxldCBzdG9yZSA9IGNyZWF0ZVN0b3JlKFxuICByZWR1Y2VyLFxuICBhcHBseU1pZGRsZXdhcmUodGh1bmtNaWRkbGV3YXJlKVxuKTtcblxucmVuZGVyKFxuICA8UHJvdmlkZXIgc3RvcmU9e3N0b3JlfT5cbiAgICA8QXBwIC8+XG4gIDwvUHJvdmlkZXI+LFxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJylcbik7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdCcpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L3JlYWN0LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW4nKTtcbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdFB1cmVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0UHVyZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKCcuL1JlYWN0Q2xhc3MnKTtcbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IHJlcXVpcmUoJy4vUmVhY3RET01GYWN0b3JpZXMnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBvbmx5Q2hpbGQgPSByZXF1aXJlKCcuL29ubHlDaGlsZCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQ7XG52YXIgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xudmFyIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQ7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xuICBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQ7XG4gIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbiAgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNsb25lRWxlbWVudDtcbn1cblxudmFyIF9fc3ByZWFkID0gX2Fzc2lnbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh3YXJuZWQsICdSZWFjdC5fX3NwcmVhZCBpcyBkZXByZWNhdGVkIGFuZCBzaG91bGQgbm90IGJlIHVzZWQuIFVzZSAnICsgJ09iamVjdC5hc3NpZ24gZGlyZWN0bHkgb3IgYW5vdGhlciBoZWxwZXIgZnVuY3Rpb24gd2l0aCBzaW1pbGFyICcgKyAnc2VtYW50aWNzLiBZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIHlvdXIgY29tcGlsZXIuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtc3ByZWFkLWRlcHJlY2F0aW9uIGZvciBtb3JlIGRldGFpbHMuJykgOiB2b2lkIDA7XG4gICAgd2FybmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gX2Fzc2lnbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgUmVhY3QgPSB7XG5cbiAgLy8gTW9kZXJuXG5cbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IFJlYWN0Q2hpbGRyZW4ubWFwLFxuICAgIGZvckVhY2g6IFJlYWN0Q2hpbGRyZW4uZm9yRWFjaCxcbiAgICBjb3VudDogUmVhY3RDaGlsZHJlbi5jb3VudCxcbiAgICB0b0FycmF5OiBSZWFjdENoaWxkcmVuLnRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUmVhY3RQdXJlQ29tcG9uZW50LFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxuICBpc1ZhbGlkRWxlbWVudDogUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50LFxuXG4gIC8vIENsYXNzaWNcblxuICBQcm9wVHlwZXM6IFJlYWN0UHJvcFR5cGVzLFxuICBjcmVhdGVDbGFzczogUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyxcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeSxcbiAgY3JlYXRlTWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIC8vIEN1cnJlbnRseSBhIG5vb3AuIFdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBhbmQgdHJhY2UgbWl4aW5zLlxuICAgIHJldHVybiBtaXhpbjtcbiAgfSxcblxuICAvLyBUaGlzIGxvb2tzIERPTSBzcGVjaWZpYyBidXQgdGhlc2UgYXJlIGFjdHVhbGx5IGlzb21vcnBoaWMgaGVscGVyc1xuICAvLyBzaW5jZSB0aGV5IGFyZSBqdXN0IGdlbmVyYXRpbmcgRE9NIHN0cmluZ3MuXG4gIERPTTogUmVhY3RET01GYWN0b3JpZXMsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8vIERlcHJlY2F0ZWQgaG9vayBmb3IgSlNYIHNwcmVhZCwgZG9uJ3QgdXNlIHRoaXMgZm9yIGFueXRoaW5nLlxuICBfX3NwcmVhZDogX19zcHJlYWRcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdC5qc1xuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L29iamVjdC1hc3NpZ24vaW5kZXguanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXI7XG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIHRyYXZlcnNhbC4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBGb3JFYWNoQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBmb3JFYWNoRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSB0cmF2ZXJzYWwgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBjb250ZXh0IHdpdGguXG4gKi9cbmZ1bmN0aW9uIEZvckVhY2hCb29rS2VlcGluZyhmb3JFYWNoRnVuY3Rpb24sIGZvckVhY2hDb250ZXh0KSB7XG4gIHRoaXMuZnVuYyA9IGZvckVhY2hGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gZm9yRWFjaENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuRm9yRWFjaEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRm9yRWFjaEJvb2tLZWVwaW5nLCB0d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZChib29rS2VlcGluZywgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jO1xuICB2YXIgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IEZvckVhY2hCb29rS2VlcGluZy5nZXRQb29sZWQoZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICBGb3JFYWNoQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogbWFwcGluZy4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBNYXBCb29rS2VlcGluZ1xuICogQHBhcmFtIHshKn0gbWFwUmVzdWx0IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICogQHBhcmFtIHshZnVuY3Rpb259IG1hcEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICogQHBhcmFtIHs/Kn0gbWFwQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICovXG5mdW5jdGlvbiBNYXBCb29rS2VlcGluZyhtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgdGhpcy5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICB0aGlzLmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5NYXBCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZXN1bHQgPSBudWxsO1xuICB0aGlzLmtleVByZWZpeCA9IG51bGw7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhNYXBCb29rS2VlcGluZywgZm91ckFyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQ7XG4gIHZhciBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXg7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYztcbiAgdmFyIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBNYXBCb29rS2VlcGluZy5nZXRQb29sZWQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICBNYXBCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZER1bW15LCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4udG9hcnJheVxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHtcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBtYXA6IG1hcENoaWxkcmVuLFxuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsOiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBQb29sZWRDbGFzc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG52YXIgZml2ZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IF9wcm9kSW52YXJpYW50KCcyNScpIDogdm9pZCAwO1xuICBpbnN0YW5jZS5kZXN0cnVjdG9yKCk7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29weUNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb29sZXIgQ3VzdG9taXphYmxlIHBvb2xlci5cbiAqL1xudmFyIGFkZFBvb2xpbmdUbyA9IGZ1bmN0aW9uIChDb3B5Q29uc3RydWN0b3IsIHBvb2xlcikge1xuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXIsXG4gIGZpdmVBcmd1bWVudFBvb2xlcjogZml2ZUFyZ3VtZW50UG9vbGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHJlYWN0UHJvZEludmFyaWFudFxuICogXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbmZ1bmN0aW9uIHJlYWN0UHJvZEludmFyaWFudChjb2RlKSB7XG4gIHZhciBhcmdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuXG4gIHZhciBtZXNzYWdlID0gJ01pbmlmaWVkIFJlYWN0IGVycm9yICMnICsgY29kZSArICc7IHZpc2l0ICcgKyAnaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9JyArIGNvZGU7XG5cbiAgZm9yICh2YXIgYXJnSWR4ID0gMDsgYXJnSWR4IDwgYXJnQ291bnQ7IGFyZ0lkeCsrKSB7XG4gICAgbWVzc2FnZSArPSAnJmFyZ3NbXT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1thcmdJZHggKyAxXSk7XG4gIH1cblxuICBtZXNzYWdlICs9ICcgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50JyArICcgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJztcblxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCByZWFjdFByb2RJbnZhcmlhbnQncyBvd24gZnJhbWVcblxuICB0aHJvdyBlcnJvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdFByb2RJbnZhcmlhbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9yZWFjdFByb2RJbnZhcmlhbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9pbnZhcmlhbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudCB0eXBlLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSB8fCAweGVhYzc7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG5cbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgbm8gaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuICAgIHZhciBzaGFkb3dDaGlsZHJlbiA9IEFycmF5LmlzQXJyYXkocHJvcHMuY2hpbGRyZW4pID8gcHJvcHMuY2hpbGRyZW4uc2xpY2UoMCkgOiBwcm9wcy5jaGlsZHJlbjtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNlbGZcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2hhZG93Q2hpbGRyZW4nLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzaGFkb3dDaGlsZHJlblxuICAgICAgfSk7XG4gICAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgIGVsZW1lbnQuX3NlbGYgPSBzZWxmO1xuICAgICAgZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4gPSBzaGFkb3dDaGlsZHJlbjtcbiAgICAgIGVsZW1lbnQuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZWxlbWVudFxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICAgICAgY29uZmlnLl9fcHJvdG9fXyA9PSBudWxsIHx8IGNvbmZpZy5fX3Byb3RvX18gPT09IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gICAgICAnUmVhY3QuY3JlYXRlRWxlbWVudCguLi4pOiBFeHBlY3RlZCBwcm9wcyBhcmd1bWVudCB0byBiZSBhIHBsYWluIG9iamVjdC4gJyArICdQcm9wZXJ0aWVzIGRlZmluZWQgaW4gaXRzIHByb3RvdHlwZSBjaGFpbiB3aWxsIGJlIGlnbm9yZWQuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZmFjdG9yeVxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBmYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgLy8gRXhwb3NlIHRoZSB0eXBlIG9uIHRoZSBmYWN0b3J5IGFuZCB0aGUgcHJvdG90eXBlIHNvIHRoYXQgaXQgY2FuIGJlXG4gIC8vIGVhc2lseSBhY2Nlc3NlZCBvbiBlbGVtZW50cy4gRS5nLiBgPEZvbyAvPi50eXBlID09PSBGb29gLlxuICAvLyBUaGlzIHNob3VsZCBub3QgYmUgbmFtZWQgYGNvbnN0cnVjdG9yYCBzaW5jZSB0aGlzIG1heSBub3QgYmUgdGhlIGZ1bmN0aW9uXG4gIC8vIHRoYXQgY3JlYXRlZCB0aGUgZWxlbWVudCwgYW5kIGl0IG1heSBub3QgZXZlbiBiZSBhIGNvbnN0cnVjdG9yLlxuICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgZmFjdG9yeS50eXBlID0gdHlwZTtcbiAgcmV0dXJuIGZhY3Rvcnk7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5ID0gZnVuY3Rpb24gKG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufTtcblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jbG9uZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICAgICAgY29uZmlnLl9fcHJvdG9fXyA9PSBudWxsIHx8IGNvbmZpZy5fX3Byb3RvX18gPT09IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gICAgICAnUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IEV4cGVjdGVkIHByb3BzIGFyZ3VtZW50IHRvIGJlIGEgcGxhaW4gb2JqZWN0LiAnICsgJ1Byb3BlcnRpZXMgZGVmaW5lZCBpbiBpdHMgcHJvdG90eXBlIGNoYWluIHdpbGwgYmUgaWdub3JlZC4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5pc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufTtcblxuUmVhY3RFbGVtZW50LlJFQUNUX0VMRU1FTlRfVFlQRSA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDdXJyZW50T3duZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEN1cnJlbnRPd25lcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH07XG5cbiAgICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi93YXJuaW5nLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjYW5EZWZpbmVQcm9wZXJ0eVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gZmFsc2U7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7IGdldDogZnVuY3Rpb24gKCkge30gfSk7XG4gICAgY2FuRGVmaW5lUHJvcGVydHkgPSB0cnVlO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gSUUgd2lsbCBmYWlsIG9uIGRlZmluZVByb3BlcnR5XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW5EZWZpbmVQcm9wZXJ0eTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHRyYXZlcnNlQWxsQ2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAoY29tcG9uZW50ICYmIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBLZXlFc2NhcGVVdGlscy5lc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnJztcbiAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgICBpZiAobWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIEtleUVzY2FwZVV0aWxzLmVzY2FwZShlbnRyeVswXSkgKyBTVUJTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIDApO1xuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQgb3Igd3JhcCB0aGUgb2JqZWN0IHVzaW5nIGNyZWF0ZUZyYWdtZW50KG9iamVjdCkgZnJvbSB0aGUgJyArICdSZWFjdCBhZGQtb25zLic7XG4gICAgICAgIGlmIChjaGlsZHJlbi5faXNSZWFjdEVsZW1lbnQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyBhbiBlbGVtZW50IGNyZWF0ZWQgYnkgYSBkaWZmZXJlbnQgJyArICd2ZXJzaW9uIG9mIFJlYWN0LiBNYWtlIHN1cmUgdG8gdXNlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtICs9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IF9wcm9kSW52YXJpYW50KCczMScsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0SXRlcmF0b3JGblxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgU3ltYm9sICovXG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4vKipcbiAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAqXG4gKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAqXG4gKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gKiAgICAgICAuLi5cbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEl0ZXJhdG9yRm47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEtleUVzY2FwZVV0aWxzXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSAoJycgKyBrZXkpLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG5cbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG5cbi8qKlxuICogVW5lc2NhcGUgYW5kIHVud3JhcCBrZXkgZm9yIGh1bWFuLXJlYWRhYmxlIGRpc3BsYXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIHVuZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgdW5lc2NhcGVkIGtleS5cbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGUoa2V5KSB7XG4gIHZhciB1bmVzY2FwZVJlZ2V4ID0gLyg9MHw9MikvZztcbiAgdmFyIHVuZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPTAnOiAnPScsXG4gICAgJz0yJzogJzonXG4gIH07XG4gIHZhciBrZXlTdWJzdHJpbmcgPSBrZXlbMF0gPT09ICcuJyAmJiBrZXlbMV0gPT09ICckJyA/IGtleS5zdWJzdHJpbmcoMikgOiBrZXkuc3Vic3RyaW5nKDEpO1xuXG4gIHJldHVybiAoJycgKyBrZXlTdWJzdHJpbmcpLnJlcGxhY2UodW5lc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIHVuZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xufVxuXG52YXIgS2V5RXNjYXBlVXRpbHMgPSB7XG4gIGVzY2FwZTogZXNjYXBlLFxuICB1bmVzY2FwZTogdW5lc2NhcGVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5RXNjYXBlVXRpbHM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9LZXlFc2NhcGVVdGlscy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Q29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IF9wcm9kSW52YXJpYW50KCc4NScpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pIDogdm9pZCAwO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3ROb29wVXBkYXRlUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaykge30sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvZW1wdHlPYmplY3QuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQdXJlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBSZWFjdFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgLy8gRHVwbGljYXRlZCBmcm9tIFJlYWN0Q29tcG9uZW50LlxuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gUmVhY3RDb21wb25lbnQucHJvdG90eXBlO1xuUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xuUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlYWN0UHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihSZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUpO1xuUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQdXJlQ29tcG9uZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RQdXJlQ29tcG9uZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2xhc3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgTUlYSU5TX0tFWSA9IGtleU9mKHsgbWl4aW5zOiBudWxsIH0pO1xuXG4vKipcbiAqIFBvbGljaWVzIHRoYXQgZGVzY3JpYmUgbWV0aG9kcyBpbiBgUmVhY3RDbGFzc0ludGVyZmFjZWAuXG4gKi9cbnZhciBTcGVjUG9saWN5ID0ga2V5TWlycm9yKHtcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIGRlZmluZWQgb25seSBvbmNlIGJ5IHRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIG9yIG1peGluLlxuICAgKi9cbiAgREVGSU5FX09OQ0U6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBkZWZpbmVkIGJ5IGJvdGggdGhlIGNsYXNzIHNwZWNpZmljYXRpb24gYW5kIG1peGlucy5cbiAgICogU3Vic2VxdWVudCBkZWZpbml0aW9ucyB3aWxsIGJlIGNoYWluZWQuIFRoZXNlIG1ldGhvZHMgbXVzdCByZXR1cm4gdm9pZC5cbiAgICovXG4gIERFRklORV9NQU5ZOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBhcmUgb3ZlcnJpZGluZyB0aGUgYmFzZSBjbGFzcy5cbiAgICovXG4gIE9WRVJSSURFX0JBU0U6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIGFyZSBzaW1pbGFyIHRvIERFRklORV9NQU5ZLCBleGNlcHQgd2UgYXNzdW1lIHRoZXkgcmV0dXJuXG4gICAqIG9iamVjdHMuIFdlIHRyeSB0byBtZXJnZSB0aGUga2V5cyBvZiB0aGUgcmV0dXJuIHZhbHVlcyBvZiBhbGwgdGhlIG1peGVkIGluXG4gICAqIGZ1bmN0aW9ucy4gSWYgdGhlcmUgaXMgYSBrZXkgY29uZmxpY3Qgd2UgdGhyb3cuXG4gICAqL1xuICBERUZJTkVfTUFOWV9NRVJHRUQ6IG51bGxcbn0pO1xuXG52YXIgaW5qZWN0ZWRNaXhpbnMgPSBbXTtcblxuLyoqXG4gKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICogb3IgaG9zdCBjb21wb25lbnRzLlxuICpcbiAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENsYXNzYCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcbiAqIHlvdXIgbmV3IGNsYXNzIHRvIGBSZWFjdC5jcmVhdGVDbGFzc2AuIFRoZSBvbmx5IHJlcXVpcmVtZW50IG9mIHlvdXIgY2xhc3NcbiAqIHNwZWNpZmljYXRpb24gaXMgdGhhdCB5b3UgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIHN1cHBvcnRzIGEgc3BlY2lmaWMgcHJvdG9jb2wgb2YgbWV0aG9kcyB0aGF0IGhhdmVcbiAqIHNwZWNpYWwgbWVhbmluZyAoZS5nLiBgcmVuZGVyYCkuIFNlZSBgUmVhY3RDbGFzc0ludGVyZmFjZWAgZm9yXG4gKiBtb3JlIHRoZSBjb21wcmVoZW5zaXZlIHByb3RvY29sLiBBbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGVcbiAqIGNsYXNzIHNwZWNpZmljYXRpb24gd2lsbCBiZSBhdmFpbGFibGUgb24gdGhlIHByb3RvdHlwZS5cbiAqXG4gKiBAaW50ZXJmYWNlIFJlYWN0Q2xhc3NJbnRlcmZhY2VcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RDbGFzc0ludGVyZmFjZSA9IHtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHthcnJheX1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBtaXhpbnM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdGhhdCBzaG91bGQgYmUgZGVmaW5lZCBvblxuICAgKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgaW5zdGVhZCBvZiBpdHMgcHJvdG90eXBlIChzdGF0aWMgbWV0aG9kcykuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc3RhdGljczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBwcm9wIHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBwcm9wVHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29udGV4dFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgdGhpcyBjb21wb25lbnQgc2V0cyBmb3IgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVmFsdWVzIGluIHRoZSBtYXBwaW5nIHdpbGwgYmUgc2V0IG9uXG4gICAqIGB0aGlzLnByb3BzYCBpZiB0aGF0IHByb3AgaXMgbm90IHNwZWNpZmllZCAoaS5lLiB1c2luZyBhbiBgaW5gIGNoZWNrKS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBiZWZvcmUgYGdldEluaXRpYWxTdGF0ZWAgYW5kIHRoZXJlZm9yZSBjYW5ub3QgcmVseVxuICAgKiBvbiBgdGhpcy5zdGF0ZWAgb3IgdXNlIGB0aGlzLnNldFN0YXRlYC5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgKiBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgdGhpcy5zdGF0ZWAuXG4gICAqXG4gICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiB7XG4gICAqICAgICAgIGlzT246IGZhbHNlLFxuICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldEluaXRpYWxTdGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRDaGlsZENvbnRleHQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBVc2VzIHByb3BzIGZyb20gYHRoaXMucHJvcHNgIGFuZCBzdGF0ZSBmcm9tIGB0aGlzLnN0YXRlYCB0byByZW5kZXIgdGhlXG4gICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBObyBndWFyYW50ZWVzIGFyZSBtYWRlIGFib3V0IHdoZW4gb3IgaG93IG9mdGVuIHRoaXMgbWV0aG9kIGlzIGludm9rZWQsIHNvXG4gICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxuICAgKlxuICAgKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICogICAgIHJldHVybiA8ZGl2PkhlbGxvLCB7bmFtZX0hPC9kaXY+O1xuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gICAqIEBub3NpZGVlZmZlY3RzXG4gICAqIEByZXF1aXJlZFxuICAgKi9cbiAgcmVuZGVyOiBTcGVjUG9saWN5LkRFRklORV9PTkNFLFxuXG4gIC8vID09PT0gRGVsZWdhdGUgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGluaXRpYWxseSBjcmVhdGVkIGFuZCBhYm91dCB0byBiZSBtb3VudGVkLlxuICAgKiBUaGlzIG1heSBoYXZlIHNpZGUgZWZmZWN0cywgYnV0IGFueSBleHRlcm5hbCBzdWJzY3JpcHRpb25zIG9yIGRhdGEgY3JlYXRlZFxuICAgKiBieSB0aGlzIG1ldGhvZCBtdXN0IGJlIGNsZWFuZWQgdXAgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsTW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgYW5kIGhhcyBhIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICogSG93ZXZlciwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIERPTSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiBtb3VudGVkIChpbml0aWFsaXplZCBhbmQgcmVuZGVyZWQpIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHMuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHJlYWN0IHRvIGEgcHJvcCB0cmFuc2l0aW9uIGJ5IHVwZGF0aW5nIHRoZVxuICAgKiBzdGF0ZSB1c2luZyBgdGhpcy5zZXRTdGF0ZWAuIEN1cnJlbnQgcHJvcHMgYXJlIGFjY2Vzc2VkIHZpYSBgdGhpcy5wcm9wc2AuXG4gICAqXG4gICAqICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAqICAgICAgIGxpa2VzSW5jcmVhc2luZzogbmV4dFByb3BzLmxpa2VDb3VudCA+IHRoaXMucHJvcHMubGlrZUNvdW50XG4gICAqICAgICB9KTtcbiAgICogICB9XG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGVxdWl2YWxlbnQgYGNvbXBvbmVudFdpbGxSZWNlaXZlU3RhdGVgLiBBbiBpbmNvbWluZyBwcm9wXG4gICAqIHRyYW5zaXRpb24gbWF5IGNhdXNlIGEgc3RhdGUgY2hhbmdlLCBidXQgdGhlIG9wcG9zaXRlIGlzIG5vdCB0cnVlLiBJZiB5b3VcbiAgICogbmVlZCBpdCwgeW91IGFyZSBwcm9iYWJseSBsb29raW5nIGZvciBgY29tcG9uZW50V2lsbFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoaWxlIGRlY2lkaW5nIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHVwZGF0ZWQgYXMgYSByZXN1bHQgb2ZcbiAgICogcmVjZWl2aW5nIG5ldyBwcm9wcywgc3RhdGUgYW5kL29yIGNvbnRleHQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGByZXR1cm4gZmFsc2VgIHdoZW4geW91J3JlIGNlcnRhaW4gdGhhdCB0aGVcbiAgICogdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzL3N0YXRlL2NvbnRleHQgd2lsbCBub3QgcmVxdWlyZSBhIGNvbXBvbmVudFxuICAgKiB1cGRhdGUuXG4gICAqXG4gICAqICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHJldHVybiAhZXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IHNob3VsZCB1cGRhdGUuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9PTkNFLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byB1cGRhdGUgZHVlIHRvIGEgdHJhbnNpdGlvbiBmcm9tXG4gICAqIGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YCB0byBgbmV4dFByb3BzYCwgYG5leHRTdGF0ZWBcbiAgICogYW5kIGBuZXh0Q29udGV4dGAuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHBlcmZvcm0gcHJlcGFyYXRpb24gYmVmb3JlIGFuIHVwZGF0ZSBvY2N1cnMuXG4gICAqXG4gICAqIE5PVEU6IFlvdSAqKmNhbm5vdCoqIHVzZSBgdGhpcy5zZXRTdGF0ZSgpYCBpbiB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCdzIERPTSByZXByZXNlbnRhdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q29udGV4dFxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgYW5kIGhhdmVcbiAgICogaXRzIERPTSByZXByZXNlbnRhdGlvbiBkZXN0cm95ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGRlYWxsb2NhdGUgYW55IGV4dGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gYGNvbXBvbmVudERpZFVubW91bnRgIHNpbmNlIHlvdXIgY29tcG9uZW50IHdpbGwgaGF2ZSBiZWVuXG4gICAqIGRlc3Ryb3llZCBieSB0aGF0IHBvaW50LlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogU3BlY1BvbGljeS5PVkVSUklERV9CQVNFXG5cbn07XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGNsYXNzIHNwZWNpZmljYXRpb24ga2V5cyB0byBzcGVjaWFsIHByb2Nlc3NpbmcgZnVuY3Rpb25zLlxuICpcbiAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cbiAqIHdoZW4gZGVmaW5pbmcgY2xhc3NlcyB1c2luZyBgUmVhY3QuY3JlYXRlQ2xhc3NgLCB0aGV5IGFyZSBhY3R1YWxseSBzdGF0aWNcbiAqIGFuZCBhcmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZCBvZiB0aGUgcHJvdG90eXBlLiBEZXNwaXRlXG4gKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxuICogd2hpY2ggYWxsIG90aGVyIHN0YXRpYyBtZXRob2RzIGFyZSBkZWZpbmVkLlxuICovXG52YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xuICBkaXNwbGF5TmFtZTogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBkaXNwbGF5TmFtZSkge1xuICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIH0sXG4gIG1peGluczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICBpZiAobWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY2hpbGRDb250ZXh0KTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0VHlwZXMpO1xuICB9LFxuICBjb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHQpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsIGNvbnRleHRUeXBlcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBTcGVjaWFsIGNhc2UgZ2V0RGVmYXVsdFByb3BzIHdoaWNoIHNob3VsZCBtb3ZlIGludG8gc3RhdGljcyBidXQgcmVxdWlyZXNcbiAgICogYXV0b21hdGljIG1lcmdpbmcuXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24oQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLCBnZXREZWZhdWx0UHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHM7XG4gICAgfVxuICB9LFxuICBwcm9wVHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvcFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMsIHByb3BUeXBlcyk7XG4gIH0sXG4gIHN0YXRpY3M6IGZ1bmN0aW9uIChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICAgIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKTtcbiAgfSxcbiAgYXV0b2JpbmQ6IGZ1bmN0aW9uICgpIHt9IH07XG5cbi8vIG5vb3BcbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgdHlwZURlZiwgbG9jYXRpb24pIHtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdHlwZURlZikge1xuICAgIGlmICh0eXBlRGVmLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgLy8gdXNlIGEgd2FybmluZyBpbnN0ZWFkIG9mIGFuIGludmFyaWFudCBzbyBjb21wb25lbnRzXG4gICAgICAvLyBkb24ndCBzaG93IHVwIGluIHByb2QgYnV0IG9ubHkgaW4gX19ERVZfX1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIHR5cGVEZWZbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ1JlYWN0LlByb3BUeXBlcy4nLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpIHtcbiAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpID8gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXSA6IG51bGw7XG5cbiAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKFJlYWN0Q2xhc3NNaXhpbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICEoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5PVkVSUklERV9CQVNFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgYCVzYCBmcm9tIHlvdXIgY2xhc3Mgc3BlY2lmaWNhdGlvbi4gRW5zdXJlIHRoYXQgeW91ciBtZXRob2QgbmFtZXMgZG8gbm90IG92ZXJsYXAgd2l0aCBSZWFjdCBtZXRob2RzLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzczJywgbmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZIHx8IHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGAlc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc0JywgbmFtZSkgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBNaXhpbiBoZWxwZXIgd2hpY2ggaGFuZGxlcyBwb2xpY3kgdmFsaWRhdGlvbiBhbmQgcmVzZXJ2ZWRcbiAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzZXMuXG4gKi9cbmZ1bmN0aW9uIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKSB7XG4gIGlmICghc3BlYykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgdHlwZW9mU3BlYyA9IHR5cGVvZiBzcGVjO1xuICAgICAgdmFyIGlzTWl4aW5WYWxpZCA9IHR5cGVvZlNwZWMgPT09ICdvYmplY3QnICYmIHNwZWMgIT09IG51bGw7XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGlzTWl4aW5WYWxpZCwgJyVzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIGluY2x1ZGUgYSBtaXhpbiB0aGF0IGlzIGVpdGhlciBudWxsICcgKyAnb3Igbm90IGFuIG9iamVjdC4gQ2hlY2sgdGhlIG1peGlucyBpbmNsdWRlZCBieSB0aGUgY29tcG9uZW50LCAnICsgJ2FzIHdlbGwgYXMgYW55IG1peGlucyB0aGV5IGluY2x1ZGUgdGhlbXNlbHZlcy4gJyArICdFeHBlY3RlZCBvYmplY3QgYnV0IGdvdCAlcy4nLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsIHNwZWMgPT09IG51bGwgPyBudWxsIDogdHlwZW9mU3BlYykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgISh0eXBlb2Ygc3BlYyAhPT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byB1c2UgYSBjb21wb25lbnQgY2xhc3Mgb3IgZnVuY3Rpb24gYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IF9wcm9kSW52YXJpYW50KCc3NScpIDogdm9pZCAwO1xuICAhIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzcGVjKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogX3Byb2RJbnZhcmlhbnQoJzc2JykgOiB2b2lkIDA7XG5cbiAgdmFyIHByb3RvID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICB2YXIgYXV0b0JpbmRQYWlycyA9IHByb3RvLl9fcmVhY3RBdXRvQmluZFBhaXJzO1xuXG4gIC8vIEJ5IGhhbmRsaW5nIG1peGlucyBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMsIHdlIGVuc3VyZSB0aGUgc2FtZVxuICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcbiAgLy8gbWl4aW5zIGFyZSBsaXN0ZWQgYmVmb3JlIG9yIGFmdGVyIHRoZXNlIG1ldGhvZHMgaW4gdGhlIHNwZWMuXG4gIGlmIChzcGVjLmhhc093blByb3BlcnR5KE1JWElOU19LRVkpKSB7XG4gICAgUkVTRVJWRURfU1BFQ19LRVlTLm1peGlucyhDb25zdHJ1Y3Rvciwgc3BlYy5taXhpbnMpO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBzcGVjKSB7XG4gICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gTUlYSU5TX0tFWSkge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWQgbWl4aW5zIGluIGEgc3BlY2lhbCBjYXNlIGFib3ZlLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3BlcnR5ID0gc3BlY1tuYW1lXTtcbiAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSk7XG5cbiAgICBpZiAoUkVTRVJWRURfU1BFQ19LRVlTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0dXAgbWV0aG9kcyBvbiBwcm90b3R5cGU6XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcbiAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgLy8gMi4gT3ZlcnJpZGRlbiBtZXRob2RzICh0aGF0IHdlcmUgbWl4ZWQgaW4pLlxuICAgICAgdmFyIGlzUmVhY3RDbGFzc01ldGhvZCA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIHZhciBzaG91bGRBdXRvQmluZCA9IGlzRnVuY3Rpb24gJiYgIWlzUmVhY3RDbGFzc01ldGhvZCAmJiAhaXNBbHJlYWR5RGVmaW5lZCAmJiBzcGVjLmF1dG9iaW5kICE9PSBmYWxzZTtcblxuICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XG4gICAgICAgIGF1dG9CaW5kUGFpcnMucHVzaChuYW1lLCBwcm9wZXJ0eSk7XG4gICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICAgICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXTtcblxuICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlLlxuICAgICAgICAgICEoaXNSZWFjdENsYXNzTWV0aG9kICYmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCB8fCBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogVW5leHBlY3RlZCBzcGVjIHBvbGljeSAlcyBmb3Iga2V5ICVzIHdoZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLCBzcGVjUG9saWN5LCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3NycsIHNwZWNQb2xpY3ksIG5hbWUpIDogdm9pZCAwO1xuXG4gICAgICAgICAgLy8gRm9yIG1ldGhvZHMgd2hpY2ggYXJlIGRlZmluZWQgbW9yZSB0aGFuIG9uY2UsIGNhbGwgdGhlIGV4aXN0aW5nXG4gICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCkge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSkge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcbiAgICAgICAgICAgIC8vIGF0IHByb2ZpbGluZyB0b29scy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbicgJiYgc3BlYy5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICBpZiAoIXN0YXRpY3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgbmFtZSBpbiBzdGF0aWNzKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gc3RhdGljc1tuYW1lXTtcbiAgICBpZiAoIXN0YXRpY3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc1Jlc2VydmVkID0gbmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVM7XG4gICAgISFpc1Jlc2VydmVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYSByZXNlcnZlZCBwcm9wZXJ0eSwgYCVzYCwgdGhhdCBzaG91bGRuXFwndCBiZSBvbiB0aGUgXCJzdGF0aWNzXCIga2V5LiBEZWZpbmUgaXQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3Rvci4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3OCcsIG5hbWUpIDogdm9pZCAwO1xuXG4gICAgdmFyIGlzSW5oZXJpdGVkID0gbmFtZSBpbiBDb25zdHJ1Y3RvcjtcbiAgICAhIWlzSW5oZXJpdGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlIHRvIGEgbWl4aW4uJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzknLCBuYW1lKSA6IHZvaWQgMDtcbiAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHByb3BlcnR5O1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9iamVjdHMsIGJ1dCB0aHJvdyBpZiBib3RoIGNvbnRhaW4gdGhlIHNhbWUga2V5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbmUgVGhlIGZpcnN0IG9iamVjdCwgd2hpY2ggaXMgbXV0YXRlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0d28gVGhlIHNlY29uZCBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdH0gb25lIGFmdGVyIGl0IGhhcyBiZWVuIG11dGF0ZWQgdG8gY29udGFpbiBldmVyeXRoaW5nIGluIHR3by5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhvbmUsIHR3bykge1xuICAhKG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogQ2Fubm90IG1lcmdlIG5vbi1vYmplY3RzLicpIDogX3Byb2RJbnZhcmlhbnQoJzgwJykgOiB2b2lkIDA7XG5cbiAgZm9yICh2YXIga2V5IGluIHR3bykge1xuICAgIGlmICh0d28uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgIShvbmVba2V5XSA9PT0gdW5kZWZpbmVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IFRyaWVkIHRvIG1lcmdlIHR3byBvYmplY3RzIHdpdGggdGhlIHNhbWUga2V5OiBgJXNgLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbjsgaW4gcGFydGljdWxhciwgdGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHR3byBnZXRJbml0aWFsU3RhdGUoKSBvciBnZXREZWZhdWx0UHJvcHMoKSBtZXRob2RzIHJldHVybmluZyBvYmplY3RzIHdpdGggY2xhc2hpbmcga2V5cy4nLCBrZXkpIDogX3Byb2RJbnZhcmlhbnQoJzgxJywga2V5KSA6IHZvaWQgMDtcbiAgICAgIG9uZVtrZXldID0gdHdvW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvbmU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBtZXJnZXMgdGhlaXIgcmV0dXJuIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZFJlc3VsdCgpIHtcbiAgICB2YXIgYSA9IG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICB2YXIgYyA9IHt9O1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYSk7XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBiKTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGJvdW5kIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG4gIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gbnVsbDtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuICAgIGJvdW5kTWV0aG9kLmJpbmQgPSBmdW5jdGlvbiAobmV3VGhpcykge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuICAgICAgLy8gaWdub3JlIHRoZSB2YWx1ZSBvZiBcInRoaXNcIiB0aGF0IHRoZSB1c2VyIGlzIHRyeWluZyB0byB1c2UsIHNvXG4gICAgICAvLyBsZXQncyB3YXJuLlxuICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBSZWFjdCBjb21wb25lbnQgbWV0aG9kcyBtYXkgb25seSBiZSBib3VuZCB0byB0aGUgJyArICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgICAgfSBlbHNlIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFlvdSBhcmUgYmluZGluZyBhIGNvbXBvbmVudCBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC4gJyArICdSZWFjdCBkb2VzIHRoaXMgZm9yIHlvdSBhdXRvbWF0aWNhbGx5IGluIGEgaGlnaC1wZXJmb3JtYW5jZSAnICsgJ3dheSwgc28geW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgICAgIH1cbiAgICAgIHZhciByZWJvdW5kTWV0aG9kID0gX2JpbmQuYXBwbHkoYm91bmRNZXRob2QsIGFyZ3VtZW50cyk7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gYXJncztcbiAgICAgIHJldHVybiByZWJvdW5kTWV0aG9kO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJvdW5kTWV0aG9kO1xufVxuXG4vKipcbiAqIEJpbmRzIGFsbCBhdXRvLWJvdW5kIG1ldGhvZHMgaW4gYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2RzKGNvbXBvbmVudCkge1xuICB2YXIgcGFpcnMgPSBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kUGFpcnM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgYXV0b0JpbmRLZXkgPSBwYWlyc1tpXTtcbiAgICB2YXIgbWV0aG9kID0gcGFpcnNbaSArIDFdO1xuICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0gPSBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpO1xuICB9XG59XG5cbi8qKlxuICogQWRkIG1vcmUgdG8gdGhlIFJlYWN0Q2xhc3MgYmFzZSBjbGFzcy4gVGhlc2UgYXJlIGFsbCBsZWdhY3kgZmVhdHVyZXMgYW5kXG4gKiB0aGVyZWZvcmUgbm90IGFscmVhZHkgcGFydCBvZiB0aGUgbW9kZXJuIFJlYWN0Q29tcG9uZW50LlxuICovXG52YXIgUmVhY3RDbGFzc01peGluID0ge1xuXG4gIC8qKlxuICAgKiBUT0RPOiBUaGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBiZWNhdXNlIHN0YXRlIHNob3VsZCBhbHdheXMga2VlcCBhIGNvbnNpc3RlbnRcbiAgICogdHlwZSBzaWduYXR1cmUgYW5kIHRoZSBvbmx5IHVzZSBjYXNlIGZvciB0aGlzLCBpcyB0byBhdm9pZCB0aGF0LlxuICAgKi9cbiAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAobmV3U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUodGhpcywgbmV3U3RhdGUpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZXIuaXNNb3VudGVkKHRoaXMpO1xuICB9XG59O1xuXG52YXIgUmVhY3RDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHt9O1xuX2Fzc2lnbihSZWFjdENsYXNzQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENsYXNzTWl4aW4pO1xuXG4vKipcbiAqIE1vZHVsZSBmb3IgY3JlYXRpbmcgY29tcG9zaXRlIGNvbXBvbmVudHMuXG4gKlxuICogQGNsYXNzIFJlYWN0Q2xhc3NcbiAqL1xudmFyIFJlYWN0Q2xhc3MgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgY29tcG9uZW50IGNsYXNzIGdpdmVuIGEgY2xhc3Mgc3BlY2lmaWNhdGlvbi5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIENsYXNzIHNwZWNpZmljYXRpb24gKHdoaWNoIG11c3QgZGVmaW5lIGByZW5kZXJgKS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IENvbXBvbmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlQ2xhc3M6IGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGdldHMgb3ZlcnJpZGRlbiBieSBtb2Nrcy4gVGhlIGFyZ3VtZW50IGlzIHVzZWRcbiAgICAgIC8vIGJ5IG1vY2tzIHRvIGFzc2VydCBvbiB3aGF0IGdldHMgbW91bnRlZC5cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodGhpcyBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLCAnU29tZXRoaW5nIGlzIGNhbGxpbmcgYSBSZWFjdCBjb21wb25lbnQgZGlyZWN0bHkuIFVzZSBhIGZhY3Rvcnkgb3IgJyArICdKU1ggaW5zdGVhZC4gU2VlOiBodHRwczovL2ZiLm1lL3JlYWN0LWxlZ2FjeWZhY3RvcnknKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgLy8gV2lyZSB1cCBhdXRvLWJpbmRpbmdcbiAgICAgIGlmICh0aGlzLl9fcmVhY3RBdXRvQmluZFBhaXJzLmxlbmd0aCkge1xuICAgICAgICBiaW5kQXV0b0JpbmRNZXRob2RzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG4gICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblxuICAgICAgLy8gUmVhY3RDbGFzc2VzIGRvZXNuJ3QgaGF2ZSBjb25zdHJ1Y3RvcnMuIEluc3RlYWQsIHRoZXkgdXNlIHRoZVxuICAgICAgLy8gZ2V0SW5pdGlhbFN0YXRlIGFuZCBjb21wb25lbnRXaWxsTW91bnQgbWV0aG9kcyBmb3IgaW5pdGlhbGl6YXRpb24uXG5cbiAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldEluaXRpYWxTdGF0ZS5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRJbml0aWFsU3RhdGUoKTogbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwnLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCc4MicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIH07XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3IFJlYWN0Q2xhc3NDb21wb25lbnQoKTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX19yZWFjdEF1dG9CaW5kUGFpcnMgPSBbXTtcblxuICAgIGluamVjdGVkTWl4aW5zLmZvckVhY2gobWl4U3BlY0ludG9Db21wb25lbnQuYmluZChudWxsLCBDb25zdHJ1Y3RvcikpO1xuXG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdFByb3BzIHByb3BlcnR5IGFmdGVyIGFsbCBtaXhpbnMgaGF2ZSBiZWVuIG1lcmdlZC5cbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHMgPSBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHRhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2Ugb2YgdGhlc2UgbWV0aG9kIG5hbWVzIGlzIG9rLFxuICAgICAgLy8gc2luY2UgaXQncyB1c2VkIHdpdGggY3JlYXRlQ2xhc3MuIElmIGl0J3Mgbm90LCB0aGVuIGl0J3MgbGlrZWx5IGFcbiAgICAgIC8vIG1pc3Rha2Ugc28gd2UnbGwgd2FybiB5b3UgdG8gdXNlIHRoZSBzdGF0aWMgcHJvcGVydHksIHByb3BlcnR5XG4gICAgICAvLyBpbml0aWFsaXplciBvciBjb25zdHJ1Y3RvciByZXNwZWN0aXZlbHkuXG4gICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUpIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgICFDb25zdHJ1Y3Rvci5wcm90b3R5cGUucmVuZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZUNsYXNzKC4uLik6IENsYXNzIHNwZWNpZmljYXRpb24gbXVzdCBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuJykgOiBfcHJvZEludmFyaWFudCgnODMnKSA6IHZvaWQgMDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gUmVkdWNlIHRpbWUgc3BlbnQgZG9pbmcgbG9va3VwcyBieSBzZXR0aW5nIHRoZXNlIG9uIHRoZSBwcm90b3R5cGUuXG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBSZWFjdENsYXNzSW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfSxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgICBpbmplY3RlZE1peGlucy5wdXNoKG1peGluKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENsYXNzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDbGFzcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlTG9jYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0ga2V5TWlycm9yKHtcbiAgcHJvcDogbnVsbCxcbiAgY29udGV4dDogbnVsbCxcbiAgY2hpbGRDb250ZXh0OiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25zO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBlbnVtZXJhdGlvbiB3aXRoIGtleXMgZXF1YWwgdG8gdGhlaXIgdmFsdWUuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogICB2YXIgQ09MT1JTID0ga2V5TWlycm9yKHtibHVlOiBudWxsLCByZWQ6IG51bGx9KTtcbiAqICAgdmFyIG15Q29sb3IgPSBDT0xPUlMuYmx1ZTtcbiAqICAgdmFyIGlzQ29sb3JWYWxpZCA9ICEhQ09MT1JTW215Q29sb3JdO1xuICpcbiAqIFRoZSBsYXN0IGxpbmUgY291bGQgbm90IGJlIHBlcmZvcm1lZCBpZiB0aGUgdmFsdWVzIG9mIHRoZSBnZW5lcmF0ZWQgZW51bSB3ZXJlXG4gKiBub3QgZXF1YWwgdG8gdGhlaXIga2V5cy5cbiAqXG4gKiAgIElucHV0OiAge2tleTE6IHZhbDEsIGtleTI6IHZhbDJ9XG4gKiAgIE91dHB1dDoge2tleTE6IGtleTEsIGtleTI6IGtleTJ9XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG52YXIga2V5TWlycm9yID0gZnVuY3Rpb24ga2V5TWlycm9yKG9iaikge1xuICB2YXIgcmV0ID0ge307XG4gIHZhciBrZXk7XG4gICEob2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmICFBcnJheS5pc0FycmF5KG9iaikpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2tleU1pcnJvciguLi4pOiBBcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXRba2V5XSA9IGtleTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlNaXJyb3I7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2tleU1pcnJvci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyoqXG4gKiBBbGxvd3MgZXh0cmFjdGlvbiBvZiBhIG1pbmlmaWVkIGtleS4gTGV0J3MgdGhlIGJ1aWxkIHN5c3RlbSBtaW5pZnkga2V5c1xuICogd2l0aG91dCBsb3NpbmcgdGhlIGFiaWxpdHkgdG8gZHluYW1pY2FsbHkgdXNlIGtleSBzdHJpbmdzIGFzIHZhbHVlc1xuICogdGhlbXNlbHZlcy4gUGFzcyBpbiBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBrZXkvdmFsIHBhaXIgYW5kIGl0IHdpbGwgcmV0dXJuXG4gKiB5b3UgdGhlIHN0cmluZyBrZXkgb2YgdGhhdCBzaW5nbGUgcmVjb3JkLiBTdXBwb3NlIHlvdSB3YW50IHRvIGdyYWIgdGhlXG4gKiB2YWx1ZSBmb3IgYSBrZXkgJ2NsYXNzTmFtZScgaW5zaWRlIG9mIGFuIG9iamVjdC4gS2V5L3ZhbCBtaW5pZmljYXRpb24gbWF5XG4gKiBoYXZlIGFsaWFzZWQgdGhhdCBrZXkgdG8gYmUgJ3hhMTInLiBrZXlPZih7Y2xhc3NOYW1lOiBudWxsfSkgd2lsbCByZXR1cm5cbiAqICd4YTEyJyBpbiB0aGF0IGNhc2UuIFJlc29sdmUga2V5cyB5b3Ugd2FudCB0byB1c2Ugb25jZSBhdCBzdGFydHVwIHRpbWUsIHRoZW5cbiAqIHJldXNlIHRob3NlIHJlc29sdXRpb25zLlxuICovXG52YXIga2V5T2YgPSBmdW5jdGlvbiBrZXlPZihvbmVLZXlPYmopIHtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gb25lS2V5T2JqKSB7XG4gICAgaWYgKCFvbmVLZXlPYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU9mO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9rZXlPZi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUZhY3Rvcmllc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgZmFjdG9yeSB0aGF0IGNyZWF0ZXMgSFRNTCB0YWcgZWxlbWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGNyZWF0ZURPTUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xuICBjcmVhdGVET01GYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcHBpbmcgZnJvbSBzdXBwb3J0ZWQgSFRNTCB0YWdzIHRvIGBSZWFjdERPTUNvbXBvbmVudGAgY2xhc3Nlcy5cbiAqIFRoaXMgaXMgYWxzbyBhY2Nlc3NpYmxlIHZpYSBgUmVhY3QuRE9NYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IHtcbiAgYTogY3JlYXRlRE9NRmFjdG9yeSgnYScpLFxuICBhYmJyOiBjcmVhdGVET01GYWN0b3J5KCdhYmJyJyksXG4gIGFkZHJlc3M6IGNyZWF0ZURPTUZhY3RvcnkoJ2FkZHJlc3MnKSxcbiAgYXJlYTogY3JlYXRlRE9NRmFjdG9yeSgnYXJlYScpLFxuICBhcnRpY2xlOiBjcmVhdGVET01GYWN0b3J5KCdhcnRpY2xlJyksXG4gIGFzaWRlOiBjcmVhdGVET01GYWN0b3J5KCdhc2lkZScpLFxuICBhdWRpbzogY3JlYXRlRE9NRmFjdG9yeSgnYXVkaW8nKSxcbiAgYjogY3JlYXRlRE9NRmFjdG9yeSgnYicpLFxuICBiYXNlOiBjcmVhdGVET01GYWN0b3J5KCdiYXNlJyksXG4gIGJkaTogY3JlYXRlRE9NRmFjdG9yeSgnYmRpJyksXG4gIGJkbzogY3JlYXRlRE9NRmFjdG9yeSgnYmRvJyksXG4gIGJpZzogY3JlYXRlRE9NRmFjdG9yeSgnYmlnJyksXG4gIGJsb2NrcXVvdGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2Jsb2NrcXVvdGUnKSxcbiAgYm9keTogY3JlYXRlRE9NRmFjdG9yeSgnYm9keScpLFxuICBicjogY3JlYXRlRE9NRmFjdG9yeSgnYnInKSxcbiAgYnV0dG9uOiBjcmVhdGVET01GYWN0b3J5KCdidXR0b24nKSxcbiAgY2FudmFzOiBjcmVhdGVET01GYWN0b3J5KCdjYW52YXMnKSxcbiAgY2FwdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnY2FwdGlvbicpLFxuICBjaXRlOiBjcmVhdGVET01GYWN0b3J5KCdjaXRlJyksXG4gIGNvZGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvZGUnKSxcbiAgY29sOiBjcmVhdGVET01GYWN0b3J5KCdjb2wnKSxcbiAgY29sZ3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvbGdyb3VwJyksXG4gIGRhdGE6IGNyZWF0ZURPTUZhY3RvcnkoJ2RhdGEnKSxcbiAgZGF0YWxpc3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ2RhdGFsaXN0JyksXG4gIGRkOiBjcmVhdGVET01GYWN0b3J5KCdkZCcpLFxuICBkZWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2RlbCcpLFxuICBkZXRhaWxzOiBjcmVhdGVET01GYWN0b3J5KCdkZXRhaWxzJyksXG4gIGRmbjogY3JlYXRlRE9NRmFjdG9yeSgnZGZuJyksXG4gIGRpYWxvZzogY3JlYXRlRE9NRmFjdG9yeSgnZGlhbG9nJyksXG4gIGRpdjogY3JlYXRlRE9NRmFjdG9yeSgnZGl2JyksXG4gIGRsOiBjcmVhdGVET01GYWN0b3J5KCdkbCcpLFxuICBkdDogY3JlYXRlRE9NRmFjdG9yeSgnZHQnKSxcbiAgZW06IGNyZWF0ZURPTUZhY3RvcnkoJ2VtJyksXG4gIGVtYmVkOiBjcmVhdGVET01GYWN0b3J5KCdlbWJlZCcpLFxuICBmaWVsZHNldDogY3JlYXRlRE9NRmFjdG9yeSgnZmllbGRzZXQnKSxcbiAgZmlnY2FwdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnZmlnY2FwdGlvbicpLFxuICBmaWd1cmU6IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZ3VyZScpLFxuICBmb290ZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ2Zvb3RlcicpLFxuICBmb3JtOiBjcmVhdGVET01GYWN0b3J5KCdmb3JtJyksXG4gIGgxOiBjcmVhdGVET01GYWN0b3J5KCdoMScpLFxuICBoMjogY3JlYXRlRE9NRmFjdG9yeSgnaDInKSxcbiAgaDM6IGNyZWF0ZURPTUZhY3RvcnkoJ2gzJyksXG4gIGg0OiBjcmVhdGVET01GYWN0b3J5KCdoNCcpLFxuICBoNTogY3JlYXRlRE9NRmFjdG9yeSgnaDUnKSxcbiAgaDY6IGNyZWF0ZURPTUZhY3RvcnkoJ2g2JyksXG4gIGhlYWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2hlYWQnKSxcbiAgaGVhZGVyOiBjcmVhdGVET01GYWN0b3J5KCdoZWFkZXInKSxcbiAgaGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdoZ3JvdXAnKSxcbiAgaHI6IGNyZWF0ZURPTUZhY3RvcnkoJ2hyJyksXG4gIGh0bWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2h0bWwnKSxcbiAgaTogY3JlYXRlRE9NRmFjdG9yeSgnaScpLFxuICBpZnJhbWU6IGNyZWF0ZURPTUZhY3RvcnkoJ2lmcmFtZScpLFxuICBpbWc6IGNyZWF0ZURPTUZhY3RvcnkoJ2ltZycpLFxuICBpbnB1dDogY3JlYXRlRE9NRmFjdG9yeSgnaW5wdXQnKSxcbiAgaW5zOiBjcmVhdGVET01GYWN0b3J5KCdpbnMnKSxcbiAga2JkOiBjcmVhdGVET01GYWN0b3J5KCdrYmQnKSxcbiAga2V5Z2VuOiBjcmVhdGVET01GYWN0b3J5KCdrZXlnZW4nKSxcbiAgbGFiZWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2xhYmVsJyksXG4gIGxlZ2VuZDogY3JlYXRlRE9NRmFjdG9yeSgnbGVnZW5kJyksXG4gIGxpOiBjcmVhdGVET01GYWN0b3J5KCdsaScpLFxuICBsaW5rOiBjcmVhdGVET01GYWN0b3J5KCdsaW5rJyksXG4gIG1haW46IGNyZWF0ZURPTUZhY3RvcnkoJ21haW4nKSxcbiAgbWFwOiBjcmVhdGVET01GYWN0b3J5KCdtYXAnKSxcbiAgbWFyazogY3JlYXRlRE9NRmFjdG9yeSgnbWFyaycpLFxuICBtZW51OiBjcmVhdGVET01GYWN0b3J5KCdtZW51JyksXG4gIG1lbnVpdGVtOiBjcmVhdGVET01GYWN0b3J5KCdtZW51aXRlbScpLFxuICBtZXRhOiBjcmVhdGVET01GYWN0b3J5KCdtZXRhJyksXG4gIG1ldGVyOiBjcmVhdGVET01GYWN0b3J5KCdtZXRlcicpLFxuICBuYXY6IGNyZWF0ZURPTUZhY3RvcnkoJ25hdicpLFxuICBub3NjcmlwdDogY3JlYXRlRE9NRmFjdG9yeSgnbm9zY3JpcHQnKSxcbiAgb2JqZWN0OiBjcmVhdGVET01GYWN0b3J5KCdvYmplY3QnKSxcbiAgb2w6IGNyZWF0ZURPTUZhY3RvcnkoJ29sJyksXG4gIG9wdGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdvcHRncm91cCcpLFxuICBvcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ29wdGlvbicpLFxuICBvdXRwdXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ291dHB1dCcpLFxuICBwOiBjcmVhdGVET01GYWN0b3J5KCdwJyksXG4gIHBhcmFtOiBjcmVhdGVET01GYWN0b3J5KCdwYXJhbScpLFxuICBwaWN0dXJlOiBjcmVhdGVET01GYWN0b3J5KCdwaWN0dXJlJyksXG4gIHByZTogY3JlYXRlRE9NRmFjdG9yeSgncHJlJyksXG4gIHByb2dyZXNzOiBjcmVhdGVET01GYWN0b3J5KCdwcm9ncmVzcycpLFxuICBxOiBjcmVhdGVET01GYWN0b3J5KCdxJyksXG4gIHJwOiBjcmVhdGVET01GYWN0b3J5KCdycCcpLFxuICBydDogY3JlYXRlRE9NRmFjdG9yeSgncnQnKSxcbiAgcnVieTogY3JlYXRlRE9NRmFjdG9yeSgncnVieScpLFxuICBzOiBjcmVhdGVET01GYWN0b3J5KCdzJyksXG4gIHNhbXA6IGNyZWF0ZURPTUZhY3RvcnkoJ3NhbXAnKSxcbiAgc2NyaXB0OiBjcmVhdGVET01GYWN0b3J5KCdzY3JpcHQnKSxcbiAgc2VjdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnc2VjdGlvbicpLFxuICBzZWxlY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3NlbGVjdCcpLFxuICBzbWFsbDogY3JlYXRlRE9NRmFjdG9yeSgnc21hbGwnKSxcbiAgc291cmNlOiBjcmVhdGVET01GYWN0b3J5KCdzb3VyY2UnKSxcbiAgc3BhbjogY3JlYXRlRE9NRmFjdG9yeSgnc3BhbicpLFxuICBzdHJvbmc6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0cm9uZycpLFxuICBzdHlsZTogY3JlYXRlRE9NRmFjdG9yeSgnc3R5bGUnKSxcbiAgc3ViOiBjcmVhdGVET01GYWN0b3J5KCdzdWInKSxcbiAgc3VtbWFyeTogY3JlYXRlRE9NRmFjdG9yeSgnc3VtbWFyeScpLFxuICBzdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1cCcpLFxuICB0YWJsZTogY3JlYXRlRE9NRmFjdG9yeSgndGFibGUnKSxcbiAgdGJvZHk6IGNyZWF0ZURPTUZhY3RvcnkoJ3Rib2R5JyksXG4gIHRkOiBjcmVhdGVET01GYWN0b3J5KCd0ZCcpLFxuICB0ZXh0YXJlYTogY3JlYXRlRE9NRmFjdG9yeSgndGV4dGFyZWEnKSxcbiAgdGZvb3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3Rmb290JyksXG4gIHRoOiBjcmVhdGVET01GYWN0b3J5KCd0aCcpLFxuICB0aGVhZDogY3JlYXRlRE9NRmFjdG9yeSgndGhlYWQnKSxcbiAgdGltZTogY3JlYXRlRE9NRmFjdG9yeSgndGltZScpLFxuICB0aXRsZTogY3JlYXRlRE9NRmFjdG9yeSgndGl0bGUnKSxcbiAgdHI6IGNyZWF0ZURPTUZhY3RvcnkoJ3RyJyksXG4gIHRyYWNrOiBjcmVhdGVET01GYWN0b3J5KCd0cmFjaycpLFxuICB1OiBjcmVhdGVET01GYWN0b3J5KCd1JyksXG4gIHVsOiBjcmVhdGVET01GYWN0b3J5KCd1bCcpLFxuICAndmFyJzogY3JlYXRlRE9NRmFjdG9yeSgndmFyJyksXG4gIHZpZGVvOiBjcmVhdGVET01GYWN0b3J5KCd2aWRlbycpLFxuICB3YnI6IGNyZWF0ZURPTUZhY3RvcnkoJ3dicicpLFxuXG4gIC8vIFNWR1xuICBjaXJjbGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NpcmNsZScpLFxuICBjbGlwUGF0aDogY3JlYXRlRE9NRmFjdG9yeSgnY2xpcFBhdGgnKSxcbiAgZGVmczogY3JlYXRlRE9NRmFjdG9yeSgnZGVmcycpLFxuICBlbGxpcHNlOiBjcmVhdGVET01GYWN0b3J5KCdlbGxpcHNlJyksXG4gIGc6IGNyZWF0ZURPTUZhY3RvcnkoJ2cnKSxcbiAgaW1hZ2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2ltYWdlJyksXG4gIGxpbmU6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmUnKSxcbiAgbGluZWFyR3JhZGllbnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmVhckdyYWRpZW50JyksXG4gIG1hc2s6IGNyZWF0ZURPTUZhY3RvcnkoJ21hc2snKSxcbiAgcGF0aDogY3JlYXRlRE9NRmFjdG9yeSgncGF0aCcpLFxuICBwYXR0ZXJuOiBjcmVhdGVET01GYWN0b3J5KCdwYXR0ZXJuJyksXG4gIHBvbHlnb246IGNyZWF0ZURPTUZhY3RvcnkoJ3BvbHlnb24nKSxcbiAgcG9seWxpbmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3BvbHlsaW5lJyksXG4gIHJhZGlhbEdyYWRpZW50OiBjcmVhdGVET01GYWN0b3J5KCdyYWRpYWxHcmFkaWVudCcpLFxuICByZWN0OiBjcmVhdGVET01GYWN0b3J5KCdyZWN0JyksXG4gIHN0b3A6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0b3AnKSxcbiAgc3ZnOiBjcmVhdGVET01GYWN0b3J5KCdzdmcnKSxcbiAgdGV4dDogY3JlYXRlRE9NRmFjdG9yeSgndGV4dCcpLFxuICB0c3BhbjogY3JlYXRlRE9NRmFjdG9yeSgndHNwYW4nKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZhY3RvcmllcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NRmFjdG9yaWVzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RWxlbWVudFZhbGlkYXRvclxuICovXG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcblxudmFyIGNoZWNrUmVhY3RUeXBlU3BlYyA9IHJlcXVpcmUoJy4vY2hlY2tSZWFjdFR5cGVTcGVjJyk7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSAnIENoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgdmFyIG1lbW9pemVyID0gb3duZXJIYXNLZXlVc2VXYXJuaW5nLnVuaXF1ZUtleSB8fCAob3duZXJIYXNLZXlVc2VXYXJuaW5nLnVuaXF1ZUtleSA9IHt9KTtcblxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gIGlmIChtZW1vaXplcltjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBtZW1vaXplcltjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJztcbiAgfVxuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4lcycsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0oZWxlbWVudCkpIDogdm9pZCAwO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyBwcm92aWRlIGltcGxpY2l0IGtleXMuXG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gZWxlbWVudC50eXBlO1xuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gY29tcG9uZW50Q2xhc3MuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Q2xhc3MubmFtZTtcbiAgaWYgKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcykge1xuICAgIGNoZWNrUmVhY3RUeXBlU3BlYyhjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCwgbmFtZSwgZWxlbWVudCwgbnVsbCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gIH1cbn1cblxudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHtcblxuICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBzaG91bGQgbm90IGJlIG51bGwsIHVuZGVmaW5lZCwgYm9vbGVhbiwgb3IgJyArICdudW1iZXIuIEl0IHNob3VsZCBiZSBhIHN0cmluZyAoZm9yIERPTSBlbGVtZW50cykgb3IgYSBSZWFjdENsYXNzICcgKyAnKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykuJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSkgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICBjcmVhdGVGYWN0b3J5OiBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbiAgfSxcblxuICBjbG9uZUVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RWxlbWVudFZhbGlkYXRvcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudFRyZWVIb29rXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBpc05hdGl2ZShmbikge1xuICAvLyBCYXNlZCBvbiBpc05hdGl2ZSgpIGZyb20gTG9kYXNoXG4gIHZhciBmdW5jVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArIGZ1bmNUb1N0cmluZ1xuICAvLyBUYWtlIGFuIGV4YW1wbGUgbmF0aXZlIGZ1bmN0aW9uIHNvdXJjZSBmb3IgY29tcGFyaXNvblxuICAuY2FsbChoYXNPd25Qcm9wZXJ0eSlcbiAgLy8gU3RyaXAgcmVnZXggY2hhcmFjdGVycyBzbyB3ZSBjYW4gdXNlIGl0IGZvciByZWdleFxuICAucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnKVxuICAvLyBSZW1vdmUgaGFzT3duUHJvcGVydHkgZnJvbSB0aGUgdGVtcGxhdGUgdG8gbWFrZSBpdCBnZW5lcmljXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJyk7XG4gIHRyeSB7XG4gICAgdmFyIHNvdXJjZSA9IGZ1bmNUb1N0cmluZy5jYWxsKGZuKTtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KHNvdXJjZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG52YXIgY2FuVXNlQ29sbGVjdGlvbnMgPVxuLy8gQXJyYXkuZnJvbVxudHlwZW9mIEFycmF5LmZyb20gPT09ICdmdW5jdGlvbicgJiZcbi8vIE1hcFxudHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShNYXApICYmXG4vLyBNYXAucHJvdG90eXBlLmtleXNcbk1hcC5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2YgTWFwLnByb3RvdHlwZS5rZXlzID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKE1hcC5wcm90b3R5cGUua2V5cykgJiZcbi8vIFNldFxudHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShTZXQpICYmXG4vLyBTZXQucHJvdG90eXBlLmtleXNcblNldC5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2YgU2V0LnByb3RvdHlwZS5rZXlzID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKFNldC5wcm90b3R5cGUua2V5cyk7XG5cbnZhciBpdGVtTWFwO1xudmFyIHJvb3RJRFNldDtcblxudmFyIGl0ZW1CeUtleTtcbnZhciByb290QnlLZXk7XG5cbmlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICBpdGVtTWFwID0gbmV3IE1hcCgpO1xuICByb290SURTZXQgPSBuZXcgU2V0KCk7XG59IGVsc2Uge1xuICBpdGVtQnlLZXkgPSB7fTtcbiAgcm9vdEJ5S2V5ID0ge307XG59XG5cbnZhciB1bm1vdW50ZWRJRHMgPSBbXTtcblxuLy8gVXNlIG5vbi1udW1lcmljIGtleXMgdG8gcHJldmVudCBWOCBwZXJmb3JtYW5jZSBpc3N1ZXM6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MjMyXG5mdW5jdGlvbiBnZXRLZXlGcm9tSUQoaWQpIHtcbiAgcmV0dXJuICcuJyArIGlkO1xufVxuZnVuY3Rpb24gZ2V0SURGcm9tS2V5KGtleSkge1xuICByZXR1cm4gcGFyc2VJbnQoa2V5LnN1YnN0cigxKSwgMTApO1xufVxuXG5mdW5jdGlvbiBnZXQoaWQpIHtcbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgcmV0dXJuIGl0ZW1NYXAuZ2V0KGlkKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICByZXR1cm4gaXRlbUJ5S2V5W2tleV07XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGlkKSB7XG4gIGlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICAgIGl0ZW1NYXBbJ2RlbGV0ZSddKGlkKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBkZWxldGUgaXRlbUJ5S2V5W2tleV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlKGlkLCBlbGVtZW50LCBwYXJlbnRJRCkge1xuICB2YXIgaXRlbSA9IHtcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICB0ZXh0OiBudWxsLFxuICAgIGNoaWxkSURzOiBbXSxcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIHVwZGF0ZUNvdW50OiAwXG4gIH07XG5cbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgaXRlbU1hcC5zZXQoaWQsIGl0ZW0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGl0ZW1CeUtleVtrZXldID0gaXRlbTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSb290KGlkKSB7XG4gIGlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICAgIHJvb3RJRFNldC5hZGQoaWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIHJvb3RCeUtleVtrZXldID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVSb290KGlkKSB7XG4gIGlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICAgIHJvb3RJRFNldFsnZGVsZXRlJ10oaWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGRlbGV0ZSByb290QnlLZXlba2V5XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZWdpc3RlcmVkSURzKCkge1xuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShpdGVtTWFwLmtleXMoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGl0ZW1CeUtleSkubWFwKGdldElERnJvbUtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Um9vdElEcygpIHtcbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocm9vdElEU2V0LmtleXMoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJvb3RCeUtleSkubWFwKGdldElERnJvbUtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVyZ2VEZWVwKGlkKSB7XG4gIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgaWYgKGl0ZW0pIHtcbiAgICB2YXIgY2hpbGRJRHMgPSBpdGVtLmNoaWxkSURzO1xuXG4gICAgcmVtb3ZlKGlkKTtcbiAgICBjaGlsZElEcy5mb3JFYWNoKHB1cmdlRGVlcCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgbmFtZSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufVxuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gJyNlbXB0eSc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiAnI3RleHQnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlLmRpc3BsYXlOYW1lIHx8IGVsZW1lbnQudHlwZS5uYW1lIHx8ICdVbmtub3duJztcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZUlEKGlkKSB7XG4gIHZhciBuYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShpZCk7XG4gIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgdmFyIG93bmVySUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldE93bmVySUQoaWQpO1xuICB2YXIgb3duZXJOYW1lO1xuICBpZiAob3duZXJJRCkge1xuICAgIG93bmVyTmFtZSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUob3duZXJJRCk7XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZWxlbWVudCwgJ1JlYWN0Q29tcG9uZW50VHJlZUhvb2s6IE1pc3NpbmcgUmVhY3QgZWxlbWVudCBmb3IgZGVidWdJRCAlcyB3aGVuICcgKyAnYnVpbGRpbmcgc3RhY2snLCBpZCkgOiB2b2lkIDA7XG4gIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGVsZW1lbnQgJiYgZWxlbWVudC5fc291cmNlLCBvd25lck5hbWUpO1xufVxuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHtcbiAgb25TZXRDaGlsZHJlbjogZnVuY3Rpb24gKGlkLCBuZXh0Q2hpbGRJRHMpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgaXRlbS5jaGlsZElEcyA9IG5leHRDaGlsZElEcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dENoaWxkSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dENoaWxkSUQgPSBuZXh0Q2hpbGRJRHNbaV07XG4gICAgICB2YXIgbmV4dENoaWxkID0gZ2V0KG5leHRDaGlsZElEKTtcbiAgICAgICFuZXh0Q2hpbGQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgaG9vayBldmVudHMgdG8gZmlyZSBmb3IgdGhlIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxNDAnKSA6IHZvaWQgMDtcbiAgICAgICEobmV4dENoaWxkLmNoaWxkSURzICE9IG51bGwgfHwgdHlwZW9mIG5leHRDaGlsZC5lbGVtZW50ICE9PSAnb2JqZWN0JyB8fCBuZXh0Q2hpbGQuZWxlbWVudCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvblNldENoaWxkcmVuKCkgdG8gZmlyZSBmb3IgYSBjb250YWluZXIgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MScpIDogdm9pZCAwO1xuICAgICAgIW5leHRDaGlsZC5pc01vdW50ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25Nb3VudENvbXBvbmVudCgpIHRvIGZpcmUgZm9yIHRoZSBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnNzEnKSA6IHZvaWQgMDtcbiAgICAgIGlmIChuZXh0Q2hpbGQucGFyZW50SUQgPT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2hpbGQucGFyZW50SUQgPSBpZDtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5IGJ1dCBtb3VudGluZyBhIG5ldyByb290IGR1cmluZyBpblxuICAgICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgY3VycmVudGx5IGNhdXNlcyBub3QteWV0LW1vdW50ZWQgY29tcG9uZW50cyB0b1xuICAgICAgICAvLyBiZSBwdXJnZWQgZnJvbSBvdXIgdHJlZSBkYXRhIHNvIHRoZWlyIHBhcmVudCBJRCBpcyBtaXNzaW5nLlxuICAgICAgfVxuICAgICAgIShuZXh0Q2hpbGQucGFyZW50SUQgPT09IGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvbkJlZm9yZU1vdW50Q29tcG9uZW50KCkgcGFyZW50IGFuZCBvblNldENoaWxkcmVuKCkgdG8gYmUgY29uc2lzdGVudCAoJXMgaGFzIHBhcmVudHMgJXMgYW5kICVzKS4nLCBuZXh0Q2hpbGRJRCwgbmV4dENoaWxkLnBhcmVudElELCBpZCkgOiBfcHJvZEludmFyaWFudCgnMTQyJywgbmV4dENoaWxkSUQsIG5leHRDaGlsZC5wYXJlbnRJRCwgaWQpIDogdm9pZCAwO1xuICAgIH1cbiAgfSxcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkLCBlbGVtZW50LCBwYXJlbnRJRCkge1xuICAgIGNyZWF0ZShpZCwgZWxlbWVudCwgcGFyZW50SUQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGlkLCBlbGVtZW50KSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIGlmICghaXRlbSB8fCAhaXRlbS5pc01vdW50ZWQpIHtcbiAgICAgIC8vIFdlIG1heSBlbmQgdXAgaGVyZSBhcyBhIHJlc3VsdCBvZiBzZXRTdGF0ZSgpIGluIGNvbXBvbmVudFdpbGxVbm1vdW50KCkuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGlnbm9yZSB0aGUgZWxlbWVudC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXRlbS5lbGVtZW50ID0gZWxlbWVudDtcbiAgfSxcbiAgb25Nb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIGl0ZW0uaXNNb3VudGVkID0gdHJ1ZTtcbiAgICB2YXIgaXNSb290ID0gaXRlbS5wYXJlbnRJRCA9PT0gMDtcbiAgICBpZiAoaXNSb290KSB7XG4gICAgICBhZGRSb290KGlkKTtcbiAgICB9XG4gIH0sXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtLmlzTW91bnRlZCkge1xuICAgICAgLy8gV2UgbWF5IGVuZCB1cCBoZXJlIGFzIGEgcmVzdWx0IG9mIHNldFN0YXRlKCkgaW4gY29tcG9uZW50V2lsbFVubW91bnQoKS5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgaWdub3JlIHRoZSBlbGVtZW50LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpdGVtLnVwZGF0ZUNvdW50Kys7XG4gIH0sXG4gIG9uVW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIGl0IGV4aXN0cy5cbiAgICAgIC8vIGBpdGVtYCBtaWdodCBub3QgZXhpc3QgaWYgaXQgaXMgaW5zaWRlIGFuIGVycm9yIGJvdW5kYXJ5LCBhbmQgYSBzaWJsaW5nXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSBjaGlsZCB0aHJldyB3aGlsZSBtb3VudGluZy4gVGhlbiB0aGlzIGluc3RhbmNlIG5ldmVyXG4gICAgICAvLyBnb3QgYSBjaGFuY2UgdG8gbW91bnQsIGJ1dCBpdCBzdGlsbCBnZXRzIGFuIHVubW91bnRpbmcgZXZlbnQgZHVyaW5nXG4gICAgICAvLyB0aGUgZXJyb3IgYm91bmRhcnkgY2xlYW51cC5cbiAgICAgIGl0ZW0uaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICB2YXIgaXNSb290ID0gaXRlbS5wYXJlbnRJRCA9PT0gMDtcbiAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgcmVtb3ZlUm9vdChpZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHVubW91bnRlZElEcy5wdXNoKGlkKTtcbiAgfSxcbiAgcHVyZ2VVbm1vdW50ZWRDb21wb25lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJlYWN0Q29tcG9uZW50VHJlZUhvb2suX3ByZXZlbnRQdXJnaW5nKSB7XG4gICAgICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0aW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5tb3VudGVkSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSB1bm1vdW50ZWRJRHNbaV07XG4gICAgICBwdXJnZURlZXAoaWQpO1xuICAgIH1cbiAgICB1bm1vdW50ZWRJRHMubGVuZ3RoID0gMDtcbiAgfSxcbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmlzTW91bnRlZCA6IGZhbHNlO1xuICB9LFxuICBnZXRDdXJyZW50U3RhY2tBZGRlbmR1bTogZnVuY3Rpb24gKHRvcEVsZW1lbnQpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0b3BFbGVtZW50KSB7XG4gICAgICB2YXIgdHlwZSA9IHRvcEVsZW1lbnQudHlwZTtcbiAgICAgIHZhciBuYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSA6IHR5cGU7XG4gICAgICB2YXIgb3duZXIgPSB0b3BFbGVtZW50Ll9vd25lcjtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lIHx8ICdVbmtub3duJywgdG9wRWxlbWVudC5fc291cmNlLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50T3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIHZhciBpZCA9IGN1cnJlbnRPd25lciAmJiBjdXJyZW50T3duZXIuX2RlYnVnSUQ7XG5cbiAgICBpbmZvICs9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoaWQpO1xuICAgIHJldHVybiBpbmZvO1xuICB9LFxuICBnZXRTdGFja0FkZGVuZHVtQnlJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB3aGlsZSAoaWQpIHtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVJRChpZCk7XG4gICAgICBpZCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UGFyZW50SUQoaWQpO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbztcbiAgfSxcbiAgZ2V0Q2hpbGRJRHM6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uY2hpbGRJRHMgOiBbXTtcbiAgfSxcbiAgZ2V0RGlzcGxheU5hbWU6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RGlzcGxheU5hbWUoZWxlbWVudCk7XG4gIH0sXG4gIGdldEVsZW1lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZWxlbWVudCA6IG51bGw7XG4gIH0sXG4gIGdldE93bmVySUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuX293bmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQuX293bmVyLl9kZWJ1Z0lEO1xuICB9LFxuICBnZXRQYXJlbnRJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5wYXJlbnRJRCA6IG51bGw7XG4gIH0sXG4gIGdldFNvdXJjZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIHZhciBlbGVtZW50ID0gaXRlbSA/IGl0ZW0uZWxlbWVudCA6IG51bGw7XG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnQgIT0gbnVsbCA/IGVsZW1lbnQuX3NvdXJjZSA6IG51bGw7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfSxcbiAgZ2V0VGV4dDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJycgKyBlbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGdldFVwZGF0ZUNvdW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnVwZGF0ZUNvdW50IDogMDtcbiAgfSxcblxuXG4gIGdldFJlZ2lzdGVyZWRJRHM6IGdldFJlZ2lzdGVyZWRJRHMsXG5cbiAgZ2V0Um9vdElEczogZ2V0Um9vdElEc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vay5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjaGVja1JlYWN0VHlwZVNwZWNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/b2JqZWN0fSBlbGVtZW50IFRoZSBSZWFjdCBlbGVtZW50IHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0gez9udW1iZXJ9IGRlYnVnSUQgVGhlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCwgZGVidWdJRCkge1xuICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICB2YXIgZXJyb3I7XG4gICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgISh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzg0JywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgfVxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpIDogdm9pZCAwO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGNvbXBvbmVudFN0YWNrSW5mbyA9ICcnO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XG4gICAgICAgICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWJ1Z0lEICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIGNvbXBvbmVudFN0YWNrSW5mbykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tSZWFjdFR5cGVTcGVjO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvY2hlY2tSZWFjdFR5cGVTcGVjLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVzU2VjcmV0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICpcbiAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAqXG4gKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAqICAgICB9LFxuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gKiAgIH0pO1xuICpcbiAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAqXG4gKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICpcbiAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgIHByb3BUeXBlczoge1xuICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICogICAgICAgICAgKTtcbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqICAgIH0sXG4gKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAqICB9KTtcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG52YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG52YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXJcbn07XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbi8qKlxuICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciB3ZSBkb24ndCB1c2UgcmVhbFxuICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICovXG5mdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5zdGFjayA9ICcnO1xufVxuLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgaWYgKCFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0pIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgKyAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgKyAnYW5kIHdpbGwgbm90IHdvcmsgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gWW91IG1heSBiZSAnICsgJ3NlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzIGxpYnJhcnkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzIGZvciBkZXRhaWxzLicsIHByb3BGdWxsTmFtZSwgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1JlcXVpcmVkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agd2FzIG5vdCBzcGVjaWZpZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyhudWxsKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgIH1cbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAoIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgfVxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gIC8vIE5hdGl2ZSBTeW1ib2wuXG4gIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbmZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cbiAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICByZXR1cm4gJ29iamVjdCc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuICdzeW1ib2wnO1xuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxuLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG5mdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gJ2RhdGUnO1xuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxuLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbmZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgfVxuICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFZlcnNpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gJzE1LjMuMSc7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFZlcnNpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgb25seUNoaWxkXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKSA6IF9wcm9kSW52YXJpYW50KCcxNDMnKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9ubHlDaGlsZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL29ubHlDaGlsZC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RET00nKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1kb20vaW5kZXguanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01cbiAqL1xuXG4vKiBnbG9iYWxzIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3REZWZhdWx0SW5qZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRJbmplY3Rpb24nKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoJy4vZmluZERPTU5vZGUnKTtcbnZhciBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZSA9IHJlcXVpcmUoJy4vZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUnKTtcbnZhciByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IHJlcXVpcmUoJy4vcmVuZGVyU3VidHJlZUludG9Db250YWluZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5SZWFjdERlZmF1bHRJbmplY3Rpb24uaW5qZWN0KCk7XG5cbnZhciBSZWFjdERPTSA9IHtcbiAgZmluZERPTU5vZGU6IGZpbmRET01Ob2RlLFxuICByZW5kZXI6IFJlYWN0TW91bnQucmVuZGVyLFxuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyXG59O1xuXG4vLyBJbmplY3QgdGhlIHJ1bnRpbWUgaW50byBhIGRldnRvb2xzIGdsb2JhbCBob29rIHJlZ2FyZGxlc3Mgb2YgYnJvd3Nlci5cbi8vIEFsbG93cyBmb3IgZGVidWdnaW5nIHdoZW4gdGhlIGhvb2sgaXMgaW5qZWN0ZWQgb24gdGhlIHBhZ2UuXG4vKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3Qoe1xuICAgIENvbXBvbmVudFRyZWU6IHtcbiAgICAgIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gICAgICBnZXROb2RlRnJvbUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICAvLyBpbnN0IGlzIGFuIGludGVybmFsIGluc3RhbmNlIChidXQgY291bGQgYmUgYSBjb21wb3NpdGUpXG4gICAgICAgIGlmIChpbnN0Ll9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgICAgIGluc3QgPSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdCkge1xuICAgICAgICAgIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgTW91bnQ6IFJlYWN0TW91bnQsXG4gICAgUmVjb25jaWxlcjogUmVhY3RSZWNvbmNpbGVyXG4gIH0pO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuICBpZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG5cbiAgICAvLyBGaXJzdCBjaGVjayBpZiBkZXZ0b29scyBpcyBub3QgaW5zdGFsbGVkXG4gICAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gLTEpIHtcbiAgICAgICAgLy8gRmlyZWZveCBkb2VzIG5vdCBoYXZlIHRoZSBpc3N1ZSB3aXRoIGRldnRvb2xzIGxvYWRlZCBvdmVyIGZpbGU6Ly9cbiAgICAgICAgdmFyIHNob3dGaWxlVXJsTWVzc2FnZSA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKCdodHRwJykgPT09IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAoc2hvd0ZpbGVVcmxNZXNzYWdlID8gJ2FuZCB1c2UgYW4gSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgYSBmaWxlOiBVUkwpICcgOiAnJykgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0ZXN0RnVuYyA9IGZ1bmN0aW9uIHRlc3RGbigpIHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCh0ZXN0RnVuYy5uYW1lIHx8IHRlc3RGdW5jLnRvU3RyaW5nKCkpLmluZGV4T2YoJ3Rlc3RGbicpICE9PSAtMSwgJ0l0IGxvb2tzIGxpa2UgeW91XFwncmUgdXNpbmcgYSBtaW5pZmllZCBjb3B5IG9mIHRoZSBkZXZlbG9wbWVudCBidWlsZCAnICsgJ29mIFJlYWN0LiBXaGVuIGRlcGxveWluZyBSZWFjdCBhcHBzIHRvIHByb2R1Y3Rpb24sIG1ha2Ugc3VyZSB0byB1c2UgJyArICd0aGUgcHJvZHVjdGlvbiBidWlsZCB3aGljaCBza2lwcyBkZXZlbG9wbWVudCB3YXJuaW5ncyBhbmQgaXMgZmFzdGVyLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LW1pbmlmaWNhdGlvbiBmb3IgbW9yZSBkZXRhaWxzLicpIDogdm9pZCAwO1xuXG4gICAgLy8gSWYgd2UncmUgaW4gSUU4LCBjaGVjayB0byBzZWUgaWYgd2UgYXJlIGluIGNvbXBhdGliaWxpdHkgbW9kZSBhbmQgcHJvdmlkZVxuICAgIC8vIGluZm9ybWF0aW9uIG9uIHByZXZlbnRpbmcgY29tcGF0aWJpbGl0eSBtb2RlXG4gICAgdmFyIGllQ29tcGF0aWJpbGl0eU1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDwgODtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpZUNvbXBhdGliaWxpdHlNb2RlLCAnSW50ZXJuZXQgRXhwbG9yZXIgaXMgcnVubmluZyBpbiBjb21wYXRpYmlsaXR5IG1vZGU7IHBsZWFzZSBhZGQgdGhlICcgKyAnZm9sbG93aW5nIHRhZyB0byB5b3VyIEhUTUwgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nOiAnICsgJzxtZXRhIGh0dHAtZXF1aXY9XCJYLVVBLUNvbXBhdGlibGVcIiBjb250ZW50PVwiSUU9ZWRnZVwiIC8+JykgOiB2b2lkIDA7XG5cbiAgICB2YXIgZXhwZWN0ZWRGZWF0dXJlcyA9IFtcbiAgICAvLyBzaGltc1xuICAgIEFycmF5LmlzQXJyYXksIEFycmF5LnByb3RvdHlwZS5ldmVyeSwgQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLCBBcnJheS5wcm90b3R5cGUubWFwLCBEYXRlLm5vdywgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsIE9iamVjdC5rZXlzLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCBTdHJpbmcucHJvdG90eXBlLnRyaW1dO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZEZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWV4cGVjdGVkRmVhdHVyZXNbaV0pIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdPbmUgb3IgbW9yZSBFUzUgc2hpbXMgZXhwZWN0ZWQgYnkgUmVhY3QgYXJlIG5vdCBhdmFpbGFibGU6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLXBvbHlmaWxscycpIDogdm9pZCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuICB2YXIgUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rID0gcmVxdWlyZSgnLi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2snKTtcbiAgdmFyIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rJyk7XG5cbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLmFkZEhvb2soUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rKTtcbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLmFkZEhvb2soUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NQ29tcG9uZW50VHJlZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUU7XG52YXIgRmxhZ3MgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzO1xuXG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbi8qKlxuICogRHJpbGwgZG93biAodGhyb3VnaCBjb21wb3NpdGVzIGFuZCBlbXB0eSBjb21wb25lbnRzKSB1bnRpbCB3ZSBnZXQgYSBob3N0IG9yXG4gKiBob3N0IHRleHQgY29tcG9uZW50LlxuICpcbiAqIFRoaXMgaXMgcHJldHR5IHBvbHltb3JwaGljIGJ1dCB1bmF2b2lkYWJsZSB3aXRoIHRoZSBjdXJyZW50IHN0cnVjdHVyZSB3ZSBoYXZlXG4gKiBmb3IgYF9yZW5kZXJlZENoaWxkcmVuYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVuZGVyZWRIb3N0T3JUZXh0RnJvbUNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgdmFyIHJlbmRlcmVkO1xuICB3aGlsZSAocmVuZGVyZWQgPSBjb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgY29tcG9uZW50ID0gcmVuZGVyZWQ7XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudDtcbn1cblxuLyoqXG4gKiBQb3B1bGF0ZSBgX2hvc3ROb2RlYCBvbiB0aGUgcmVuZGVyZWQgaG9zdC90ZXh0IGNvbXBvbmVudCB3aXRoIHRoZSBnaXZlblxuICogRE9NIG5vZGUuIFRoZSBwYXNzZWQgYGluc3RgIGNhbiBiZSBhIGNvbXBvc2l0ZS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVOb2RlKGluc3QsIG5vZGUpIHtcbiAgdmFyIGhvc3RJbnN0ID0gZ2V0UmVuZGVyZWRIb3N0T3JUZXh0RnJvbUNvbXBvbmVudChpbnN0KTtcbiAgaG9zdEluc3QuX2hvc3ROb2RlID0gbm9kZTtcbiAgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGhvc3RJbnN0O1xufVxuXG5mdW5jdGlvbiB1bmNhY2hlTm9kZShpbnN0KSB7XG4gIHZhciBub2RlID0gaW5zdC5faG9zdE5vZGU7XG4gIGlmIChub2RlKSB7XG4gICAgZGVsZXRlIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gICAgaW5zdC5faG9zdE5vZGUgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogUG9wdWxhdGUgYF9ob3N0Tm9kZWAgb24gZWFjaCBjaGlsZCBvZiBgaW5zdGAsIGFzc3VtaW5nIHRoYXQgdGhlIGNoaWxkcmVuXG4gKiBtYXRjaCB1cCB3aXRoIHRoZSBET00gKGVsZW1lbnQpIGNoaWxkcmVuIG9mIGBub2RlYC5cbiAqXG4gKiBXZSBjYWNoZSBlbnRpcmUgbGV2ZWxzIGF0IG9uY2UgdG8gYXZvaWQgYW4gbl4yIHByb2JsZW0gd2hlcmUgd2UgYWNjZXNzIHRoZVxuICogY2hpbGRyZW4gb2YgYSBub2RlIHNlcXVlbnRpYWxseSBhbmQgaGF2ZSB0byB3YWxrIGZyb20gdGhlIHN0YXJ0IHRvIG91ciB0YXJnZXRcbiAqIG5vZGUgZXZlcnkgdGltZS5cbiAqXG4gKiBTaW5jZSB3ZSB1cGRhdGUgYF9yZW5kZXJlZENoaWxkcmVuYCBhbmQgdGhlIGFjdHVhbCBET00gYXQgKHNsaWdodGx5KVxuICogZGlmZmVyZW50IHRpbWVzLCB3ZSBjb3VsZCByYWNlIGhlcmUgYW5kIHNlZSBhIG5ld2VyIGBfcmVuZGVyZWRDaGlsZHJlbmAgdGhhblxuICogdGhlIERPTSBub2RlcyB3ZSBzZWUuIFRvIGF2b2lkIHRoaXMsIFJlYWN0TXVsdGlDaGlsZCBjYWxsc1xuICogYHByZXBhcmVUb01hbmFnZUNoaWxkcmVuYCBiZWZvcmUgd2UgY2hhbmdlIGBfcmVuZGVyZWRDaGlsZHJlbmAsIGF0IHdoaWNoXG4gKiB0aW1lIHRoZSBjb250YWluZXIncyBjaGlsZCBub2RlcyBhcmUgYWx3YXlzIGNhY2hlZCAodW50aWwgaXQgdW5tb3VudHMpLlxuICovXG5mdW5jdGlvbiBwcmVjYWNoZUNoaWxkTm9kZXMoaW5zdCwgbm9kZSkge1xuICBpZiAoaW5zdC5fZmxhZ3MgJiBGbGFncy5oYXNDYWNoZWRDaGlsZE5vZGVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjaGlsZHJlbiA9IGluc3QuX3JlbmRlcmVkQ2hpbGRyZW47XG4gIHZhciBjaGlsZE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIG91dGVyOiBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgaWYgKCFjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBjaGlsZEluc3QgPSBjaGlsZHJlbltuYW1lXTtcbiAgICB2YXIgY2hpbGRJRCA9IGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoY2hpbGRJbnN0KS5fZG9tSUQ7XG4gICAgaWYgKGNoaWxkSUQgPT09IDApIHtcbiAgICAgIC8vIFdlJ3JlIGN1cnJlbnRseSB1bm1vdW50aW5nIHRoaXMgY2hpbGQgaW4gUmVhY3RNdWx0aUNoaWxkOyBza2lwIGl0LlxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIFdlIGFzc3VtZSB0aGUgY2hpbGQgbm9kZXMgYXJlIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBjaGlsZCBpbnN0YW5jZXMuXG4gICAgZm9yICg7IGNoaWxkTm9kZSAhPT0gbnVsbDsgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxICYmIGNoaWxkTm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSA9PT0gU3RyaW5nKGNoaWxkSUQpIHx8IGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBjaGlsZE5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LXRleHQ6ICcgKyBjaGlsZElEICsgJyAnIHx8IGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBjaGlsZE5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LWVtcHR5OiAnICsgY2hpbGRJRCArICcgJykge1xuICAgICAgICBwcmVjYWNoZU5vZGUoY2hpbGRJbnN0LCBjaGlsZE5vZGUpO1xuICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBET00gY2hpbGRyZW4gd2l0aG91dCBmaW5kaW5nIGFuIElEIG1hdGNoLlxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBlbGVtZW50IHdpdGggSUQgJXMuJywgY2hpbGRJRCkgOiBfcHJvZEludmFyaWFudCgnMzInLCBjaGlsZElEKSA6IHZvaWQgMDtcbiAgfVxuICBpbnN0Ll9mbGFncyB8PSBGbGFncy5oYXNDYWNoZWRDaGlsZE5vZGVzO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgY2xvc2VzdCBSZWFjdERPTUNvbXBvbmVudCBvclxuICogUmVhY3RET01UZXh0Q29tcG9uZW50IGluc3RhbmNlIGFuY2VzdG9yLlxuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIGlmIChub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcmV0dXJuIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gYW5jZXN0b3Igd2hvc2UgaW5zdGFuY2Ugd2UgaGF2ZSBjYWNoZWQuXG4gIHZhciBwYXJlbnRzID0gW107XG4gIHdoaWxlICghbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUb3Agb2YgdGhlIHRyZWUuIFRoaXMgbm9kZSBtdXN0IG5vdCBiZSBwYXJ0IG9mIGEgUmVhY3QgdHJlZSAob3IgaXNcbiAgICAgIC8vIHVubW91bnRlZCwgcG90ZW50aWFsbHkpLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNsb3Nlc3Q7XG4gIHZhciBpbnN0O1xuICBmb3IgKDsgbm9kZSAmJiAoaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pOyBub2RlID0gcGFyZW50cy5wb3AoKSkge1xuICAgIGNsb3Nlc3QgPSBpbnN0O1xuICAgIGlmIChwYXJlbnRzLmxlbmd0aCkge1xuICAgICAgcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXG4gKi9cbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgaW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpO1xuICBpZiAoaW5zdCAhPSBudWxsICYmIGluc3QuX2hvc3ROb2RlID09PSBub2RlKSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSB7XG4gIC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbiAgIShpbnN0Ll9ob3N0Tm9kZSAhPT0gdW5kZWZpbmVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzMzJykgOiB2b2lkIDA7XG5cbiAgaWYgKGluc3QuX2hvc3ROb2RlKSB7XG4gICAgcmV0dXJuIGluc3QuX2hvc3ROb2RlO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIERPTSBub2RlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIWluc3QuX2hvc3ROb2RlKSB7XG4gICAgcGFyZW50cy5wdXNoKGluc3QpO1xuICAgICFpbnN0Ll9ob3N0UGFyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0IERPTSB0cmVlIHJvb3Qgc2hvdWxkIGFsd2F5cyBoYXZlIGEgbm9kZSByZWZlcmVuY2UuJykgOiBfcHJvZEludmFyaWFudCgnMzQnKSA6IHZvaWQgMDtcbiAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcbiAgfVxuXG4gIC8vIE5vdyBwYXJlbnRzIGNvbnRhaW5zIGVhY2ggYW5jZXN0b3IgdGhhdCBkb2VzICpub3QqIGhhdmUgYSBjYWNoZWQgbmF0aXZlXG4gIC8vIG5vZGUsIGFuZCBgaW5zdGAgaXMgdGhlIGRlZXBlc3QgYW5jZXN0b3IgdGhhdCBkb2VzLlxuICBmb3IgKDsgcGFyZW50cy5sZW5ndGg7IGluc3QgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIGluc3QuX2hvc3ROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBpbnN0Ll9ob3N0Tm9kZTtcbn1cblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHtcbiAgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICBnZXRJbnN0YW5jZUZyb21Ob2RlOiBnZXRJbnN0YW5jZUZyb21Ob2RlLFxuICBnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlLFxuICBwcmVjYWNoZUNoaWxkTm9kZXM6IHByZWNhY2hlQ2hpbGROb2RlcyxcbiAgcHJlY2FjaGVOb2RlOiBwcmVjYWNoZU5vZGUsXG4gIHVuY2FjaGVOb2RlOiB1bmNhY2hlTm9kZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudFRyZWU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudFRyZWUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NUHJvcGVydHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuZnVuY3Rpb24gY2hlY2tNYXNrKHZhbHVlLCBiaXRtYXNrKSB7XG4gIHJldHVybiAodmFsdWUgJiBiaXRtYXNrKSA9PT0gYml0bWFzaztcbn1cblxudmFyIERPTVByb3BlcnR5SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQsIGNhbWVsY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gYSBjb25maWd1cmF0aW9uIHRoYXRcbiAgICogc3BlY2lmaWVzIGhvdyB0aGUgYXNzb2NpYXRlZCBET00gcHJvcGVydHkgc2hvdWxkIGJlIGFjY2Vzc2VkIG9yIHJlbmRlcmVkLlxuICAgKi9cbiAgTVVTVF9VU0VfUFJPUEVSVFk6IDB4MSxcbiAgSEFTX0JPT0xFQU5fVkFMVUU6IDB4NCxcbiAgSEFTX05VTUVSSUNfVkFMVUU6IDB4OCxcbiAgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6IDB4MTAgfCAweDgsXG4gIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU6IDB4MjAsXG5cbiAgLyoqXG4gICAqIEluamVjdCBzb21lIHNwZWNpYWxpemVkIGtub3dsZWRnZSBhYm91dCB0aGUgRE9NLiBUaGlzIHRha2VzIGEgY29uZmlnIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIHRoYXQgZ2l2ZW4gYW4gYXR0cmlidXRlIG5hbWUgd2lsbCByZXR1cm4gdHJ1ZVxuICAgKiBpZiBpdCBjYW4gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NIHZlcmJhdGltLiBVc2VmdWwgZm9yIGRhdGEtKiBvciBhcmlhLSpcbiAgICogYXR0cmlidXRlcyB3aGVyZSBpdCdzIGltcG9zc2libGUgdG8gZW51bWVyYXRlIGFsbCBvZiB0aGUgcG9zc2libGVcbiAgICogYXR0cmlidXRlIG5hbWVzLFxuICAgKlxuICAgKiBQcm9wZXJ0aWVzOiBvYmplY3QgbWFwcGluZyBET00gcHJvcGVydHkgbmFtZSB0byBvbmUgb2YgdGhlXG4gICAqIERPTVByb3BlcnR5SW5qZWN0aW9uIGNvbnN0YW50cyBvciBudWxsLiBJZiB5b3VyIGF0dHJpYnV0ZSBpc24ndCBpbiBoZXJlLFxuICAgKiBpdCB3b24ndCBnZXQgd3JpdHRlbiB0byB0aGUgRE9NLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxuICAgKiBhdHRyaWJ1dGUgbmFtZS4gQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSAqKmxvd2VyY2FzZSoqXG4gICAqIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXNwYWNlczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxuICAgKiBhdHRyaWJ1dGUgbmFtZXNwYWNlIFVSTC4gKEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSBubyBuYW1lc3BhY2UuKVxuICAgKlxuICAgKiBET01Qcm9wZXJ0eU5hbWVzOiBzaW1pbGFyIHRvIERPTUF0dHJpYnV0ZU5hbWVzIGJ1dCBmb3IgRE9NIHByb3BlcnRpZXMuXG4gICAqIFByb3BlcnR5IG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTU11dGF0aW9uTWV0aG9kczogUHJvcGVydGllcyB0aGF0IHJlcXVpcmUgc3BlY2lhbCBtdXRhdGlvbiBtZXRob2RzLiBJZlxuICAgKiBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgdGhlIG11dGF0aW9uIG1ldGhvZCBzaG91bGQgdW5zZXQgdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZG9tUHJvcGVydHlDb25maWcgdGhlIGNvbmZpZyBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAqL1xuICBpbmplY3RET01Qcm9wZXJ0eUNvbmZpZzogZnVuY3Rpb24gKGRvbVByb3BlcnR5Q29uZmlnKSB7XG4gICAgdmFyIEluamVjdGlvbiA9IERPTVByb3BlcnR5SW5qZWN0aW9uO1xuICAgIHZhciBQcm9wZXJ0aWVzID0gZG9tUHJvcGVydHlDb25maWcuUHJvcGVydGllcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXNwYWNlcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXMgfHwge307XG4gICAgdmFyIERPTVByb3BlcnR5TmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01Qcm9wZXJ0eU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01NdXRhdGlvbk1ldGhvZHMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01NdXRhdGlvbk1ldGhvZHMgfHwge307XG5cbiAgICBpZiAoZG9tUHJvcGVydHlDb25maWcuaXNDdXN0b21BdHRyaWJ1dGUpIHtcbiAgICAgIERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5wdXNoKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBQcm9wZXJ0aWVzKSB7XG4gICAgICAhIURPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2luamVjdERPTVByb3BlcnR5Q29uZmlnKC4uLik6IFlvdVxcJ3JlIHRyeWluZyB0byBpbmplY3QgRE9NIHByb3BlcnR5IFxcJyVzXFwnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5IGluamVjdGluZyB0aGUgc2FtZSBET00gcHJvcGVydHkgY29uZmlnIHR3aWNlLCBvciB5b3UgbWF5IGJlIGluamVjdGluZyB0d28gY29uZmlncyB0aGF0IGhhdmUgY29uZmxpY3RpbmcgcHJvcGVydHkgbmFtZXMuJywgcHJvcE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzQ4JywgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICB2YXIgbG93ZXJDYXNlZCA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcHJvcENvbmZpZyA9IFByb3BlcnRpZXNbcHJvcE5hbWVdO1xuXG4gICAgICB2YXIgcHJvcGVydHlJbmZvID0ge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBsb3dlckNhc2VkLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lc3BhY2U6IG51bGwsXG4gICAgICAgIHByb3BlcnR5TmFtZTogcHJvcE5hbWUsXG4gICAgICAgIG11dGF0aW9uTWV0aG9kOiBudWxsLFxuXG4gICAgICAgIG11c3RVc2VQcm9wZXJ0eTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWSksXG4gICAgICAgIGhhc0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc051bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFKVxuICAgICAgfTtcbiAgICAgICEocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSArIHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdET01Qcm9wZXJ0eTogVmFsdWUgY2FuIGJlIG9uZSBvZiBib29sZWFuLCBvdmVybG9hZGVkIGJvb2xlYW4sIG9yIG51bWVyaWMgdmFsdWUsIGJ1dCBub3QgYSBjb21iaW5hdGlvbjogJXMnLCBwcm9wTmFtZSkgOiBfcHJvZEludmFyaWFudCgnNTAnLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWRdID0gcHJvcE5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVthdHRyaWJ1dGVOYW1lXSA9IHByb3BOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlID0gRE9NQXR0cmlidXRlTmFtZXNwYWNlc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01Qcm9wZXJ0eU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lID0gRE9NUHJvcGVydHlOYW1lc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01NdXRhdGlvbk1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZCA9IERPTU11dGF0aW9uTWV0aG9kc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xuICAgIH1cbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSAnOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRCc7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBET01Qcm9wZXJ0eSBleHBvcnRzIGxvb2t1cCBvYmplY3RzIHRoYXQgY2FuIGJlIHVzZWQgbGlrZSBmdW5jdGlvbnM6XG4gKlxuICogICA+IERPTVByb3BlcnR5LmlzVmFsaWRbJ2lkJ11cbiAqICAgdHJ1ZVxuICogICA+IERPTVByb3BlcnR5LmlzVmFsaWRbJ2Zvb2JhciddXG4gKiAgIHVuZGVmaW5lZFxuICpcbiAqIEFsdGhvdWdoIHRoaXMgbWF5IGJlIGNvbmZ1c2luZywgaXQgcGVyZm9ybXMgYmV0dGVyIGluIGdlbmVyYWwuXG4gKlxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktZXhpc3RzXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1taXNzaW5nXG4gKi9cbnZhciBET01Qcm9wZXJ0eSA9IHtcblxuICBJRF9BVFRSSUJVVEVfTkFNRTogJ2RhdGEtcmVhY3RpZCcsXG4gIFJPT1RfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0cm9vdCcsXG5cbiAgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUjogQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUixcbiAgQVRUUklCVVRFX05BTUVfQ0hBUjogQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICdcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MCcsXG5cbiAgLyoqXG4gICAqIE1hcCBmcm9tIHByb3BlcnR5IFwic3RhbmRhcmQgbmFtZVwiIHRvIGFuIG9iamVjdCB3aXRoIGluZm8gYWJvdXQgaG93IHRvIHNldFxuICAgKiB0aGUgcHJvcGVydHkgaW4gdGhlIERPTS4gRWFjaCBvYmplY3QgY29udGFpbnM6XG4gICAqXG4gICAqIGF0dHJpYnV0ZU5hbWU6XG4gICAqICAgVXNlZCB3aGVuIHJlbmRlcmluZyBtYXJrdXAgb3Igd2l0aCBgKkF0dHJpYnV0ZSgpYC5cbiAgICogYXR0cmlidXRlTmFtZXNwYWNlXG4gICAqIHByb3BlcnR5TmFtZTpcbiAgICogICBVc2VkIG9uIERPTSBub2RlIGluc3RhbmNlcy4gKFRoaXMgaW5jbHVkZXMgcHJvcGVydGllcyB0aGF0IG11dGF0ZSBkdWUgdG9cbiAgICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAgICogbXV0YXRpb25NZXRob2Q6XG4gICAqICAgSWYgbm9uLW51bGwsIHVzZWQgaW5zdGVhZCBvZiB0aGUgcHJvcGVydHkgb3IgYHNldEF0dHJpYnV0ZSgpYCBhZnRlclxuICAgKiAgIGluaXRpYWwgcmVuZGVyLlxuICAgKiBtdXN0VXNlUHJvcGVydHk6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBhbmQgbXV0YXRlZCBhcyBhbiBvYmplY3QgcHJvcGVydHkuXG4gICAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogaGFzTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICAgKiAgIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gICAqICAgbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICAgKiAgIFJlbW92ZWQgd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlblxuICAgKiAgIHN0cmljdGx5IGVxdWFsIHRvIHRydWU7IHByZXNlbnQgd2l0aCBhIHZhbHVlIG90aGVyd2lzZS5cbiAgICovXG4gIHByb3BlcnRpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHByb3BlcnR5IG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLCB1c2VkXG4gICAqIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBwcm9wZXJ0aWVzLiBBdmFpbGFibGUgb25seSBpbiBfX0RFVl9fLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UG9zc2libGVTdGFuZGFyZE5hbWU6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB7fSA6IG51bGwsXG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGUgaXNDdXN0b21BdHRyaWJ1dGUoKSBmdW5jdGlvbnMgdGhhdCBoYXZlIGJlZW4gaW5qZWN0ZWQuXG4gICAqL1xuICBfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBjdXN0b20gYXR0cmlidXRlLlxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlzQ3VzdG9tQXR0cmlidXRlRm4gPSBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnNbaV07XG4gICAgICBpZiAoaXNDdXN0b21BdHRyaWJ1dGVGbihhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIGluamVjdGlvbjogRE9NUHJvcGVydHlJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9ET01Qcm9wZXJ0eS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudEZsYWdzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRGbGFncyA9IHtcbiAgaGFzQ2FjaGVkQ2hpbGROb2RlczogMSA8PCAwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudEZsYWdzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdEluamVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nKTtcbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQ2hhbmdlRXZlbnRQbHVnaW4nKTtcbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IHJlcXVpcmUoJy4vRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXInKTtcbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0VudGVyTGVhdmVFdmVudFBsdWdpbicpO1xudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vSFRNTERPTVByb3BlcnR5Q29uZmlnJyk7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTUVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTUVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RET01UcmVlVHJhdmVyc2FsID0gcmVxdWlyZSgnLi9SZWFjdERPTVRyZWVUcmF2ZXJzYWwnKTtcbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dENvbXBvbmVudCcpO1xudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3knKTtcbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRMaXN0ZW5lcicpO1xudmFyIFJlYWN0SW5qZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluamVjdGlvbicpO1xudmFyIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24nKTtcbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vU1ZHRE9NUHJvcGVydHlDb25maWcnKTtcbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2VsZWN0RXZlbnRQbHVnaW4nKTtcbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2ltcGxlRXZlbnRQbHVnaW4nKTtcblxudmFyIGFscmVhZHlJbmplY3RlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbmplY3QoKSB7XG4gIGlmIChhbHJlYWR5SW5qZWN0ZWQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGN1cnJlbnRseSB0cnVlIGJlY2F1c2UgdGhlc2UgaW5qZWN0aW9ucyBhcmUgc2hhcmVkIGJldHdlZW5cbiAgICAvLyB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyIHBhY2thZ2UuIFRoZXkgc2hvdWxkIGJlIGJ1aWx0IGluZGVwZW5kZW50bHlcbiAgICAvLyBhbmQgbm90IHNoYXJlIGFueSBpbmplY3Rpb24gc3RhdGUuIFRoZW4gdGhpcyBwcm9ibGVtIHdpbGwgYmUgc29sdmVkLlxuICAgIHJldHVybjtcbiAgfVxuICBhbHJlYWR5SW5qZWN0ZWQgPSB0cnVlO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50RW1pdHRlci5pbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIoUmVhY3RFdmVudExpc3RlbmVyKTtcblxuICAvKipcbiAgICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERlZmF1bHRFdmVudFBsdWdpbk9yZGVyKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5VdGlscy5pbmplY3RDb21wb25lbnRUcmVlKFJlYWN0RE9NQ29tcG9uZW50VHJlZSk7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0VHJlZVRyYXZlcnNhbChSZWFjdERPTVRyZWVUcmF2ZXJzYWwpO1xuXG4gIC8qKlxuICAgKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAgICogdGhlbSkuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1xuICAgIFNpbXBsZUV2ZW50UGx1Z2luOiBTaW1wbGVFdmVudFBsdWdpbixcbiAgICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgICBDaGFuZ2VFdmVudFBsdWdpbjogQ2hhbmdlRXZlbnRQbHVnaW4sXG4gICAgU2VsZWN0RXZlbnRQbHVnaW46IFNlbGVjdEV2ZW50UGx1Z2luLFxuICAgIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbiAgfSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uSG9zdENvbXBvbmVudC5pbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MoUmVhY3RET01Db21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkhvc3RDb21wb25lbnQuaW5qZWN0VGV4dENvbXBvbmVudENsYXNzKFJlYWN0RE9NVGV4dENvbXBvbmVudCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnKTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkVtcHR5Q29tcG9uZW50LmluamVjdEVtcHR5Q29tcG9uZW50RmFjdG9yeShmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgICByZXR1cm4gbmV3IFJlYWN0RE9NRW1wdHlDb21wb25lbnQoaW5zdGFudGlhdGUpO1xuICB9KTtcblxuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uQ29tcG9uZW50LmluamVjdEVudmlyb25tZW50KFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluamVjdDogaW5qZWN0XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50IEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlID0gcmVxdWlyZSgnLi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUnKTtcbnZhciBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljSW5wdXRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljSW5wdXRFdmVudCcpO1xuXG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgJiYgIWlzUHJlc3RvKCk7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbi8qKlxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcbiAqIHRleHQgaW5wdXQgZXZlbnRzLiBSZWx5IG9uIGtleXByZXNzIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xuICB2YXIgb3BlcmEgPSB3aW5kb3cub3BlcmE7XG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQmVmb3JlSW5wdXQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkJlZm9yZUlucHV0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BUZXh0SW5wdXQsIHRvcExldmVsVHlwZXMudG9wUGFzdGVdXG4gIH0sXG4gIGNvbXBvc2l0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvbkVuZDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25FbmRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH0sXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uU3RhcnQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25TdGFydCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uVXBkYXRlOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblVwZGF0ZSwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfVxufTtcblxuLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIG5hdGl2ZSBrZXlwcmVzcyBldmVudCBpcyBhc3N1bWVkIHRvIGJlIGEgY29tbWFuZC5cbiAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IGZpcmVzIGBrZXlwcmVzc2AgZXZlbnRzIGZvciBrZXkgY29tbWFuZHNcbiAqIChjdXQsIGNvcHksIHNlbGVjdC1hbGwsIGV0Yy4pIGV2ZW4gdGhvdWdoIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJlxuICAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25TdGFydDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uVXBkYXRlOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25VcGRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgbW9kZSB0aGluayB0aGF0IHRoaXMgZXZlbnQgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvbj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG4gICAgICByZXR1cm4gRU5EX0tFWUNPREVTLmluZGV4T2YobmF0aXZlRXZlbnQua2V5Q29kZSkgIT09IC0xO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRldGFpbCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBmYWxsYmFjayBvYmplY3QsIGlmIGFueS5cbnZhciBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuXG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50VHlwZTtcbiAgdmFyIGZhbGxiYWNrRGF0YTtcblxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xuICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gIH0gZWxzZSBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbiAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmdldFBvb2xlZChuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQpIHtcbiAgICAgIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRleHRJbnB1dDpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCB8fCBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucmVsZWFzZShjdXJyZW50Q29tcG9zaXRpb24pO1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZTpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCAmJiAhaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgcmV0dXJuIFtleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCksIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KV07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmVmb3JlSW5wdXRFdmVudFBsdWdpbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRDb25zdGFudHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcblxudmFyIFByb3BhZ2F0aW9uUGhhc2VzID0ga2V5TWlycm9yKHsgYnViYmxlZDogbnVsbCwgY2FwdHVyZWQ6IG51bGwgfSk7XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICB0b3BBYm9ydDogbnVsbCxcbiAgdG9wQW5pbWF0aW9uRW5kOiBudWxsLFxuICB0b3BBbmltYXRpb25JdGVyYXRpb246IG51bGwsXG4gIHRvcEFuaW1hdGlvblN0YXJ0OiBudWxsLFxuICB0b3BCbHVyOiBudWxsLFxuICB0b3BDYW5QbGF5OiBudWxsLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogbnVsbCxcbiAgdG9wQ2hhbmdlOiBudWxsLFxuICB0b3BDbGljazogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiBudWxsLFxuICB0b3BDb250ZXh0TWVudTogbnVsbCxcbiAgdG9wQ29weTogbnVsbCxcbiAgdG9wQ3V0OiBudWxsLFxuICB0b3BEb3VibGVDbGljazogbnVsbCxcbiAgdG9wRHJhZzogbnVsbCxcbiAgdG9wRHJhZ0VuZDogbnVsbCxcbiAgdG9wRHJhZ0VudGVyOiBudWxsLFxuICB0b3BEcmFnRXhpdDogbnVsbCxcbiAgdG9wRHJhZ0xlYXZlOiBudWxsLFxuICB0b3BEcmFnT3ZlcjogbnVsbCxcbiAgdG9wRHJhZ1N0YXJ0OiBudWxsLFxuICB0b3BEcm9wOiBudWxsLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogbnVsbCxcbiAgdG9wRW1wdGllZDogbnVsbCxcbiAgdG9wRW5jcnlwdGVkOiBudWxsLFxuICB0b3BFbmRlZDogbnVsbCxcbiAgdG9wRXJyb3I6IG51bGwsXG4gIHRvcEZvY3VzOiBudWxsLFxuICB0b3BJbnB1dDogbnVsbCxcbiAgdG9wSW52YWxpZDogbnVsbCxcbiAgdG9wS2V5RG93bjogbnVsbCxcbiAgdG9wS2V5UHJlc3M6IG51bGwsXG4gIHRvcEtleVVwOiBudWxsLFxuICB0b3BMb2FkOiBudWxsLFxuICB0b3BMb2FkZWREYXRhOiBudWxsLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogbnVsbCxcbiAgdG9wTG9hZFN0YXJ0OiBudWxsLFxuICB0b3BNb3VzZURvd246IG51bGwsXG4gIHRvcE1vdXNlTW92ZTogbnVsbCxcbiAgdG9wTW91c2VPdXQ6IG51bGwsXG4gIHRvcE1vdXNlT3ZlcjogbnVsbCxcbiAgdG9wTW91c2VVcDogbnVsbCxcbiAgdG9wUGFzdGU6IG51bGwsXG4gIHRvcFBhdXNlOiBudWxsLFxuICB0b3BQbGF5OiBudWxsLFxuICB0b3BQbGF5aW5nOiBudWxsLFxuICB0b3BQcm9ncmVzczogbnVsbCxcbiAgdG9wUmF0ZUNoYW5nZTogbnVsbCxcbiAgdG9wUmVzZXQ6IG51bGwsXG4gIHRvcFNjcm9sbDogbnVsbCxcbiAgdG9wU2Vla2VkOiBudWxsLFxuICB0b3BTZWVraW5nOiBudWxsLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6IG51bGwsXG4gIHRvcFN0YWxsZWQ6IG51bGwsXG4gIHRvcFN1Ym1pdDogbnVsbCxcbiAgdG9wU3VzcGVuZDogbnVsbCxcbiAgdG9wVGV4dElucHV0OiBudWxsLFxuICB0b3BUaW1lVXBkYXRlOiBudWxsLFxuICB0b3BUb3VjaENhbmNlbDogbnVsbCxcbiAgdG9wVG91Y2hFbmQ6IG51bGwsXG4gIHRvcFRvdWNoTW92ZTogbnVsbCxcbiAgdG9wVG91Y2hTdGFydDogbnVsbCxcbiAgdG9wVHJhbnNpdGlvbkVuZDogbnVsbCxcbiAgdG9wVm9sdW1lQ2hhbmdlOiBudWxsLFxuICB0b3BXYWl0aW5nOiBudWxsLFxuICB0b3BXaGVlbDogbnVsbFxufSk7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHtcbiAgdG9wTGV2ZWxUeXBlczogdG9wTGV2ZWxUeXBlcyxcbiAgUHJvcGFnYXRpb25QaGFzZXM6IFByb3BhZ2F0aW9uUGhhc2VzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50Q29uc3RhbnRzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRDb25zdGFudHMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQcm9wYWdhdG9yc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFByb3BhZ2F0aW9uUGhhc2VzID0gRXZlbnRDb25zdGFudHMuUHJvcGFnYXRpb25QaGFzZXM7XG52YXIgZ2V0TGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcjtcblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCB1cHdhcmRzLCBldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3QsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgfVxuICB2YXIgcGhhc2UgPSB1cHdhcmRzID8gUHJvcGFnYXRpb25QaGFzZXMuYnViYmxlZCA6IFByb3BhZ2F0aW9uUGhhc2VzLmNhcHR1cmVkO1xuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gRXZlbnRQbHVnaW5VdGlscy5nZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZVR3b1BoYXNlKHBhcmVudEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW50IGFcbiAqIHNpbmdsZSBvbmUuXG4gKlxuICogQGNvbnN0cnVjdG9yIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSB7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFByb3BhZ2F0b3JzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRQcm9wYWdhdG9ycy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpbkh1YlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogSW50ZXJuYWwgc3RvcmUgZm9yIGV2ZW50IGxpc3RlbmVyc1xuICovXG52YXIgbGlzdGVuZXJCYW5rID0ge307XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCB0cnVlKTtcbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIGZhbHNlKTtcbn07XG5cbnZhciBnZXREaWN0aW9uYXJ5S2V5ID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgLy8gUHJldmVudHMgVjggcGVyZm9ybWFuY2UgaXNzdWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgcmV0dXJuICcuJyArIGluc3QuX3Jvb3ROb2RlSUQ7XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gKlxuICogRXZlbnQgcGx1Z2lucyBjYW4gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxuICogICAgIFJlcXVpcmVkLiBXaGVuIGEgdG9wLWxldmVsIGV2ZW50IGlzIGZpcmVkLCB0aGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0b1xuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXG4gKlxuICogICBgZXZlbnRUeXBlc2Age29iamVjdH1cbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxuICogICAgIGJlIG9iamVjdHMgdGhhdCBjb250YWluIGByZWdpc3RyYXRpb25OYW1lYCBvciBgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNgLlxuICpcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XG4gKiAgICAgT3B0aW9uYWwsIGFsbG93cyBwbHVnaW5zIHRvIG92ZXJyaWRlIGhvdyBhbiBldmVudCBnZXRzIGRpc3BhdGNoZWQuIEJ5XG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxuICpcbiAqIEVhY2ggcGx1Z2luIHRoYXQgaXMgaW5qZWN0ZWQgaW50byBgRXZlbnRzUGx1Z2luSHViYCBpcyBpbW1lZGlhdGVseSBvcGVyYWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBFdmVudFBsdWdpbkh1YiA9IHtcblxuICAvKipcbiAgICogTWV0aG9kcyBmb3IgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAgICovXG4gIGluamVjdGlvbjoge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcblxuICB9LFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYGxpc3RlbmVyYCBhdCBgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV1gLiBJcyBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBzdG9yZS5cbiAgICovXG4gIHB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAhKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgJXMgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgdHlwZSAlcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiBfcHJvZEludmFyaWFudCgnOTQnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xuXG4gICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdIHx8IChsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gPSB7fSk7XG4gICAgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XSA9IGxpc3RlbmVyO1xuXG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAgICovXG4gIGdldExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICByZXR1cm4gYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgJiYgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XTtcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhIGxpc3RlbmVyIGZyb20gdGhlIHJlZ2lzdHJhdGlvbiBiYW5rLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqL1xuICBkZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG5ldmVyIGJlIG51bGwgLS0gd2hlbiBpcyBpdD9cbiAgICBpZiAoYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgZGVsZXRlIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBET00gZWxlbWVudCB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICovXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIGxpc3RlbmVyQmFuaykge1xuICAgICAgaWYgKCFsaXN0ZW5lckJhbmsuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAgICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIHZhciBwbHVnaW5zID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgIGlmIChwb3NzaWJsZVBsdWdpbikge1xuICAgICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgICBldmVudHMgPSBhY2N1bXVsYXRlSW50byhldmVudHMsIGV4dHJhY3RlZEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzeW50aGV0aWMgZXZlbnQgdGhhdCBzaG91bGQgYmUgZGlzcGF0Y2hlZCB3aGVuXG4gICAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBldmVudHMgQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUV2ZW50czogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIGV2ZW50UXVldWUgPSBhY2N1bXVsYXRlSW50byhldmVudFF1ZXVlLCBldmVudHMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbGwgc3ludGhldGljIGV2ZW50cyBvbiB0aGUgZXZlbnQgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc0V2ZW50UXVldWU6IGZ1bmN0aW9uIChzaW11bGF0ZWQpIHtcbiAgICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gICAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICAgIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XG4gICAgZXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgaWYgKHNpbXVsYXRlZCkge1xuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgICB9XG4gICAgISFldmVudFF1ZXVlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyBhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzk1JykgOiB2b2lkIDA7XG4gICAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gICAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgbmVlZGVkIGZvciB0ZXN0cyBvbmx5LiBEbyBub3QgdXNlIVxuICAgKi9cbiAgX19wdXJnZTogZnVuY3Rpb24gKCkge1xuICAgIGxpc3RlbmVyQmFuayA9IHt9O1xuICB9LFxuXG4gIF9fZ2V0TGlzdGVuZXJCYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5IdWIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQbHVnaW5SZWdpc3RyeVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIEV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIUV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBFdmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBFdmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbnMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIHBsdWdpbiBvcmRlcmluZywgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5NicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIVBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTcnLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdID0gUGx1Z2luTW9kdWxlO1xuICAgIHZhciBwdWJsaXNoZWRFdmVudHMgPSBQbHVnaW5Nb2R1bGUuZXZlbnRUeXBlcztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcHVibGlzaGVkRXZlbnRzKSB7XG4gICAgICAhcHVibGlzaEV2ZW50Rm9yUGx1Z2luKHB1Ymxpc2hlZEV2ZW50c1tldmVudE5hbWVdLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5OCcsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTknLCBldmVudE5hbWUpIDogdm9pZCAwO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cyBhbmRcbiAqIGNhbiBiZSB1c2VkIHdpdGggYEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyYCB0byByZWdpc3RlciBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgUmVnaXN0cmF0aW9uIG5hbWUgdG8gYWRkLlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShyZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIHJlZ2lzdHJhdGlvbiBuYW1lLCBgJXNgLicsIHJlZ2lzdHJhdGlvbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzEwMCcsIHJlZ2lzdHJhdGlvbk5hbWUpIDogdm9pZCAwO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gUGx1Z2luTW9kdWxlO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBQbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5vbmRibGNsaWNrID0gcmVnaXN0cmF0aW9uTmFtZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgcGx1Z2lucyBzbyB0aGF0IHRoZXkgY2FuIGV4dHJhY3QgYW5kIGRpc3BhdGNoIGV2ZW50cy5cbiAqXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yn1cbiAqL1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSB7XG5cbiAgLyoqXG4gICAqIE9yZGVyZWQgbGlzdCBvZiBpbmplY3RlZCBwbHVnaW5zLlxuICAgKi9cbiAgcGx1Z2luczogW10sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBldmVudCBuYW1lIHRvIGRpc3BhdGNoIGNvbmZpZ1xuICAgKi9cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIHBsdWdpbiBtb2R1bGVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIGV2ZW50IG5hbWVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHJlZ2lzdHJhdGlvbiBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbixcbiAgICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICAgKiBvbmx5IGluIF9fREVWX18uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge30gOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gICAqIHRvIGJlIGRlY291cGxlZCBmcm9tIGluamVjdGlvbiBvZiB0aGUgYWN0dWFsIHBsdWdpbnMgc28gdGhhdCBvcmRlcmluZyBpc1xuICAgKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGZ1bmN0aW9uIChJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAhIUV2ZW50UGx1Z2luT3JkZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW4gb3JkZXJpbmcgbW9yZSB0aGFuIG9uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDEnKSA6IHZvaWQgMDtcbiAgICAvLyBDbG9uZSB0aGUgb3JkZXJpbmcgc28gaXQgY2Fubm90IGJlIGR5bmFtaWNhbGx5IG11dGF0ZWQuXG4gICAgRXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKEluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gICAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXG4gICAqXG4gICAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGZ1bmN0aW9uIChpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIGlzT3JkZXJpbmdEaXJ0eSA9IGZhbHNlO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICBpZiAoIW5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpIHx8IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdICE9PSBQbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IHR3byBkaWZmZXJlbnQgZXZlbnQgcGx1Z2lucyB1c2luZyB0aGUgc2FtZSBuYW1lLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzEwMicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IFBsdWdpbk1vZHVsZTtcbiAgICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xuICAgICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvb2tzIHVwIHRoZSBwbHVnaW4gZm9yIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IEEgc3ludGhldGljIGV2ZW50LlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBUaGUgcGx1Z2luIHRoYXQgY3JlYXRlZCB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UGx1Z2luTW9kdWxlRm9yRXZlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnO1xuICAgIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICByZXR1cm4gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lXSB8fCBudWxsO1xuICAgIH1cbiAgICBmb3IgKHZhciBwaGFzZSBpbiBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKCFkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZV1dO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSkge1xuICAgICAgICByZXR1cm4gUGx1Z2luTW9kdWxlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0RXZlbnRQbHVnaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgRXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKG5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xuICAgICAgaWYgKGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMpIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBkZWxldGUgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuICAgICAgZm9yICh2YXIgbG93ZXJDYXNlZE5hbWUgaW4gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgICBpZiAocG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgICAgICBkZWxldGUgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblV0aWxzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSW5qZWN0ZWQgZGVwZW5kZW5jaWVzOlxuICovXG5cbi8qKlxuICogLSBgQ29tcG9uZW50VHJlZWA6IFtyZXF1aXJlZF0gTW9kdWxlIHRoYXQgY2FuIGNvbnZlcnQgYmV0d2VlbiBSZWFjdCBpbnN0YW5jZXNcbiAqICAgYW5kIGFjdHVhbCBub2RlIHJlZmVyZW5jZXMuXG4gKi9cbnZhciBDb21wb25lbnRUcmVlO1xudmFyIFRyZWVUcmF2ZXJzYWw7XG52YXIgaW5qZWN0aW9uID0ge1xuICBpbmplY3RDb21wb25lbnRUcmVlOiBmdW5jdGlvbiAoSW5qZWN0ZWQpIHtcbiAgICBDb21wb25lbnRUcmVlID0gSW5qZWN0ZWQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEluamVjdGVkICYmIEluamVjdGVkLmdldE5vZGVGcm9tSW5zdGFuY2UgJiYgSW5qZWN0ZWQuZ2V0SW5zdGFuY2VGcm9tTm9kZSwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdENvbXBvbmVudFRyZWUoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBnZXROb2RlRnJvbUluc3RhbmNlIG9yIGdldEluc3RhbmNlRnJvbU5vZGUuJykgOiB2b2lkIDA7XG4gICAgfVxuICB9LFxuICBpbmplY3RUcmVlVHJhdmVyc2FsOiBmdW5jdGlvbiAoSW5qZWN0ZWQpIHtcbiAgICBUcmVlVHJhdmVyc2FsID0gSW5qZWN0ZWQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEluamVjdGVkICYmIEluamVjdGVkLmlzQW5jZXN0b3IgJiYgSW5qZWN0ZWQuZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RUcmVlVHJhdmVyc2FsKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgaXNBbmNlc3RvciBvciBnZXRMb3dlc3RDb21tb25BbmNlc3Rvci4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuZnVuY3Rpb24gaXNFbmRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VVcCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoQ2FuY2VsO1xufVxuXG5mdW5jdGlvbiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VNb3ZlIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDtcbn1cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4sICdFdmVudFBsdWdpblV0aWxzOiBJbnZhbGlkIGBldmVudGAuJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFja1xuICogQHBhcmFtIHsqfSBpbnN0IEludGVybmFsIGNvbXBvbmVudCBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgbGlzdGVuZXIsIGluc3QpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IEV2ZW50UGx1Z2luVXRpbHMuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2godHlwZSwgbGlzdGVuZXIsIGV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrKHR5cGUsIGxpc3RlbmVyLCBldmVudCk7XG4gIH1cbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcywgYnV0IHN0b3BzXG4gKiBhdCB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHJldHVybmluZyB0cnVlLCBhbmQgcmV0dXJucyB0aGF0IGlkLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IGlkIG9mIHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gd2hvJ3MgbGlzdGVuZXIgcmV0dXJuc1xuICogdHJ1ZSwgb3IgbnVsbCBpZiBubyBsaXN0ZW5lciByZXR1cm5lZCB0cnVlLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEluc3RhbmNlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSW5zdGFuY2VzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcbiAgdmFyIHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlyZWN0RGlzcGF0Y2goZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXIgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICAhIUFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZXhlY3V0ZURpcmVjdERpc3BhdGNoKC4uLik6IEludmFsaWQgYGV2ZW50YC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDMnKSA6IHZvaWQgMDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGRpc3BhdGNoTGlzdGVuZXIgPyBFdmVudFBsdWdpblV0aWxzLmdldE5vZGVGcm9tSW5zdGFuY2UoZGlzcGF0Y2hJbnN0YW5jZSkgOiBudWxsO1xuICB2YXIgcmVzID0gZGlzcGF0Y2hMaXN0ZW5lciA/IGRpc3BhdGNoTGlzdGVuZXIoZXZlbnQpIDogbnVsbDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbn1cblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdGllcyB0aGF0IGFyZSB1c2VmdWwgaW4gY3JlYXRpbmcgY3VzdG9tIEV2ZW50IFBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xuICBpc0VuZGlzaDogaXNFbmRpc2gsXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxuXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZTogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSxcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcblxuICBnZXRJbnN0YW5jZUZyb21Ob2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBDb21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gIH0sXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShub2RlKTtcbiAgfSxcbiAgaXNBbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5pc0FuY2VzdG9yKGEsIGIpO1xuICB9LFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5nZXRMb3dlc3RDb21tb25BbmNlc3RvcihhLCBiKTtcbiAgfSxcbiAgZ2V0UGFyZW50SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCk7XG4gIH0sXG4gIHRyYXZlcnNlVHdvUGhhc2U6IGZ1bmN0aW9uICh0YXJnZXQsIGZuLCBhcmcpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZVR3b1BoYXNlKHRhcmdldCwgZm4sIGFyZyk7XG4gIH0sXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogZnVuY3Rpb24gKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbyk7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBpbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5VdGlscztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luVXRpbHMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFcnJvclV0aWxzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICpcbiAqIEBwYXJhbSB7P1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGEgRmlyc3QgYXJndW1lbnRcbiAqIEBwYXJhbSB7Kn0gYiBTZWNvbmQgYXJndW1lbnRcbiAqL1xuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGEsIGIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnVuYyhhLCBiKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIGlmIChjYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgY2F1Z2h0RXJyb3IgPSB4O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbnZhciBSZWFjdEVycm9yVXRpbHMgPSB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjazogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJ5IFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlIHNvIHRoYXQgYW55IGVycm9ycyB0aHJvd24gYnkgdGhlIGV2ZW50XG4gICAqIGhhbmRsZXIgYXJlIHN1cmUgdG8gYmUgcmV0aHJvd24gYnkgcmV0aHJvd0NhdWdodEVycm9yLlxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2F1Z2h0RXJyb3IpIHtcbiAgICAgIHZhciBlcnJvciA9IGNhdWdodEVycm9yO1xuICAgICAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvKipcbiAgICogVG8gaGVscCBkZXZlbG9wbWVudCB3ZSBjYW4gZ2V0IGJldHRlciBkZXZ0b29scyBpbnRlZ3JhdGlvbiBieSBzaW11bGF0aW5nIGFcbiAgICogcmVhbCBicm93c2VyIGV2ZW50LlxuICAgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBhLCBiKSB7XG4gICAgICB2YXIgYm91bmRGdW5jID0gZnVuYy5iaW5kKG51bGwsIGEsIGIpO1xuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIG5hbWU7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFcnJvclV0aWxzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFcnJvclV0aWxzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGFjY3VtdWxhdGVJbnRvXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IF9wcm9kSW52YXJpYW50KCczMCcpIDogdm9pZCAwO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWNjdW11bGF0ZUludG87XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9hY2N1bXVsYXRlSW50by5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmb3JFYWNoQWNjdW11bGF0ZWRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqL1xuXG5mdW5jdGlvbiBmb3JFYWNoQWNjdW11bGF0ZWQoYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hBY2N1bXVsYXRlZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2ZvckVhY2hBY2N1bXVsYXRlZC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgY2xhc3Mgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gcm9vdFxuICovXG5mdW5jdGlvbiBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUocm9vdCkge1xuICB0aGlzLl9yb290ID0gcm9vdDtcbiAgdGhpcy5fc3RhcnRUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbl9hc3NpZ24oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnByb3RvdHlwZSwge1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5fc3RhcnRUZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCB0ZXh0IG9mIGlucHV0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRUZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCd2YWx1ZScgaW4gdGhpcy5fcm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgZGlmZmVyaW5nIHN1YnN0cmluZyBiZXR3ZWVuIHRoZSBpbml0aWFsbHkgc3RvcmVkXG4gICAqIHRleHQgY29udGVudCBhbmQgdGhlIGN1cnJlbnQgY29udGVudC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0RGF0YTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9mYWxsYmFja1RleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0O1xuICAgIHZhciBzdGFydFZhbHVlID0gdGhpcy5fc3RhcnRUZXh0O1xuICAgIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICAgIHZhciBlbmQ7XG4gICAgdmFyIGVuZFZhbHVlID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICAgIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQ29tcG9zaXRpb25FdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xudmFyIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ29tcG9zaXRpb25FdmVudCwgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IGZhbHNlO1xudmFyIGlzUHJveHlTdXBwb3J0ZWQgPSB0eXBlb2YgUHJveHkgPT09ICdmdW5jdGlvbic7XG5cbnZhciBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcyA9IFsnZGlzcGF0Y2hDb25maWcnLCAnX3RhcmdldEluc3QnLCAnbmF0aXZlRXZlbnQnLCAnaXNEZWZhdWx0UHJldmVudGVkJywgJ2lzUHJvcGFnYXRpb25TdG9wcGVkJywgJ19kaXNwYXRjaExpc3RlbmVycycsICdfZGlzcGF0Y2hJbnN0YW5jZXMnXTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICB0YXJnZXQ6IG51bGwsXG4gIC8vIGN1cnJlbnRUYXJnZXQgaXMgc2V0IHdoZW4gZGlzcGF0Y2hpbmc7IG5vIHVzZSBpbiBjb3B5aW5nIGl0IGhlcmVcbiAgY3VycmVudFRhcmdldDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsXG4gIGV2ZW50UGhhc2U6IG51bGwsXG4gIGJ1YmJsZXM6IG51bGwsXG4gIGNhbmNlbGFibGU6IG51bGwsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiBudWxsLFxuICBpc1RydXN0ZWQ6IG51bGxcbn07XG5cbi8qKlxuICogU3ludGhldGljIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBieSBldmVudCBwbHVnaW5zLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gYVxuICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAqXG4gKiBUaGVzZSBzeXN0ZW1zIHNob3VsZCBnZW5lcmFsbHkgdXNlIHBvb2xpbmcgdG8gcmVkdWNlIHRoZSBmcmVxdWVuY3kgb2YgZ2FyYmFnZVxuICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gKiBuZWVkIGEgcGVyc2lzdGVkIGV2ZW50IHNob3VsZCBpbnZva2UgYHBlcnNpc3RgLlxuICpcbiAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAqIG5vcm1hbGl6aW5nIGJyb3dzZXIgcXVpcmtzLiBTdWJjbGFzc2VzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGltcGxlbWVudCBhXG4gKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHsqfSB0YXJnZXRJbnN0IE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gbmF0aXZlRXZlbnRUYXJnZXQgVGFyZ2V0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0V2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyB0aGVzZSBoYXZlIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICBkZWxldGUgdGhpcy5uYXRpdmVFdmVudDtcbiAgICBkZWxldGUgdGhpcy5wcmV2ZW50RGVmYXVsdDtcbiAgICBkZWxldGUgdGhpcy5zdG9wUHJvcGFnYXRpb247XG4gIH1cblxuICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gZGlzcGF0Y2hDb25maWc7XG4gIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG5cbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSB2YWxpZC10eXBlb2ZcbiAgICAgIC8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4gICAgICAvLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxuICAgICAgLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuICAgICAgLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4gICAgICAvLyBJRSBzcGVjaWZpYykuXG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BOYW1lLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBJbnRlcmZhY2VbcHJvcE5hbWVdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXNbc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXNbaV1dID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxuXG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlmIChpc1Byb3h5U3VwcG9ydGVkKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICAgIFN5bnRoZXRpY0V2ZW50ID0gbmV3IFByb3h5KFN5bnRoZXRpY0V2ZW50LCB7XG4gICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkodGFyZ2V0LCBPYmplY3QuY3JlYXRlKHRhcmdldC5wcm90b3R5cGUpLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBhcHBseTogZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCB0aGF0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJncyksIHtcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2lzUGVyc2lzdGVudCcgJiYgIXRhcmdldC5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgfHwgdGFyZ2V0LmlzUGVyc2lzdGVudCgpLCAnVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcXCdyZSAnICsgJ3NlZWluZyB0aGlzLCB5b3VcXCdyZSBhZGRpbmcgYSBuZXcgcHJvcGVydHkgaW4gdGhlIHN5bnRoZXRpYyBldmVudCBvYmplY3QuICcgKyAnVGhlIHByb3BlcnR5IGlzIG5ldmVyIHJlbGVhc2VkLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKmVzbGludC1lbmFibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gcmVkdWNlIGJvaWxlcnBsYXRlIHdoZW4gY3JlYXRpbmcgc3ViY2xhc3Nlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzc1xuICogQHBhcmFtIHs/b2JqZWN0fSBJbnRlcmZhY2VcbiAqL1xuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzID0gZnVuY3Rpb24gKENsYXNzLCBJbnRlcmZhY2UpIHtcbiAgdmFyIFN1cGVyID0gdGhpcztcblxuICB2YXIgRSA9IGZ1bmN0aW9uICgpIHt9O1xuICBFLnByb3RvdHlwZSA9IFN1cGVyLnByb3RvdHlwZTtcbiAgdmFyIHByb3RvdHlwZSA9IG5ldyBFKCk7XG5cbiAgX2Fzc2lnbihwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5hdWdtZW50Q2xhc3MgPSBTdXBlci5hdWdtZW50Q2xhc3M7XG5cbiAgUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENsYXNzLCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xufTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50LCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0V2ZW50O1xuXG4vKipcbiAgKiBIZWxwZXIgdG8gbnVsbGlmeSBzeW50aGV0aWNFdmVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gZGVzdHJ1Y3RpbmdcbiAgKlxuICAqIEBwYXJhbSB7b2JqZWN0fSBTeW50aGV0aWNFdmVudFxuICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICAqIEByZXR1cm4ge29iamVjdH0gZGVmaW5lUHJvcGVydHkgb2JqZWN0XG4gICovXG5mdW5jdGlvbiBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBnZXRWYWwpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnIDogJ2FjY2Vzc2luZyB0aGUgcHJvcGVydHknO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGdldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oYWN0aW9uLCByZXN1bHQpIHtcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5pbmdDb25kaXRpb24sICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlIHNlZWluZyB0aGlzLCAnICsgJ3lvdVxcJ3JlICVzIGAlc2Agb24gYSByZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiAlcy4gJyArICdJZiB5b3UgbXVzdCBrZWVwIHRoZSBvcmlnaW5hbCBzeW50aGV0aWMgZXZlbnQgYXJvdW5kLCB1c2UgZXZlbnQucGVyc2lzdCgpLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgYWN0aW9uLCBwcm9wTmFtZSwgcmVzdWx0KSA6IHZvaWQgMDtcbiAgfVxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljSW5wdXRFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0lucHV0RXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljSW5wdXRFdmVudCwgSW5wdXRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljSW5wdXRFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2hhbmdlRXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DaGFuZ2U6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNoYW5nZUNhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UsIHRvcExldmVsVHlwZXMudG9wQ2xpY2ssIHRvcExldmVsVHlwZXMudG9wRm9jdXMsIHRvcExldmVsVHlwZXMudG9wSW5wdXQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2VdXG4gIH1cbn07XG5cbi8qKlxuICogRm9yIElFIHNoaW1zXG4gKi9cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxudmFyIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBTZWUgYGhhbmRsZUNoYW5nZWAgY29tbWVudCBiZWxvd1xuICBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBpc0V2ZW50U3VwcG9ydGVkKCdjaGFuZ2UnKSAmJiAoISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOCk7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCBhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnQpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUeXBlLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cykge1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgLy8gSUUxMCsgZmlyZSBpbnB1dCBldmVudHMgdG8gb2Z0ZW4sIHN1Y2ggd2hlbiBhIHBsYWNlaG9sZGVyXG4gIC8vIGNoYW5nZXMgb3Igd2hlbiBhbiBpbnB1dCB3aXRoIGEgcGxhY2Vob2xkZXIgaXMgZm9jdXNlZC5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gMTEpO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgUmVwbGFjZW1lbnQgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGB2YWx1ZWAgcHJvcGVydHkgdGhhdCBnZXRzXG4gKiBzZXQgb24gdGhlIGFjdGl2ZSBlbGVtZW50LlxuICovXG52YXIgbmV3VmFsdWVQcm9wID0ge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5nZXQuY2FsbCh0aGlzKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgLy8gQ2FzdCB0byBhIHN0cmluZyBzbyB3ZSBjYW4gZG8gZXF1YWxpdHkgY2hlY2tzLlxuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9ICcnICsgdmFsO1xuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3Auc2V0LmNhbGwodGhpcywgdmFsKTtcbiAgfVxufTtcblxuLyoqXG4gKiAoRm9yIElFIDw9MTEpIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB0YXJnZXQudmFsdWU7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICd2YWx1ZScpO1xuXG4gIC8vIE5vdCBndWFyZGVkIGluIGEgY2FuRGVmaW5lUHJvcGVydHkgY2hlY2s6IElFOCBzdXBwb3J0cyBkZWZpbmVQcm9wZXJ0eSBvbmx5XG4gIC8vIG9uIERPTSBlbGVtZW50c1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWN0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbmV3VmFsdWVQcm9wKTtcbiAgaWYgKGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICB9IGVsc2Uge1xuICAgIGFjdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY3VycmVudGx5LXRyYWNrZWQgZWxlbWVudCxcbiAqIGlmIGFueSBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBkZWxldGUgcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHByb3BlcnR5IGRlZmluaXRpb25cbiAgZGVsZXRlIGFjdGl2ZUVsZW1lbnQudmFsdWU7XG5cbiAgaWYgKGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQpIHtcbiAgICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICB9IGVsc2Uge1xuICAgIGFjdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSwgZmFsc2UpO1xuICB9XG5cbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdmFsdWUgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50LnZhbHVlO1xuICBpZiAodmFsdWUgPT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB2YWx1ZTtcblxuICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcbn1cblxuLyoqXG4gKiBJZiBhIGBjaGFuZ2VgIGV2ZW50IHNob3VsZCBiZSBmaXJlZCwgcmV0dXJucyB0aGUgdGFyZ2V0J3MgSUQuXG4gKi9cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcElucHV0KSB7XG4gICAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzIChpLmUuLCBub3QgSUU4IG9yIElFOSksIHRoZSBpbnB1dCBldmVudCBpcyBleGFjdGx5XG4gICAgLy8gd2hhdCB3ZSB3YW50IHNvIGZhbGwgdGhyb3VnaCBoZXJlIGFuZCB0cmlnZ2VyIGFuIGFic3RyYWN0IGV2ZW50XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFKHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMpIHtcbiAgICAvLyBJbiBJRTgsIHdlIGNhbiBjYXB0dXJlIGFsbW9zdCBhbGwgLnZhbHVlIGNoYW5nZXMgYnkgYWRkaW5nIGFcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBoYW5kbGVyIGFuZCBsb29raW5nIGZvciBldmVudHMgd2l0aCBwcm9wZXJ0eU5hbWVcbiAgICAvLyBlcXVhbCB0byAndmFsdWUnXG4gICAgLy8gSW4gSUU5LTExLCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudElFKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZSB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5VXAgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24pIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LnZhbHVlICE9PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IGFjdGl2ZUVsZW1lbnQudmFsdWU7XG4gICAgICByZXR1cm4gYWN0aXZlRWxlbWVudEluc3Q7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDbGljaykge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBpZiAoZG9lc0NoYW5nZUV2ZW50QnViYmxlKSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRJRTtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2hvdWxkVXNlQ2xpY2tFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudDtcbiAgICB9XG5cbiAgICBpZiAoZ2V0VGFyZ2V0SW5zdEZ1bmMpIHtcbiAgICAgIHZhciBpbnN0ID0gZ2V0VGFyZ2V0SW5zdEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KTtcbiAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmNoYW5nZSwgaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgZXZlbnQudHlwZSA9ICdjaGFuZ2UnO1xuICAgICAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgICAgaGFuZGxlRXZlbnRGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0Tm9kZSwgdGFyZ2V0SW5zdCk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhbmdlRXZlbnRQbHVnaW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFVwZGF0ZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBkaXJ0eUNvbXBvbmVudHMgPSBbXTtcbnZhciB1cGRhdGVCYXRjaE51bWJlciA9IDA7XG52YXIgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xudmFyIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuXG52YXIgYmF0Y2hpbmdTdHJhdGVneSA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuc3VyZUluamVjdGVkKCkge1xuICAhKFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uICYmIGJhdGNoaW5nU3RyYXRlZ3kpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBpbmplY3QgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MgYW5kIGJhdGNoaW5nIHN0cmF0ZWd5JykgOiBfcHJvZEludmFyaWFudCgnMTIzJykgOiB2b2lkIDA7XG59XG5cbnZhciBORVNURURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gZGlydHlDb21wb25lbnRzLmxlbmd0aDtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggIT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIEFkZGl0aW9uYWwgdXBkYXRlcyB3ZXJlIGVucXVldWVkIGJ5IGNvbXBvbmVudERpZFVwZGF0ZSBoYW5kbGVycyBvclxuICAgICAgLy8gc2ltaWxhcjsgYmVmb3JlIG91ciBvd24gVVBEQVRFX1FVRVVFSU5HIHdyYXBwZXIgY2xvc2VzLCB3ZSB3YW50IHRvIHJ1blxuICAgICAgLy8gdGhlc2UgbmV3IHVwZGF0ZXMgc28gdGhhdCBpZiBBJ3MgY29tcG9uZW50RGlkVXBkYXRlIGNhbGxzIHNldFN0YXRlIG9uXG4gICAgICAvLyBCLCBCIHdpbGwgdXBkYXRlIGJlZm9yZSB0aGUgY2FsbGJhY2sgQSdzIHVwZGF0ZXIgcHJvdmlkZWQgd2hlbiBjYWxsaW5nXG4gICAgICAvLyBzZXRTdGF0ZS5cbiAgICAgIGRpcnR5Q29tcG9uZW50cy5zcGxpY2UoMCwgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGgpO1xuICAgICAgZmx1c2hCYXRjaGVkVXBkYXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBVUERBVEVfUVVFVUVJTkcgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUucmVzZXQoKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtORVNURURfVVBEQVRFUywgVVBEQVRFX1FVRVVFSU5HXTtcblxuZnVuY3Rpb24gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi90cnVlKTtcbn1cblxuX2Fzc2lnbihSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLmNhbGxiYWNrUXVldWUpO1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IG51bGw7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgfSxcblxuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSkge1xuICAgIC8vIEVzc2VudGlhbGx5IGNhbGxzIGB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0obWV0aG9kLCBzY29wZSwgYSlgXG4gICAgLy8gd2l0aCB0aGlzIHRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgYXJvdW5kIGl0LlxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5NaXhpbi5wZXJmb3JtLmNhbGwodGhpcywgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLCBtZXRob2QsIHNjb3BlLCBhKTtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKTtcblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcbiAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSk7XG59XG5cbi8qKlxuICogQXJyYXkgY29tcGFyYXRvciBmb3IgUmVhY3RDb21wb25lbnRzIGJ5IG1vdW50IG9yZGVyaW5nLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMxIGZpcnN0IGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMiBzZWNvbmQgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJuIHZhbHVlIHVzYWJsZSBieSBBcnJheS5wcm90b3R5cGUuc29ydCgpLlxuICovXG5mdW5jdGlvbiBtb3VudE9yZGVyQ29tcGFyYXRvcihjMSwgYzIpIHtcbiAgcmV0dXJuIGMxLl9tb3VudE9yZGVyIC0gYzIuX21vdW50T3JkZXI7XG59XG5cbmZ1bmN0aW9uIHJ1bkJhdGNoZWRVcGRhdGVzKHRyYW5zYWN0aW9uKSB7XG4gIHZhciBsZW4gPSB0cmFuc2FjdGlvbi5kaXJ0eUNvbXBvbmVudHNMZW5ndGg7XG4gICEobGVuID09PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBmbHVzaCB0cmFuc2FjdGlvblxcJ3Mgc3RvcmVkIGRpcnR5LWNvbXBvbmVudHMgbGVuZ3RoICglcykgdG8gbWF0Y2ggZGlydHktY29tcG9uZW50cyBhcnJheSBsZW5ndGggKCVzKS4nLCBsZW4sIGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIDogX3Byb2RJbnZhcmlhbnQoJzEyNCcsIGxlbiwgZGlydHlDb21wb25lbnRzLmxlbmd0aCkgOiB2b2lkIDA7XG5cbiAgLy8gU2luY2UgcmVjb25jaWxpbmcgYSBjb21wb25lbnQgaGlnaGVyIGluIHRoZSBvd25lciBoaWVyYXJjaHkgdXN1YWxseSAobm90XG4gIC8vIGFsd2F5cyAtLSBzZWUgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkpIHdpbGwgcmVjb25jaWxlIGNoaWxkcmVuLCByZWNvbmNpbGVcbiAgLy8gdGhlbSBiZWZvcmUgdGhlaXIgY2hpbGRyZW4gYnkgc29ydGluZyB0aGUgYXJyYXkuXG4gIGRpcnR5Q29tcG9uZW50cy5zb3J0KG1vdW50T3JkZXJDb21wYXJhdG9yKTtcblxuICAvLyBBbnkgdXBkYXRlcyBlbnF1ZXVlZCB3aGlsZSByZWNvbmNpbGluZyBtdXN0IGJlIHBlcmZvcm1lZCBhZnRlciB0aGlzIGVudGlyZVxuICAvLyBiYXRjaC4gT3RoZXJ3aXNlLCBpZiBkaXJ0eUNvbXBvbmVudHMgaXMgW0EsIEJdIHdoZXJlIEEgaGFzIGNoaWxkcmVuIEIgYW5kXG4gIC8vIEMsIEIgY291bGQgdXBkYXRlIHR3aWNlIGluIGEgc2luZ2xlIGJhdGNoIGlmIEMncyByZW5kZXIgZW5xdWV1ZXMgYW4gdXBkYXRlXG4gIC8vIHRvIEIgKHNpbmNlIEIgd291bGQgaGF2ZSBhbHJlYWR5IHVwZGF0ZWQsIHdlIHNob3VsZCBza2lwIGl0LCBhbmQgdGhlIG9ubHlcbiAgLy8gd2F5IHdlIGNhbiBrbm93IHRvIGRvIHNvIGlzIGJ5IGNoZWNraW5nIHRoZSBiYXRjaCBjb3VudGVyKS5cbiAgdXBkYXRlQmF0Y2hOdW1iZXIrKztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gSWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGJlZm9yZSBwZW5kaW5nIGNoYW5nZXMgYXBwbHksIGl0IHdpbGwgc3RpbGxcbiAgICAvLyBiZSBoZXJlLCBidXQgd2UgYXNzdW1lIHRoYXQgaXQgaGFzIGNsZWFyZWQgaXRzIF9wZW5kaW5nQ2FsbGJhY2tzIGFuZFxuICAgIC8vIHRoYXQgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGlzIGEgbm9vcC5cbiAgICB2YXIgY29tcG9uZW50ID0gZGlydHlDb21wb25lbnRzW2ldO1xuXG4gICAgLy8gSWYgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGhhcHBlbnMgdG8gZW5xdWV1ZSBhbnkgbmV3IHVwZGF0ZXMsIHdlXG4gICAgLy8gc2hvdWxkbid0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgaGFwcGVucywgc29cbiAgICAvLyBzdGFzaCB0aGUgY2FsbGJhY2tzIGZpcnN0XG4gICAgdmFyIGNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcztcbiAgICBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuXG4gICAgdmFyIG1hcmtlck5hbWU7XG4gICAgaWYgKFJlYWN0RmVhdHVyZUZsYWdzLmxvZ1RvcExldmVsUmVuZGVycykge1xuICAgICAgdmFyIG5hbWVkQ29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgLy8gRHVjayB0eXBlIFRvcExldmVsV3JhcHBlci4gVGhpcyBpcyBwcm9iYWJseSBhbHdheXMgdHJ1ZS5cbiAgICAgIGlmIChjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnByb3BzID09PSBjb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50Ll9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICBuYW1lZENvbXBvbmVudCA9IGNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgICB9XG4gICAgICBtYXJrZXJOYW1lID0gJ1JlYWN0IHVwZGF0ZTogJyArIG5hbWVkQ29tcG9uZW50LmdldE5hbWUoKTtcbiAgICAgIGNvbnNvbGUudGltZShtYXJrZXJOYW1lKTtcbiAgICB9XG5cbiAgICBSZWFjdFJlY29uY2lsZXIucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KGNvbXBvbmVudCwgdHJhbnNhY3Rpb24ucmVjb25jaWxlVHJhbnNhY3Rpb24sIHVwZGF0ZUJhdGNoTnVtYmVyKTtcblxuICAgIGlmIChtYXJrZXJOYW1lKSB7XG4gICAgICBjb25zb2xlLnRpbWVFbmQobWFya2VyTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYWxsYmFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uY2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrc1tqXSwgY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZmx1c2hCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbidzIHdyYXBwZXJzIHdpbGwgY2xlYXIgdGhlIGRpcnR5Q29tcG9uZW50c1xuICAvLyBhcnJheSBhbmQgcGVyZm9ybSBhbnkgdXBkYXRlcyBlbnF1ZXVlZCBieSBtb3VudC1yZWFkeSBoYW5kbGVycyAoaS5lLixcbiAgLy8gY29tcG9uZW50RGlkVXBkYXRlKSBidXQgd2UgbmVlZCB0byBjaGVjayBoZXJlIHRvbyBpbiBvcmRlciB0byBjYXRjaFxuICAvLyB1cGRhdGVzIGVucXVldWVkIGJ5IHNldFN0YXRlIGNhbGxiYWNrcyBhbmQgYXNhcCBjYWxscy5cbiAgd2hpbGUgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGggfHwgYXNhcEVucXVldWVkKSB7XG4gICAgaWYgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCk7XG4gICAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKHJ1bkJhdGNoZWRVcGRhdGVzLCBudWxsLCB0cmFuc2FjdGlvbik7XG4gICAgICBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICAgIH1cblxuICAgIGlmIChhc2FwRW5xdWV1ZWQpIHtcbiAgICAgIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuICAgICAgdmFyIHF1ZXVlID0gYXNhcENhbGxiYWNrUXVldWU7XG4gICAgICBhc2FwQ2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gICAgICBxdWV1ZS5ub3RpZnlBbGwoKTtcbiAgICAgIENhbGxiYWNrUXVldWUucmVsZWFzZShxdWV1ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1hcmsgYSBjb21wb25lbnQgYXMgbmVlZGluZyBhIHJlcmVuZGVyLCBhZGRpbmcgYW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYVxuICogbGlzdCBvZiBmdW5jdGlvbnMgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBvbmNlIHRoZSByZXJlbmRlciBvY2N1cnMuXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoY29tcG9uZW50KSB7XG4gIGVuc3VyZUluamVjdGVkKCk7XG5cbiAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChUaGlzIGlzIGNhbGxlZCBieSBlYWNoIHRvcC1sZXZlbCB1cGRhdGVcbiAgLy8gZnVuY3Rpb24sIGxpa2Ugc2V0U3RhdGUsIGZvcmNlVXBkYXRlLCBldGMuOyBjcmVhdGlvbiBhbmRcbiAgLy8gZGVzdHJ1Y3Rpb24gb2YgdG9wLWxldmVsIGNvbXBvbmVudHMgaXMgZ3VhcmRlZCBpbiBSZWFjdE1vdW50LilcblxuICBpZiAoIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGVucXVldWVVcGRhdGUsIGNvbXBvbmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGlydHlDb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgaWYgKGNvbXBvbmVudC5fdXBkYXRlQmF0Y2hOdW1iZXIgPT0gbnVsbCkge1xuICAgIGNvbXBvbmVudC5fdXBkYXRlQmF0Y2hOdW1iZXIgPSB1cGRhdGVCYXRjaE51bWJlciArIDE7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdG8gYmUgcnVuIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYmF0Y2hpbmcgY3ljbGUuIFRocm93c1xuICogaWYgbm8gdXBkYXRlcyBhcmUgY3VycmVudGx5IGJlaW5nIHBlcmZvcm1lZC5cbiAqL1xuZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgY29udGV4dCkge1xuICAhYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXMuYXNhcDogQ2FuXFwndCBlbnF1ZXVlIGFuIGFzYXAgY2FsbGJhY2sgaW4gYSBjb250ZXh0IHdoZXJldXBkYXRlcyBhcmUgbm90IGJlaW5nIGJhdGNoZWQuJykgOiBfcHJvZEludmFyaWFudCgnMTI1JykgOiB2b2lkIDA7XG4gIGFzYXBDYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2ssIGNvbnRleHQpO1xuICBhc2FwRW5xdWV1ZWQgPSB0cnVlO1xufVxuXG52YXIgUmVhY3RVcGRhdGVzSW5qZWN0aW9uID0ge1xuICBpbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKFJlY29uY2lsZVRyYW5zYWN0aW9uKSB7XG4gICAgIVJlY29uY2lsZVRyYW5zYWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzJykgOiBfcHJvZEludmFyaWFudCgnMTI2JykgOiB2b2lkIDA7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWNvbmNpbGVUcmFuc2FjdGlvbjtcbiAgfSxcblxuICBpbmplY3RCYXRjaGluZ1N0cmF0ZWd5OiBmdW5jdGlvbiAoX2JhdGNoaW5nU3RyYXRlZ3kpIHtcbiAgICAhX2JhdGNoaW5nU3RyYXRlZ3kgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGluZyBzdHJhdGVneScpIDogX3Byb2RJbnZhcmlhbnQoJzEyNycpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoZWRVcGRhdGVzKCkgZnVuY3Rpb24nKSA6IF9wcm9kSW52YXJpYW50KCcxMjgnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9PT0gJ2Jvb2xlYW4nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhbiBpc0JhdGNoaW5nVXBkYXRlcyBib29sZWFuIGF0dHJpYnV0ZScpIDogX3Byb2RJbnZhcmlhbnQoJzEyOScpIDogdm9pZCAwO1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kgPSBfYmF0Y2hpbmdTdHJhdGVneTtcbiAgfVxufTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHtcbiAgLyoqXG4gICAqIFJlYWN0IHJlZmVyZW5jZXMgYFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25gIHVzaW5nIHRoaXMgcHJvcGVydHkgaW4gb3JkZXJcbiAgICogdG8gYWxsb3cgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogbnVsbCxcblxuICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gIGVucXVldWVVcGRhdGU6IGVucXVldWVVcGRhdGUsXG4gIGZsdXNoQmF0Y2hlZFVwZGF0ZXM6IGZsdXNoQmF0Y2hlZFVwZGF0ZXMsXG4gIGluamVjdGlvbjogUmVhY3RVcGRhdGVzSW5qZWN0aW9uLFxuICBhc2FwOiBhc2FwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDYWxsYmFja1F1ZXVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgcHNldWRvLWV2ZW50IG1vZHVsZSB0byBoZWxwIGtlZXAgdHJhY2sgb2YgY29tcG9uZW50cyB3YWl0aW5nIHRvXG4gKiBiZSBub3RpZmllZCB3aGVuIHRoZWlyIERPTSByZXByZXNlbnRhdGlvbnMgYXJlIGF2YWlsYWJsZSBmb3IgdXNlLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50cyBgUG9vbGVkQ2xhc3NgLCBzbyB5b3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cbiAqIEluc3RlYWQsIHVzZSBgQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKWAuXG4gKlxuICogQGNsYXNzIFJlYWN0TW91bnRSZWFkeVxuICogQGltcGxlbWVudHMgUG9vbGVkQ2xhc3NcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBDYWxsYmFja1F1ZXVlKCkge1xuICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG59XG5cbl9hc3NpZ24oQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUsIHtcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgSW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dCBDb250ZXh0IHRvIGNhbGwgYGNhbGxiYWNrYCB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWU6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCBbXTtcbiAgICB0aGlzLl9jb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzIHx8IFtdO1xuICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB0aGlzLl9jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGFsbCBlbnF1ZXVlZCBjYWxsYmFja3MgYW5kIGNsZWFycyB0aGUgcXVldWUuIFRoaXMgaXMgaW52b2tlZCBhZnRlclxuICAgKiB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIG9mIGEgY29tcG9uZW50IGhhcyBiZWVuIGNyZWF0ZWQgb3IgdXBkYXRlZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBub3RpZnlBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICAgIHZhciBjb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzO1xuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICEoY2FsbGJhY2tzLmxlbmd0aCA9PT0gY29udGV4dHMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNtYXRjaGVkIGxpc3Qgb2YgY29udGV4dHMgaW4gY2FsbGJhY2sgcXVldWUnKSA6IF9wcm9kSW52YXJpYW50KCcyNCcpIDogdm9pZCAwO1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKGNvbnRleHRzW2ldKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgY29udGV4dHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sXG5cbiAgY2hlY2twb2ludDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsYmFja3MgPyB0aGlzLl9jYWxsYmFja3MubGVuZ3RoIDogMDtcbiAgfSxcblxuICByb2xsYmFjazogZnVuY3Rpb24gKGxlbikge1xuICAgIGlmICh0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggPSBsZW47XG4gICAgICB0aGlzLl9jb250ZXh0cy5sZW5ndGggPSBsZW47XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGludGVybmFsIHF1ZXVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2FsbGJhY2tRdWV1ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FsbGJhY2tRdWV1ZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0NhbGxiYWNrUXVldWUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RGZWF0dXJlRmxhZ3NcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RmVhdHVyZUZsYWdzID0ge1xuICAvLyBXaGVuIHRydWUsIGNhbGwgY29uc29sZS50aW1lKCkgYmVmb3JlIGFuZCAudGltZUVuZCgpIGFmdGVyIGVhY2ggdG9wLWxldmVsXG4gIC8vIHJlbmRlciAoYm90aCBpbml0aWFsIHJlbmRlcnMgYW5kIHVwZGF0ZXMpLiBVc2VmdWwgd2hlbiBsb29raW5nIGF0IHByb2QtbW9kZVxuICAvLyB0aW1lbGluZSBwcm9maWxlcyBpbiBDaHJvbWUsIGZvciBleGFtcGxlLlxuICBsb2dUb3BMZXZlbFJlbmRlcnM6IGZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RmVhdHVyZUZsYWdzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RGZWF0dXJlRmxhZ3MuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWNvbmNpbGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWYgPSByZXF1aXJlKCcuL1JlYWN0UmVmJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEhlbHBlciB0byBjYWxsIFJlYWN0UmVmLmF0dGFjaFJlZnMgd2l0aCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQsIHNwbGl0IG91dFxuICogdG8gYXZvaWQgYWxsb2NhdGlvbnMgaW4gdGhlIHRyYW5zYWN0aW9uIG1vdW50LXJlYWR5IHF1ZXVlLlxuICovXG5mdW5jdGlvbiBhdHRhY2hSZWZzKCkge1xuICBSZWFjdFJlZi5hdHRhY2hSZWZzKHRoaXMsIHRoaXMuX2N1cnJlbnRFbGVtZW50KTtcbn1cblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHRoZSBjb250YWluaW5nIGhvc3QgY29tcG9uZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaW5mbyBhYm91dCB0aGUgaG9zdCBjb250YWluZXJcbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHBhcmVudERlYnVnSUQgLy8gMCBpbiBwcm9kdWN0aW9uIGFuZCBmb3Igcm9vdHNcbiAgKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZU1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1hcmt1cCA9IGludGVybmFsSW5zdGFuY2UubW91bnRDb21wb25lbnQodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Nb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZhbHVlIHRoYXQgY2FuIGJlIHBhc3NlZCB0b1xuICAgKiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cC5cbiAgICovXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnRlcm5hbEluc3RhbmNlLmdldEhvc3ROb2RlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBzYWZlbHkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlVW5tb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS51bm1vdW50Q29tcG9uZW50KHNhZmVseSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVubW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBjb21wb25lbnQgdXNpbmcgYSBuZXcgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcblxuICAgIGlmIChuZXh0RWxlbWVudCA9PT0gcHJldkVsZW1lbnQgJiYgY29udGV4dCA9PT0gaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCkge1xuICAgICAgLy8gU2luY2UgZWxlbWVudHMgYXJlIGltbXV0YWJsZSBhZnRlciB0aGUgb3duZXIgaXMgcmVuZGVyZWQsXG4gICAgICAvLyB3ZSBjYW4gZG8gYSBjaGVhcCBpZGVudGl0eSBjb21wYXJlIGhlcmUgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYVxuICAgICAgLy8gc3VwZXJmbHVvdXMgcmVjb25jaWxlLiBJdCdzIHBvc3NpYmxlIGZvciBzdGF0ZSB0byBiZSBtdXRhYmxlIGJ1dCBzdWNoXG4gICAgICAvLyBjaGFuZ2Ugc2hvdWxkIHRyaWdnZXIgYW4gdXBkYXRlIG9mIHRoZSBvd25lciB3aGljaCB3b3VsZCByZWNyZWF0ZVxuICAgICAgLy8gdGhlIGVsZW1lbnQuIFdlIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gb3duZXIgc2luY2VcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIGFuIGVsZW1lbnQgY3JlYXRlZCBvdXRzaWRlIGEgY29tcG9zaXRlIHRvIGJlXG4gICAgICAvLyBkZWVwbHkgbXV0YXRlZCBhbmQgcmV1c2VkLlxuXG4gICAgICAvLyBUT0RPOiBCYWlsaW5nIG91dCBlYXJseSBpcyBqdXN0IGEgcGVyZiBvcHRpbWl6YXRpb24gcmlnaHQ/XG4gICAgICAvLyBUT0RPOiBSZW1vdmluZyB0aGUgcmV0dXJuIHN0YXRlbWVudCBzaG91bGQgYWZmZWN0IGNvcnJlY3RuZXNzP1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgbmV4dEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWZzQ2hhbmdlZCA9IFJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCkge1xuICAgICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBwcmV2RWxlbWVudCk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50KG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBpZiAocmVmc0NoYW5nZWQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZsdXNoIGFueSBkaXJ0eSBjaGFuZ2VzIGluIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgdXBkYXRlQmF0Y2hOdW1iZXIpIHtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgIT09IHVwZGF0ZUJhdGNoTnVtYmVyKSB7XG4gICAgICAvLyBUaGUgY29tcG9uZW50J3MgZW5xdWV1ZWQgYmF0Y2ggbnVtYmVyIHNob3VsZCBhbHdheXMgYmUgdGhlIGN1cnJlbnRcbiAgICAgIC8vIGJhdGNoIG9yIHRoZSBmb2xsb3dpbmcgb25lLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgPT0gbnVsbCB8fCBpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciA9PT0gdXBkYXRlQmF0Y2hOdW1iZXIgKyAxLCAncGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBVbmV4cGVjdGVkIGJhdGNoIG51bWJlciAoY3VycmVudCAlcywgJyArICdwZW5kaW5nICVzKScsIHVwZGF0ZUJhdGNoTnVtYmVyLCBpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlcikgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnRlcm5hbEluc3RhbmNlLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSh0cmFuc2FjdGlvbik7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWZcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdE93bmVyJyk7XG5cbnZhciBSZWFjdFJlZiA9IHt9O1xuXG5mdW5jdGlvbiBhdHRhY2hSZWYocmVmLCBjb21wb25lbnQsIG93bmVyKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMZWdhY3kgcmVmXG4gICAgUmVhY3RPd25lci5hZGRDb21wb25lbnRBc1JlZlRvKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihudWxsKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMZWdhY3kgcmVmXG4gICAgUmVhY3RPd25lci5yZW1vdmVDb21wb25lbnRBc1JlZkZyb20oY29tcG9uZW50LCByZWYsIG93bmVyKTtcbiAgfVxufVxuXG5SZWFjdFJlZi5hdHRhY2hSZWZzID0gZnVuY3Rpb24gKGluc3RhbmNlLCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgYXR0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxuUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyA9IGZ1bmN0aW9uIChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgLy8gSWYgZWl0aGVyIHRoZSBvd25lciBvciBhIGByZWZgIGhhcyBjaGFuZ2VkLCBtYWtlIHN1cmUgdGhlIG5ld2VzdCBvd25lclxuICAvLyBoYXMgc3RvcmVkIGEgcmVmZXJlbmNlIHRvIGB0aGlzYCwgYW5kIHRoZSBwcmV2aW91cyBvd25lciAoaWYgZGlmZmVyZW50KVxuICAvLyBoYXMgZm9yZ290dGVuIHRoZSByZWZlcmVuY2UgdG8gYHRoaXNgLiBXZSB1c2UgdGhlIGVsZW1lbnQgaW5zdGVhZFxuICAvLyBvZiB0aGUgcHVibGljIHRoaXMucHJvcHMgYmVjYXVzZSB0aGUgcG9zdCBwcm9jZXNzaW5nIGNhbm5vdCBkZXRlcm1pbmVcbiAgLy8gYSByZWYuIFRoZSByZWYgY29uY2VwdHVhbGx5IGxpdmVzIG9uIHRoZSBlbGVtZW50LlxuXG4gIC8vIFRPRE86IFNob3VsZCB0aGlzIGV2ZW4gYmUgcG9zc2libGU/IFRoZSBvd25lciBjYW5ub3QgY2hhbmdlIGJlY2F1c2VcbiAgLy8gaXQncyBmb3JiaWRkZW4gYnkgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuIFRoZSByZWYgY2FuIGNoYW5nZVxuICAvLyBpZiB5b3Ugc3dhcCB0aGUga2V5cyBvZiBidXQgbm90IHRoZSByZWZzLiBSZWNvbnNpZGVyIHdoZXJlIHRoaXMgY2hlY2tcbiAgLy8gaXMgbWFkZS4gSXQgcHJvYmFibHkgYmVsb25ncyB3aGVyZSB0aGUga2V5IGNoZWNraW5nIGFuZFxuICAvLyBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IGlzIGRvbmUuXG5cbiAgdmFyIHByZXZFbXB0eSA9IHByZXZFbGVtZW50ID09PSBudWxsIHx8IHByZXZFbGVtZW50ID09PSBmYWxzZTtcbiAgdmFyIG5leHRFbXB0eSA9IG5leHRFbGVtZW50ID09PSBudWxsIHx8IG5leHRFbGVtZW50ID09PSBmYWxzZTtcblxuICByZXR1cm4gKFxuICAgIC8vIFRoaXMgaGFzIGEgZmV3IGZhbHNlIHBvc2l0aXZlcyB3L3IvdCBlbXB0eSBjb21wb25lbnRzLlxuICAgIHByZXZFbXB0eSB8fCBuZXh0RW1wdHkgfHwgbmV4dEVsZW1lbnQucmVmICE9PSBwcmV2RWxlbWVudC5yZWYgfHxcbiAgICAvLyBJZiBvd25lciBjaGFuZ2VzIGJ1dCB3ZSBoYXZlIGFuIHVuY2hhbmdlZCBmdW5jdGlvbiByZWYsIGRvbid0IHVwZGF0ZSByZWZzXG4gICAgdHlwZW9mIG5leHRFbGVtZW50LnJlZiA9PT0gJ3N0cmluZycgJiYgbmV4dEVsZW1lbnQuX293bmVyICE9PSBwcmV2RWxlbWVudC5fb3duZXJcbiAgKTtcbn07XG5cblJlYWN0UmVmLmRldGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBkZXRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVmO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RSZWYuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJlYWN0T3duZXJzIGFyZSBjYXBhYmxlIG9mIHN0b3JpbmcgcmVmZXJlbmNlcyB0byBvd25lZCBjb21wb25lbnRzLlxuICpcbiAqIEFsbCBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vYmVpbmcvLyByZWZlcmVuY2VkIGJ5IG93bmVyIGNvbXBvbmVudHMsIGJ1dFxuICogb25seSBSZWFjdE93bmVyIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9yZWZlcmVuY2luZy8vIG93bmVkIGNvbXBvbmVudHMuXG4gKiBUaGUgbmFtZWQgcmVmZXJlbmNlIGlzIGtub3duIGFzIGEgXCJyZWZcIi5cbiAqXG4gKiBSZWZzIGFyZSBhdmFpbGFibGUgd2hlbiBtb3VudGVkIGFuZCB1cGRhdGVkIGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIChcbiAqICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfT5cbiAqICAgICAgICAgICA8Q3VzdG9tQ29tcG9uZW50IHJlZj1cImN1c3RvbVwiIC8+XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgKTtcbiAqICAgICB9LFxuICogICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaGFuZGxlQ2xpY2soKTtcbiAqICAgICB9LFxuICogICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaW5pdGlhbGl6ZSgpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogUmVmcyBzaG91bGQgcmFyZWx5IGJlIHVzZWQuIFdoZW4gcmVmcyBhcmUgdXNlZCwgdGhleSBzaG91bGQgb25seSBiZSBkb25lIHRvXG4gKiBjb250cm9sIGRhdGEgdGhhdCBpcyBub3QgaGFuZGxlZCBieSBSZWFjdCdzIGRhdGEgZmxvdy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RPd25lclxuICovXG52YXIgUmVhY3RPd25lciA9IHtcblxuICAvKipcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIG93bmVyLlxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzVmFsaWRPd25lcjogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiAhIShvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5hdHRhY2hSZWYgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iamVjdC5kZXRhY2hSZWYgPT09ICdmdW5jdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY29tcG9uZW50IGJ5IHJlZiB0byBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgYnkgd2hpY2ggdG8gcmVmZXIgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdG8gcmVjb3JkIHRoZSByZWYuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFkZENvbXBvbmVudEFzUmVmVG86IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhUmVhY3RPd25lci5pc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FkZENvbXBvbmVudEFzUmVmVG8oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0IGJlIGFkZGluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzIGByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBfcHJvZEludmFyaWFudCgnMTE5JykgOiB2b2lkIDA7XG4gICAgb3duZXIuYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNvbXBvbmVudCBieSByZWYgZnJvbSBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gZGVyZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBvZiB0aGUgcmVmIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdGhlIHJlZiBpcyByZWNvcmRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgIVJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW1vdmVDb21wb25lbnRBc1JlZkZyb20oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0IGJlIHJlbW92aW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgYHJlbmRlcmAgbWV0aG9kLCBvciB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkIChkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMjAnKSA6IHZvaWQgMDtcbiAgICB2YXIgb3duZXJQdWJsaWNJbnN0YW5jZSA9IG93bmVyLmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgLy8gQ2hlY2sgdGhhdCBgY29tcG9uZW50YCdzIG93bmVyIGlzIHN0aWxsIGFsaXZlIGFuZCB0aGF0IGBjb21wb25lbnRgIGlzIHN0aWxsIHRoZSBjdXJyZW50IHJlZlxuICAgIC8vIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG8gZGV0YWNoIHRoZSByZWYgaWYgYW5vdGhlciBjb21wb25lbnQgc3RvbGUgaXQuXG4gICAgaWYgKG93bmVyUHVibGljSW5zdGFuY2UgJiYgb3duZXJQdWJsaWNJbnN0YW5jZS5yZWZzW3JlZl0gPT09IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKSB7XG4gICAgICBvd25lci5kZXRhY2hSZWYocmVmKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE93bmVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RPd25lci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluc3RydW1lbnRhdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlYnVnVG9vbCA9IG51bGw7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdERlYnVnVG9vbCA9IHJlcXVpcmUoJy4vUmVhY3REZWJ1Z1Rvb2wnKTtcbiAgZGVidWdUb29sID0gUmVhY3REZWJ1Z1Rvb2w7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBkZWJ1Z1Rvb2w6IGRlYnVnVG9vbCB9O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbnN0cnVtZW50YXRpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWJ1Z1Rvb2xcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rID0gcmVxdWlyZSgnLi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rJyk7XG52YXIgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rJyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xudmFyIFJlYWN0Q2hpbGRyZW5NdXRhdGlvbldhcm5pbmdIb29rID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vaycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93ID0gcmVxdWlyZSgnZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgaG9va3MgPSBbXTtcbnZhciBkaWRIb29rVGhyb3dGb3JFdmVudCA9IHt9O1xuXG5mdW5jdGlvbiBjYWxsSG9vayhldmVudCwgZm4sIGNvbnRleHQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgdHJ5IHtcbiAgICBmbi5jYWxsKGNvbnRleHQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkSG9va1Rocm93Rm9yRXZlbnRbZXZlbnRdLCAnRXhjZXB0aW9uIHRocm93biBieSBob29rIHdoaWxlIGhhbmRsaW5nICVzOiAlcycsIGV2ZW50LCBlICsgJ1xcbicgKyBlLnN0YWNrKSA6IHZvaWQgMDtcbiAgICBkaWRIb29rVGhyb3dGb3JFdmVudFtldmVudF0gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFdmVudChldmVudCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGhvb2sgPSBob29rc1tpXTtcbiAgICB2YXIgZm4gPSBob29rW2V2ZW50XTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIGNhbGxIb29rKGV2ZW50LCBmbiwgaG9vaywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBpc1Byb2ZpbGluZyA9IGZhbHNlO1xudmFyIGZsdXNoSGlzdG9yeSA9IFtdO1xudmFyIGxpZmVDeWNsZVRpbWVyU3RhY2sgPSBbXTtcbnZhciBjdXJyZW50Rmx1c2hOZXN0aW5nID0gMDtcbnZhciBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBudWxsO1xudmFyIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IG51bGw7XG52YXIgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG52YXIgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gbnVsbDtcbnZhciBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gbnVsbDtcbnZhciBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcblxudmFyIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNsZWFySGlzdG9yeSgpIHtcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vay5wdXJnZVVubW91bnRlZENvbXBvbmVudHMoKTtcbiAgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suY2xlYXJIaXN0b3J5KCk7XG59XG5cbmZ1bmN0aW9uIGdldFRyZWVTbmFwc2hvdChyZWdpc3RlcmVkSURzKSB7XG4gIHJldHVybiByZWdpc3RlcmVkSURzLnJlZHVjZShmdW5jdGlvbiAodHJlZSwgaWQpIHtcbiAgICB2YXIgb3duZXJJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChpZCk7XG4gICAgdmFyIHBhcmVudElEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRQYXJlbnRJRChpZCk7XG4gICAgdHJlZVtpZF0gPSB7XG4gICAgICBkaXNwbGF5TmFtZTogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShpZCksXG4gICAgICB0ZXh0OiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFRleHQoaWQpLFxuICAgICAgdXBkYXRlQ291bnQ6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0VXBkYXRlQ291bnQoaWQpLFxuICAgICAgY2hpbGRJRHM6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q2hpbGRJRHMoaWQpLFxuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIG93bmVycyBidXQgdGhpcyBpcyBjbG9zZSBlbm91Z2guXG4gICAgICBvd25lcklEOiBvd25lcklEIHx8IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChwYXJlbnRJRCksXG4gICAgICBwYXJlbnRJRDogcGFyZW50SURcbiAgICB9O1xuICAgIHJldHVybiB0cmVlO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0TWVhc3VyZW1lbnRzKCkge1xuICB2YXIgcHJldmlvdXNTdGFydFRpbWUgPSBjdXJyZW50Rmx1c2hTdGFydFRpbWU7XG4gIHZhciBwcmV2aW91c01lYXN1cmVtZW50cyA9IGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyB8fCBbXTtcbiAgdmFyIHByZXZpb3VzT3BlcmF0aW9ucyA9IFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmdldEhpc3RvcnkoKTtcblxuICBpZiAoY3VycmVudEZsdXNoTmVzdGluZyA9PT0gMCkge1xuICAgIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IG51bGw7XG4gICAgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gbnVsbDtcbiAgICBjbGVhckhpc3RvcnkoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJldmlvdXNNZWFzdXJlbWVudHMubGVuZ3RoIHx8IHByZXZpb3VzT3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICB2YXIgcmVnaXN0ZXJlZElEcyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UmVnaXN0ZXJlZElEcygpO1xuICAgIGZsdXNoSGlzdG9yeS5wdXNoKHtcbiAgICAgIGR1cmF0aW9uOiBwZXJmb3JtYW5jZU5vdygpIC0gcHJldmlvdXNTdGFydFRpbWUsXG4gICAgICBtZWFzdXJlbWVudHM6IHByZXZpb3VzTWVhc3VyZW1lbnRzIHx8IFtdLFxuICAgICAgb3BlcmF0aW9uczogcHJldmlvdXNPcGVyYXRpb25zIHx8IFtdLFxuICAgICAgdHJlZVNuYXBzaG90OiBnZXRUcmVlU25hcHNob3QocmVnaXN0ZXJlZElEcylcbiAgICB9KTtcbiAgfVxuXG4gIGNsZWFySGlzdG9yeSgpO1xuICBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBbXTtcbn1cblxuZnVuY3Rpb24gY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpIHtcbiAgdmFyIGFsbG93Um9vdCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzFdO1xuXG4gIGlmIChhbGxvd1Jvb3QgJiYgZGVidWdJRCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWRlYnVnSUQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0RGVidWdUb29sOiBkZWJ1Z0lEIG1heSBub3QgYmUgZW1wdHkuJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmVnaW5MaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGN1cnJlbnRUaW1lclR5cGUgJiYgIWxpZmVDeWNsZVRpbWVySGFzV2FybmVkKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGVyZSBpcyBhbiBpbnRlcm5hbCBlcnJvciBpbiB0aGUgUmVhY3QgcGVyZm9ybWFuY2UgbWVhc3VyZW1lbnQgY29kZS4gJyArICdEaWQgbm90IGV4cGVjdCAlcyB0aW1lciB0byBzdGFydCB3aGlsZSAlcyB0aW1lciBpcyBzdGlsbCBpbiAnICsgJ3Byb2dyZXNzIGZvciAlcyBpbnN0YW5jZS4nLCB0aW1lclR5cGUsIGN1cnJlbnRUaW1lclR5cGUgfHwgJ25vJywgZGVidWdJRCA9PT0gY3VycmVudFRpbWVyRGVidWdJRCA/ICd0aGUgc2FtZScgOiAnYW5vdGhlcicpIDogdm9pZCAwO1xuICAgIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gdHJ1ZTtcbiAgfVxuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IGRlYnVnSUQ7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSB0aW1lclR5cGU7XG59XG5cbmZ1bmN0aW9uIGVuZExpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICBpZiAoY3VycmVudEZsdXNoTmVzdGluZyA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY3VycmVudFRpbWVyVHlwZSAhPT0gdGltZXJUeXBlICYmICFsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IgaW4gdGhlIFJlYWN0IHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGNvZGUuICcgKyAnV2UgZGlkIG5vdCBleHBlY3QgJXMgdGltZXIgdG8gc3RvcCB3aGlsZSAlcyB0aW1lciBpcyBzdGlsbCBpbiAnICsgJ3Byb2dyZXNzIGZvciAlcyBpbnN0YW5jZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGFzIGEgYnVnIGluIFJlYWN0LicsIHRpbWVyVHlwZSwgY3VycmVudFRpbWVyVHlwZSB8fCAnbm8nLCBkZWJ1Z0lEID09PSBjdXJyZW50VGltZXJEZWJ1Z0lEID8gJ3RoZSBzYW1lJyA6ICdhbm90aGVyJykgOiB2b2lkIDA7XG4gICAgbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQgPSB0cnVlO1xuICB9XG4gIGlmIChpc1Byb2ZpbGluZykge1xuICAgIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cy5wdXNoKHtcbiAgICAgIHRpbWVyVHlwZTogdGltZXJUeXBlLFxuICAgICAgaW5zdGFuY2VJRDogZGVidWdJRCxcbiAgICAgIGR1cmF0aW9uOiBwZXJmb3JtYW5jZU5vdygpIC0gY3VycmVudFRpbWVyU3RhcnRUaW1lIC0gY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvblxuICAgIH0pO1xuICB9XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IG51bGw7XG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSBudWxsO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhdXNlQ3VycmVudExpZmVDeWNsZVRpbWVyKCkge1xuICB2YXIgY3VycmVudFRpbWVyID0ge1xuICAgIHN0YXJ0VGltZTogY3VycmVudFRpbWVyU3RhcnRUaW1lLFxuICAgIG5lc3RlZEZsdXNoU3RhcnRUaW1lOiBwZXJmb3JtYW5jZU5vdygpLFxuICAgIGRlYnVnSUQ6IGN1cnJlbnRUaW1lckRlYnVnSUQsXG4gICAgdGltZXJUeXBlOiBjdXJyZW50VGltZXJUeXBlXG4gIH07XG4gIGxpZmVDeWNsZVRpbWVyU3RhY2sucHVzaChjdXJyZW50VGltZXIpO1xuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBudWxsO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gbnVsbDtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZXN1bWVDdXJyZW50TGlmZUN5Y2xlVGltZXIoKSB7XG4gIHZhciBfbGlmZUN5Y2xlVGltZXJTdGFjayQgPSBsaWZlQ3ljbGVUaW1lclN0YWNrLnBvcCgpO1xuXG4gIHZhciBzdGFydFRpbWUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQuc3RhcnRUaW1lO1xuICB2YXIgbmVzdGVkRmx1c2hTdGFydFRpbWUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQubmVzdGVkRmx1c2hTdGFydFRpbWU7XG4gIHZhciBkZWJ1Z0lEID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLmRlYnVnSUQ7XG4gIHZhciB0aW1lclR5cGUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQudGltZXJUeXBlO1xuXG4gIHZhciBuZXN0ZWRGbHVzaER1cmF0aW9uID0gcGVyZm9ybWFuY2VOb3coKSAtIG5lc3RlZEZsdXNoU3RhcnRUaW1lO1xuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gKz0gbmVzdGVkRmx1c2hEdXJhdGlvbjtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IGRlYnVnSUQ7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSB0aW1lclR5cGU7XG59XG5cbnZhciBSZWFjdERlYnVnVG9vbCA9IHtcbiAgYWRkSG9vazogZnVuY3Rpb24gKGhvb2spIHtcbiAgICBob29rcy5wdXNoKGhvb2spO1xuICB9LFxuICByZW1vdmVIb29rOiBmdW5jdGlvbiAoaG9vaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChob29rc1tpXSA9PT0gaG9vaykge1xuICAgICAgICBob29rcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGlzUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzUHJvZmlsaW5nO1xuICB9LFxuICBiZWdpblByb2ZpbGluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlzUHJvZmlsaW5nID0gdHJ1ZTtcbiAgICBmbHVzaEhpc3RvcnkubGVuZ3RoID0gMDtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIFJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2spO1xuICB9LFxuICBlbmRQcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzUHJvZmlsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNQcm9maWxpbmcgPSBmYWxzZTtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIFJlYWN0RGVidWdUb29sLnJlbW92ZUhvb2soUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2spO1xuICB9LFxuICBnZXRGbHVzaEhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmx1c2hIaXN0b3J5O1xuICB9LFxuICBvbkJlZ2luRmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyZW50Rmx1c2hOZXN0aW5nKys7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpO1xuICAgIGVtaXRFdmVudCgnb25CZWdpbkZsdXNoJyk7XG4gIH0sXG4gIG9uRW5kRmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIGN1cnJlbnRGbHVzaE5lc3RpbmctLTtcbiAgICByZXN1bWVDdXJyZW50TGlmZUN5Y2xlVGltZXIoKTtcbiAgICBlbWl0RXZlbnQoJ29uRW5kRmx1c2gnKTtcbiAgfSxcbiAgb25CZWdpbkxpZmVDeWNsZVRpbWVyOiBmdW5jdGlvbiAoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25CZWdpbkxpZmVDeWNsZVRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBiZWdpbkxpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIH0sXG4gIG9uRW5kTGlmZUN5Y2xlVGltZXI6IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBlbWl0RXZlbnQoJ29uRW5kTGlmZUN5Y2xlVGltZXInLCBkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICB9LFxuICBvbkVycm9yOiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGlmIChjdXJyZW50VGltZXJEZWJ1Z0lEICE9IG51bGwpIHtcbiAgICAgIGVuZExpZmVDeWNsZVRpbWVyKGN1cnJlbnRUaW1lckRlYnVnSUQsIGN1cnJlbnRUaW1lclR5cGUpO1xuICAgIH1cbiAgICBlbWl0RXZlbnQoJ29uRXJyb3InLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XG4gIH0sXG4gIG9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XG4gIH0sXG4gIG9uSG9zdE9wZXJhdGlvbjogZnVuY3Rpb24gKGRlYnVnSUQsIHR5cGUsIHBheWxvYWQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkhvc3RPcGVyYXRpb24nLCBkZWJ1Z0lELCB0eXBlLCBwYXlsb2FkKTtcbiAgfSxcbiAgb25TZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25TZXRTdGF0ZScpO1xuICB9LFxuICBvblNldENoaWxkcmVuOiBmdW5jdGlvbiAoZGVidWdJRCwgY2hpbGREZWJ1Z0lEcykge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBjaGlsZERlYnVnSURzLmZvckVhY2goY2hlY2tEZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uU2V0Q2hpbGRyZW4nLCBkZWJ1Z0lELCBjaGlsZERlYnVnSURzKTtcbiAgfSxcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQsIHBhcmVudERlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgY2hlY2tEZWJ1Z0lEKHBhcmVudERlYnVnSUQsIHRydWUpO1xuICAgIGVtaXRFdmVudCgnb25CZWZvcmVNb3VudENvbXBvbmVudCcsIGRlYnVnSUQsIGVsZW1lbnQsIHBhcmVudERlYnVnSUQpO1xuICB9LFxuICBvbk1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uTW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25CZWZvcmVVcGRhdGVDb21wb25lbnQnLCBkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfSxcbiAgb25VcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25VcGRhdGVDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25CZWZvcmVVbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlVW5tb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvblVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25Vbm1vdW50Q29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uVGVzdEV2ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvblRlc3RFdmVudCcpO1xuICB9XG59O1xuXG4vLyBUT0RPIHJlbW92ZSB0aGVzZSB3aGVuIFJOL3d3dyBnZXRzIHVwZGF0ZWRcblJlYWN0RGVidWdUb29sLmFkZERldnRvb2wgPSBSZWFjdERlYnVnVG9vbC5hZGRIb29rO1xuUmVhY3REZWJ1Z1Rvb2wucmVtb3ZlRGV2dG9vbCA9IFJlYWN0RGVidWdUb29sLnJlbW92ZUhvb2s7XG5cblJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayk7XG5SZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0Q29tcG9uZW50VHJlZUhvb2spO1xuUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vayk7XG52YXIgdXJsID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICcnO1xuaWYgKC9bPyZdcmVhY3RfcGVyZlxcYi8udGVzdCh1cmwpKSB7XG4gIFJlYWN0RGVidWdUb29sLmJlZ2luUHJvZmlsaW5nKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWJ1Z1Rvb2w7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERlYnVnVG9vbC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByb2Nlc3NpbmdDaGlsZENvbnRleHQgPSBmYWxzZTtcblxuICB2YXIgd2FybkludmFsaWRTZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCwgJ3NldFN0YXRlKC4uLik6IENhbm5vdCBjYWxsIHNldFN0YXRlKCkgaW5zaWRlIGdldENoaWxkQ29udGV4dCgpJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbnZhciBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rID0ge1xuICBvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3NpbmdDaGlsZENvbnRleHQgPSB0cnVlO1xuICB9LFxuICBvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIH0sXG4gIG9uU2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB3YXJuSW52YWxpZFNldFN0YXRlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vaztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2suanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2tcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoaXN0b3J5ID0gW107XG5cbnZhciBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayA9IHtcbiAgb25Ib3N0T3BlcmF0aW9uOiBmdW5jdGlvbiAoZGVidWdJRCwgdHlwZSwgcGF5bG9hZCkge1xuICAgIGhpc3RvcnkucHVzaCh7XG4gICAgICBpbnN0YW5jZUlEOiBkZWJ1Z0lELFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICB9KTtcbiAgfSxcbiAgY2xlYXJIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLl9wcmV2ZW50Q2xlYXJpbmcpIHtcbiAgICAgIC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlc3RzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhpc3RvcnkgPSBbXTtcbiAgfSxcbiAgZ2V0SGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoaXN0b3J5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2tcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4gPT09IGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlzTXV0YXRlZCA9IGZhbHNlO1xuICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50Ll9zaGFkb3dDaGlsZHJlbikpIHtcbiAgICBpZiAoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4ubGVuZ3RoID09PSBlbGVtZW50LnByb3BzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50Ll9zaGFkb3dDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW5baV0gIT09IGVsZW1lbnQucHJvcHMuY2hpbGRyZW5baV0pIHtcbiAgICAgICAgICBpc011dGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzTXV0YXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShlbGVtZW50Ll9zaGFkb3dDaGlsZHJlbikgfHwgaXNNdXRhdGVkKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdDb21wb25lbnRcXCdzIGNoaWxkcmVuIHNob3VsZCBub3QgYmUgbXV0YXRlZC4lcycsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9XG59XG5cbnZhciBSZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vayA9IHtcbiAgb25Nb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChkZWJ1Z0lEKSk7XG4gIH0sXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGRlYnVnSUQpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vaztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW5NdXRhdGlvbldhcm5pbmdIb29rLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgcGVyZm9ybWFuY2UgPSByZXF1aXJlKCcuL3BlcmZvcm1hbmNlJyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdztcblxuLyoqXG4gKiBEZXRlY3QgaWYgd2UgY2FuIHVzZSBgd2luZG93LnBlcmZvcm1hbmNlLm5vdygpYCBhbmQgZ3JhY2VmdWxseSBmYWxsYmFjayB0b1xuICogYERhdGUubm93KClgIGlmIGl0IGRvZXNuJ3QgZXhpc3QuIFdlIG5lZWQgdG8gc3VwcG9ydCBGaXJlZm94IDwgMTUgZm9yIG5vd1xuICogYmVjYXVzZSBvZiBGYWNlYm9vaydzIHRlc3RpbmcgaW5mcmFzdHJ1Y3R1cmUuXG4gKi9cbmlmIChwZXJmb3JtYW5jZS5ub3cpIHtcbiAgcGVyZm9ybWFuY2VOb3cgPSBmdW5jdGlvbiBwZXJmb3JtYW5jZU5vdygpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH07XG59IGVsc2Uge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlTm93O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgcGVyZm9ybWFuY2U7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwgd2luZG93Lm1zUGVyZm9ybWFuY2UgfHwgd2luZG93LndlYmtpdFBlcmZvcm1hbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlIHx8IHt9O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9wZXJmb3JtYW5jZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBUcmFuc2FjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIGBUcmFuc2FjdGlvbmAgY3JlYXRlcyBhIGJsYWNrIGJveCB0aGF0IGlzIGFibGUgdG8gd3JhcCBhbnkgbWV0aG9kIHN1Y2ggdGhhdFxuICogY2VydGFpbiBpbnZhcmlhbnRzIGFyZSBtYWludGFpbmVkIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIG1ldGhvZCBpcyBpbnZva2VkXG4gKiAoRXZlbiBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIHdoaWxlIGludm9raW5nIHRoZSB3cmFwcGVkIG1ldGhvZCkuIFdob2V2ZXJcbiAqIGluc3RhbnRpYXRlcyBhIHRyYW5zYWN0aW9uIGNhbiBwcm92aWRlIGVuZm9yY2VycyBvZiB0aGUgaW52YXJpYW50cyBhdFxuICogY3JlYXRpb24gdGltZS4gVGhlIGBUcmFuc2FjdGlvbmAgY2xhc3MgaXRzZWxmIHdpbGwgc3VwcGx5IG9uZSBhZGRpdGlvbmFsXG4gKiBhdXRvbWF0aWMgaW52YXJpYW50IGZvciB5b3UgLSB0aGUgaW52YXJpYW50IHRoYXQgYW55IHRyYW5zYWN0aW9uIGluc3RhbmNlXG4gKiBzaG91bGQgbm90IGJlIHJ1biB3aGlsZSBpdCBpcyBhbHJlYWR5IGJlaW5nIHJ1bi4gWW91IHdvdWxkIHR5cGljYWxseSBjcmVhdGUgYVxuICogc2luZ2xlIGluc3RhbmNlIG9mIGEgYFRyYW5zYWN0aW9uYCBmb3IgcmV1c2UgbXVsdGlwbGUgdGltZXMsIHRoYXQgcG90ZW50aWFsbHlcbiAqIGlzIHVzZWQgdG8gd3JhcCBzZXZlcmFsIGRpZmZlcmVudCBtZXRob2RzLiBXcmFwcGVycyBhcmUgZXh0cmVtZWx5IHNpbXBsZSAtXG4gKiB0aGV5IG9ubHkgcmVxdWlyZSBpbXBsZW1lbnRpbmcgdHdvIG1ldGhvZHMuXG4gKlxuICogPHByZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVycyAoaW5qZWN0ZWQgYXQgY3JlYXRpb24gdGltZSlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICAgICAgICArXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB2ICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICstLS0tLS0tLS0tLS0tLS0rICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICArLS18ICAgIHdyYXBwZXIxICAgfC0tLXwtLS0tKyAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgKy0tLS0tLS0tLS0tLS0tLSsgICB2ICAgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICAgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICArLS0tLXwgICB3cmFwcGVyMiAgfC0tLS0tLS0tKyAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgdiAgICAgdiAgIHwgd3JhcHBlclxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHwgaW52YXJpYW50c1xuICogcGVyZm9ybShhbnlNZXRob2QpIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHwgbWFpbnRhaW5lZFxuICogKy0tLS0tLS0tLS0tLS0tLS0tPnwtfC0tLXwtfC0tLXwtLT58YW55TWV0aG9kfC0tLXwtLS18LXwtLS18LXwtLS0tLS0tLT5cbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgaW5pdGlhbGl6ZSAgICAgICAgICAgICAgICAgICAgY2xvc2UgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqIDwvcHJlPlxuICpcbiAqIFVzZSBjYXNlczpcbiAqIC0gUHJlc2VydmluZyB0aGUgaW5wdXQgc2VsZWN0aW9uIHJhbmdlcyBiZWZvcmUvYWZ0ZXIgcmVjb25jaWxpYXRpb24uXG4gKiAgIFJlc3RvcmluZyBzZWxlY3Rpb24gZXZlbiBpbiB0aGUgZXZlbnQgb2YgYW4gdW5leHBlY3RlZCBlcnJvci5cbiAqIC0gRGVhY3RpdmF0aW5nIGV2ZW50cyB3aGlsZSByZWFycmFuZ2luZyB0aGUgRE9NLCBwcmV2ZW50aW5nIGJsdXJzL2ZvY3VzZXMsXG4gKiAgIHdoaWxlIGd1YXJhbnRlZWluZyB0aGF0IGFmdGVyd2FyZHMsIHRoZSBldmVudCBzeXN0ZW0gaXMgcmVhY3RpdmF0ZWQuXG4gKiAtIEZsdXNoaW5nIGEgcXVldWUgb2YgY29sbGVjdGVkIERPTSBtdXRhdGlvbnMgdG8gdGhlIG1haW4gVUkgdGhyZWFkIGFmdGVyIGFcbiAqICAgcmVjb25jaWxpYXRpb24gdGFrZXMgcGxhY2UgaW4gYSB3b3JrZXIgdGhyZWFkLlxuICogLSBJbnZva2luZyBhbnkgY29sbGVjdGVkIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBhZnRlciByZW5kZXJpbmcgbmV3XG4gKiAgIGNvbnRlbnQuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBXcmFwcGluZyBwYXJ0aWN1bGFyIGZsdXNoZXMgb2YgdGhlIGBSZWFjdFdvcmtlcmAgcXVldWVcbiAqICAgdG8gcHJlc2VydmUgdGhlIGBzY3JvbGxUb3BgIChhbiBhdXRvbWF0aWMgc2Nyb2xsIGF3YXJlIERPTSkuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBMYXlvdXQgY2FsY3VsYXRpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgRE9NIHVwZGF0ZXMuXG4gKlxuICogVHJhbnNhY3Rpb25hbCBwbHVnaW4gQVBJOlxuICogLSBBIG1vZHVsZSB0aGF0IGhhcyBhbiBgaW5pdGlhbGl6ZWAgbWV0aG9kIHRoYXQgcmV0dXJucyBhbnkgcHJlY29tcHV0YXRpb24uXG4gKiAtIGFuZCBhIGBjbG9zZWAgbWV0aG9kIHRoYXQgYWNjZXB0cyB0aGUgcHJlY29tcHV0YXRpb24uIGBjbG9zZWAgaXMgaW52b2tlZFxuICogICB3aGVuIHRoZSB3cmFwcGVkIHByb2Nlc3MgaXMgY29tcGxldGVkLCBvciBoYXMgZmFpbGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VHJhbnNhY3Rpb25hbFdyYXBwZXI+fSB0cmFuc2FjdGlvbldyYXBwZXIgV3JhcHBlciBtb2R1bGVzXG4gKiB0aGF0IGltcGxlbWVudCBgaW5pdGlhbGl6ZWAgYW5kIGBjbG9zZWAuXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gU2luZ2xlIHRyYW5zYWN0aW9uIGZvciByZXVzZSBpbiB0aHJlYWQuXG4gKlxuICogQGNsYXNzIFRyYW5zYWN0aW9uXG4gKi9cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIFNldHMgdXAgdGhpcyBpbnN0YW5jZSBzbyB0aGF0IGl0IGlzIHByZXBhcmVkIGZvciBjb2xsZWN0aW5nIG1ldHJpY3MuIERvZXNcbiAgICogc28gc3VjaCB0aGF0IHRoaXMgc2V0dXAgbWV0aG9kIG1heSBiZSB1c2VkIG9uIGFuIGluc3RhbmNlIHRoYXQgaXMgYWxyZWFkeVxuICAgKiBpbml0aWFsaXplZCwgaW4gYSB3YXkgdGhhdCBkb2VzIG5vdCBjb25zdW1lIGFkZGl0aW9uYWwgbWVtb3J5IHVwb24gcmV1c2UuXG4gICAqIFRoYXQgY2FuIGJlIHVzZWZ1bCBpZiB5b3UgZGVjaWRlIHRvIG1ha2UgeW91ciBzdWJjbGFzcyBvZiB0aGlzIG1peGluIGFcbiAgICogXCJQb29sZWRDbGFzc1wiLlxuICAgKi9cbiAgcmVpbml0aWFsaXplVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLmdldFRyYW5zYWN0aW9uV3JhcHBlcnMoKTtcbiAgICBpZiAodGhpcy53cmFwcGVySW5pdERhdGEpIHtcbiAgICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3JhcHBlckluaXREYXRhID0gW107XG4gICAgfVxuICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICB9LFxuXG4gIF9pc0luVHJhbnNhY3Rpb246IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7QXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPn0gQXJyYXkgb2YgdHJhbnNhY3Rpb24gd3JhcHBlcnMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBudWxsLFxuXG4gIGlzSW5UcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2lzSW5UcmFuc2FjdGlvbjtcbiAgfSxcblxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIGZ1bmN0aW9uIHdpdGhpbiBhIHNhZmV0eSB3aW5kb3cuIFVzZSB0aGlzIGZvciB0aGUgdG9wIGxldmVsXG4gICAqIG1ldGhvZHMgdGhhdCByZXN1bHQgaW4gbGFyZ2UgYW1vdW50cyBvZiBjb21wdXRhdGlvbi9tdXRhdGlvbnMgdGhhdCB3b3VsZFxuICAgKiBuZWVkIHRvIGJlIHNhZmV0eSBjaGVja2VkLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGhlbHBzIHByZXZlbnQgdGhlIG5lZWRcbiAgICogdG8gYmluZCBpbiBtYW55IGNhc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWVtYmVyIG9mIHNjb3BlIHRvIGNhbGwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBTY29wZSB0byBpbnZva2UgZnJvbS5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGIgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBjIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZCBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGUgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBmIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICpcbiAgICogQHJldHVybiB7Kn0gUmV0dXJuIHZhbHVlIGZyb20gYG1ldGhvZGAuXG4gICAqL1xuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICEhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5wZXJmb3JtKC4uLik6IENhbm5vdCBpbml0aWFsaXplIGEgdHJhbnNhY3Rpb24gd2hlbiB0aGVyZSBpcyBhbHJlYWR5IGFuIG91dHN0YW5kaW5nIHRyYW5zYWN0aW9uLicpIDogX3Byb2RJbnZhcmlhbnQoJzI3JykgOiB2b2lkIDA7XG4gICAgdmFyIGVycm9yVGhyb3duO1xuICAgIHZhciByZXQ7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgLy8gb25lIG9mIHRoZXNlIGNhbGxzIHRocmV3LlxuICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdGhpcy5pbml0aWFsaXplQWxsKDApO1xuICAgICAgcmV0ID0gbWV0aG9kLmNhbGwoc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gSWYgYG1ldGhvZGAgdGhyb3dzLCBwcmVmZXIgdG8gc2hvdyB0aGF0IHN0YWNrIHRyYWNlIG92ZXIgYW55IHRocm93blxuICAgICAgICAgIC8vIGJ5IGludm9raW5nIGBjbG9zZUFsbGAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbmNlIGBtZXRob2RgIGRpZG4ndCB0aHJvdywgd2UgZG9uJ3Qgd2FudCB0byBzaWxlbmNlIHRoZSBleGNlcHRpb25cbiAgICAgICAgICAvLyBoZXJlLlxuICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIGluaXRpYWxpemVBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoIHRoZVxuICAgICAgICAvLyBPQlNFUlZFRF9FUlJPUiBzdGF0ZSBiZWZvcmUgb3ZlcndyaXRpbmcgaXQgd2l0aCB0aGUgcmVhbCByZXR1cm4gdmFsdWVcbiAgICAgICAgLy8gb2YgaW5pdGlhbGl6ZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byBPQlNFUlZFRF9FUlJPUiBpbiB0aGUgZmluYWxseVxuICAgICAgICAvLyBibG9jaywgaXQgbWVhbnMgd3JhcHBlci5pbml0aWFsaXplIHRocmV3LlxuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SO1xuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IHdyYXBwZXIuaW5pdGlhbGl6ZSA/IHdyYXBwZXIuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpIDogbnVsbDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9PT0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1IpIHtcbiAgICAgICAgICAvLyBUaGUgaW5pdGlhbGl6ZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgaW5pdGlhbGl6ZSB0aGVcbiAgICAgICAgICAvLyByZW1haW5pbmcgd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZVxuICAgICAgICAgIC8vIHRoYXQgdGhlIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBlYWNoIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuY2xvc2VbaV1gIGZ1bmN0aW9ucywgcGFzc2luZyBpbnRvXG4gICAqIHRoZW0gdGhlIHJlc3BlY3RpdmUgcmV0dXJuIHZhbHVlcyBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmluaXRbaV1gXG4gICAqIChgY2xvc2VgcnMgdGhhdCBjb3JyZXNwb25kIHRvIGluaXRpYWxpemVycyB0aGF0IGZhaWxlZCB3aWxsIG5vdCBiZVxuICAgKiBpbnZva2VkKS5cbiAgICovXG4gIGNsb3NlQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgICF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLmNsb3NlQWxsKCk6IENhbm5vdCBjbG9zZSB0cmFuc2FjdGlvbiB3aGVuIG5vbmUgYXJlIG9wZW4uJykgOiBfcHJvZEludmFyaWFudCgnMjgnKSA6IHZvaWQgMDtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHZhciBpbml0RGF0YSA9IHRoaXMud3JhcHBlckluaXREYXRhW2ldO1xuICAgICAgdmFyIGVycm9yVGhyb3duO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAgIC8vIHdyYXBwZXIuY2xvc2UgdGhyZXcuXG4gICAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluaXREYXRhICE9PSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUiAmJiB3cmFwcGVyLmNsb3NlKSB7XG4gICAgICAgICAgd3JhcHBlci5jbG9zZS5jYWxsKHRoaXMsIGluaXREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gVGhlIGNsb3NlciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBjbG9zZSB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgLy8gd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAgICAgICAgIC8vIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gIH1cbn07XG5cbnZhciBUcmFuc2FjdGlvbiA9IHtcblxuICBNaXhpbjogTWl4aW4sXG5cbiAgLyoqXG4gICAqIFRva2VuIHRvIGxvb2sgZm9yIHRvIGRldGVybWluZSBpZiBhbiBlcnJvciBvY2N1cnJlZC5cbiAgICovXG4gIE9CU0VSVkVEX0VSUk9SOiB7fVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvVHJhbnNhY3Rpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRUYXJnZXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcblxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRUYXJnZXQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc0V2ZW50U3VwcG9ydGVkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgdXNlSGFzRmVhdHVyZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdXNlSGFzRmVhdHVyZSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcbiAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxuICAvLyBAc2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZG9taW1wbGVtZW50YXRpb24taGFzZmVhdHVyZVxuICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCcnLCAnJykgIT09IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8IGNhcHR1cmUgJiYgISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IGV2ZW50TmFtZSBpbiBkb2N1bWVudDtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCAmJiB1c2VIYXNGZWF0dXJlICYmIGV2ZW50TmFtZVN1ZmZpeCA9PT0gJ3doZWVsJykge1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHRlc3Qgc3VwcG9ydCBmb3IgdGhlIGB3aGVlbGAgZXZlbnQgaW4gSUU5Ky5cbiAgICBpc1N1cHBvcnRlZCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ0V2ZW50cy53aGVlbCcsICczLjAnKTtcbiAgfVxuXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0V2ZW50U3VwcG9ydGVkO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvaXNFdmVudFN1cHBvcnRlZC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc1RleHRJbnB1dEVsZW1lbnRcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1pbnB1dC1lbGVtZW50Lmh0bWwjaW5wdXQtdHlwZS1hdHRyLXN1bW1hcnlcbiAqL1xuXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgJ2NvbG9yJzogdHJ1ZSxcbiAgJ2RhdGUnOiB0cnVlLFxuICAnZGF0ZXRpbWUnOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICAnZW1haWwnOiB0cnVlLFxuICAnbW9udGgnOiB0cnVlLFxuICAnbnVtYmVyJzogdHJ1ZSxcbiAgJ3Bhc3N3b3JkJzogdHJ1ZSxcbiAgJ3JhbmdlJzogdHJ1ZSxcbiAgJ3NlYXJjaCc6IHRydWUsXG4gICd0ZWwnOiB0cnVlLFxuICAndGV4dCc6IHRydWUsXG4gICd0aW1lJzogdHJ1ZSxcbiAgJ3VybCc6IHRydWUsXG4gICd3ZWVrJzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdpbnB1dCcpIHtcbiAgICByZXR1cm4gISFzdXBwb3J0ZWRJbnB1dFR5cGVzW2VsZW0udHlwZV07XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHRJbnB1dEVsZW1lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IFtrZXlPZih7IFJlc3BvbmRlckV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFNpbXBsZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFRhcEV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IEVudGVyTGVhdmVFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBDaGFuZ2VFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBTZWxlY3RFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBudWxsIH0pXTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEVudGVyTGVhdmVFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHsgb25Nb3VzZUVudGVyOiBudWxsIH0pLFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wTW91c2VPdXQsIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZToga2V5T2YoeyBvbk1vdXNlTGVhdmU6IG51bGwgfSksXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXJdXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXIgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCAmJiB0b3BMZXZlbFR5cGUgIT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0KSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVsYXRlZCkgOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZpbmcgdG8gYSBub2RlIGZyb20gb3V0c2lkZSB0aGUgd2luZG93LlxuICAgICAgZnJvbSA9IG51bGw7XG4gICAgICB0byA9IHRhcmdldEluc3Q7XG4gICAgfVxuXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAvLyBOb3RoaW5nIHBlcnRhaW5zIHRvIG91ciBtYW5hZ2VkIGNvbXBvbmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShmcm9tKTtcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlRW50ZXIsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyLnR5cGUgPSAnbW91c2VlbnRlcic7XG4gICAgZW50ZXIudGFyZ2V0ID0gdG9Ob2RlO1xuICAgIGVudGVyLnJlbGF0ZWRUYXJnZXQgPSBmcm9tTm9kZTtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY01vdXNlRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZSgnLi9WaWV3cG9ydE1ldHJpY3MnKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIE1vdXNlRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHNjcmVlblg6IG51bGwsXG4gIHNjcmVlblk6IG51bGwsXG4gIGNsaWVudFg6IG51bGwsXG4gIGNsaWVudFk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBXZWJraXQsIEZpcmVmb3gsIElFOStcbiAgICAvLyB3aGljaDogIDEgMiAzXG4gICAgLy8gYnV0dG9uOiAwIDEgMiAoc3RhbmRhcmQpXG4gICAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcbiAgICBpZiAoJ3doaWNoJyBpbiBldmVudCkge1xuICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gICAgLy8gSUU8OVxuICAgIC8vIHdoaWNoOiAgdW5kZWZpbmVkXG4gICAgLy8gYnV0dG9uOiAwIDAgMFxuICAgIC8vIGJ1dHRvbjogMSA0IDIgKG9ubW91c2V1cClcbiAgICByZXR1cm4gYnV0dG9uID09PSAyID8gMiA6IGJ1dHRvbiA9PT0gNCA/IDEgOiAwO1xuICB9LFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH0sXG4gIC8vIFwiUHJvcHJpZXRhcnlcIiBJbnRlcmZhY2UuXG4gIHBhZ2VYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VYJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VYIDogZXZlbnQuY2xpZW50WCArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdDtcbiAgfSxcbiAgcGFnZVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVknIGluIGV2ZW50ID8gZXZlbnQucGFnZVkgOiBldmVudC5jbGllbnRZICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3A7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY01vdXNlRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1VJRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudmlldykge1xuICAgICAgcmV0dXJuIGV2ZW50LnZpZXc7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICBpZiAodGFyZ2V0LndpbmRvdyA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyB0YXJnZXQgaXMgYSB3aW5kb3cgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgaWYgKGRvYykge1xuICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgfSxcbiAgZGV0YWlsOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZGV0YWlsIHx8IDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1VJRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFZpZXdwb3J0TWV0cmljc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZpZXdwb3J0TWV0cmljcyA9IHtcblxuICBjdXJyZW50U2Nyb2xsTGVmdDogMCxcblxuICBjdXJyZW50U2Nyb2xsVG9wOiAwLFxuXG4gIHJlZnJlc2hTY3JvbGxWYWx1ZXM6IGZ1bmN0aW9uIChzY3JvbGxQb3NpdGlvbikge1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbi55O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvVmlld3BvcnRNZXRyaWNzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gICdBbHQnOiAnYWx0S2V5JyxcbiAgJ0NvbnRyb2wnOiAnY3RybEtleScsXG4gICdNZXRhJzogJ21ldGFLZXknLFxuICAnU2hpZnQnOiAnc2hpZnRLZXknXG59O1xuXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxuLy8gQ3VycmVudGx5LCBhbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IENocm9tZSBzZWVtcyB0byBzdXBwb3J0IExvY2sta2V5cy5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50TW9kaWZpZXJTdGF0ZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBIVE1MRE9NUHJvcGVydHlDb25maWdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcblxudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgaXNDdXN0b21BdHRyaWJ1dGU6IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKG5ldyBSZWdFeHAoJ14oZGF0YXxhcmlhKS1bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJykpLFxuICBQcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFjY2VwdDogMCxcbiAgICBhY2NlcHRDaGFyc2V0OiAwLFxuICAgIGFjY2Vzc0tleTogMCxcbiAgICBhY3Rpb246IDAsXG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogMCxcbiAgICBhbHQ6IDAsXG4gICAgYXN5bmM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9Db21wbGV0ZTogMCxcbiAgICAvLyBhdXRvRm9jdXMgaXMgcG9seWZpbGxlZC9ub3JtYWxpemVkIGJ5IEF1dG9Gb2N1c1V0aWxzXG4gICAgLy8gYXV0b0ZvY3VzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvUGxheTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2FwdHVyZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2VsbFBhZGRpbmc6IDAsXG4gICAgY2VsbFNwYWNpbmc6IDAsXG4gICAgY2hhclNldDogMCxcbiAgICBjaGFsbGVuZ2U6IDAsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjaXRlOiAwLFxuICAgIGNsYXNzSUQ6IDAsXG4gICAgY2xhc3NOYW1lOiAwLFxuICAgIGNvbHM6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIGNvbFNwYW46IDAsXG4gICAgY29udGVudDogMCxcbiAgICBjb250ZW50RWRpdGFibGU6IDAsXG4gICAgY29udGV4dE1lbnU6IDAsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNvb3JkczogMCxcbiAgICBjcm9zc09yaWdpbjogMCxcbiAgICBkYXRhOiAwLCAvLyBGb3IgYDxvYmplY3QgLz5gIGFjdHMgYXMgYHNyY2AuXG4gICAgZGF0ZVRpbWU6IDAsXG4gICAgJ2RlZmF1bHQnOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlyOiAwLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IDAsXG4gICAgZW5jVHlwZTogMCxcbiAgICBmb3JtOiAwLFxuICAgIGZvcm1BY3Rpb246IDAsXG4gICAgZm9ybUVuY1R5cGU6IDAsXG4gICAgZm9ybU1ldGhvZDogMCxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZm9ybVRhcmdldDogMCxcbiAgICBmcmFtZUJvcmRlcjogMCxcbiAgICBoZWFkZXJzOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBoaWRkZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGhpZ2g6IDAsXG4gICAgaHJlZjogMCxcbiAgICBocmVmTGFuZzogMCxcbiAgICBodG1sRm9yOiAwLFxuICAgIGh0dHBFcXVpdjogMCxcbiAgICBpY29uOiAwLFxuICAgIGlkOiAwLFxuICAgIGlucHV0TW9kZTogMCxcbiAgICBpbnRlZ3JpdHk6IDAsXG4gICAgaXM6IDAsXG4gICAga2V5UGFyYW1zOiAwLFxuICAgIGtleVR5cGU6IDAsXG4gICAga2luZDogMCxcbiAgICBsYWJlbDogMCxcbiAgICBsYW5nOiAwLFxuICAgIGxpc3Q6IDAsXG4gICAgbG9vcDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbG93OiAwLFxuICAgIG1hbmlmZXN0OiAwLFxuICAgIG1hcmdpbkhlaWdodDogMCxcbiAgICBtYXJnaW5XaWR0aDogMCxcbiAgICBtYXg6IDAsXG4gICAgbWF4TGVuZ3RoOiAwLFxuICAgIG1lZGlhOiAwLFxuICAgIG1lZGlhR3JvdXA6IDAsXG4gICAgbWV0aG9kOiAwLFxuICAgIG1pbjogMCxcbiAgICBtaW5MZW5ndGg6IDAsXG4gICAgLy8gQ2F1dGlvbjsgYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbiAgICAvLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLlxuICAgIG11bHRpcGxlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG11dGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG5hbWU6IDAsXG4gICAgbm9uY2U6IDAsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3B0aW11bTogMCxcbiAgICBwYXR0ZXJuOiAwLFxuICAgIHBsYWNlaG9sZGVyOiAwLFxuICAgIHBvc3RlcjogMCxcbiAgICBwcmVsb2FkOiAwLFxuICAgIHByb2ZpbGU6IDAsXG4gICAgcmFkaW9Hcm91cDogMCxcbiAgICByZWFkT25seTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmVmZXJyZXJQb2xpY3k6IDAsXG4gICAgcmVsOiAwLFxuICAgIHJlcXVpcmVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXZlcnNlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcm9sZTogMCxcbiAgICByb3dzOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICByb3dTcGFuOiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzYW5kYm94OiAwLFxuICAgIHNjb3BlOiAwLFxuICAgIHNjb3BlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2Nyb2xsaW5nOiAwLFxuICAgIHNlYW1sZXNzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzZWxlY3RlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzaGFwZTogMCxcbiAgICBzaXplOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzaXplczogMCxcbiAgICBzcGFuOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzcGVsbENoZWNrOiAwLFxuICAgIHNyYzogMCxcbiAgICBzcmNEb2M6IDAsXG4gICAgc3JjTGFuZzogMCxcbiAgICBzcmNTZXQ6IDAsXG4gICAgc3RhcnQ6IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHN0ZXA6IDAsXG4gICAgc3R5bGU6IDAsXG4gICAgc3VtbWFyeTogMCxcbiAgICB0YWJJbmRleDogMCxcbiAgICB0YXJnZXQ6IDAsXG4gICAgdGl0bGU6IDAsXG4gICAgLy8gU2V0dGluZyAudHlwZSB0aHJvd3Mgb24gbm9uLTxpbnB1dD4gdGFnc1xuICAgIHR5cGU6IDAsXG4gICAgdXNlTWFwOiAwLFxuICAgIHZhbHVlOiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIHdtb2RlOiAwLFxuICAgIHdyYXA6IDAsXG5cbiAgICAvKipcbiAgICAgKiBSREZhIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhYm91dDogMCxcbiAgICBkYXRhdHlwZTogMCxcbiAgICBpbmxpc3Q6IDAsXG4gICAgcHJlZml4OiAwLFxuICAgIC8vIHByb3BlcnR5IGlzIGFsc28gc3VwcG9ydGVkIGZvciBPcGVuR3JhcGggaW4gbWV0YSB0YWdzLlxuICAgIHByb3BlcnR5OiAwLFxuICAgIHJlc291cmNlOiAwLFxuICAgICd0eXBlb2YnOiAwLFxuICAgIHZvY2FiOiAwLFxuXG4gICAgLyoqXG4gICAgICogTm9uLXN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICAvLyBhdXRvQ2FwaXRhbGl6ZSBhbmQgYXV0b0NvcnJlY3QgYXJlIHN1cHBvcnRlZCBpbiBNb2JpbGUgU2FmYXJpIGZvclxuICAgIC8vIGtleWJvYXJkIGhpbnRzLlxuICAgIGF1dG9DYXBpdGFsaXplOiAwLFxuICAgIGF1dG9Db3JyZWN0OiAwLFxuICAgIC8vIGF1dG9TYXZlIGFsbG93cyBXZWJLaXQvQmxpbmsgdG8gcGVyc2lzdCB2YWx1ZXMgb2YgaW5wdXQgZmllbGRzIG9uIHBhZ2UgcmVsb2Fkc1xuICAgIGF1dG9TYXZlOiAwLFxuICAgIC8vIGNvbG9yIGlzIGZvciBTYWZhcmkgbWFzay1pY29uIGxpbmtcbiAgICBjb2xvcjogMCxcbiAgICAvLyBpdGVtUHJvcCwgaXRlbVNjb3BlLCBpdGVtVHlwZSBhcmUgZm9yXG4gICAgLy8gTWljcm9kYXRhIHN1cHBvcnQuIFNlZSBodHRwOi8vc2NoZW1hLm9yZy9kb2NzL2dzLmh0bWxcbiAgICBpdGVtUHJvcDogMCxcbiAgICBpdGVtU2NvcGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGl0ZW1UeXBlOiAwLFxuICAgIC8vIGl0ZW1JRCBhbmQgaXRlbVJlZiBhcmUgZm9yIE1pY3JvZGF0YSBzdXBwb3J0IGFzIHdlbGwgYnV0XG4gICAgLy8gb25seSBzcGVjaWZpZWQgaW4gdGhlIFdIQVRXRyBzcGVjIGRvY3VtZW50LiBTZWVcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9taWNyb2RhdGEuaHRtbCNtaWNyb2RhdGEtZG9tLWFwaVxuICAgIGl0ZW1JRDogMCxcbiAgICBpdGVtUmVmOiAwLFxuICAgIC8vIHJlc3VsdHMgc2hvdyBsb29raW5nIGdsYXNzIGljb24gYW5kIHJlY2VudCBzZWFyY2hlcyBvbiBpbnB1dFxuICAgIC8vIHNlYXJjaCBmaWVsZHMgaW4gV2ViS2l0L0JsaW5rXG4gICAgcmVzdWx0czogMCxcbiAgICAvLyBJRS1vbmx5IGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyBzZWN1cml0eSByZXN0cmljdGlvbnMgb24gYW4gaWZyYW1lXG4gICAgLy8gYXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIHNhbmRib3ggYXR0cmlidXRlIG9uIElFPDEwXG4gICAgc2VjdXJpdHk6IDAsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBjb250cm9scyBmb2N1cyBiZWhhdmlvclxuICAgIHVuc2VsZWN0YWJsZTogMFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgIGh0bWxGb3I6ICdmb3InLFxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXG4gIH0sXG4gIERPTVByb3BlcnR5TmFtZXM6IHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhUTUxET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0hUTUxET01Qcm9wZXJ0eUNvbmZpZy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XG5cbi8qKlxuICogQWJzdHJhY3RzIGF3YXkgYWxsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHJlY29uY2lsZXIgdGhhdCByZXF1aXJlcyBrbm93bGVkZ2Ugb2ZcbiAqIHRoZSBicm93c2VyIGNvbnRleHQuIFRPRE86IFRoZXNlIGNhbGxlcnMgc2hvdWxkIGJlIHJlZmFjdG9yZWQgdG8gYXZvaWQgdGhlXG4gKiBuZWVkIGZvciB0aGlzIGluamVjdGlvbi5cbiAqL1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0ge1xuXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyxcblxuICByZXBsYWNlTm9kZVdpdGhNYXJrdXA6IERPTUNoaWxkcmVuT3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NQ2hpbGRyZW5PcGVyYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRGFuZ2VyID0gcmVxdWlyZSgnLi9EYW5nZXInKTtcbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XG5cbmZ1bmN0aW9uIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCBub2RlKSB7XG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgdGV4dCBjb21wb25lbnRzLCB3aGljaCByZXR1cm4gW29wZW4sIGNsb3NlXSBjb21tZW50c1xuICAvLyBmcm9tIGdldEhvc3ROb2RlLlxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIG5vZGUgPSBub2RlWzFdO1xuICB9XG4gIHJldHVybiBub2RlID8gbm9kZS5uZXh0U2libGluZyA6IHBhcmVudE5vZGUuZmlyc3RDaGlsZDtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIGBjaGlsZE5vZGVgIGFzIGEgY2hpbGQgb2YgYHBhcmVudE5vZGVgIGF0IHRoZSBgaW5kZXhgLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcGFyZW50Tm9kZSBQYXJlbnQgbm9kZSBpbiB3aGljaCB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNoaWxkTm9kZSBDaGlsZCBub2RlIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICogQGludGVybmFsXG4gKi9cbnZhciBpbnNlcnRDaGlsZEF0ID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIC8vIFdlIHJlbHkgZXhjbHVzaXZlbHkgb24gYGluc2VydEJlZm9yZShub2RlLCBudWxsKWAgaW5zdGVhZCBvZiBhbHNvIHVzaW5nXG4gIC8vIGBhcHBlbmRDaGlsZChub2RlKWAuIChVc2luZyBgdW5kZWZpbmVkYCBpcyBub3QgYWxsb3dlZCBieSBhbGwgYnJvd3NlcnMgc29cbiAgLy8gd2UgYXJlIGNhcmVmdWwgdG8gdXNlIGBudWxsYC4pXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59KTtcblxuZnVuY3Rpb24gaW5zZXJ0TGF6eVRyZWVDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkVHJlZSwgcmVmZXJlbmNlTm9kZSkge1xuICBET01MYXp5VHJlZS5pbnNlcnRUcmVlQmVmb3JlKHBhcmVudE5vZGUsIGNoaWxkVHJlZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIG1vdmVDaGlsZChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGROb2RlKSkge1xuICAgIG1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIGNoaWxkTm9kZVswXSwgY2hpbGROb2RlWzFdLCByZWZlcmVuY2VOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkTm9kZSkpIHtcbiAgICB2YXIgY2xvc2luZ0NvbW1lbnQgPSBjaGlsZE5vZGVbMV07XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlWzBdO1xuICAgIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCBjbG9zaW5nQ29tbWVudCk7XG4gICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9zaW5nQ29tbWVudCk7XG4gIH1cbiAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZE5vZGUpO1xufVxuXG5mdW5jdGlvbiBtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQsIHJlZmVyZW5jZU5vZGUpIHtcbiAgdmFyIG5vZGUgPSBvcGVuaW5nQ29tbWVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgbm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgaWYgKG5vZGUgPT09IGNsb3NpbmdDb21tZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbm9kZSA9IG5leHROb2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgc3RhcnROb2RlLCBjbG9zaW5nQ29tbWVudCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlLm5leHRTaWJsaW5nO1xuICAgIGlmIChub2RlID09PSBjbG9zaW5nQ29tbWVudCkge1xuICAgICAgLy8gVGhlIGNsb3NpbmcgY29tbWVudCBpcyByZW1vdmVkIGJ5IFJlYWN0TXVsdGlDaGlsZC5cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlRGVsaW1pdGVkVGV4dChvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQsIHN0cmluZ1RleHQpIHtcbiAgdmFyIHBhcmVudE5vZGUgPSBvcGVuaW5nQ29tbWVudC5wYXJlbnROb2RlO1xuICB2YXIgbm9kZUFmdGVyQ29tbWVudCA9IG9wZW5pbmdDb21tZW50Lm5leHRTaWJsaW5nO1xuICBpZiAobm9kZUFmdGVyQ29tbWVudCA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAvLyBUaGVyZSBhcmUgbm8gdGV4dCBub2RlcyBiZXR3ZWVuIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIGNvbW1lbnRzOyBpbnNlcnRcbiAgICAvLyBhIG5ldyBvbmUgaWYgc3RyaW5nVGV4dCBpc24ndCBlbXB0eS5cbiAgICBpZiAoc3RyaW5nVGV4dCkge1xuICAgICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHJpbmdUZXh0KSwgbm9kZUFmdGVyQ29tbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzdHJpbmdUZXh0KSB7XG4gICAgICAvLyBTZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgZmlyc3Qgbm9kZSBhZnRlciB0aGUgb3BlbmluZyBjb21tZW50LCBhbmRcbiAgICAgIC8vIHJlbW92ZSBhbGwgZm9sbG93aW5nIG5vZGVzIHVwIHVudGlsIHRoZSBjbG9zaW5nIGNvbW1lbnQuXG4gICAgICBzZXRUZXh0Q29udGVudChub2RlQWZ0ZXJDb21tZW50LCBzdHJpbmdUZXh0KTtcbiAgICAgIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgbm9kZUFmdGVyQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG9wZW5pbmdDb21tZW50LCBjbG9zaW5nQ29tbWVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG9wZW5pbmdDb21tZW50KS5fZGVidWdJRCwgJ3JlcGxhY2UgdGV4dCcsIHN0cmluZ1RleHQpO1xuICB9XG59XG5cbnZhciBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXAsIHByZXZJbnN0YW5jZSkge1xuICAgIERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRDaGlsZCwgbWFya3VwKTtcbiAgICBpZiAocHJldkluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHByZXZJbnN0YW5jZS5fZGVidWdJRCwgJ3JlcGxhY2Ugd2l0aCcsIG1hcmt1cC50b1N0cmluZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG1hcmt1cC5ub2RlKTtcbiAgICAgIGlmIChuZXh0SW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihuZXh0SW5zdGFuY2UuX2RlYnVnSUQsICdtb3VudCcsIG1hcmt1cC50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgdXBkYXRpbmcgd2l0aCBET00gY2hpbGRyZW4uXG4gKi9cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSB7XG5cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwLFxuXG4gIHJlcGxhY2VEZWxpbWl0ZWRUZXh0OiByZXBsYWNlRGVsaW1pdGVkVGV4dCxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy4gVGhlXG4gICAqIHVwZGF0ZSBjb25maWd1cmF0aW9ucyBhcmUgZWFjaCBleHBlY3RlZCB0byBoYXZlIGEgYHBhcmVudE5vZGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc1VwZGF0ZXM6IGZ1bmN0aW9uIChwYXJlbnROb2RlLCB1cGRhdGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnROb2RlRGVidWdJRCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHBhcmVudE5vZGUpLl9kZWJ1Z0lEO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdXBkYXRlcy5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIHVwZGF0ZSA9IHVwZGF0ZXNba107XG4gICAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuSU5TRVJUX01BUktVUDpcbiAgICAgICAgICBpbnNlcnRMYXp5VHJlZUNoaWxkQXQocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdpbnNlcnQgY2hpbGQnLCB7IHRvSW5kZXg6IHVwZGF0ZS50b0luZGV4LCBjb250ZW50OiB1cGRhdGUuY29udGVudC50b1N0cmluZygpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HOlxuICAgICAgICAgIG1vdmVDaGlsZChwYXJlbnROb2RlLCB1cGRhdGUuZnJvbU5vZGUsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdtb3ZlIGNoaWxkJywgeyBmcm9tSW5kZXg6IHVwZGF0ZS5mcm9tSW5kZXgsIHRvSW5kZXg6IHVwZGF0ZS50b0luZGV4IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5TRVRfTUFSS1VQOlxuICAgICAgICAgIHNldElubmVySFRNTChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdyZXBsYWNlIGNoaWxkcmVuJywgdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVDpcbiAgICAgICAgICBzZXRUZXh0Q29udGVudChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdyZXBsYWNlIHRleHQnLCB1cGRhdGUuY29udGVudC50b1N0cmluZygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREU6XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgdXBkYXRlLmZyb21Ob2RlKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihwYXJlbnROb2RlRGVidWdJRCwgJ3JlbW92ZSBjaGlsZCcsIHsgZnJvbUluZGV4OiB1cGRhdGUuZnJvbUluZGV4IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9ET01DaGlsZHJlbk9wZXJhdGlvbnMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NTGF6eVRyZWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxuLyoqXG4gKiBJbiBJRSAoOC0xMSkgYW5kIEVkZ2UsIGFwcGVuZGluZyBub2RlcyB3aXRoIG5vIGNoaWxkcmVuIGlzIGRyYW1hdGljYWxseVxuICogZmFzdGVyIHRoYW4gYXBwZW5kaW5nIGEgZnVsbCBzdWJ0cmVlLCBzbyB3ZSBlc3NlbnRpYWxseSBxdWV1ZSB1cCB0aGVcbiAqIC5hcHBlbmRDaGlsZCBjYWxscyBoZXJlIGFuZCBhcHBseSB0aGVtIHNvIGVhY2ggbm9kZSBpcyBhZGRlZCB0byBpdHMgcGFyZW50XG4gKiBiZWZvcmUgYW55IGNoaWxkcmVuIGFyZSBhZGRlZC5cbiAqXG4gKiBJbiBvdGhlciBicm93c2VycywgZG9pbmcgc28gaXMgc2xvd2VyIG9yIG5ldXRyYWwgY29tcGFyZWQgdG8gdGhlIG90aGVyIG9yZGVyXG4gKiAoaW4gRmlyZWZveCwgdHdpY2UgYXMgc2xvdykgc28gd2Ugb25seSBkbyB0aGlzIGludmVyc2lvbiBpbiBJRS5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NwaWN5ai9pbm5lcmh0bWwtdnMtY3JlYXRlZWxlbWVudC12cy1jbG9uZW5vZGUuXG4gKi9cbnZhciBlbmFibGVMYXp5ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCA9PT0gJ3N0cmluZycgJiYgL1xcYkVkZ2VcXC9cXGQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbmZ1bmN0aW9uIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKSB7XG4gIGlmICghZW5hYmxlTGF6eSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbm9kZSA9IHRyZWUubm9kZTtcbiAgdmFyIGNoaWxkcmVuID0gdHJlZS5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGluc2VydFRyZWVCZWZvcmUobm9kZSwgY2hpbGRyZW5baV0sIG51bGwpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0cmVlLmh0bWwgIT0gbnVsbCkge1xuICAgIHNldElubmVySFRNTChub2RlLCB0cmVlLmh0bWwpO1xuICB9IGVsc2UgaWYgKHRyZWUudGV4dCAhPSBudWxsKSB7XG4gICAgc2V0VGV4dENvbnRlbnQobm9kZSwgdHJlZS50ZXh0KTtcbiAgfVxufVxuXG52YXIgaW5zZXJ0VHJlZUJlZm9yZSA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKHBhcmVudE5vZGUsIHRyZWUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlbid0IGFjdHVhbGx5IHBhcnQgb2YgdGhlIERPTSBhZnRlciBpbnNlcnRpb24gc29cbiAgLy8gYXBwZW5kaW5nIGNoaWxkcmVuIHdvbid0IHVwZGF0ZSB0aGUgRE9NLiBXZSBuZWVkIHRvIGVuc3VyZSB0aGUgZnJhZ21lbnRcbiAgLy8gaXMgcHJvcGVybHkgcG9wdWxhdGVkIGZpcnN0LCBicmVha2luZyBvdXQgb2Ygb3VyIGxhenkgYXBwcm9hY2ggZm9yIGp1c3RcbiAgLy8gdGhpcyBsZXZlbC4gQWxzbywgc29tZSA8b2JqZWN0PiBwbHVnaW5zIChsaWtlIEZsYXNoIFBsYXllcikgd2lsbCByZWFkXG4gIC8vIDxwYXJhbT4gbm9kZXMgaW1tZWRpYXRlbHkgdXBvbiBpbnNlcnRpb24gaW50byB0aGUgRE9NLCBzbyA8b2JqZWN0PlxuICAvLyBtdXN0IGFsc28gYmUgcG9wdWxhdGVkIHByaW9yIHRvIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gIGlmICh0cmVlLm5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSB8fCB0cmVlLm5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFICYmIHRyZWUubm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0JyAmJiAodHJlZS5ub2RlLm5hbWVzcGFjZVVSSSA9PSBudWxsIHx8IHRyZWUubm9kZS5uYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkpIHtcbiAgICBpbnNlcnRUcmVlQ2hpbGRyZW4odHJlZSk7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodHJlZS5ub2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmVlLm5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VDaGlsZFdpdGhUcmVlKG9sZE5vZGUsIG5ld1RyZWUpIHtcbiAgb2xkTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdUcmVlLm5vZGUsIG9sZE5vZGUpO1xuICBpbnNlcnRUcmVlQ2hpbGRyZW4obmV3VHJlZSk7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlQ2hpbGQocGFyZW50VHJlZSwgY2hpbGRUcmVlKSB7XG4gIGlmIChlbmFibGVMYXp5KSB7XG4gICAgcGFyZW50VHJlZS5jaGlsZHJlbi5wdXNoKGNoaWxkVHJlZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50VHJlZS5ub2RlLmFwcGVuZENoaWxkKGNoaWxkVHJlZS5ub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBxdWV1ZUhUTUwodHJlZSwgaHRtbCkge1xuICBpZiAoZW5hYmxlTGF6eSkge1xuICAgIHRyZWUuaHRtbCA9IGh0bWw7XG4gIH0gZWxzZSB7XG4gICAgc2V0SW5uZXJIVE1MKHRyZWUubm9kZSwgaHRtbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVldWVUZXh0KHRyZWUsIHRleHQpIHtcbiAgaWYgKGVuYWJsZUxhenkpIHtcbiAgICB0cmVlLnRleHQgPSB0ZXh0O1xuICB9IGVsc2Uge1xuICAgIHNldFRleHRDb250ZW50KHRyZWUubm9kZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLm5vZGUubm9kZU5hbWU7XG59XG5cbmZ1bmN0aW9uIERPTUxhenlUcmVlKG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiBub2RlLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBodG1sOiBudWxsLFxuICAgIHRleHQ6IG51bGwsXG4gICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gIH07XG59XG5cbkRPTUxhenlUcmVlLmluc2VydFRyZWVCZWZvcmUgPSBpbnNlcnRUcmVlQmVmb3JlO1xuRE9NTGF6eVRyZWUucmVwbGFjZUNoaWxkV2l0aFRyZWUgPSByZXBsYWNlQ2hpbGRXaXRoVHJlZTtcbkRPTUxhenlUcmVlLnF1ZXVlQ2hpbGQgPSBxdWV1ZUNoaWxkO1xuRE9NTGF6eVRyZWUucXVldWVIVE1MID0gcXVldWVIVE1MO1xuRE9NTGF6eVRyZWUucXVldWVUZXh0ID0gcXVldWVUZXh0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUxhenlUcmVlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRE9NTGF6eVRyZWUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NTmFtZXNwYWNlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcbiAgbWF0aG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcsXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01OYW1lc3BhY2VzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRE9NTmFtZXNwYWNlcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzZXRJbm5lckhUTUxcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgRE9NTmFtZXNwYWNlcyA9IHJlcXVpcmUoJy4vRE9NTmFtZXNwYWNlcycpO1xuXG52YXIgV0hJVEVTUEFDRV9URVNUID0gL15bIFxcclxcblxcdFxcZl0vO1xudmFyIE5PTlZJU0lCTEVfVEVTVCA9IC88KCEtLXxsaW5rfG5vc2NyaXB0fG1ldGF8c2NyaXB0fHN0eWxlKVsgXFxyXFxuXFx0XFxmXFwvPl0vO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXI7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgLy8gSUUgZG9lcyBub3QgaGF2ZSBpbm5lckhUTUwgZm9yIFNWRyBub2Rlcywgc28gaW5zdGVhZCB3ZSBpbmplY3QgdGhlXG4gIC8vIG5ldyBtYXJrdXAgaW4gYSB0ZW1wIG5vZGUgYW5kIHRoZW4gbW92ZSB0aGUgY2hpbGQgbm9kZXMgYWNyb3NzIGludG9cbiAgLy8gdGhlIHRhcmdldCBub2RlXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgbmV3Tm9kZXMgPSByZXVzYWJsZVNWR0NvbnRhaW5lci5maXJzdENoaWxkLmNoaWxkTm9kZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChuZXdOb2Rlc1tpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU4OiBXaGVuIHVwZGF0aW5nIGEganVzdCBjcmVhdGVkIG5vZGUgd2l0aCBpbm5lckhUTUwgb25seSBsZWFkaW5nXG4gIC8vIHdoaXRlc3BhY2UgaXMgcmVtb3ZlZC4gV2hlbiB1cGRhdGluZyBhbiBleGlzdGluZyBub2RlIHdpdGggaW5uZXJIVE1MXG4gIC8vIHdoaXRlc3BhY2UgaW4gcm9vdCBUZXh0Tm9kZXMgaXMgYWxzbyBjb2xsYXBzZWQuXG4gIC8vIEBzZWUgcXVpcmtzbW9kZS5vcmcvYnVncmVwb3J0cy9hcmNoaXZlcy8yMDA0LzExL2lubmVyaHRtbF9hbmRfdC5odG1sXG5cbiAgLy8gRmVhdHVyZSBkZXRlY3Rpb247IG9ubHkgSUU4IGlzIGtub3duIHRvIGJlaGF2ZSBpbXByb3Blcmx5IGxpa2UgdGhpcy5cbiAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRlc3RFbGVtZW50LmlubmVySFRNTCA9ICcgJztcbiAgaWYgKHRlc3RFbGVtZW50LmlubmVySFRNTCA9PT0gJycpIHtcbiAgICBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAgICAgLy8gTWFnaWMgdGhlb3J5OiBJRTggc3VwcG9zZWRseSBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFkZGVkIGFuZCB1cGRhdGVkXG4gICAgICAvLyBub2RlcyB3aGVuIHByb2Nlc3NpbmcgaW5uZXJIVE1MLCBpbm5lckhUTUwgb24gdXBkYXRlZCBub2RlcyBzdWZmZXJzXG4gICAgICAvLyBmcm9tIHdvcnNlIHdoaXRlc3BhY2UgYmVoYXZpb3IuIFJlLWFkZGluZyBhIG5vZGUgbGlrZSB0aGlzIHRyaWdnZXJzXG4gICAgICAvLyB0aGUgaW5pdGlhbCBhbmQgbW9yZSBmYXZvcmFibGUgd2hpdGVzcGFjZSBiZWhhdmlvci5cbiAgICAgIC8vIFRPRE86IFdoYXQgdG8gZG8gb24gYSBkZXRhY2hlZCBub2RlP1xuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBhbHNvIGltcGxlbWVudCBhIHdvcmthcm91bmQgZm9yIG5vbi12aXNpYmxlIHRhZ3MgZGlzYXBwZWFyaW5nIGludG9cbiAgICAgIC8vIHRoaW4gYWlyIG9uIElFOCwgdGhpcyBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gdmlzaWJsZSB0ZXh0XG4gICAgICAvLyBpbi1mcm9udCBvZiB0aGUgbm9uLXZpc2libGUgdGFncy4gUGlnZ3liYWNrIG9uIHRoZSB3aGl0ZXNwYWNlIGZpeFxuICAgICAgLy8gYW5kIHNpbXBseSBjaGVjayBpZiBhbnkgbm9uLXZpc2libGUgdGFncyBhcHBlYXIgaW4gdGhlIHNvdXJjZS5cbiAgICAgIGlmIChXSElURVNQQUNFX1RFU1QudGVzdChodG1sKSB8fCBodG1sWzBdID09PSAnPCcgJiYgTk9OVklTSUJMRV9URVNULnRlc3QoaHRtbCkpIHtcbiAgICAgICAgLy8gUmVjb3ZlciBsZWFkaW5nIHdoaXRlc3BhY2UgYnkgdGVtcG9yYXJpbHkgcHJlcGVuZGluZyBhbnkgY2hhcmFjdGVyLlxuICAgICAgICAvLyBcXHVGRUZGIGhhcyB0aGUgcG90ZW50aWFsIGFkdmFudGFnZSBvZiBiZWluZyB6ZXJvLXdpZHRoL2ludmlzaWJsZS5cbiAgICAgICAgLy8gVWdsaWZ5SlMgZHJvcHMgVStGRUZGIGNoYXJzIHdoZW4gcGFyc2luZywgc28gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgICAgLy8gaW4gaG9wZXMgdGhhdCB0aGlzIGlzIHByZXNlcnZlZCBldmVuIGlmIFwiXFx1RkVGRlwiIGlzIHRyYW5zZm9ybWVkIHRvXG4gICAgICAgIC8vIHRoZSBhY3R1YWwgVW5pY29kZSBjaGFyYWN0ZXIgKGJ5IEJhYmVsLCBmb3IgZXhhbXBsZSkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2Jsb2IvdjIuNC4yMC9saWIvcGFyc2UuanMjTDIxNlxuICAgICAgICBub2RlLmlubmVySFRNTCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRUZGKSArIGh0bWw7XG5cbiAgICAgICAgLy8gZGVsZXRlRGF0YSBsZWF2ZXMgYW4gZW1wdHkgYFRleHROb2RlYCB3aGljaCBvZmZzZXRzIHRoZSBpbmRleCBvZiBhbGxcbiAgICAgICAgLy8gY2hpbGRyZW4uIERlZmluaXRlbHkgd2FudCB0byBhdm9pZCB0aGlzLlxuICAgICAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZS5kYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlLmRlbGV0ZURhdGEoMCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRlc3RFbGVtZW50ID0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRJbm5lckhUTUw7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9zZXRJbm5lckhUTUwuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvblxuICovXG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZ1bmN0aW9uIHdoaWNoIGhhcyAndW5zYWZlJyBwcml2aWxlZ2VzIChyZXF1aXJlZCBieSB3aW5kb3dzOCBhcHBzKVxuICovXG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNldFRleHRDb250ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguIGlubmVyVGV4dCBpcyBhIHBvb3Igc3Vic3RpdHV0ZSBmb3IgdGV4dENvbnRlbnQgYW5kLCBhbW9uZyBtYW55XG4gKiBpc3N1ZXMsIGluc2VydHMgPGJyPiBpbnN0ZWFkIG9mIHRoZSBsaXRlcmFsIG5ld2xpbmUgY2hhcnMuIGlubmVySFRNTCBiZWhhdmVzXG4gKiBhcyBpdCBzaG91bGQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIGlmICh0ZXh0KSB7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBpZiAoISgndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpIHtcbiAgICBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gICAgICBzZXRJbm5lckhUTUwobm9kZSwgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VGV4dENvbnRlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9zZXRUZXh0Q29udGVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEJhc2VkIG9uIHRoZSBlc2NhcGUtaHRtbCBsaWJyYXJ5LCB3aGljaCBpcyB1c2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSBiZWxvdzpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxMyBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0IChjKSAyMDE1IEFuZHJlYXMgTHViYmVcbiAqIENvcHlyaWdodCAoYykgMjAxNSBUaWFuY2hlbmcgXCJUaW1vdGh5XCIgR3VcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogJ1NvZnR3YXJlJyksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG4gKiBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxuICogVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcbiAqIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuXG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlIGZvciBpbnNlcnRpbmcgaW50byBIVE1MXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gJlxuICAgICAgICBlc2NhcGUgPSAnJmFtcDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgLy8gPFxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbi8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGFuZ2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY3JlYXRlTm9kZXNGcm9tTWFya3VwID0gcmVxdWlyZSgnZmJqcy9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIERhbmdlciA9IHtcblxuICAvKipcbiAgICogUmVwbGFjZXMgYSBub2RlIHdpdGggYSBzdHJpbmcgb2YgbWFya3VwIGF0IGl0cyBjdXJyZW50IHBvc2l0aW9uIHdpdGhpbiBpdHNcbiAgICogcGFyZW50LiBUaGUgbWFya3VwIG11c3QgcmVuZGVyIGludG8gYSBzaW5nbGUgcm9vdCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG9sZENoaWxkIENoaWxkIG5vZGUgdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdG8gcmVuZGVyIGluIHBsYWNlIG9mIHRoZSBjaGlsZCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkQ2hpbGQsIG1hcmt1cCkge1xuICAgICFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSB3b3JrZXIgdGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSBnbG9iYWxseSBiZWZvcmUgcmVxdWlyaW5nIFJlYWN0IHdoZW4gdW5pdCB0ZXN0aW5nIG9yIHVzZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogX3Byb2RJbnZhcmlhbnQoJzU2JykgOiB2b2lkIDA7XG4gICAgIW1hcmt1cCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IF9wcm9kSW52YXJpYW50KCc1NycpIDogdm9pZCAwO1xuICAgICEob2xkQ2hpbGQubm9kZU5hbWUgIT09ICdIVE1MJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlcGxhY2UgbWFya3VwIG9mIHRoZSA8aHRtbD4gbm9kZS4gVGhpcyBpcyBiZWNhdXNlIGJyb3dzZXIgcXVpcmtzIG1ha2UgdGhpcyB1bnJlbGlhYmxlIGFuZC9vciBzbG93LiBJZiB5b3Ugd2FudCB0byByZW5kZXIgdG8gdGhlIHJvb3QgeW91IG11c3QgdXNlIHNlcnZlciByZW5kZXJpbmcuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpLicpIDogX3Byb2RJbnZhcmlhbnQoJzU4JykgOiB2b2lkIDA7XG5cbiAgICBpZiAodHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBuZXdDaGlsZCA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGVtcHR5RnVuY3Rpb24pWzBdO1xuICAgICAgb2xkQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIG9sZENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NTGF6eVRyZWUucmVwbGFjZUNoaWxkV2l0aFRyZWUob2xkQ2hpbGQsIG1hcmt1cCk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGFuZ2VyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRGFuZ2VyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIGZiLXd3dy91bnNhZmUtaHRtbCovXG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNyZWF0ZUFycmF5RnJvbU1peGVkID0gcmVxdWlyZSgnLi9jcmVhdGVBcnJheUZyb21NaXhlZCcpO1xudmFyIGdldE1hcmt1cFdyYXAgPSByZXF1aXJlKCcuL2dldE1hcmt1cFdyYXAnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIHJlbmRlciBhbGwgbWFya3VwLlxuICovXG52YXIgZHVtbXlOb2RlID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xuXG4vKipcbiAqIFBhdHRlcm4gdXNlZCBieSBgZ2V0Tm9kZU5hbWVgLlxuICovXG52YXIgbm9kZU5hbWVQYXR0ZXJuID0gL15cXHMqPChcXHcrKS87XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGBub2RlTmFtZWAgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBzdHJpbmcgb2YgbWFya3VwLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IE5vZGUgbmFtZSBvZiB0aGUgc3VwcGxpZWQgbWFya3VwLlxuICovXG5mdW5jdGlvbiBnZXROb2RlTmFtZShtYXJrdXApIHtcbiAgdmFyIG5vZGVOYW1lTWF0Y2ggPSBtYXJrdXAubWF0Y2gobm9kZU5hbWVQYXR0ZXJuKTtcbiAgcmV0dXJuIG5vZGVOYW1lTWF0Y2ggJiYgbm9kZU5hbWVNYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbm9kZXMgcmVuZGVyZWQgZnJvbSB0aGUgc3VwcGxpZWQgbWFya3VwLiBUaGVcbiAqIG9wdGlvbmFsbHkgc3VwcGxpZWQgYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIG9uY2UgZm9yIGVhY2hcbiAqIDxzY3JpcHQ+IGVsZW1lbnQgdGhhdCBpcyByZW5kZXJlZC4gSWYgbm8gYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gaXMgc3VwcGxpZWQsXG4gKiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIGFueSA8c2NyaXB0PiBlbGVtZW50cyBhcmUgcmVuZGVyZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBBIHN0cmluZyBvZiB2YWxpZCBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBoYW5kbGVTY3JpcHQgSW52b2tlZCBvbmNlIGZvciBlYWNoIHJlbmRlcmVkIDxzY3JpcHQ+LlxuICogQHJldHVybiB7YXJyYXk8RE9NRWxlbWVudHxET01UZXh0Tm9kZT59IEFuIGFycmF5IG9mIHJlbmRlcmVkIG5vZGVzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBoYW5kbGVTY3JpcHQpIHtcbiAgdmFyIG5vZGUgPSBkdW1teU5vZGU7XG4gICEhIWR1bW15Tm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgZHVtbXkgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgbm9kZU5hbWUgPSBnZXROb2RlTmFtZShtYXJrdXApO1xuXG4gIHZhciB3cmFwID0gbm9kZU5hbWUgJiYgZ2V0TWFya3VwV3JhcChub2RlTmFtZSk7XG4gIGlmICh3cmFwKSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSB3cmFwWzFdICsgbWFya3VwICsgd3JhcFsyXTtcblxuICAgIHZhciB3cmFwRGVwdGggPSB3cmFwWzBdO1xuICAgIHdoaWxlICh3cmFwRGVwdGgtLSkge1xuICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgfVxuXG4gIHZhciBzY3JpcHRzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gIGlmIChzY3JpcHRzLmxlbmd0aCkge1xuICAgICFoYW5kbGVTY3JpcHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwKC4uLik6IFVuZXhwZWN0ZWQgPHNjcmlwdD4gZWxlbWVudCByZW5kZXJlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY3JlYXRlQXJyYXlGcm9tTWl4ZWQoc2NyaXB0cykuZm9yRWFjaChoYW5kbGVTY3JpcHQpO1xuICB9XG5cbiAgdmFyIG5vZGVzID0gQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpO1xuICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIGFycmF5cy5cbiAqXG4gKiBUaGlzIEFQSSBhc3N1bWVzIHRoZSBjYWxsZXIga25vd3MgdGhlIGNvbnRlbnRzIG9mIHRoZSBkYXRhIHR5cGUuIEZvciBsZXNzXG4gKiB3ZWxsIGRlZmluZWQgaW5wdXRzIHVzZSBjcmVhdGVBcnJheUZyb21NaXhlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbnxmaWxlbGlzdH0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cbiAgLy8gU29tZSBicm93c2VycyBidWlsdGluIG9iamVjdHMgY2FuIHJlcG9ydCB0eXBlb2YgJ2Z1bmN0aW9uJyAoZS5nLiBOb2RlTGlzdFxuICAvLyBpbiBvbGQgdmVyc2lvbnMgb2YgU2FmYXJpKS5cbiAgISghQXJyYXkuaXNBcnJheShvYmopICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogQXJyYXktbGlrZSBvYmplY3QgZXhwZWN0ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgISh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IG5lZWRzIGEgbGVuZ3RoIHByb3BlcnR5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEobGVuZ3RoID09PSAwIHx8IGxlbmd0aCAtIDEgaW4gb2JqKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3Qgc2hvdWxkIGhhdmUga2V5cyBmb3IgaW5kaWNlcycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKHR5cGVvZiBvYmouY2FsbGVlICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3QgY2FuXFwndCBiZSBgYXJndW1lbnRzYC4gVXNlIHJlc3QgcGFyYW1zICcgKyAnKGZ1bmN0aW9uKC4uLmFyZ3MpIHt9KSBvciBBcnJheS5mcm9tKCkgaW5zdGVhZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgLy8gT2xkIElFIGRvZXNuJ3QgZ2l2ZSBjb2xsZWN0aW9ucyBhY2Nlc3MgdG8gaGFzT3duUHJvcGVydHkuIEFzc3VtZSBpbnB1dHNcbiAgLy8gd2l0aG91dCBtZXRob2Qgd2lsbCB0aHJvdyBkdXJpbmcgdGhlIHNsaWNlIGNhbGwgYW5kIHNraXAgc3RyYWlnaHQgdG8gdGhlXG4gIC8vIGZhbGxiYWNrLlxuICBpZiAob2JqLmhhc093blByb3BlcnR5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFIDwgOSBkb2VzIG5vdCBzdXBwb3J0IEFycmF5I3NsaWNlIG9uIGNvbGxlY3Rpb25zIG9iamVjdHNcbiAgICB9XG4gIH1cblxuICAvLyBGYWxsIGJhY2sgdG8gY29weWluZyBrZXkgYnkga2V5LiBUaGlzIGFzc3VtZXMgYWxsIGtleXMgaGF2ZSBhIHZhbHVlLFxuICAvLyBzbyB3aWxsIG5vdCBwcmVzZXJ2ZSBzcGFyc2VseSBwb3B1bGF0ZWQgaW5wdXRzLlxuICB2YXIgcmV0ID0gQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbmd0aDsgaWkrKykge1xuICAgIHJldFtpaV0gPSBvYmpbaWldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybSBhIGhldXJpc3RpYyB0ZXN0IHRvIGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgXCJhcnJheS1saWtlXCIuXG4gKlxuICogICBBIG1vbmsgYXNrZWQgSm9zaHUsIGEgWmVuIG1hc3RlciwgXCJIYXMgYSBkb2cgQnVkZGhhIG5hdHVyZT9cIlxuICogICBKb3NodSByZXBsaWVkOiBcIk11LlwiXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIGlmIGl0cyBhcmd1bWVudCBoYXMgXCJhcnJheSBuYXR1cmVcIjogaXQgcmV0dXJuc1xuICogdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYWN0dWFsIGFycmF5LCBhbiBgYXJndW1lbnRzJyBvYmplY3QsIG9yIGFuXG4gKiBIVE1MQ29sbGVjdGlvbiAoZS5nLiBub2RlLmNoaWxkTm9kZXMgb3Igbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgpKS5cbiAqXG4gKiBJdCB3aWxsIHJldHVybiBmYWxzZSBmb3Igb3RoZXIgYXJyYXktbGlrZSBvYmplY3RzIGxpa2UgRmlsZWxpc3QuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc0FycmF5TmF0dXJlKG9iaikge1xuICByZXR1cm4gKFxuICAgIC8vIG5vdCBudWxsL2ZhbHNlXG4gICAgISFvYmogJiYgKFxuICAgIC8vIGFycmF5cyBhcmUgb2JqZWN0cywgTm9kZUxpc3RzIGFyZSBmdW5jdGlvbnMgaW4gU2FmYXJpXG4gICAgdHlwZW9mIG9iaiA9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicpICYmXG4gICAgLy8gcXVhY2tzIGxpa2UgYW4gYXJyYXlcbiAgICAnbGVuZ3RoJyBpbiBvYmogJiZcbiAgICAvLyBub3Qgd2luZG93XG4gICAgISgnc2V0SW50ZXJ2YWwnIGluIG9iaikgJiZcbiAgICAvLyBubyBET00gbm9kZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhbiBhcnJheS1saWtlXG4gICAgLy8gYSAnc2VsZWN0JyBlbGVtZW50IGhhcyAnbGVuZ3RoJyBhbmQgJ2l0ZW0nIHByb3BlcnRpZXMgb24gSUU4XG4gICAgdHlwZW9mIG9iai5ub2RlVHlwZSAhPSAnbnVtYmVyJyAmJiAoXG4gICAgLy8gYSByZWFsIGFycmF5XG4gICAgQXJyYXkuaXNBcnJheShvYmopIHx8XG4gICAgLy8gYXJndW1lbnRzXG4gICAgJ2NhbGxlZScgaW4gb2JqIHx8XG4gICAgLy8gSFRNTENvbGxlY3Rpb24vTm9kZUxpc3RcbiAgICAnaXRlbScgaW4gb2JqKVxuICApO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBieSB3cmFwcGluZyBpdCBpbiBhbiBhcnJheSBpZiBpdCBpcyBub3QuXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgYXJndW1lbnQgaWYgaXQgaXMgYWxyZWFkeSBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgaWRpb21hdGljYWxseTpcbiAqXG4gKiAgIHZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJ2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG4gKlxuICogICBmdW5jdGlvbiB0YWtlc09uZU9yTW9yZVRoaW5ncyh0aGluZ3MpIHtcbiAqICAgICB0aGluZ3MgPSBjcmVhdGVBcnJheUZyb21NaXhlZCh0aGluZ3MpO1xuICogICAgIC4uLlxuICogICB9XG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyZWF0IGB0aGluZ3MnIGFzIGFuIGFycmF5LCBidXQgYWNjZXB0IHNjYWxhcnMgaW4gdGhlIEFQSS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBsaWtlIGBhcmd1bWVudHNgLCBpbnRvIGFuIGFycmF5XG4gKiB1c2UgdG9BcnJheSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWl4ZWQob2JqKSB7XG4gIGlmICghaGFzQXJyYXlOYXR1cmUob2JqKSkge1xuICAgIHJldHVybiBbb2JqXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvQXJyYXkob2JqKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIGZiLXd3dy91bnNhZmUtaHRtbCAqL1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIGRldGVjdCB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5LlxuICovXG52YXIgZHVtbXlOb2RlID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xuXG4vKipcbiAqIFNvbWUgYnJvd3NlcnMgY2Fubm90IHVzZSBgaW5uZXJIVE1MYCB0byByZW5kZXIgY2VydGFpbiBlbGVtZW50cyBzdGFuZGFsb25lLFxuICogc28gd2Ugd3JhcCB0aGVtLCByZW5kZXIgdGhlIHdyYXBwZWQgbm9kZXMsIHRoZW4gZXh0cmFjdCB0aGUgZGVzaXJlZCBub2RlLlxuICpcbiAqIEluIElFOCwgY2VydGFpbiBlbGVtZW50cyBjYW5ub3QgcmVuZGVyIGFsb25lLCBzbyB3cmFwIGFsbCBlbGVtZW50cyAoJyonKS5cbiAqL1xuXG52YXIgc2hvdWxkV3JhcCA9IHt9O1xuXG52YXIgc2VsZWN0V3JhcCA9IFsxLCAnPHNlbGVjdCBtdWx0aXBsZT1cInRydWVcIj4nLCAnPC9zZWxlY3Q+J107XG52YXIgdGFibGVXcmFwID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG52YXIgdHJXcmFwID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbnZhciBzdmdXcmFwID0gWzEsICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj4nLCAnPC9zdmc+J107XG5cbnZhciBtYXJrdXBXcmFwID0ge1xuICAnKic6IFsxLCAnPzxkaXY+JywgJzwvZGl2PiddLFxuXG4gICdhcmVhJzogWzEsICc8bWFwPicsICc8L21hcD4nXSxcbiAgJ2NvbCc6IFsyLCAnPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4nLCAnPC9jb2xncm91cD48L3RhYmxlPiddLFxuICAnbGVnZW5kJzogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gICdwYXJhbSc6IFsxLCAnPG9iamVjdD4nLCAnPC9vYmplY3Q+J10sXG4gICd0cic6IFsyLCAnPHRhYmxlPjx0Ym9keT4nLCAnPC90Ym9keT48L3RhYmxlPiddLFxuXG4gICdvcHRncm91cCc6IHNlbGVjdFdyYXAsXG4gICdvcHRpb24nOiBzZWxlY3RXcmFwLFxuXG4gICdjYXB0aW9uJzogdGFibGVXcmFwLFxuICAnY29sZ3JvdXAnOiB0YWJsZVdyYXAsXG4gICd0Ym9keSc6IHRhYmxlV3JhcCxcbiAgJ3Rmb290JzogdGFibGVXcmFwLFxuICAndGhlYWQnOiB0YWJsZVdyYXAsXG5cbiAgJ3RkJzogdHJXcmFwLFxuICAndGgnOiB0cldyYXBcbn07XG5cbi8vIEluaXRpYWxpemUgdGhlIFNWRyBlbGVtZW50cyBzaW5jZSB3ZSBrbm93IHRoZXknbGwgYWx3YXlzIG5lZWQgdG8gYmUgd3JhcHBlZFxuLy8gY29uc2lzdGVudGx5LiBJZiB0aGV5IGFyZSBjcmVhdGVkIGluc2lkZSBhIDxkaXY+IHRoZXkgd2lsbCBiZSBpbml0aWFsaXplZCBpblxuLy8gdGhlIHdyb25nIG5hbWVzcGFjZSAoYW5kIHdpbGwgbm90IGRpc3BsYXkpLlxudmFyIHN2Z0VsZW1lbnRzID0gWydjaXJjbGUnLCAnY2xpcFBhdGgnLCAnZGVmcycsICdlbGxpcHNlJywgJ2cnLCAnaW1hZ2UnLCAnbGluZScsICdsaW5lYXJHcmFkaWVudCcsICdtYXNrJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbEdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICd0ZXh0JywgJ3RzcGFuJ107XG5zdmdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlTmFtZSkge1xuICBtYXJrdXBXcmFwW25vZGVOYW1lXSA9IHN2Z1dyYXA7XG4gIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gdHJ1ZTtcbn0pO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBwbGllZCBgbm9kZU5hbWVgLlxuICpcbiAqIE5PVEU6IFRoaXMgbGF6aWx5IGRldGVjdHMgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeSBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgTG93ZXJjYXNlIGBub2RlTmFtZWAuXG4gKiBAcmV0dXJuIHs/YXJyYXl9IE1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24sIGlmIGFwcGxpY2FibGUuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpIHtcbiAgISEhZHVtbXlOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01hcmt1cCB3cmFwcGluZyBub2RlIG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgaWYgKCFtYXJrdXBXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIG5vZGVOYW1lID0gJyonO1xuICB9XG4gIGlmICghc2hvdWxkV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBpZiAobm9kZU5hbWUgPT09ICcqJykge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8bGluayAvPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPCcgKyBub2RlTmFtZSArICc+PC8nICsgbm9kZU5hbWUgKyAnPic7XG4gICAgfVxuICAgIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gIWR1bW15Tm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBzaG91bGRXcmFwW25vZGVOYW1lXSA/IG1hcmt1cFdyYXBbbm9kZU5hbWVdIDogbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXJrdXBXcmFwO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9nZXRNYXJrdXBXcmFwLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbi8qKlxuICogV2hlbiBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGFyZSB1cGRhdGVkLCBhIHNlcmllcyBvZiB1cGRhdGUgY29uZmlndXJhdGlvblxuICogb2JqZWN0cyBhcmUgY3JlYXRlZCBpbiBvcmRlciB0byBiYXRjaCBhbmQgc2VyaWFsaXplIHRoZSByZXF1aXJlZCBjaGFuZ2VzLlxuICpcbiAqIEVudW1lcmF0ZXMgYWxsIHRoZSBwb3NzaWJsZSB0eXBlcyBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IGtleU1pcnJvcih7XG4gIElOU0VSVF9NQVJLVVA6IG51bGwsXG4gIE1PVkVfRVhJU1RJTkc6IG51bGwsXG4gIFJFTU9WRV9OT0RFOiBudWxsLFxuICBTRVRfTUFSS1VQOiBudWxsLFxuICBURVhUX0NPTlRFTlQ6IG51bGxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01JRE9wZXJhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbi8qKlxuICogT3BlcmF0aW9ucyB1c2VkIHRvIHByb2Nlc3MgdXBkYXRlcyB0byBET00gbm9kZXMuXG4gKi9cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogZnVuY3Rpb24gKHBhcmVudEluc3QsIHVwZGF0ZXMpIHtcbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHBhcmVudEluc3QpO1xuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5wcm9jZXNzVXBkYXRlcyhub2RlLCB1cGRhdGVzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlET3BlcmF0aW9ucztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NSURPcGVyYXRpb25zLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NQ29tcG9uZW50XG4gKi9cblxuLyogZ2xvYmFsIGhhc093blByb3BlcnR5OnRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBBdXRvRm9jdXNVdGlscyA9IHJlcXVpcmUoJy4vQXV0b0ZvY3VzVXRpbHMnKTtcbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0RE9NQnV0dG9uID0gcmVxdWlyZSgnLi9SZWFjdERPTUJ1dHRvbicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NSW5wdXQgPSByZXF1aXJlKCcuL1JlYWN0RE9NSW5wdXQnKTtcbnZhciBSZWFjdERPTU9wdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01PcHRpb24nKTtcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3QnKTtcbnZhciBSZWFjdERPTVRleHRhcmVhID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRhcmVhJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGQnKTtcbnZhciBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBGbGFncyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XG52YXIgZGVsZXRlTGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5kZWxldGVMaXN0ZW5lcjtcbnZhciBnZXROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2U7XG52YXIgbGlzdGVuVG8gPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIubGlzdGVuVG87XG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuXG4vLyBGb3IgcXVpY2tseSBtYXRjaGluZyBjaGlsZHJlbiB0eXBlLCB0byB0ZXN0IGlmIGNhbiBiZSB0cmVhdGVkIGFzIGNvbnRlbnQuXG52YXIgQ09OVEVOVF9UWVBFUyA9IHsgJ3N0cmluZyc6IHRydWUsICdudW1iZXInOiB0cnVlIH07XG5cbnZhciBTVFlMRSA9IGtleU9mKHsgc3R5bGU6IG51bGwgfSk7XG52YXIgSFRNTCA9IGtleU9mKHsgX19odG1sOiBudWxsIH0pO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IG51bGwsXG4gIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogbnVsbFxufTtcblxuLy8gTm9kZSB0eXBlIGZvciBkb2N1bWVudCBmcmFnbWVudHMgKE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkuXG52YXIgRE9DX0ZSQUdNRU5UX1RZUEUgPSAxMTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGludGVybmFsSW5zdGFuY2UpIHtcbiAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICB2YXIgb3duZXIgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcgVGhpcyBET00gbm9kZSB3YXMgcmVuZGVyZWQgYnkgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBmcmllbmRseVN0cmluZ2lmeShvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuICdbJyArIG9iai5tYXAoZnJpZW5kbHlTdHJpbmdpZnkpLmpvaW4oJywgJykgKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYWlycyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIHZhciBrZXlFc2NhcGVkID0gL15bYS16JF9dW1xcdyRfXSokL2kudGVzdChrZXkpID8ga2V5IDogSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgICAgICBwYWlycy5wdXNoKGtleUVzY2FwZWQgKyAnOiAnICsgZnJpZW5kbHlTdHJpbmdpZnkob2JqW2tleV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICd7JyArIHBhaXJzLmpvaW4oJywgJykgKyAnfSc7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAnW2Z1bmN0aW9uIG9iamVjdF0nO1xuICB9XG4gIC8vIERpZmZlcnMgZnJvbSBKU09OLnN0cmluZ2lmeSBpbiB0aGF0IHVuZGVmaW5lZCBiZWNhdXNlIHVuZGVmaW5lZCBhbmQgdGhhdFxuICAvLyBpbmYgYW5kIG5hbiBkb24ndCBiZWNvbWUgbnVsbFxuICByZXR1cm4gU3RyaW5nKG9iaik7XG59XG5cbnZhciBzdHlsZU11dGF0aW9uV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUoc3R5bGUxLCBzdHlsZTIsIGNvbXBvbmVudCkge1xuICBpZiAoc3R5bGUxID09IG51bGwgfHwgc3R5bGUyID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNoYWxsb3dFcXVhbChzdHlsZTEsIHN0eWxlMikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5fdGFnO1xuICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgdmFyIG93bmVyTmFtZTtcbiAgaWYgKG93bmVyKSB7XG4gICAgb3duZXJOYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICB9XG5cbiAgdmFyIGhhc2ggPSBvd25lck5hbWUgKyAnfCcgKyBjb21wb25lbnROYW1lO1xuXG4gIGlmIChzdHlsZU11dGF0aW9uV2FybmluZy5oYXNPd25Qcm9wZXJ0eShoYXNoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0eWxlTXV0YXRpb25XYXJuaW5nW2hhc2hdID0gdHJ1ZTtcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2Alc2Agd2FzIHBhc3NlZCBhIHN0eWxlIG9iamVjdCB0aGF0IGhhcyBwcmV2aW91c2x5IGJlZW4gbXV0YXRlZC4gJyArICdNdXRhdGluZyBgc3R5bGVgIGlzIGRlcHJlY2F0ZWQuIENvbnNpZGVyIGNsb25pbmcgaXQgYmVmb3JlaGFuZC4gQ2hlY2sgJyArICd0aGUgYHJlbmRlcmAgJXMuIFByZXZpb3VzIHN0eWxlOiAlcy4gTXV0YXRlZCBzdHlsZTogJXMuJywgY29tcG9uZW50TmFtZSwgb3duZXIgPyAnb2YgYCcgKyBvd25lck5hbWUgKyAnYCcgOiAndXNpbmcgPCcgKyBjb21wb25lbnROYW1lICsgJz4nLCBmcmllbmRseVN0cmluZ2lmeShzdHlsZTEpLCBmcmllbmRseVN0cmluZ2lmeShzdHlsZTIpKSA6IHZvaWQgMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IHByb3BzXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHMoY29tcG9uZW50LCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbY29tcG9uZW50Ll90YWddKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJXMnLCBjb21wb25lbnQuX3RhZywgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIgPyAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICcgKyBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLicgOiAnJykgOiBfcHJvZEludmFyaWFudCgnMTM3JywgY29tcG9uZW50Ll90YWcsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyID8gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAnICsgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nIDogJycpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IF9wcm9kSW52YXJpYW50KCc2MCcpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhcmlhbnQtZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiBfcHJvZEludmFyaWFudCgnNjEnKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLmlubmVySFRNTCA9PSBudWxsLCAnRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyB8fCAhcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJykgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMub25Gb2N1c0luID09IG51bGwgJiYgcHJvcHMub25Gb2N1c091dCA9PSBudWxsLCAnUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgKyAnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnICsgJ2FyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgfVxuICAhKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuIHVzaW5nIEpTWC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IF9wcm9kSW52YXJpYW50KCc2MicsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVB1dExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyLCB0cmFuc2FjdGlvbikge1xuICBpZiAodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gSUU4IGhhcyBubyBBUEkgZm9yIGV2ZW50IGNhcHR1cmluZyBhbmQgdGhlIGBvblNjcm9sbGAgZXZlbnQgZG9lc24ndFxuICAgIC8vIGJ1YmJsZS5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhyZWdpc3RyYXRpb25OYW1lICE9PSAnb25TY3JvbGwnIHx8IGlzRXZlbnRTdXBwb3J0ZWQoJ3Njcm9sbCcsIHRydWUpLCAnVGhpcyBicm93c2VyIGRvZXNuXFwndCBzdXBwb3J0IHRoZSBgb25TY3JvbGxgIGV2ZW50JykgOiB2b2lkIDA7XG4gIH1cbiAgdmFyIGNvbnRhaW5lckluZm8gPSBpbnN0Ll9ob3N0Q29udGFpbmVySW5mbztcbiAgdmFyIGlzRG9jdW1lbnRGcmFnbWVudCA9IGNvbnRhaW5lckluZm8uX25vZGUgJiYgY29udGFpbmVySW5mby5fbm9kZS5ub2RlVHlwZSA9PT0gRE9DX0ZSQUdNRU5UX1RZUEU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50RnJhZ21lbnQgPyBjb250YWluZXJJbmZvLl9ub2RlIDogY29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbiAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwdXRMaXN0ZW5lciwge1xuICAgIGluc3Q6IGluc3QsXG4gICAgcmVnaXN0cmF0aW9uTmFtZTogcmVnaXN0cmF0aW9uTmFtZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHB1dExpc3RlbmVyKCkge1xuICB2YXIgbGlzdGVuZXJUb1B1dCA9IHRoaXM7XG4gIEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyKGxpc3RlbmVyVG9QdXQuaW5zdCwgbGlzdGVuZXJUb1B1dC5yZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lclRvUHV0Lmxpc3RlbmVyKTtcbn1cblxuZnVuY3Rpb24gaW5wdXRQb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01JbnB1dC5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xufVxuXG5mdW5jdGlvbiB0ZXh0YXJlYVBvc3RNb3VudCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICBSZWFjdERPTVRleHRhcmVhLnBvc3RNb3VudFdyYXBwZXIoaW5zdCk7XG59XG5cbmZ1bmN0aW9uIG9wdGlvblBvc3RNb3VudCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICBSZWFjdERPTU9wdGlvbi5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xufVxuXG52YXIgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uID0gZW1wdHlGdW5jdGlvbjtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbiA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgdmFyIGhhc0V4aXN0aW5nQ29udGVudCA9IHRoaXMuX2NvbnRlbnREZWJ1Z0lEICE9IG51bGw7XG4gICAgdmFyIGRlYnVnSUQgPSB0aGlzLl9kZWJ1Z0lEO1xuICAgIC8vIFRoaXMgSUQgcmVwcmVzZW50cyB0aGUgaW5saW5lZCBjaGlsZCB0aGF0IGhhcyBubyBiYWNraW5nIGluc3RhbmNlOlxuICAgIHZhciBjb250ZW50RGVidWdJRCA9IC1kZWJ1Z0lEO1xuXG4gICAgaWYgKGNvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgaWYgKGhhc0V4aXN0aW5nQ29udGVudCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Vbm1vdW50Q29tcG9uZW50KHRoaXMuX2NvbnRlbnREZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbnRlbnREZWJ1Z0lEID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jb250ZW50RGVidWdJRCA9IGNvbnRlbnREZWJ1Z0lEO1xuICAgIGlmIChoYXNFeGlzdGluZ0NvbnRlbnQpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChjb250ZW50RGVidWdJRCwgY29udGVudCk7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25VcGRhdGVDb21wb25lbnQoY29udGVudERlYnVnSUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVNb3VudENvbXBvbmVudChjb250ZW50RGVidWdJRCwgY29udGVudCwgZGVidWdJRCk7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Nb3VudENvbXBvbmVudChjb250ZW50RGVidWdJRCk7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBbY29udGVudERlYnVnSURdKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIFRoZXJlIGFyZSBzbyBtYW55IG1lZGlhIGV2ZW50cywgaXQgbWFrZXMgc2Vuc2UgdG8ganVzdFxuLy8gbWFpbnRhaW4gYSBsaXN0IHJhdGhlciB0aGFuIGNyZWF0ZSBhIGB0cmFwQnViYmxlZEV2ZW50YCBmb3IgZWFjaFxudmFyIG1lZGlhRXZlbnRzID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnXG59O1xuXG5mdW5jdGlvbiB0cmFwQnViYmxlZEV2ZW50c0xvY2FsKCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIC8vIElmIGEgY29tcG9uZW50IHJlbmRlcnMgdG8gbnVsbCBvciBpZiBhbm90aGVyIGNvbXBvbmVudCBmYXRhbHMgYW5kIGNhdXNlc1xuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHRyZWUgdG8gYmUgY29ycnVwdGVkLCBgbm9kZWAgaGVyZSBjYW4gYmUgbnVsbC5cbiAgIWluc3QuX3Jvb3ROb2RlSUQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBiZSBtb3VudGVkIHRvIHRyYXAgZXZlbnRzJykgOiBfcHJvZEludmFyaWFudCgnNjMnKSA6IHZvaWQgMDtcbiAgdmFyIG5vZGUgPSBnZXROb2RlKGluc3QpO1xuICAhbm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmFwQnViYmxlZEV2ZW50KC4uLik6IFJlcXVpcmVzIG5vZGUgdG8gYmUgcmVuZGVyZWQuJykgOiBfcHJvZEludmFyaWFudCgnNjQnKSA6IHZvaWQgMDtcblxuICBzd2l0Y2ggKGluc3QuX3RhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BMb2FkLCAnbG9hZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG5cbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgIC8vIENyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgZm9yICh2YXIgZXZlbnQgaW4gbWVkaWFFdmVudHMpIHtcbiAgICAgICAgaWYgKG1lZGlhRXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMucHVzaChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzW2V2ZW50XSwgbWVkaWFFdmVudHNbZXZlbnRdLCBub2RlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wRXJyb3IsICdlcnJvcicsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wRXJyb3IsICdlcnJvcicsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcExvYWQsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wUmVzZXQsICdyZXNldCcsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdCwgJ3N1Ym1pdCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BJbnZhbGlkLCAnaW52YWxpZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyKCkge1xuICBSZWFjdERPTVNlbGVjdC5wb3N0VXBkYXRlV3JhcHBlcih0aGlzKTtcbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gICdhcmVhJzogdHJ1ZSxcbiAgJ2Jhc2UnOiB0cnVlLFxuICAnYnInOiB0cnVlLFxuICAnY29sJzogdHJ1ZSxcbiAgJ2VtYmVkJzogdHJ1ZSxcbiAgJ2hyJzogdHJ1ZSxcbiAgJ2ltZyc6IHRydWUsXG4gICdpbnB1dCc6IHRydWUsXG4gICdrZXlnZW4nOiB0cnVlLFxuICAnbGluayc6IHRydWUsXG4gICdtZXRhJzogdHJ1ZSxcbiAgJ3BhcmFtJzogdHJ1ZSxcbiAgJ3NvdXJjZSc6IHRydWUsXG4gICd0cmFjayc6IHRydWUsXG4gICd3YnInOiB0cnVlXG59O1xuXG4vLyBOT1RFOiBtZW51aXRlbSdzIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IHRoYXQgY2F1c2VzIHByb2JsZW1zLlxudmFyIG5ld2xpbmVFYXRpbmdUYWdzID0ge1xuICAnbGlzdGluZyc6IHRydWUsXG4gICdwcmUnOiB0cnVlLFxuICAndGV4dGFyZWEnOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgJ21lbnVpdGVtJzogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbi8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSB7fTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZFRhZ0NhY2hlLCB0YWcpKSB7XG4gICAgIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCB0YWc6ICVzJywgdGFnKSA6IF9wcm9kSW52YXJpYW50KCc2NScsIHRhZykgOiB2b2lkIDA7XG4gICAgdmFsaWRhdGVkVGFnQ2FjaGVbdGFnXSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgcmV0dXJuIHRhZ05hbWUuaW5kZXhPZignLScpID49IDAgfHwgcHJvcHMuaXMgIT0gbnVsbDtcbn1cblxudmFyIGdsb2JhbElkQ291bnRlciA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBSZWFjdCBjbGFzcyB0aGF0IGlzIGlkZW1wb3RlbnQgYW5kIGNhcGFibGUgb2YgY29udGFpbmluZyBvdGhlclxuICogUmVhY3QgY29tcG9uZW50cy4gSXQgYWNjZXB0cyBldmVudCBsaXN0ZW5lcnMgYW5kIERPTSBwcm9wZXJ0aWVzIHRoYXQgYXJlXG4gKiB2YWxpZCBhY2NvcmRpbmcgdG8gYERPTVByb3BlcnR5YC5cbiAqXG4gKiAgLSBFdmVudCBsaXN0ZW5lcnM6IGBvbkNsaWNrYCwgYG9uTW91c2VEb3duYCwgZXRjLlxuICogIC0gRE9NIHByb3BlcnRpZXM6IGBjbGFzc05hbWVgLCBgbmFtZWAsIGB0aXRsZWAsIGV0Yy5cbiAqXG4gKiBUaGUgYHN0eWxlYCBwcm9wZXJ0eSBmdW5jdGlvbnMgZGlmZmVyZW50bHkgZnJvbSB0aGUgRE9NIEFQSS4gSXQgYWNjZXB0cyBhblxuICogb2JqZWN0IG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yIFJlYWN0RE9NQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdE11bHRpQ2hpbGRcbiAqL1xuZnVuY3Rpb24gUmVhY3RET01Db21wb25lbnQoZWxlbWVudCkge1xuICB2YXIgdGFnID0gZWxlbWVudC50eXBlO1xuICB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpO1xuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuX3RhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICB0aGlzLl9uYW1lc3BhY2VVUkkgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgdGhpcy5faG9zdE5vZGUgPSBudWxsO1xuICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcbiAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gIHRoaXMuX2RvbUlEID0gMDtcbiAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuICB0aGlzLl9mbGFncyA9IDA7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdGhpcy5fYW5jZXN0b3JJbmZvID0gbnVsbDtcbiAgICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBudWxsKTtcbiAgfVxufVxuXG5SZWFjdERPTUNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdSZWFjdERPTUNvbXBvbmVudCc7XG5cblJlYWN0RE9NQ29tcG9uZW50Lk1peGluID0ge1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcm9vdCB0YWcgbWFya3VwIHRoZW4gcmVjdXJzZXMuIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYW5kXG4gICAqIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P1JlYWN0RE9NQ29tcG9uZW50fSB0aGUgcGFyZW50IGNvbXBvbmVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IGluZm8gYWJvdXQgdGhlIGhvc3QgY29udGFpbmVyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXB1dGVkIG1hcmt1cC5cbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IGdsb2JhbElkQ291bnRlcisrO1xuICAgIHRoaXMuX2RvbUlEID0gaG9zdENvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnbGluayc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgdGhpcy5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgICAgIGxpc3RlbmVyczogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHByb3BzID0gUmVhY3RET01CdXR0b24uZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIFJlYWN0RE9NSW5wdXQubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgUmVhY3RET01PcHRpb24ubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIFJlYWN0RE9NU2VsZWN0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGFzc2VydFZhbGlkUHJvcHModGhpcywgcHJvcHMpO1xuXG4gICAgLy8gV2UgY3JlYXRlIHRhZ3MgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGVpciBwYXJlbnQgY29udGFpbmVyLCBleGNlcHQgSFRNTFxuICAgIC8vIHRhZ3MgZ2V0IG5vIG5hbWVzcGFjZS5cbiAgICB2YXIgbmFtZXNwYWNlVVJJO1xuICAgIHZhciBwYXJlbnRUYWc7XG4gICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgbmFtZXNwYWNlVVJJID0gaG9zdFBhcmVudC5fbmFtZXNwYWNlVVJJO1xuICAgICAgcGFyZW50VGFnID0gaG9zdFBhcmVudC5fdGFnO1xuICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8uX3RhZykge1xuICAgICAgbmFtZXNwYWNlVVJJID0gaG9zdENvbnRhaW5lckluZm8uX25hbWVzcGFjZVVSSTtcbiAgICAgIHBhcmVudFRhZyA9IGhvc3RDb250YWluZXJJbmZvLl90YWc7XG4gICAgfVxuICAgIGlmIChuYW1lc3BhY2VVUkkgPT0gbnVsbCB8fCBuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuc3ZnICYmIHBhcmVudFRhZyA9PT0gJ2ZvcmVpZ25vYmplY3QnKSB7XG4gICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLmh0bWw7XG4gICAgfVxuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkge1xuICAgICAgaWYgKHRoaXMuX3RhZyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5zdmc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3RhZyA9PT0gJ21hdGgnKSB7XG4gICAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMubWF0aG1sO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9uYW1lc3BhY2VVUkkgPSBuYW1lc3BhY2VVUkk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBhcmVudEluZm87XG4gICAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0UGFyZW50Ll9hbmNlc3RvckluZm87XG4gICAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvLl90YWcpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RDb250YWluZXJJbmZvLl9hbmNlc3RvckluZm87XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50SW5mbykge1xuICAgICAgICAvLyBwYXJlbnRJbmZvIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCBleGNlcHQgZm9yIHRoZSB0b3AtbGV2ZWxcbiAgICAgICAgLy8gY29tcG9uZW50IHdoZW4gc2VydmVyIHJlbmRlcmluZ1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodGhpcy5fdGFnLCB0aGlzLCBwYXJlbnRJbmZvKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FuY2VzdG9ySW5mbyA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEluZm8sIHRoaXMuX3RhZywgdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIG1vdW50SW1hZ2U7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gaG9zdENvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgZWw7XG4gICAgICBpZiAobmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhZyA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAgICAgLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcbiAgICAgICAgICB2YXIgZGl2ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICAgICAgZGl2LmlubmVySFRNTCA9ICc8JyArIHR5cGUgKyAnPjwvJyArIHR5cGUgKyAnPic7XG4gICAgICAgICAgZWwgPSBkaXYucmVtb3ZlQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLmlzKSB7XG4gICAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSwgcHJvcHMuaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjdWFzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgICAgICAvLyBhbmQgZGlzY3Vzc2lvbiBpbiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjc2MjQwXG4gICAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlKTtcbiAgICAgIH1cbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgZWwpO1xuICAgICAgdGhpcy5fZmxhZ3MgfD0gRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2RlcztcbiAgICAgIGlmICghdGhpcy5faG9zdFBhcmVudCkge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0QXR0cmlidXRlRm9yUm9vdChlbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKG51bGwsIHByb3BzLCB0cmFuc2FjdGlvbik7XG4gICAgICB2YXIgbGF6eVRyZWUgPSBET01MYXp5VHJlZShlbCk7XG4gICAgICB0aGlzLl9jcmVhdGVJbml0aWFsQ2hpbGRyZW4odHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBsYXp5VHJlZSk7XG4gICAgICBtb3VudEltYWdlID0gbGF6eVRyZWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YWdPcGVuID0gdGhpcy5fY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyh0cmFuc2FjdGlvbiwgcHJvcHMpO1xuICAgICAgdmFyIHRhZ0NvbnRlbnQgPSB0aGlzLl9jcmVhdGVDb250ZW50TWFya3VwKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCk7XG4gICAgICBpZiAoIXRhZ0NvbnRlbnQgJiYgb21pdHRlZENsb3NlVGFnc1t0aGlzLl90YWddKSB7XG4gICAgICAgIG1vdW50SW1hZ2UgPSB0YWdPcGVuICsgJy8+JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50SW1hZ2UgPSB0YWdPcGVuICsgJz4nICsgdGFnQ29udGVudCArICc8LycgKyB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlICsgJz4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5wdXRQb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodGV4dGFyZWFQb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKG9wdGlvblBvc3RNb3VudCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBtb3VudEltYWdlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIG9wZW4gdGFnIGFuZCBhbGwgYXR0cmlidXRlcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBiZWNhdXNlIGV2ZW50cyBnZXQgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogSXRlcmF0aW5nIG92ZXIgb2JqZWN0IHByb3BlcnRpZXMgaXMgZmFzdGVyIHRoYW4gaXRlcmF0aW5nIG92ZXIgYXJyYXlzLlxuICAgKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL29iai12cy1hcnItaXRlcmF0aW9uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgb2Ygb3BlbmluZyB0YWcuXG4gICAqL1xuICBfY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVyczogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcykge1xuICAgIHZhciByZXQgPSAnPCcgKyB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlKSB7XG4gICAgICAgICAgZW5xdWV1ZVB1dExpc3RlbmVyKHRoaXMsIHByb3BLZXksIHByb3BWYWx1ZSwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgICBpZiAocHJvcFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAvLyBTZWUgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gc3R5bGUgYmxvY2tcbiAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BWYWx1ZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gX2Fzc2lnbih7fSwgcHJvcHMuc3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9wVmFsdWUgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHByb3BWYWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmt1cCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl90YWcgIT0gbnVsbCAmJiBpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIHByb3BzKSkge1xuICAgICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgICAvLyBieXRlcy5cbiAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9ob3N0UGFyZW50KSB7XG4gICAgICByZXQgKz0gJyAnICsgRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclJvb3QoKTtcbiAgICB9XG4gICAgcmV0ICs9ICcgJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRCh0aGlzLl9kb21JRCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIHRhZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBDb250ZW50IG1hcmt1cC5cbiAgICovXG4gIF9jcmVhdGVDb250ZW50TWFya3VwOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIHJldCA9ICcnO1xuXG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICByZXQgPSBpbm5lckhUTUwuX19odG1sO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRleHQgaXMgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoaXMgbm9kZVxuICAgICAgICByZXQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIoY29udGVudFRvVXNlKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBjb250ZW50VG9Vc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuVG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGRyZW5Ub1VzZSwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICByZXQgPSBtb3VudEltYWdlcy5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld2xpbmVFYXRpbmdUYWdzW3RoaXMuX3RhZ10gJiYgcmV0LmNoYXJBdCgwKSA9PT0gJ1xcbicpIHtcbiAgICAgIC8vIHRleHQvaHRtbCBpZ25vcmVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlc2UgdGFncyBpZiBpdCdzIGEgbmV3bGluZVxuICAgICAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gICAgICAvLyBhIG5ld2xpbmUgc3BlY2lmaWNhbGx5IHRvIGdldCBlYXRlbiBieSB0aGUgcGFyc2VyLiAoQWx0ZXJuYXRlbHkgZm9yXG4gICAgICAvLyB0ZXh0YXJlYXMsIHJlcGxhY2luZyBcIl5cXG5cIiB3aXRoIFwiXFxyXFxuXCIgZG9lc24ndCBnZXQgZWF0ZW4sIGFuZCB0aGUgZmlyc3RcbiAgICAgIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtcG9seWdsb3QvI25ld2xpbmVzLWluLXRleHRhcmVhLWFuZC1wcmU+XG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50LXJlc3RyaWN0aW9ucz5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAgICAgLy8gU2VlOiBQYXJzaW5nIG9mIFwidGV4dGFyZWFcIiBcImxpc3RpbmdcIiBhbmQgXCJwcmVcIiBlbGVtZW50c1xuICAgICAgLy8gIGZyb20gPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHk+XG4gICAgICByZXR1cm4gJ1xcbicgKyByZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LFxuXG4gIF9jcmVhdGVJbml0aWFsQ2hpbGRyZW46IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQsIGxhenlUcmVlKSB7XG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUhUTUwobGF6eVRyZWUsIGlubmVySFRNTC5fX2h0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRleHQgaXMgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoaXMgbm9kZVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIGNvbnRlbnRUb1VzZSk7XG4gICAgICAgIH1cbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVUZXh0KGxhenlUcmVlLCBjb250ZW50VG9Vc2UpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3VudEltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIG1vdW50SW1hZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjZWl2ZXMgYSBuZXh0IGVsZW1lbnQgYW5kIHVwZGF0ZXMgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgRE9NIGNvbXBvbmVudCBhZnRlciBpdCBoYXMgYWxyZWFkeSBiZWVuIGFsbG9jYXRlZCBhbmRcbiAgICogYXR0YWNoZWQgdG8gdGhlIERPTS4gUmVjb25jaWxlcyB0aGUgcm9vdCBET00gbm9kZSwgdGhlbiByZWN1cnNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldkVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdFByb3BzID0gcHJldkVsZW1lbnQucHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NQnV0dG9uLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGFzc2VydFZhbGlkUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbik7XG4gICAgdGhpcy5fdXBkYXRlRE9NQ2hpbGRyZW4obGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAgIC8vIGhhcHBlbiBhZnRlciBgX3VwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgICAgLy8gcmFpc2Ugd2FybmluZ3MgYW5kIHByZXZlbnQgdGhlIG5ldyB2YWx1ZSBmcm9tIGJlaW5nIGFzc2lnbmVkLlxuICAgICAgICBSZWFjdERPTUlucHV0LnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgLy8gPHNlbGVjdD4gdmFsdWUgdXBkYXRlIG5lZWRzIHRvIG9jY3VyIGFmdGVyIDxvcHRpb24+IGNoaWxkcmVuXG4gICAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocG9zdFVwZGF0ZVNlbGVjdFdyYXBwZXIsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIHByb3BlcnRpZXMgYnkgZGV0ZWN0aW5nIGRpZmZlcmVuY2VzIGluIHByb3BlcnR5IHZhbHVlcyBhbmRcbiAgICogdXBkYXRpbmcgdGhlIERPTSBhcyBuZWNlc3NhcnkuIFRoaXMgZnVuY3Rpb24gaXMgcHJvYmFibHkgdGhlIHNpbmdsZSBtb3N0XG4gICAqIGNyaXRpY2FsIHBhdGggZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAgICpcbiAgICogVE9ETzogQmVuY2htYXJrIHdoZXRoZXIgY2hlY2tpbmcgZm9yIGNoYW5nZWQgdmFsdWVzIGluIG1lbW9yeSBhY3R1YWxseVxuICAgKiAgICAgICBpbXByb3ZlcyBwZXJmb3JtYW5jZSAoZXNwZWNpYWxseSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudHMpLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgdGhlIGVmZmVjdHMgb2YgcHV0dGluZyB0aGlzIGF0IHRoZSB0b3Agc2luY2UgOTklIG9mIHByb3BzXG4gICAqICAgICAgIGRvIG5vdCBjaGFuZ2UgZm9yIGEgZ2l2ZW4gcmVjb25jaWxpYXRpb24uXG4gICAqIFRPRE86IEJlbmNobWFyayBhcmVhcyB0aGF0IGNhbiBiZSBpbXByb3ZlZCB3aXRoIGNhY2hpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBfdXBkYXRlRE9NUHJvcGVydGllczogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbikge1xuICAgIHZhciBwcm9wS2V5O1xuICAgIHZhciBzdHlsZU5hbWU7XG4gICAgdmFyIHN0eWxlVXBkYXRlcztcbiAgICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgdmFyIGxhc3RTdHlsZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5O1xuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKGxhc3RQcm9wc1twcm9wS2V5XSkge1xuICAgICAgICAgIC8vIE9ubHkgY2FsbCBkZWxldGVMaXN0ZW5lciBpZiB0aGVyZSB3YXMgYSBsaXN0ZW5lciBwcmV2aW91c2x5IG9yXG4gICAgICAgICAgLy8gZWxzZSB3aWxsRGVsZXRlTGlzdGVuZXIgZ2V0cyBjYWxsZWQgd2hlbiB0aGVyZSB3YXNuJ3QgYWN0dWFsbHkgYVxuICAgICAgICAgIC8vIGxpc3RlbmVyIChlLmcuLCBvbkNsaWNrPXtudWxsfSlcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIGxhc3RQcm9wcykpIHtcbiAgICAgICAgaWYgKCFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvckF0dHJpYnV0ZShnZXROb2RlKHRoaXMpLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KGdldE5vZGUodGhpcyksIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHByb3BLZXkgaW4gbmV4dFByb3BzKSB7XG4gICAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgICB2YXIgbGFzdFByb3AgPSBwcm9wS2V5ID09PSBTVFlMRSA/IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5IDogbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUodGhpcy5fcHJldmlvdXNTdHlsZUNvcHksIHRoaXMuX3ByZXZpb3VzU3R5bGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IG5leHRQcm9wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0UHJvcCA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gX2Fzc2lnbih7fSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICAgIGlmIChsYXN0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmICghbmV4dFByb3AgfHwgIW5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgICAgaWYgKG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgbGFzdFByb3Bbc3R5bGVOYW1lXSAhPT0gbmV4dFByb3Bbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgICAgc3R5bGVVcGRhdGVzID0gbmV4dFByb3A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgZW5xdWV1ZVB1dExpc3RlbmVyKHRoaXMsIHByb3BLZXksIG5leHRQcm9wLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIG5leHRQcm9wcykpIHtcbiAgICAgICAgaWYgKCFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShnZXROb2RlKHRoaXMpLCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wS2V5XSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICB2YXIgbm9kZSA9IGdldE5vZGUodGhpcyk7XG4gICAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHlsZVVwZGF0ZXMpIHtcbiAgICAgIENTU1Byb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclN0eWxlcyhnZXROb2RlKHRoaXMpLCBzdHlsZVVwZGF0ZXMsIHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IHRoZVxuICAgKiBjaGlsZHJlbiBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgX3VwZGF0ZURPTUNoaWxkcmVuOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbGFzdFByb3BzLmNoaWxkcmVuXSA/IGxhc3RQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgdmFyIG5leHRDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbmV4dFByb3BzLmNoaWxkcmVuXSA/IG5leHRQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG5cbiAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcbiAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcblxuICAgIC8vIE5vdGUgdGhlIHVzZSBvZiBgIT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gICAgdmFyIGxhc3RDaGlsZHJlbiA9IGxhc3RDb250ZW50ICE9IG51bGwgPyBudWxsIDogbGFzdFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGNoaWxkcmVuIHRvIGNvbnRlbnQvaHRtbCBvciB2aWNlIHZlcnNhLCByZW1vdmVcbiAgICAvLyB0aGUgb2xkIGNvbnRlbnRcbiAgICB2YXIgbGFzdEhhc0NvbnRlbnRPckh0bWwgPSBsYXN0Q29udGVudCAhPSBudWxsIHx8IGxhc3RIdG1sICE9IG51bGw7XG4gICAgdmFyIG5leHRIYXNDb250ZW50T3JIdG1sID0gbmV4dENvbnRlbnQgIT0gbnVsbCB8fCBuZXh0SHRtbCAhPSBudWxsO1xuICAgIGlmIChsYXN0Q2hpbGRyZW4gIT0gbnVsbCAmJiBuZXh0Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihudWxsLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChsYXN0SGFzQ29udGVudE9ySHRtbCAmJiAhbmV4dEhhc0NvbnRlbnRPckh0bWwpIHtcbiAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgW10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZXh0Q29udGVudCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdENvbnRlbnQgIT09IG5leHRDb250ZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycgKyBuZXh0Q29udGVudCk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgbmV4dENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWFya3VwKCcnICsgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgW10pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXROb2RlKHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS4gRG9lcyBub3QgcmVtb3ZlIGZyb21cbiAgICogdGhlIERPTS4gVGhhdCBtdXN0IGJlIGRvbmUgYnkgdGhlIHBhcmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoc2FmZWx5KSB7XG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAnaWZyYW1lJzpcbiAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICBjYXNlICdsaW5rJzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fd3JhcHBlclN0YXRlLmxpc3RlbmVycztcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0ucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXG4gICAgICAgICAqIGVhc2lseSBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LCBob3dldmVyIGl0J3MgdmFsdWFibGUgdG8gYmUgYWJsZSB0b1xuICAgICAgICAgKiB0YWtlIGFkdmFudGFnZSBvZiBSZWFjdCdzIHJlY29uY2lsaWF0aW9uIGZvciBzdHlsaW5nIGFuZCA8dGl0bGU+XG4gICAgICAgICAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cbiAgICAgICAgICovXG4gICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8JXM+IHRyaWVkIHRvIHVubW91bnQuIEJlY2F1c2Ugb2YgY3Jvc3MtYnJvd3NlciBxdWlya3MgaXQgaXMgaW1wb3NzaWJsZSB0byB1bm1vdW50IHNvbWUgdG9wLWxldmVsIGNvbXBvbmVudHMgKGVnIDxodG1sPiwgPGhlYWQ+LCBhbmQgPGJvZHk+KSByZWxpYWJseSBhbmQgZWZmaWNpZW50bHkuIFRvIGZpeCB0aGlzLCBoYXZlIGEgc2luZ2xlIHRvcC1sZXZlbCBjb21wb25lbnQgdGhhdCBuZXZlciB1bm1vdW50cyByZW5kZXIgdGhlc2UgZWxlbWVudHMuJywgdGhpcy5fdGFnKSA6IF9wcm9kSW52YXJpYW50KCc2NicsIHRoaXMuX3RhZykgOiB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMudW5tb3VudENoaWxkcmVuKHNhZmVseSk7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICAgIEV2ZW50UGx1Z2luSHViLmRlbGV0ZUFsbExpc3RlbmVycyh0aGlzKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl9kb21JRCA9IDA7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBudWxsKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0Tm9kZSh0aGlzKTtcbiAgfVxuXG59O1xuXG5fYXNzaWduKFJlYWN0RE9NQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RET01Db21wb25lbnQuTWl4aW4sIFJlYWN0TXVsdGlDaGlsZC5NaXhpbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBBdXRvRm9jdXNVdGlsc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcblxudmFyIEF1dG9Gb2N1c1V0aWxzID0ge1xuICBmb2N1c0RPTUNvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIGZvY3VzTm9kZShSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0b0ZvY3VzVXRpbHM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9BdXRvRm9jdXNVdGlscy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBpbnB1dC90ZXh0YXJlYSB0byBmb2N1c1xuICovXG5cbmZ1bmN0aW9uIGZvY3VzTm9kZShub2RlKSB7XG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxuICAvLyBub3QgZW5hYmxlZCwgb3Igb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWNjZXB0IHRoZSBmb2N1cy5cIiBmb3IgYWxsIGtpbmRzIG9mXG4gIC8vIHJlYXNvbnMgdGhhdCBhcmUgdG9vIGV4cGVuc2l2ZSBhbmQgZnJhZ2lsZSB0byB0ZXN0LlxuICB0cnkge1xuICAgIG5vZGUuZm9jdXMoKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2ZvY3VzTm9kZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XG52YXIgZGFuZ2Vyb3VzU3R5bGVWYWx1ZSA9IHJlcXVpcmUoJy4vZGFuZ2Vyb3VzU3R5bGVWYWx1ZScpO1xudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZScpO1xudmFyIG1lbW9pemVTdHJpbmdPbmx5ID0gcmVxdWlyZSgnZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHknKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IG1lbW9pemVTdHJpbmdPbmx5KGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpO1xufSk7XG5cbnZhciBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IGZhbHNlO1xudmFyIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdjc3NGbG9hdCc7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHZhciB0ZW1wU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgdHJ5IHtcbiAgICAvLyBJRTggdGhyb3dzIFwiSW52YWxpZCBhcmd1bWVudC5cIiBpZiByZXNldHRpbmcgc2hvcnRoYW5kIHN0eWxlIHByb3BlcnRpZXMuXG4gICAgdGVtcFN0eWxlLmZvbnQgPSAnJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gdHJ1ZTtcbiAgfVxuICAvLyBJRTggb25seSBzdXBwb3J0cyBhY2Nlc3NpbmcgY3NzRmxvYXQgKHN0YW5kYXJkKSBhcyBzdHlsZUZsb2F0XG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3NzRmxvYXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdzdHlsZUZsb2F0JztcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIGNhbWVsaXplU3R5bGVOYW1lKG5hbWUpLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkblxcJ3QgY29udGFpbiBhIHNlbWljb2xvbi4lcyAnICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJywgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSwgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYE5hTmAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIGNoZWNrUmVuZGVyTWVzc2FnZSA9IGZ1bmN0aW9uIChvd25lcikge1xuICAgIGlmIChvd25lcikge1xuICAgICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuICB2YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGNvbXBvbmVudCkge1xuICAgIHZhciBvd25lcjtcbiAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgIH1cbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSwgb3duZXIpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lLCBvd25lcik7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSwgb3duZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSwgb3duZXIpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggQ1NTIHByb3BlcnRpZXMuXG4gKi9cbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgYSBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgZm9yIHVzZSBhcyBpbmxpbmUgc3R5bGVzOlxuICAgKlxuICAgKiAgID4gY3JlYXRlTWFya3VwRm9yU3R5bGVzKHt3aWR0aDogJzIwMHB4JywgaGVpZ2h0OiAwfSlcbiAgICogICBcIndpZHRoOjIwMHB4O2hlaWdodDowO1wiXG4gICAqXG4gICAqIFVuZGVmaW5lZCB2YWx1ZXMgYXJlIGlnbm9yZWQgc28gdGhhdCBkZWNsYXJhdGl2ZSBwcm9ncmFtbWluZyBpcyBlYXNpZXIuXG4gICAqIFRoZSByZXN1bHQgc2hvdWxkIGJlIEhUTUwtZXNjYXBlZCBiZWZvcmUgaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclN0eWxlczogZnVuY3Rpb24gKHN0eWxlcywgY29tcG9uZW50KSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgY29tcG9uZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2VyaWFsaXplZCArPSBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkgKyAnOic7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGNvbXBvbmVudCkgKyAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBtdWx0aXBsZSBzdHlsZXMgb24gYSBub2RlLiAgSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXNcbiAgICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICAgKi9cbiAgc2V0VmFsdWVGb3JTdHlsZXM6IGZ1bmN0aW9uIChub2RlLCBzdHlsZXMsIGNvbXBvbmVudCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKGNvbXBvbmVudC5fZGVidWdJRCwgJ3VwZGF0ZSBzdHlsZXMnLCBzdHlsZXMpO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgY29tcG9uZW50KTtcbiAgICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcgfHwgc3R5bGVOYW1lID09PSAnY3NzRmxvYXQnKSB7XG4gICAgICAgIHN0eWxlTmFtZSA9IHN0eWxlRmxvYXRBY2Nlc3NvcjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZVZhbHVlKSB7XG4gICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnICYmIENTU1Byb3BlcnR5LnNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1tzdHlsZU5hbWVdO1xuICAgICAgICBpZiAoZXhwYW5zaW9uKSB7XG4gICAgICAgICAgLy8gU2hvcnRoYW5kIHByb3BlcnR5IHRoYXQgSUU4IHdvbid0IGxpa2UgdW5zZXR0aW5nLCBzbyB1bnNldCBlYWNoXG4gICAgICAgICAgLy8gY29tcG9uZW50IHRvIHBsYWNhdGUgaXRcbiAgICAgICAgICBmb3IgKHZhciBpbmRpdmlkdWFsU3R5bGVOYW1lIGluIGV4cGFuc2lvbikge1xuICAgICAgICAgICAgc3R5bGVbaW5kaXZpZHVhbFN0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU1Byb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xuXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGJvcmRlckltYWdlT3V0c2V0OiB0cnVlLFxuICBib3JkZXJJbWFnZVNsaWNlOiB0cnVlLFxuICBib3JkZXJJbWFnZVdpZHRoOiB0cnVlLFxuICBib3hGbGV4OiB0cnVlLFxuICBib3hGbGV4R3JvdXA6IHRydWUsXG4gIGJveE9yZGluYWxHcm91cDogdHJ1ZSxcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIGZsZXhHcm93OiB0cnVlLFxuICBmbGV4UG9zaXRpdmU6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZsZXhOZWdhdGl2ZTogdHJ1ZSxcbiAgZmxleE9yZGVyOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcblxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xuXG4vLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIE1vc3Qgc3R5bGUgcHJvcGVydGllcyBjYW4gYmUgdW5zZXQgYnkgZG9pbmcgLnN0eWxlW3Byb3BdID0gJycgYnV0IElFOFxuICogZG9lc24ndCBsaWtlIGRvaW5nIHRoYXQgd2l0aCBzaG9ydGhhbmQgcHJvcGVydGllcyBzbyBmb3IgdGhlIHByb3BlcnRpZXMgdGhhdFxuICogSUU4IGJyZWFrcyBvbiwgd2hpY2ggYXJlIGxpc3RlZCBoZXJlLCB3ZSBpbnN0ZWFkIHVuc2V0IGVhY2ggb2YgdGhlXG4gKiBpbmRpdmlkdWFsIHByb3BlcnRpZXMuIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM4NS5cbiAqIFRoZSA0LXZhbHVlICdjbG9jaycgcHJvcGVydGllcyBsaWtlIG1hcmdpbiwgcGFkZGluZywgYm9yZGVyLXdpZHRoIHNlZW0gdG9cbiAqIGJlaGF2ZSB3aXRob3V0IGFueSBwcm9ibGVtcy4gQ3VyaW91c2x5LCBsaXN0LXN0eWxlIHdvcmtzIHRvbyB3aXRob3V0IGFueVxuICogc3BlY2lhbCBwcm9kZGluZy5cbiAqL1xudmFyIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyA9IHtcbiAgYmFja2dyb3VuZDoge1xuICAgIGJhY2tncm91bmRBdHRhY2htZW50OiB0cnVlLFxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlLFxuICAgIGJhY2tncm91bmRSZXBlYXQ6IHRydWVcbiAgfSxcbiAgYmFja2dyb3VuZFBvc2l0aW9uOiB7XG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlXG4gIH0sXG4gIGJvcmRlcjoge1xuICAgIGJvcmRlcldpZHRoOiB0cnVlLFxuICAgIGJvcmRlclN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckJvdHRvbToge1xuICAgIGJvcmRlckJvdHRvbVdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbVN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckxlZnQ6IHtcbiAgICBib3JkZXJMZWZ0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyTGVmdFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckxlZnRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJSaWdodDoge1xuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJSaWdodENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclRvcDoge1xuICAgIGJvcmRlclRvcFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclRvcFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclRvcENvbG9yOiB0cnVlXG4gIH0sXG4gIGZvbnQ6IHtcbiAgICBmb250U3R5bGU6IHRydWUsXG4gICAgZm9udFZhcmlhbnQ6IHRydWUsXG4gICAgZm9udFdlaWdodDogdHJ1ZSxcbiAgICBmb250U2l6ZTogdHJ1ZSxcbiAgICBsaW5lSGVpZ2h0OiB0cnVlLFxuICAgIGZvbnRGYW1pbHk6IHRydWVcbiAgfSxcbiAgb3V0bGluZToge1xuICAgIG91dGxpbmVXaWR0aDogdHJ1ZSxcbiAgICBvdXRsaW5lU3R5bGU6IHRydWUsXG4gICAgb3V0bGluZUNvbG9yOiB0cnVlXG4gIH1cbn07XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHtcbiAgaXNVbml0bGVzc051bWJlcjogaXNVbml0bGVzc051bWJlcixcbiAgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zOiBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9DU1NQcm9wZXJ0eS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2NhbWVsaXplLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGRhbmdlcm91c1N0eWxlVmFsdWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgaXNVbml0bGVzc051bWJlciA9IENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXI7XG52YXIgc3R5bGVXYXJuaW5ncyA9IHt9O1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGNvbXBvbmVudCkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGlzTm9uTnVtZXJpYyA9IGlzTmFOKHZhbHVlKTtcbiAgaWYgKGlzTm9uTnVtZXJpYyB8fCB2YWx1ZSA9PT0gMCB8fCBpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTsgLy8gY2FzdCB0byBzdHJpbmdcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIEFsbG93ICcwJyB0byBwYXNzIHRocm91Z2ggd2l0aG91dCB3YXJuaW5nLiAwIGlzIGFscmVhZHkgc3BlY2lhbCBhbmRcbiAgICAgIC8vIGRvZXNuJ3QgcmVxdWlyZSB1bml0cywgc28gd2UgZG9uJ3QgbmVlZCB0byB3YXJuIGFib3V0IGl0LlxuICAgICAgaWYgKGNvbXBvbmVudCAmJiB2YWx1ZSAhPT0gJzAnKSB7XG4gICAgICAgIHZhciBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBvd25lci5nZXROYW1lKCkgOiBudWxsO1xuICAgICAgICBpZiAob3duZXJOYW1lICYmICFzdHlsZVdhcm5pbmdzW293bmVyTmFtZV0pIHtcbiAgICAgICAgICBzdHlsZVdhcm5pbmdzW293bmVyTmFtZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2FybmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICB2YXIgd2FybmluZ3MgPSBzdHlsZVdhcm5pbmdzW293bmVyTmFtZV07XG4gICAgICAgICAgd2FybmVkID0gd2FybmluZ3NbbmFtZV07XG4gICAgICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2EgYCVzYCB0YWcgKG93bmVyOiBgJXNgKSB3YXMgcGFzc2VkIGEgbnVtZXJpYyBzdHJpbmcgdmFsdWUgJyArICdmb3IgQ1NTIHByb3BlcnR5IGAlc2AgKHZhbHVlOiBgJXNgKSB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgJyArICdhcyBhIHVuaXRsZXNzIG51bWJlciBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0LicsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQudHlwZSwgb3duZXJOYW1lIHx8ICd1bmtub3duJywgbmFtZSwgdmFsdWUpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZSArICdweCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX3VwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICpcbiAqIEZvciBDU1Mgc3R5bGUgbmFtZXMsIHVzZSBgaHlwaGVuYXRlU3R5bGVOYW1lYCBpbnN0ZWFkIHdoaWNoIHdvcmtzIHByb3Blcmx5XG4gKiB3aXRoIGFsbCB2ZW5kb3IgcHJlZml4ZXMsIGluY2x1ZGluZyBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX3VwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvaHlwaGVuYXRlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTWVtb2l6ZXMgdGhlIHJldHVybiB2YWx1ZSBvZiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgc3RyaW5nIGFyZ3VtZW50LlxuICovXG5cbmZ1bmN0aW9uIG1lbW9pemVTdHJpbmdPbmx5KGNhbGxiYWNrKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIGlmICghY2FjaGUuaGFzT3duUHJvcGVydHkoc3RyaW5nKSkge1xuICAgICAgY2FjaGVbc3RyaW5nXSA9IGNhbGxiYWNrLmNhbGwodGhpcywgc3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW3N0cmluZ107XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZVN0cmluZ09ubHk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTVByb3BlcnR5T3BlcmF0aW9uc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSkgOiB2b2lkIDA7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICYmICF2YWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICYmIGlzTmFOKHZhbHVlKSB8fCBwcm9wZXJ0eUluZm8uaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUgJiYgdmFsdWUgPCAxIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSBmYWxzZTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXG4gKi9cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgSUQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmVzY2FwZWQgSUQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZy5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcihpZCk7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9ySUQ6IGZ1bmN0aW9uIChub2RlLCBpZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FLCBpZCk7XG4gIH0sXG5cbiAgY3JlYXRlTWFya3VwRm9yUm9vdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FICsgJz1cIlwiJztcbiAgfSxcblxuICBzZXRBdHRyaWJ1dGVGb3JSb290OiBmdW5jdGlvbiAobm9kZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LlJPT1RfQVRUUklCVVRFX05BTUUsICcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7P3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz1cIlwiJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgY3VzdG9tIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICAgIG5vZGVbcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICAgIHBheWxvYWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsICd1cGRhdGUgYXR0cmlidXRlJywgcGF5bG9hZCk7XG4gICAgfVxuICB9LFxuXG4gIHNldFZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyArIHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICAgIHBheWxvYWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsICd1cGRhdGUgYXR0cmlidXRlJywgcGF5bG9hZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGF0dHJpYnV0ZXMgZnJvbSBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGU6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsICdyZW1vdmUgYXR0cmlidXRlJywgbmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsICdyZW1vdmUgYXR0cmlidXRlJywgbmFtZSk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHlPcGVyYXRpb25zO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcblxuLyoqXG4gKiBFc2NhcGVzIGF0dHJpYnV0ZSB2YWx1ZSB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpIHtcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodmFsdWUpICsgJ1wiJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudEVtaXR0ZXJNaXhpbicpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XG5cbnZhciBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSA9IHJlcXVpcmUoJy4vZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdEV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnQgcGx1Z2dhYmxlXG4gKiAgICBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW4gdGhyZWFkLlxuICpcbiAqICAtIFdlIG5vcm1hbGl6ZSBhbmQgZGUtZHVwbGljYXRlIGV2ZW50cyB0byBhY2NvdW50IGZvciBicm93c2VyIHF1aXJrcy4gVGhpc1xuICogICAgbWF5IGJlIGRvbmUgaW4gdGhlIHdvcmtlciB0aHJlYWQuXG4gKlxuICogIC0gRm9yd2FyZCB0aGVzZSBuYXRpdmUgZXZlbnRzICh3aXRoIHRoZSBhc3NvY2lhdGVkIHRvcC1sZXZlbCB0eXBlIHVzZWQgdG9cbiAqICAgIHRyYXAgaXQpIHRvIGBFdmVudFBsdWdpbkh1YmAsIHdoaWNoIGluIHR1cm4gd2lsbCBhc2sgcGx1Z2lucyBpZiB0aGV5IHdhbnRcbiAqICAgIHRvIGV4dHJhY3QgYW55IHN5bnRoZXRpYyBldmVudHMuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgd2lsbCB0aGVuIHByb2Nlc3MgZWFjaCBldmVudCBieSBhbm5vdGF0aW5nIHRoZW0gd2l0aFxuICogICAgXCJkaXNwYXRjaGVzXCIsIGEgc2VxdWVuY2Ugb2YgbGlzdGVuZXJzIGFuZCBJRHMgdGhhdCBjYXJlIGFib3V0IHRoYXQgZXZlbnQuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgdGhlbiBkaXNwYXRjaGVzIHRoZSBldmVudHMuXG4gKlxuICogT3ZlcnZpZXcgb2YgUmVhY3QgYW5kIHRoZSBldmVudCBzeXN0ZW06XG4gKlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCAgICBET00gICAgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogICAgICAgfCAgICAgICAgICAgLlxuICogICAgICAgdiAgICAgICAgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCBSZWFjdEV2ZW50IHwgICAgLlxuICogfCAgTGlzdGVuZXIgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgKy0tLS0tLS0tK3xTaW1wbGVFdmVudHxcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICB8ICAgICAgICAgfFBsdWdpbiAgICAgfFxuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgIHYgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnxFdmVudFBsdWdpbkh1YnwgICAgICAgICAgICAgICAgICAgIHwgICAgRXZlbnQgICB8XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgUHJvcGFnYXRvcnN8XG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgIHxUYXBFdmVudCAgIHwgIHwtLS0tLS0tLS0tLS18XG4gKiB8ICBFbWl0dGVyICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHw8LS0tK3xQbHVnaW4gICAgIHwgIHxvdGhlciBwbHVnaW58XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgIHV0aWxpdGllcyB8XG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLStcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgXiAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICB8ICAgICAgICB8RW50ZXIvTGVhdmV8XG4gKiAgICAgICArICAgICAgICAgICAuICAgICAgICAgICAgICAgICstLS0tLS0tK3xQbHVnaW4gICAgIHxcbiAqICstLS0tLS0tLS0tLS0tKyAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCBhcHBsaWNhdGlvbiB8ICAgLlxuICogfC0tLS0tLS0tLS0tLS18ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogKy0tLS0tLS0tLS0tLS0rICAgLlxuICogICAgICAgICAgICAgICAgICAgLlxuICogICAgUmVhY3QgQ29yZSAgICAgLiAgR2VuZXJhbCBQdXJwb3NlIEV2ZW50IFBsdWdpbiBTeXN0ZW1cbiAqL1xuXG52YXIgaGFzRXZlbnRQYWdlWFk7XG52YXIgYWxyZWFkeUxpc3RlbmluZ1RvID0ge307XG52YXIgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSBmYWxzZTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vLyBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2UgdHJhcCBhdCBhXG4vLyBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZCBjYXVzZSBkdXBsaWNhdGVcbi8vIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZVxudmFyIHRvcEV2ZW50TWFwcGluZyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcEFuaW1hdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpIHx8ICdhbmltYXRpb25lbmQnLFxuICB0b3BBbmltYXRpb25JdGVyYXRpb246IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKSB8fCAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25zdGFydCcpIHx8ICdhbmltYXRpb25zdGFydCcsXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiAnY29tcG9zaXRpb25lbmQnLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiAnY29tcG9zaXRpb25zdGFydCcsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiAnY29tcG9zaXRpb251cGRhdGUnLFxuICB0b3BDb250ZXh0TWVudTogJ2NvbnRleHRtZW51JyxcbiAgdG9wQ29weTogJ2NvcHknLFxuICB0b3BDdXQ6ICdjdXQnLFxuICB0b3BEb3VibGVDbGljazogJ2RibGNsaWNrJyxcbiAgdG9wRHJhZzogJ2RyYWcnLFxuICB0b3BEcmFnRW5kOiAnZHJhZ2VuZCcsXG4gIHRvcERyYWdFbnRlcjogJ2RyYWdlbnRlcicsXG4gIHRvcERyYWdFeGl0OiAnZHJhZ2V4aXQnLFxuICB0b3BEcmFnTGVhdmU6ICdkcmFnbGVhdmUnLFxuICB0b3BEcmFnT3ZlcjogJ2RyYWdvdmVyJyxcbiAgdG9wRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgdG9wRHJvcDogJ2Ryb3AnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcEZvY3VzOiAnZm9jdXMnLFxuICB0b3BJbnB1dDogJ2lucHV0JyxcbiAgdG9wS2V5RG93bjogJ2tleWRvd24nLFxuICB0b3BLZXlQcmVzczogJ2tleXByZXNzJyxcbiAgdG9wS2V5VXA6ICdrZXl1cCcsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJykgfHwgJ3RyYW5zaXRpb25lbmQnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZycsXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyBTdHJpbmcoTWF0aC5yYW5kb20oKSkuc2xpY2UoMik7XG5cbmZ1bmN0aW9uIGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpIHtcbiAgLy8gSW4gSUU4LCBgbW91bnRBdGAgaXMgYSBob3N0IG9iamVjdCBhbmQgZG9lc24ndCBoYXZlIGBoYXNPd25Qcm9wZXJ0eWBcbiAgLy8gZGlyZWN0bHkuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vdW50QXQsIHRvcExpc3RlbmVyc0lES2V5KSkge1xuICAgIG1vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldID0gcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyKys7XG4gICAgYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXSA9IHt9O1xuICB9XG4gIHJldHVybiBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dO1xufVxuXG4vKipcbiAqIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGlzIHVzZWQgdG8gYXR0YWNoIHRvcC1sZXZlbCBldmVudCBsaXN0ZW5lcnMuIEZvclxuICogZXhhbXBsZTpcbiAqXG4gKiAgIEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyKCdteUlEJywgJ29uQ2xpY2snLCBteUZ1bmN0aW9uKTtcbiAqXG4gKiBUaGlzIHdvdWxkIGFsbG9jYXRlIGEgXCJyZWdpc3RyYXRpb25cIiBvZiBgKCdvbkNsaWNrJywgbXlGdW5jdGlvbilgIG9uICdteUlEJy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IF9hc3NpZ24oe30sIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4sIHtcblxuICAvKipcbiAgICogSW5qZWN0YWJsZSBldmVudCBiYWNrZW5kXG4gICAqL1xuICBSZWFjdEV2ZW50TGlzdGVuZXI6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFJlYWN0RXZlbnRMaXN0ZW5lclxuICAgICAqL1xuICAgIGluamVjdFJlYWN0RXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKFJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RFdmVudExpc3RlbmVyLnNldEhhbmRsZVRvcExldmVsKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5oYW5kbGVUb3BMZXZlbCk7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyID0gUmVhY3RFdmVudExpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCBhbnkgY3JlYXRlZCBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBUcnVlIGlmIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgaWYgKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuc2V0RW5hYmxlZChlbmFibGVkKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgY2FsbGJhY2tzIGFyZSBlbmFibGVkLlxuICAgKi9cbiAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgJiYgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5pc0VuYWJsZWQoKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIGxpc3RlbiBmb3IgYnViYmxlZCB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50IG9iamVjdC5cbiAgICpcbiAgICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxuICAgKiBtb3VudGluZyBgb25tb3VzZW1vdmVgIGV2ZW50cyBhdCBzb21lIG5vZGUgdGhhdCB3YXMgbm90IHRoZSBkb2N1bWVudFxuICAgKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xuICAgKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcbiAgICogdG9wLWxldmVsIGxpc3RlbmVycyBmb3IgYG9ubW91c2Vtb3ZlYCB3b24ndCBiZSBjYWxsZWQuIEhvd2V2ZXIsIGlmIHlvdVxuICAgKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxuICAgKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgdG8gdGhlIGRvY3VtZW50IG9iamVjdCBvbmx5LCBhdCBsZWFzdCBmb3IgdGhlc2VcbiAgICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDEwLzA5L2NsaWNrX2V2ZW50X2RlbC5odG1sXG4gICAqXG4gICAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcbiAgICogdGhleSBidWJibGUgdG8gZG9jdW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRlbnREb2N1bWVudEhhbmRsZSBEb2N1bWVudCB3aGljaCBvd25zIHRoZSBjb250YWluZXJcbiAgICovXG4gIGxpc3RlblRvOiBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgY29udGVudERvY3VtZW50SGFuZGxlKSB7XG4gICAgdmFyIG1vdW50QXQgPSBjb250ZW50RG9jdW1lbnRIYW5kbGU7XG4gICAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gICAgdmFyIGRlcGVuZGVuY2llcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICAgIHZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wV2hlZWwpIHtcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wV2hlZWwsICd3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ21vdXNld2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0byBjYXB0dXJlIGEgZGlmZmVyZW50IG1vdXNlIHNjcm9sbCBldmVudC5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Rlc3RzL3Njcm9sbC5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ0RPTU1vdXNlU2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wU2Nyb2xsKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wU2Nyb2xsLCAnc2Nyb2xsJywgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5XSU5ET1dfSEFORExFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cyB8fCBkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1cycsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wRm9jdXMsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEJsdXIsICdibHVyJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1c2luJykpIHtcbiAgICAgICAgICAgIC8vIElFIGhhcyBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnRzIHdoaWNoIGJ1YmJsZS5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMDgvMDQvZGVsZWdhdGluZ190aGUuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wRm9jdXMsICdmb2N1c2luJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BCbHVyLCAnZm9jdXNvdXQnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgICBpc0xpc3RlbmluZ1t0b3BMZXZlbFR5cGVzLnRvcEJsdXJdID0gdHJ1ZTtcbiAgICAgICAgICBpc0xpc3RlbmluZ1t0b3BMZXZlbFR5cGVzLnRvcEZvY3VzXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodG9wRXZlbnRNYXBwaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcEV2ZW50TWFwcGluZ1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVucyB0byB3aW5kb3cgc2Nyb2xsIGFuZCByZXNpemUgZXZlbnRzLiBXZSBjYWNoZSBzY3JvbGwgdmFsdWVzIHNvIHRoYXRcbiAgICogYXBwbGljYXRpb24gY29kZSBjYW4gYWNjZXNzIHRoZW0gd2l0aG91dCB0cmlnZ2VyaW5nIHJlZmxvd3MuXG4gICAqXG4gICAqIFZpZXdwb3J0TWV0cmljcyBpcyBvbmx5IHVzZWQgYnkgU3ludGhldGljTW91c2UvVG91Y2hFdmVudCBhbmQgb25seSB3aGVuXG4gICAqIHBhZ2VYL3BhZ2VZIGlzbid0IHN1cHBvcnRlZCAobGVnYWN5IGJyb3dzZXJzKS5cbiAgICpcbiAgICogTk9URTogU2Nyb2xsIGV2ZW50cyBkbyBub3QgYnViYmxlLlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy9zY3JvbGwuaHRtbFxuICAgKi9cbiAgZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGhhc0V2ZW50UGFnZVhZID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGhhc0V2ZW50UGFnZVhZID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQgJiYgJ3BhZ2VYJyBpbiBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xuICAgIH1cbiAgICBpZiAoIWhhc0V2ZW50UGFnZVhZICYmICFpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSkge1xuICAgICAgdmFyIHJlZnJlc2ggPSBWaWV3cG9ydE1ldHJpY3MucmVmcmVzaFNjcm9sbFZhbHVlcztcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIubW9uaXRvclNjcm9sbFZhbHVlKHJlZnJlc2gpO1xuICAgICAgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFdmVudEVtaXR0ZXJNaXhpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xuXG5mdW5jdGlvbiBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudHMpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0ge1xuXG4gIC8qKlxuICAgKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICAgKiBvcHBvcnR1bml0eSB0byBjcmVhdGUgYFJlYWN0RXZlbnRgcyB0byBiZSBkaXNwYXRjaGVkLlxuICAgKi9cbiAgaGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBldmVudHMgPSBFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXZlbnRFbWl0dGVyTWl4aW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgbWFwcGluZyBvZiBzdGFuZGFyZCB2ZW5kb3IgcHJlZml4ZXMgdXNpbmcgdGhlIGRlZmluZWQgc3R5bGUgcHJvcGVydHkgYW5kIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlUHJvcFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcblxuICBwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV0gPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcHJlZml4ZXNbJ1dlYmtpdCcgKyBzdHlsZVByb3BdID0gJ3dlYmtpdCcgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydNb3onICsgc3R5bGVQcm9wXSA9ICdtb3onICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snbXMnICsgc3R5bGVQcm9wXSA9ICdNUycgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydPJyArIHN0eWxlUHJvcF0gPSAnbycgKyBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcblxuICByZXR1cm4gcHJlZml4ZXM7XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIGV2ZW50IG5hbWVzIHRvIGEgY29uZmlndXJhYmxlIGxpc3Qgb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XG4gIGFuaW1hdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkVuZCcpLFxuICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25JdGVyYXRpb24nKSxcbiAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25TdGFydCcpLFxuICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdUcmFuc2l0aW9uJywgJ1RyYW5zaXRpb25FbmQnKVxufTtcblxuLyoqXG4gKiBFdmVudCBuYW1lcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRldGVjdGVkIGFuZCBwcmVmaXhlZCAoaWYgYXBwbGljYWJsZSkuXG4gKi9cbnZhciBwcmVmaXhlZEV2ZW50TmFtZXMgPSB7fTtcblxuLyoqXG4gKiBFbGVtZW50IHRvIGNoZWNrIGZvciBwcmVmaXhlcyBvbi5cbiAqL1xudmFyIHN0eWxlID0ge307XG5cbi8qKlxuICogQm9vdHN0cmFwIGlmIGEgRE9NIGV4aXN0cy5cbiAqL1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuXG4gIC8vIE9uIHNvbWUgcGxhdGZvcm1zLCBpbiBwYXJ0aWN1bGFyIHNvbWUgcmVsZWFzZXMgb2YgQW5kcm9pZCA0LngsXG4gIC8vIHRoZSB1bi1wcmVmaXhlZCBcImFuaW1hdGlvblwiIGFuZCBcInRyYW5zaXRpb25cIiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHRoZVxuICAvLyBzdHlsZSBvYmplY3QgYnV0IHRoZSBldmVudHMgdGhhdCBmaXJlIHdpbGwgc3RpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIG5lZWRcbiAgLy8gdG8gY2hlY2sgaWYgdGhlIHVuLXByZWZpeGVkIGV2ZW50cyBhcmUgdXNhYmxlLCBhbmQgaWYgbm90IHJlbW92ZSB0aGVtIGZyb20gdGhlIG1hcC5cbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbjtcbiAgfVxuXG4gIC8vIFNhbWUgYXMgYWJvdmVcbiAgaWYgKCEoJ1RyYW5zaXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdmVuZG9yIHByZWZpeGVkIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gIGlmIChwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgfSBlbHNlIGlmICghdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBldmVudE5hbWU7XG4gIH1cblxuICB2YXIgcHJlZml4TWFwID0gdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXTtcblxuICBmb3IgKHZhciBzdHlsZVByb3AgaW4gcHJlZml4TWFwKSB7XG4gICAgaWYgKHByZWZpeE1hcC5oYXNPd25Qcm9wZXJ0eShzdHlsZVByb3ApICYmIHN0eWxlUHJvcCBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdID0gcHJlZml4TWFwW3N0eWxlUHJvcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01CdXR0b25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEaXNhYmxlZElucHV0VXRpbHMgPSByZXF1aXJlKCcuL0Rpc2FibGVkSW5wdXRVdGlscycpO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8YnV0dG9uPiBob3N0IGNvbXBvbmVudCB0aGF0IGRvZXMgbm90IHJlY2VpdmUgbW91c2UgZXZlbnRzXG4gKiB3aGVuIGBkaXNhYmxlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01CdXR0b24gPSB7XG4gIGdldEhvc3RQcm9wczogRGlzYWJsZWRJbnB1dFV0aWxzLmdldEhvc3RQcm9wc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUJ1dHRvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NQnV0dG9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERpc2FibGVkSW5wdXRVdGlsc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGRpc2FibGVhYmxlTW91c2VMaXN0ZW5lck5hbWVzID0ge1xuICBvbkNsaWNrOiB0cnVlLFxuICBvbkRvdWJsZUNsaWNrOiB0cnVlLFxuICBvbk1vdXNlRG93bjogdHJ1ZSxcbiAgb25Nb3VzZU1vdmU6IHRydWUsXG4gIG9uTW91c2VVcDogdHJ1ZSxcblxuICBvbkNsaWNrQ2FwdHVyZTogdHJ1ZSxcbiAgb25Eb3VibGVDbGlja0NhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VEb3duQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZU1vdmVDYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlVXBDYXB0dXJlOiB0cnVlXG59O1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSBob3N0IGNvbXBvbmVudCB0aGF0IGRvZXMgbm90IHJlY2VpdmUgbW91c2UgZXZlbnRzXG4gKiB3aGVuIGBkaXNhYmxlZGAgaXMgc2V0LlxuICovXG52YXIgRGlzYWJsZWRJbnB1dFV0aWxzID0ge1xuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmICghcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG5cbiAgICAvLyBDb3B5IHRoZSBwcm9wcywgZXhjZXB0IHRoZSBtb3VzZSBsaXN0ZW5lcnNcbiAgICB2YXIgaG9zdFByb3BzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIWRpc2FibGVhYmxlTW91c2VMaXN0ZW5lck5hbWVzW2tleV0gJiYgcHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBob3N0UHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaXNhYmxlZElucHV0VXRpbHM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9EaXNhYmxlZElucHV0VXRpbHMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01JbnB1dFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRGlzYWJsZWRJbnB1dFV0aWxzID0gcmVxdWlyZSgnLi9EaXNhYmxlZElucHV0VXRpbHMnKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgOiBwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG52YXIgUmVhY3RET01JbnB1dCA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgY2hlY2tlZCA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0Q2hlY2tlZChwcm9wcyk7XG5cbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC50eXBlIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcyAoc2V0dGluZyAudmFsdWVcbiAgICAgIC8vIGJlZm9yZSAudHlwZSBtZWFucyAudmFsdWUgaXMgbG9zdCBpbiBJRTExIGFuZCBiZWxvdylcbiAgICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnN0ZXAgYmVmb3JlIC52YWx1ZSAoc2V0dGluZyAudmFsdWUgYmVmb3JlIC5zdGVwXG4gICAgICAvLyBtZWFucyAudmFsdWUgaXMgcm91bmRlZCBvbiBtb3VudCwgYmFzZWQgdXBvbiBzdGVwIHByZWNpc2lvbilcbiAgICAgIHN0ZXA6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLm1pbiAmIC5tYXggYmVmb3JlIC52YWx1ZSAodG8gZW5zdXJlIHByb3BlciBvcmRlclxuICAgICAgLy8gaW4gY29ybmVyIGNhc2VzIHN1Y2ggYXMgbWluIG9yIG1heCBkZXJpdmluZyBmcm9tIHZhbHVlLCBlLmcuIElzc3VlICM3MTcwKVxuICAgICAgbWluOiB1bmRlZmluZWQsXG4gICAgICBtYXg6IHVuZGVmaW5lZFxuICAgIH0sIERpc2FibGVkSW5wdXRVdGlscy5nZXRIb3N0UHJvcHMoaW5zdCwgcHJvcHMpLCB7XG4gICAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB2YWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG5cbiAgICAgIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWRMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2BjaGVja2VkTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5DaGVja2VkTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgICBpbml0aWFsVmFsdWU6IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29udHJvbGxlZCA9IGlzQ29udHJvbGxlZChwcm9wcyk7XG4gICAgICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIGlmICghaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnN0Ll93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiAhY29udHJvbGxlZCAmJiAhZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGNoYW5naW5nIGEgY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIHVuY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFNob3VsZG4ndCB0aGlzIGJlIGdldENoZWNrZWQocHJvcHMpP1xuICAgIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSwgJ2NoZWNrZWQnLCBjaGVja2VkIHx8IGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BzLnZhbHVlID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5jaGVja2VkID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuXG4gICAgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlLiBXZSB3b24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSB3b3JraW5nIG9uXG4gICAgLy8gc3VibWl0IG9yIHJlc2V0IGlucHV0cyBhcyB0aG9zZSB2YWx1ZXMgJiBkZWZhdWx0VmFsdWVzIGFyZSBsaW5rZWQuIFRoZXlcbiAgICAvLyBhcmUgbm90IHJlc2V0YWJsZSBub2RlcyBzbyB0aGlzIG9wZXJhdGlvbiBkb2Vzbid0IG1hdHRlciBhbmQgYWN0dWFsbHlcbiAgICAvLyByZW1vdmVzIGJyb3dzZXItZGVmYXVsdCB2YWx1ZXMgKGVnIFwiU3VibWl0IFF1ZXJ5XCIpIHdoZW4gbm8gdmFsdWUgaXNcbiAgICAvLyBwcm92aWRlZC5cblxuICAgIHN3aXRjaCAocHJvcHMudHlwZSkge1xuICAgICAgY2FzZSAnc3VibWl0JzpcbiAgICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjb2xvcic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgIGNhc2UgJ2RhdGV0aW1lLWxvY2FsJzpcbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIC8vIFRoaXMgZml4ZXMgdGhlIG5vLXNob3cgaXNzdWUgb24gaU9TIFNhZmFyaSBhbmQgQW5kcm9pZCBDaHJvbWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzIzM1xuICAgICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICAgIG5vZGUudmFsdWUgPSBub2RlLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBub2RlLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgICAvLyB0aGlzIGlzIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBhIGNocm9tZSBidWcgd2hlcmUgc2V0dGluZyBkZWZhdWx0Q2hlY2tlZFxuICAgIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAgIC8vIFdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgdW5zZXQgbmFtZSB0byBhdm9pZCBkaXNydXB0aW5nIHJhZGlvIGJ1dHRvbiBncm91cHMuXG4gICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgICBub2RlLm5hbWUgPSAnJztcbiAgICB9XG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgLy8gSGVyZSB3ZSB1c2UgYXNhcCB0byB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2hcbiAgLy8gaXMgaW1wb3J0YW50IHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG5cbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0sIGxldCdzIGp1c3QgdXNlIHRoZSBnbG9iYWxcbiAgICAvLyBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0IG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG4gICAgICB2YXIgb3RoZXJJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG90aGVyTm9kZSk7XG4gICAgICAhb3RoZXJJbnN0YW5jZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5MCcpIDogdm9pZCAwO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgb3RoZXJJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW5wdXQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlucHV0LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIExpbmtlZFZhbHVlVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgJ2J1dHRvbic6IHRydWUsXG4gICdjaGVja2JveCc6IHRydWUsXG4gICdpbWFnZSc6IHRydWUsXG4gICdoaWRkZW4nOiB0cnVlLFxuICAncmFkaW8nOiB0cnVlLFxuICAncmVzZXQnOiB0cnVlLFxuICAnc3VibWl0JzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcykge1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZExpbmsgPT0gbnVsbCB8fCBpbnB1dFByb3BzLnZhbHVlTGluayA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIHZhbHVlTGluay4gSWYgeW91IHdhbnQgdG8gdXNlIGNoZWNrZWRMaW5rLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsgYW5kIHZpY2UgdmVyc2EuJykgOiBfcHJvZEludmFyaWFudCgnODcnKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcykge1xuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcbiAgIShpbnB1dFByb3BzLnZhbHVlID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIHZhbHVlTGluayBhbmQgYSB2YWx1ZSBvciBvbkNoYW5nZSBldmVudC4gSWYgeW91IHdhbnQgdG8gdXNlIHZhbHVlIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsuJykgOiBfcHJvZEludmFyaWFudCgnODgnKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy5jaGVja2VkID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIGNoZWNrZWQgcHJvcGVydHkgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSBjaGVja2VkTGluaycpIDogX3Byb2RJbnZhcmlhbnQoJzg5JykgOiB2b2lkIDA7XG59XG5cbnZhciBwcm9wVHlwZXMgPSB7XG4gIHZhbHVlOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gIH0sXG4gIGNoZWNrZWQ6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBvbkNoYW5nZTogUmVhY3RQcm9wVHlwZXMuZnVuY1xufTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICovXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHtcbiAgY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgb3duZXIpIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCB0YWdOYW1lLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3AsIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcik7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIGZvcm0gcHJvcFR5cGU6ICVzJXMnLCBlcnJvci5tZXNzYWdlLCBhZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gdmFsdWUgcHJvcCBvciBsaW5rLlxuICAgKi9cbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgY2hlY2tlZCBzdGF0dXMgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIGNoZWNrZWQgcHJvcFxuICAgKiAgICAgICAgICAgICBvciBsaW5rLlxuICAgKi9cbiAgZ2V0Q2hlY2tlZDogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZExpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBjaGFuZ2UgZXZlbnQgdG8gaGFuZGxlXG4gICAqL1xuICBleGVjdXRlT25DaGFuZ2U6IGZ1bmN0aW9uIChpbnB1dFByb3BzLCBldmVudCkge1xuICAgIGlmIChpbnB1dFByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMub25DaGFuZ2UpIHtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLm9uQ2hhbmdlLmNhbGwodW5kZWZpbmVkLCBldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtlZFZhbHVlVXRpbHM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NT3B0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW4nKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdCcpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuICBSZWFjdENoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgfSBlbHNlIGlmICghZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbikge1xuICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTU9wdGlvbiA9IHtcbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGhvc3RQYXJlbnQpIHtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgd2hldGhlciB0aGlzIG9wdGlvbiBpcyAnc2VsZWN0ZWQnXG4gICAgdmFyIHNlbGVjdFZhbHVlID0gbnVsbDtcbiAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICB2YXIgc2VsZWN0UGFyZW50ID0gaG9zdFBhcmVudDtcblxuICAgICAgaWYgKHNlbGVjdFBhcmVudC5fdGFnID09PSAnb3B0Z3JvdXAnKSB7XG4gICAgICAgIHNlbGVjdFBhcmVudCA9IHNlbGVjdFBhcmVudC5faG9zdFBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdFBhcmVudCAhPSBudWxsICYmIHNlbGVjdFBhcmVudC5fdGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgICBzZWxlY3RWYWx1ZSA9IFJlYWN0RE9NU2VsZWN0LmdldFNlbGVjdFZhbHVlQ29udGV4dChzZWxlY3RQYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBudWxsIChlLmcuLCBubyBzcGVjaWZpZWQgdmFsdWUgb3IgYWZ0ZXIgaW5pdGlhbCBtb3VudClcbiAgICAvLyBvciBtaXNzaW5nIChlLmcuLCBmb3IgPGRhdGFsaXN0PiksIHdlIGRvbid0IGNoYW5nZSBwcm9wcy5zZWxlY3RlZFxuICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XG4gICAgaWYgKHNlbGVjdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gcHJvcHMudmFsdWUgKyAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcbiAgICAgICAgLy8gbXVsdGlwbGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgnJyArIHNlbGVjdFZhbHVlW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH07XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHByb3BzLnZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7IHNlbGVjdGVkOiB1bmRlZmluZWQsIGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuXG4gICAgLy8gUmVhZCBzdGF0ZSBvbmx5IGZyb20gaW5pdGlhbCBtb3VudCBiZWNhdXNlIDxzZWxlY3Q+IHVwZGF0ZXMgdmFsdWVcbiAgICAvLyBtYW51YWxseTsgd2UgbmVlZCB0aGUgaW5pdGlhbCBzdGF0ZSBvbmx5IGZvciBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICBob3N0UHJvcHMuc2VsZWN0ZWQgPSBpbnN0Ll93cmFwcGVyU3RhdGUuc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIGhvc3RQcm9wcy5jaGlsZHJlbiA9IGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NT3B0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01PcHRpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01TZWxlY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRGlzYWJsZWRJbnB1dFV0aWxzID0gcmVxdWlyZSgnLi9EaXNhYmxlZElucHV0VXRpbHMnKTtcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZUxpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEICYmIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlKSB7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnModGhpcywgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG5cbi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcykge1xuICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3NlbGVjdCcsIHByb3BzLCBvd25lcik7XG5cbiAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVMaW5rYCBwcm9wIG9uIGBzZWxlY3RgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgZGlkV2FyblZhbHVlTGluayA9IHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG4gICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpKSA6IHZvaWQgMDtcbiAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBpc0FycmF5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gaW5zdFxuICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBsZVxuICogQHBhcmFtIHsqfSBwcm9wVmFsdWUgQSBzdHJpbmdhYmxlICh3aXRoIGBtdWx0aXBsZWAsIGEgbGlzdCBvZiBzdHJpbmdhYmxlcykuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKGluc3QsIG11bHRpcGxlLCBwcm9wVmFsdWUpIHtcbiAgdmFyIHNlbGVjdGVkVmFsdWUsIGk7XG4gIHZhciBvcHRpb25zID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICBzZWxlY3RlZFZhbHVlID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJyArIHByb3BWYWx1ZVtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShvcHRpb25zW2ldLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zW2ldLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICBzZWxlY3RlZFZhbHVlID0gJycgKyBwcm9wVmFsdWU7XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvcHRpb25zW2ldLnZhbHVlID09PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxlbmd0aCkge1xuICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG52YXIgUmVhY3RET01TZWxlY3QgPSB7XG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIF9hc3NpZ24oe30sIERpc2FibGVkSW5wdXRVdGlscy5nZXRIb3N0UHJvcHMoaW5zdCwgcHJvcHMpLCB7XG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBwZW5kaW5nVXBkYXRlOiBmYWxzZSxcbiAgICAgIGluaXRpYWxWYWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KSxcbiAgICAgIHdhc011bHRpcGxlOiBCb29sZWFuKHByb3BzLm11bHRpcGxlKVxuICAgIH07XG5cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJykgOiB2b2lkIDA7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBnZXRTZWxlY3RWYWx1ZUNvbnRleHQ6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgLy8gUmVhY3RET01PcHRpb24gbG9va3MgYXQgdGhpcyBpbml0aWFsIHZhbHVlIHNvIHRoZSBpbml0aWFsIGdlbmVyYXRlZFxuICAgIC8vIG1hcmt1cCBoYXMgY29ycmVjdCBgc2VsZWN0ZWRgIGF0dHJpYnV0ZXNcbiAgICByZXR1cm4gaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTtcbiAgfSxcblxuICBwb3N0VXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIEFmdGVyIHRoZSBpbml0aWFsIG1vdW50LCB3ZSBjb250cm9sIHNlbGVjdGVkLW5lc3MgbWFudWFsbHkgc28gZG9uJ3QgcGFzc1xuICAgIC8vIHRoaXMgdmFsdWUgZG93blxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgd2FzTXVsdGlwbGUgPSBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSk7XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSBCb29sZWFuKHByb3BzLm11bHRpcGxlKSkge1xuICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLm11bHRpcGxlID8gW10gOiAnJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuXG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSB0cnVlO1xuICB9XG4gIFJlYWN0VXBkYXRlcy5hc2FwKHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkLCB0aGlzKTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3QuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01UZXh0YXJlYVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRGlzYWJsZWRJbnB1dFV0aWxzID0gcmVxdWlyZSgnLi9EaXNhYmxlZElucHV0VXRpbHMnKTtcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZUxpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSB7XG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IF9wcm9kSW52YXJpYW50KCc5MScpIDogdm9pZCAwO1xuXG4gICAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgICAvLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuICAgIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitCZW4gc2VlbWVkIHRvIGxpa2UgdGhpcyBzb2x1dGlvbi5cbiAgICAvLyBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZCB0byBiZSBhIHN0cmluZy5cbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7fSwgRGlzYWJsZWRJbnB1dFV0aWxzLmdldEhvc3RQcm9wcyhpbnN0LCBwcm9wcyksIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGNoaWxkcmVuOiAnJyArIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3RleHRhcmVhJywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVMaW5rYCBwcm9wIG9uIGB0ZXh0YXJlYWAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgaW5pdGlhbFZhbHVlID0gdmFsdWU7XG5cbiAgICAvLyBPbmx5IGJvdGhlciBmZXRjaGluZyBkZWZhdWx0IHZhbHVlIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpdFxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IF9wcm9kSW52YXJpYW50KCc5MicpIDogdm9pZCAwO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJykgOiBfcHJvZEludmFyaWFudCgnOTMnKSA6IHZvaWQgMDtcbiAgICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBpbml0aWFsVmFsdWU6ICcnICsgaW5pdGlhbFZhbHVlLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuXG4gICAgLy8gV2FybmluZzogbm9kZS52YWx1ZSBtYXkgYmUgdGhlIGVtcHR5IHN0cmluZyBhdCB0aGlzIHBvaW50IChJRTExKSBpZiBwbGFjZWhvbGRlciBpcyBzZXQuXG4gICAgbm9kZS52YWx1ZSA9IG5vZGUudGV4dENvbnRlbnQ7IC8vIERldGFjaCB2YWx1ZSBmcm9tIGRlZmF1bHRWYWx1ZVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRhcmVhO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0YXJlYS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcycpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdENoaWxkUmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZFJlY29uY2lsZXInKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZmxhdHRlbkNoaWxkcmVuID0gcmVxdWlyZSgnLi9mbGF0dGVuQ2hpbGRyZW4nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3IgbWFya3VwIHRvIGJlIHJlbmRlcmVkIGFuZCBpbnNlcnRlZCBhdCBhIHN1cHBsaWVkIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VJbnNlcnRNYXJrdXAobWFya3VwLCBhZnRlck5vZGUsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVAsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiB0b0luZGV4LFxuICAgIGFmdGVyTm9kZTogYWZ0ZXJOb2RlXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1vdmluZyBhbiBleGlzdGluZyBlbGVtZW50IHRvIGFub3RoZXIgaW5kZXguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBTb3VyY2UgaW5kZXggb2YgdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkcsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGNoaWxkLl9tb3VudEluZGV4LFxuICAgIGZyb21Ob2RlOiBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUoY2hpbGQpLFxuICAgIHRvSW5kZXg6IHRvSW5kZXgsXG4gICAgYWZ0ZXJOb2RlOiBhZnRlck5vZGVcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3IgcmVtb3ZpbmcgYW4gZWxlbWVudCBhdCBhbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IEluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VSZW1vdmUoY2hpbGQsIG5vZGUpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBjaGlsZC5fbW91bnRJbmRleCxcbiAgICBmcm9tTm9kZTogbm9kZSxcbiAgICB0b0luZGV4OiBudWxsLFxuICAgIGFmdGVyTm9kZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBzZXR0aW5nIHRoZSBtYXJrdXAgb2YgYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlU2V0TWFya3VwKG1hcmt1cCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuU0VUX01BUktVUCxcbiAgICBjb250ZW50OiBtYXJrdXAsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHNldHRpbmcgdGhlIHRleHQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VUZXh0Q29udGVudCh0ZXh0Q29udGVudCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuVEVYVF9DT05URU5ULFxuICAgIGNvbnRlbnQ6IHRleHRDb250ZW50LFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsLFxuICAgIGFmdGVyTm9kZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIFB1c2ggYW4gdXBkYXRlLCBpZiBhbnksIG9udG8gdGhlIHF1ZXVlLiBDcmVhdGVzIGEgbmV3IHF1ZXVlIGlmIG5vbmUgaXNcbiAqIHBhc3NlZCBhbmQgYWx3YXlzIHJldHVybnMgdGhlIHF1ZXVlLiBNdXRhdGl2ZS5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIGlmICh1cGRhdGUpIHtcbiAgICBxdWV1ZSA9IHF1ZXVlIHx8IFtdO1xuICAgIHF1ZXVlLnB1c2godXBkYXRlKTtcbiAgfVxuICByZXR1cm4gcXVldWU7XG59XG5cbi8qKlxuICogUHJvY2Vzc2VzIGFueSBlbnF1ZXVlZCB1cGRhdGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NRdWV1ZShpbnN0LCB1cGRhdGVRdWV1ZSkge1xuICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMoaW5zdCwgdXBkYXRlUXVldWUpO1xufVxuXG52YXIgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24gPSBlbXB0eUZ1bmN0aW9uO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGdldERlYnVnSUQgPSBmdW5jdGlvbiAoaW5zdCkge1xuICAgIGlmICghaW5zdC5fZGVidWdJRCkge1xuICAgICAgLy8gQ2hlY2sgZm9yIEFSVC1saWtlIGluc3RhbmNlcy4gVE9ETzogVGhpcyBpcyBzaWxseS9ncm9zcy5cbiAgICAgIHZhciBpbnRlcm5hbDtcbiAgICAgIGlmIChpbnRlcm5hbCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGluc3QpKSB7XG4gICAgICAgIGluc3QgPSBpbnRlcm5hbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc3QuX2RlYnVnSUQ7XG4gIH07XG4gIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgdmFyIGRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgIC8vIFRPRE86IFJlYWN0IE5hdGl2ZSBlbXB0eSBjb21wb25lbnRzIGFyZSBhbHNvIG11bHRpY2hpbGQuXG4gICAgLy8gVGhpcyBtZWFucyB0aGV5IHN0aWxsIGdldCBpbnRvIHRoaXMgbWV0aG9kIGJ1dCBkb24ndCBoYXZlIF9kZWJ1Z0lELlxuICAgIGlmIChkZWJ1Z0lEICE9PSAwKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBjaGlsZHJlbiA/IE9iamVjdC5rZXlzKGNoaWxkcmVuKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5ba2V5XS5fZGVidWdJRDtcbiAgICAgIH0pIDogW10pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBSZWFjdE11bHRpQ2hpbGQgYXJlIGNhcGFibGUgb2YgcmVjb25jaWxpbmcgbXVsdGlwbGUgY2hpbGRyZW4uXG4gKlxuICogQGNsYXNzIFJlYWN0TXVsdGlDaGlsZFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGQgPSB7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBjb21wb25lbnRzIHRoYXQgbXVzdCByZWNvbmNpbGUgbXVsdGlwbGVcbiAgICogY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCBieSBgUmVhY3RET01Db21wb25lbnRgIHRvIG1vdW50LCB1cGRhdGUsIGFuZFxuICAgKiB1bm1vdW50IGNoaWxkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBsZW5kcyB7UmVhY3RNdWx0aUNoaWxkLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG5cbiAgICBfcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbmV4dENoaWxkcmVuO1xuICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gMDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICByZXR1cm4gbmV4dENoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXG4gICAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkcmVuIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBtb3VudGVkIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBtb3VudENoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW25hbWVdO1xuICAgICAgICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgICBtb3VudEltYWdlcy5wdXNoKG1vdW50SW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgY2hpbGRyZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW91bnRJbWFnZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0Q29udGVudCBTdHJpbmcgb2YgY29udGVudC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0Q29udGVudDogZnVuY3Rpb24gKG5leHRDb250ZW50KSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBmYWxzZSk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVRleHRDb250ZW50IGNhbGxlZCBvbiBub24tZW1wdHkgY29tcG9uZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzExOCcpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgbmV3IHRleHQgY29udGVudC5cbiAgICAgIHZhciB1cGRhdGVzID0gW21ha2VUZXh0Q29udGVudChuZXh0Q29udGVudCldO1xuICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG1hcmt1cCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dE1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZU1hcmt1cDogZnVuY3Rpb24gKG5leHRNYXJrdXApIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIGZhbHNlKTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlVGV4dENvbnRlbnQgY2FsbGVkIG9uIG5vbi1lbXB0eSBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMTE4JykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB1cGRhdGVzID0gW21ha2VTZXRNYXJrdXAobmV4dE1hcmt1cCldO1xuICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIG5ldyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIC8vIEhvb2sgdXNlZCBieSBSZWFjdCBBUlRcbiAgICAgIHRoaXMuX3VwZGF0ZUNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGZpbmFsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF91cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICB2YXIgcmVtb3ZlZE5vZGVzID0ge307XG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdXBkYXRlcyA9IG51bGw7XG4gICAgICB2YXIgbmFtZTtcbiAgICAgIC8vIGBuZXh0SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIGNoaWxkIGluIGBuZXh0Q2hpbGRyZW5gLCBidXRcbiAgICAgIC8vIGBsYXN0SW5kZXhgIHdpbGwgYmUgdGhlIGxhc3QgaW5kZXggdmlzaXRlZCBpbiBgcHJldkNoaWxkcmVuYC5cbiAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICAvLyBgbmV4dE1vdW50SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIG5ld2x5IG1vdW50ZWQgY2hpbGQuXG4gICAgICB2YXIgbmV4dE1vdW50SW5kZXggPSAwO1xuICAgICAgdmFyIGxhc3RQbGFjZWROb2RlID0gbnVsbDtcbiAgICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgaWYgKHByZXZDaGlsZCA9PT0gbmV4dENoaWxkKSB7XG4gICAgICAgICAgdXBkYXRlcyA9IGVucXVldWUodXBkYXRlcywgdGhpcy5tb3ZlQ2hpbGQocHJldkNoaWxkLCBsYXN0UGxhY2VkTm9kZSwgbmV4dEluZGV4LCBsYXN0SW5kZXgpKTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgcHJldkNoaWxkLl9tb3VudEluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBgbGFzdEluZGV4YCBiZWZvcmUgYF9tb3VudEluZGV4YCBnZXRzIHVuc2V0IGJ5IHVubW91bnRpbmcuXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgICAvLyBUaGUgYHJlbW92ZWROb2Rlc2AgbG9vcCBiZWxvdyB3aWxsIGFjdHVhbGx5IHJlbW92ZSB0aGUgY2hpbGQuXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMuX21vdW50Q2hpbGRBdEluZGV4KG5leHRDaGlsZCwgbW91bnRJbWFnZXNbbmV4dE1vdW50SW5kZXhdLCBsYXN0UGxhY2VkTm9kZSwgbmV4dEluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkpO1xuICAgICAgICAgIG5leHRNb3VudEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgIGxhc3RQbGFjZWROb2RlID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKG5leHRDaGlsZCk7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgICBmb3IgKG5hbWUgaW4gcmVtb3ZlZE5vZGVzKSB7XG4gICAgICAgIGlmIChyZW1vdmVkTm9kZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkcmVuW25hbWVdLCByZW1vdmVkTm9kZXNbbmFtZV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZXMpIHtcbiAgICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG5leHRDaGlsZHJlbjtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC4gSXQgZG9lcyBub3QgYWN0dWFsbHkgcGVyZm9ybSBhbnlcbiAgICAgKiBiYWNrZW5kIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICAgIHZhciByZW5kZXJlZENoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihyZW5kZXJlZENoaWxkcmVuLCBzYWZlbHkpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgY2hpbGQgY29tcG9uZW50IHRvIHRoZSBzdXBwbGllZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0SW5kZXggTGFzdCBpbmRleCB2aXNpdGVkIG9mIHRoZSBzaWJsaW5ncyBvZiBgY2hpbGRgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4LCBsYXN0SW5kZXgpIHtcbiAgICAgIC8vIElmIHRoZSBpbmRleCBvZiBgY2hpbGRgIGlzIGxlc3MgdGhhbiBgbGFzdEluZGV4YCwgdGhlbiBpdCBuZWVkcyB0b1xuICAgICAgLy8gYmUgbW92ZWQuIE90aGVyd2lzZSwgd2UgZG8gbm90IG5lZWQgdG8gbW92ZSBpdCBiZWNhdXNlIGEgY2hpbGQgd2lsbCBiZVxuICAgICAgLy8gaW5zZXJ0ZWQgb3IgbW92ZWQgYmVmb3JlIGBjaGlsZGAuXG4gICAgICBpZiAoY2hpbGQuX21vdW50SW5kZXggPCBsYXN0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW91bnRJbWFnZSBNYXJrdXAgdG8gaW5zZXJ0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBhZnRlck5vZGUsIG1vdW50SW1hZ2UpIHtcbiAgICAgIHJldHVybiBtYWtlSW5zZXJ0TWFya3VwKG1vdW50SW1hZ2UsIGFmdGVyTm9kZSwgY2hpbGQuX21vdW50SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ2hpbGQgdG8gcmVtb3ZlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBub2RlKSB7XG4gICAgICByZXR1cm4gbWFrZVJlbW92ZShjaGlsZCwgbm9kZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdW50cyBhIGNoaWxkIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW91bnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdW50Q2hpbGRBdEluZGV4OiBmdW5jdGlvbiAoY2hpbGQsIG1vdW50SW1hZ2UsIGFmdGVyTm9kZSwgaW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4O1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ2hpbGQoY2hpbGQsIGFmdGVyTm9kZSwgbW91bnRJbWFnZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGEgcmVuZGVyZWQgY2hpbGQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gdW5tb3VudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91bm1vdW50Q2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbm9kZSkge1xuICAgICAgdmFyIHVwZGF0ZSA9IHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQsIG5vZGUpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZTtcbiAgICB9XG5cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0TXVsdGlDaGlsZC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbmplY3RlZCA9IGZhbHNlO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHtcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHN3YXBwaW5nIG91dCBtb3VudCBpbWFnZXMgaW4gdGhlIG1pZGRsZSBvZlxuICAgKiB0aGUgdHJlZS5cbiAgICovXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cDogbnVsbCxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZSBvZiBjaGlsZCB1cGRhdGVzLiBXaWxsXG4gICAqIGxhdGVyIG1vdmUgaW50byBNdWx0aUNoaWxkQ29tcG9uZW50cy5cbiAgICovXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuICAgICAgISFpbmplY3RlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogaW5qZWN0RW52aXJvbm1lbnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb25jZS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDQnKSA6IHZvaWQgMDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwO1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzID0gZW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcztcbiAgICAgIGluamVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluc3RhbmNlTWFwXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICovXG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIEVTNjogdmFyIFJlYWN0SW5zdGFuY2VNYXAgPSBuZXcgTWFwKCk7XG5cbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VNYXA7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEluc3RhbmNlTWFwLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2hpbGRSZWNvbmNpbGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxuZnVuY3Rpb24gaW5zdGFudGlhdGVDaGlsZChjaGlsZEluc3RhbmNlcywgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKSB7XG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICB2YXIga2V5VW5pcXVlID0gY2hpbGRJbnN0YW5jZXNbbmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICB9XG4gICAgaWYgKCFrZXlVbmlxdWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJXMnLCBLZXlFc2NhcGVVdGlscy51bmVzY2FwZShuYW1lKSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChzZWxmRGVidWdJRCkpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICBpZiAoY2hpbGQgIT0gbnVsbCAmJiBrZXlVbmlxdWUpIHtcbiAgICBjaGlsZEluc3RhbmNlc1tuYW1lXSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoY2hpbGQsIHRydWUpO1xuICB9XG59XG5cbi8qKlxuICogUmVhY3RDaGlsZFJlY29uY2lsZXIgcHJvdmlkZXMgaGVscGVycyBmb3IgaW5pdGlhbGl6aW5nIG9yIHVwZGF0aW5nIGEgc2V0IG9mXG4gKiBjaGlsZHJlbi4gSXRzIG91dHB1dCBpcyBzdWl0YWJsZSBmb3IgcGFzc2luZyBpdCBvbnRvIFJlYWN0TXVsdGlDaGlsZCB3aGljaFxuICogZG9lcyBkaWZmZWQgcmVvcmRlcmluZyBhbmQgaW5zZXJ0aW9uLlxuICovXG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSB7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZE5vZGVzIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBIHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgaW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0LCBzZWxmRGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICApIHtcbiAgICBpZiAobmVzdGVkQ2hpbGROb2RlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNoaWxkSW5zdGFuY2VzID0ge307XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBmdW5jdGlvbiAoY2hpbGRJbnN0cywgY2hpbGQsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlQ2hpbGQoY2hpbGRJbnN0cywgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIH0sIGNoaWxkSW5zdGFuY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBpbnN0YW50aWF0ZUNoaWxkLCBjaGlsZEluc3RhbmNlcyk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZEluc3RhbmNlcztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gYW5kIHJldHVybnMgYSBuZXcgc2V0IG9mIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q2hpbGRyZW4gRmxhdCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH0gQSBuZXcgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEIC8vIDAgaW4gcHJvZHVjdGlvbiBhbmQgZm9yIHJvb3RzXG4gICkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBkb24ndCBoYXZlIGEgd2F5IHRvIHRyYWNrIG1vdmVzIGhlcmUgYnV0IGlmIHdlIHVzZSBpdGVyYXRvcnNcbiAgICAvLyBpbnN0ZWFkIG9mIGZvci4uaW4gd2UgY2FuIHppcCB0aGUgaXRlcmF0b3JzIGFuZCBjaGVjayBpZiBhbiBpdGVtIGhhc1xuICAgIC8vIG1vdmVkLlxuICAgIC8vIFRPRE86IElmIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHJldHVybiB0aGUgcHJldkNoaWxkcmVuIG9iamVjdCBzbyB0aGF0IHdlXG4gICAgLy8gY2FuIHF1aWNrbHkgYmFpbG91dCBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkLlxuICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIHByZXZDaGlsZDtcbiAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2Q2hpbGQgJiYgcHJldkNoaWxkLl9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBuZXh0RWxlbWVudCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgIGlmIChwcmV2Q2hpbGQgIT0gbnVsbCAmJiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHByZXZDaGlsZCwgbmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gcHJldkNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgIHJlbW92ZWROb2Rlc1tuYW1lXSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q2hpbGQpO1xuICAgICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICB2YXIgbmV4dENoaWxkSW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gbmV4dENoaWxkSW5zdGFuY2U7XG4gICAgICAgIC8vIENyZWF0aW5nIG1vdW50IGltYWdlIG5vdyBlbnN1cmVzIHJlZnMgYXJlIHJlc29sdmVkIGluIHJpZ2h0IG9yZGVyXG4gICAgICAgIC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzEwMSBmb3IgZXhwbGFuYXRpb24pLlxuICAgICAgICB2YXIgbmV4dENoaWxkTW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChuZXh0Q2hpbGRJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgIG1vdW50SW1hZ2VzLnB1c2gobmV4dENoaWxkTW91bnRJbWFnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFVubW91bnQgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgZm9yIChuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhKG5leHRDaGlsZHJlbiAmJiBuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgcmVtb3ZlZE5vZGVzW25hbWVdID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDaGlsZCk7XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXG4gICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHJlbmRlcmVkQ2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAocmVuZGVyZWRDaGlsZHJlbiwgc2FmZWx5KSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiByZW5kZXJlZENoaWxkcmVuKSB7XG4gICAgICBpZiAocmVuZGVyZWRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB2YXIgcmVuZGVyZWRDaGlsZCA9IHJlbmRlcmVkQ2hpbGRyZW5bbmFtZV07XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHJlbmRlcmVkQ2hpbGQsIHNhZmVseSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZFJlY29uY2lsZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkUmVjb25jaWxlci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RIb3N0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEhvc3RDb21wb25lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8vIFRvIGF2b2lkIGEgY3ljbGljIGRlcGVuZGVuY3ksIHdlIGNyZWF0ZSB0aGUgZmluYWwgY2xhc3MgaW4gdGhpcyBtb2R1bGVcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB0aGlzLmNvbnN0cnVjdChlbGVtZW50KTtcbn07XG5fYXNzaWduKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlci5wcm90b3R5cGUsIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50Lk1peGluLCB7XG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XG59KTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHR5cGUgcmVmZXJlbmNlIGlzIGEga25vd24gaW50ZXJuYWwgdHlwZS4gSS5lLiBub3QgYSB1c2VyXG4gKiBwcm92aWRlZCBjb21wb3NpdGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhpcyBpcyBhIHZhbGlkIGludGVybmFsIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJuYWxDb21wb25lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nO1xufVxuXG52YXIgbmV4dERlYnVnSUQgPSAxO1xuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3ROb2RlLCBjcmVhdGUgYW4gaW5zdGFuY2UgdGhhdCB3aWxsIGFjdHVhbGx5IGJlIG1vdW50ZWQuXG4gKlxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkSGF2ZURlYnVnSURcbiAqIEByZXR1cm4ge29iamVjdH0gQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGVsZW1lbnQncyBjb25zdHJ1Y3Rvci5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChub2RlLCBzaG91bGRIYXZlRGVidWdJRCkge1xuICB2YXIgaW5zdGFuY2U7XG5cbiAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gZmFsc2UpIHtcbiAgICBpbnN0YW5jZSA9IFJlYWN0RW1wdHlDb21wb25lbnQuY3JlYXRlKGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBlbGVtZW50ID0gbm9kZTtcbiAgICAhKGVsZW1lbnQgJiYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgZWxlbWVudC50eXBlID09IG51bGwgPyBlbGVtZW50LnR5cGUgOiB0eXBlb2YgZWxlbWVudC50eXBlLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oZWxlbWVudC5fb3duZXIpKSA6IF9wcm9kSW52YXJpYW50KCcxMzAnLCBlbGVtZW50LnR5cGUgPT0gbnVsbCA/IGVsZW1lbnQudHlwZSA6IHR5cGVvZiBlbGVtZW50LnR5cGUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShlbGVtZW50Ll9vd25lcikpIDogdm9pZCAwO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHN0cmluZyB2YWx1ZXNcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGluc3RhbmNlID0gUmVhY3RIb3N0Q29tcG9uZW50LmNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAoaXNJbnRlcm5hbENvbXBvbmVudFR5cGUoZWxlbWVudC50eXBlKSkge1xuICAgICAgLy8gVGhpcyBpcyB0ZW1wb3JhcmlseSBhdmFpbGFibGUgZm9yIGN1c3RvbSBjb21wb25lbnRzIHRoYXQgYXJlIG5vdCBzdHJpbmdcbiAgICAgIC8vIHJlcHJlc2VudGF0aW9ucy4gSS5lLiBBUlQuIE9uY2UgdGhvc2UgYXJlIHVwZGF0ZWQgdG8gdXNlIHRoZSBzdHJpbmdcbiAgICAgIC8vIHJlcHJlc2VudGF0aW9uLCB3ZSBjYW4gZHJvcCB0aGlzIGNvZGUgcGF0aC5cbiAgICAgIGluc3RhbmNlID0gbmV3IGVsZW1lbnQudHlwZShlbGVtZW50KTtcblxuICAgICAgLy8gV2UgcmVuYW1lZCB0aGlzLiBBbGxvdyB0aGUgb2xkIG5hbWUgZm9yIGNvbXBhdC4gOihcbiAgICAgIGlmICghaW5zdGFuY2UuZ2V0SG9zdE5vZGUpIHtcbiAgICAgICAgaW5zdGFuY2UuZ2V0SG9zdE5vZGUgPSBpbnN0YW5jZS5nZXROYXRpdmVOb2RlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZSA9IG5ldyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIoZWxlbWVudCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpIHtcbiAgICBpbnN0YW5jZSA9IFJlYWN0SG9zdENvbXBvbmVudC5jcmVhdGVJbnN0YW5jZUZvclRleHQobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VuY291bnRlcmVkIGludmFsaWQgUmVhY3Qgbm9kZSBvZiB0eXBlICVzJywgdHlwZW9mIG5vZGUpIDogX3Byb2RJbnZhcmlhbnQoJzEzMScsIHR5cGVvZiBub2RlKSA6IHZvaWQgMDtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3RhbmNlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRIb3N0Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UudW5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJywgJ09ubHkgUmVhY3QgQ29tcG9uZW50cyBjYW4gYmUgbW91bnRlZC4nKSA6IHZvaWQgMDtcbiAgfVxuXG4gIC8vIFRoZXNlIHR3byBmaWVsZHMgYXJlIHVzZWQgYnkgdGhlIERPTSBhbmQgQVJUIGRpZmZpbmcgYWxnb3JpdGhtc1xuICAvLyByZXNwZWN0aXZlbHkuIEluc3RlYWQgb2YgdXNpbmcgZXhwYW5kb3Mgb24gY29tcG9uZW50cywgd2Ugc2hvdWxkIGJlXG4gIC8vIHN0b3JpbmcgdGhlIHN0YXRlIG5lZWRlZCBieSB0aGUgZGlmZmluZyBhbGdvcml0aG1zIGVsc2V3aGVyZS5cbiAgaW5zdGFuY2UuX21vdW50SW5kZXggPSAwO1xuICBpbnN0YW5jZS5fbW91bnRJbWFnZSA9IG51bGw7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpbnN0YW5jZS5fZGVidWdJRCA9IHNob3VsZEhhdmVEZWJ1Z0lEID8gbmV4dERlYnVnSUQrKyA6IDA7XG4gIH1cblxuICAvLyBJbnRlcm5hbCBpbnN0YW5jZXMgc2hvdWxkIGZ1bGx5IGNvbnN0cnVjdGVkIGF0IHRoaXMgcG9pbnQsIHNvIHRoZXkgc2hvdWxkXG4gIC8vIG5vdCBnZXQgYW55IG5ldyBmaWVsZHMgYWRkZWQgdG8gdGhlbSBhdCB0aGlzIHBvaW50LlxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChPYmplY3QucHJldmVudEV4dGVuc2lvbnMpIHtcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhpbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdE5vZGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3ROb2RlVHlwZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGNoZWNrUmVhY3RUeXBlU3BlYyA9IHJlcXVpcmUoJy4vY2hlY2tSZWFjdFR5cGVTcGVjJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBDb21wb3NpdGVUeXBlcyA9IHtcbiAgSW1wdXJlQ2xhc3M6IDAsXG4gIFB1cmVDbGFzczogMSxcbiAgU3RhdGVsZXNzRnVuY3Rpb25hbDogMlxufTtcblxuZnVuY3Rpb24gU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCkge31cblN0YXRlbGVzc0NvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgQ29tcG9uZW50ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gIHZhciBlbGVtZW50ID0gQ29tcG9uZW50KHRoaXMucHJvcHMsIHRoaXMuY29udGV4dCwgdGhpcy51cGRhdGVyKTtcbiAgd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCBlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5mdW5jdGlvbiB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSwgJyVzKC4uLik6IEEgdmFsaWQgUmVhY3QgZWxlbWVudCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlICcgKyAncmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb25hbCBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VDb21wb25lbnREaWRNb3VudFdpdGhUaW1lcigpIHtcbiAgdmFyIHB1YmxpY0luc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50RGlkTW91bnQnKTtcbiAgfVxuICBwdWJsaWNJbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnREaWRNb3VudCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNvbXBvbmVudERpZFVwZGF0ZVdpdGhUaW1lcihwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpIHtcbiAgdmFyIHB1YmxpY0luc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gIH1cbiAgcHVibGljSW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCk7XG4gIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gaXNQdXJlQ29tcG9uZW50KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KTtcbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0gVGhlIExpZmUtQ3ljbGUgb2YgYSBDb21wb3NpdGUgQ29tcG9uZW50IC0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIC0gY29uc3RydWN0b3I6IEluaXRpYWxpemF0aW9uIG9mIHN0YXRlLiBUaGUgaW5zdGFuY2UgaXMgbm93IHJldGFpbmVkLlxuICogICAtIGNvbXBvbmVudFdpbGxNb3VudFxuICogICAtIHJlbmRlclxuICogICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9yc11cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50RGlkTW91bnRdXG4gKiAgICAgLSBjb21wb25lbnREaWRNb3VudFxuICpcbiAqICAgICAgIFVwZGF0ZSBQaGFzZXM6XG4gKiAgICAgICAtIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG9ubHkgY2FsbGVkIGlmIHBhcmVudCB1cGRhdGVkKVxuICogICAgICAgLSBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAqICAgICAgICAgLSBjb21wb25lbnRXaWxsVXBkYXRlXG4gKiAgICAgICAgICAgLSByZW5kZXJcbiAqICAgICAgICAgICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9ycyBvciByZWNlaXZlIHByb3BzIHBoYXNlc11cbiAqICAgICAgICAgLSBjb21wb25lbnREaWRVcGRhdGVcbiAqXG4gKiAgICAgLSBjb21wb25lbnRXaWxsVW5tb3VudFxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbFVubW91bnRdXG4gKiAgIC0gW2NoaWxkcmVuIGRlc3Ryb3llZF1cbiAqIC0gKGRlc3Ryb3llZCk6IFRoZSBpbnN0YW5jZSBpcyBub3cgYmxhbmssIHJlbGVhc2VkIGJ5IFJlYWN0IGFuZCByZWFkeSBmb3IgR0MuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIEFuIGluY3JlbWVudGluZyBJRCBhc3NpZ25lZCB0byBlYWNoIGNvbXBvbmVudCB3aGVuIGl0IGlzIG1vdW50ZWQuIFRoaXMgaXNcbiAqIHVzZWQgdG8gZW5mb3JjZSB0aGUgb3JkZXIgaW4gd2hpY2ggYFJlYWN0VXBkYXRlc2AgdXBkYXRlcyBkaXJ0eSBjb21wb25lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBuZXh0TW91bnRJRCA9IDE7XG5cbi8qKlxuICogQGxlbmRzIHtSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5wcm90b3R5cGV9XG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluID0ge1xuXG4gIC8qKlxuICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgY29tcG9zaXRlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlUXVldWVcbiAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZXMgYW5kIFJlYWN0VXBkYXRlUXVldWUuXG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG5cbiAgICAvLyBDb21wb25lbnRXaWxsVW5tb3VudCBzaGFsbCBvbmx5IGJlIGNhbGxlZCBvbmNlXG4gICAgdGhpcy5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQgPSBmYWxzZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aGlzLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBob3N0UGFyZW50XG4gICAqIEBwYXJhbSB7P29iamVjdH0gaG9zdENvbnRhaW5lckluZm9cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IG5leHRNb3VudElEKys7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcblxuICAgIHZhciBwdWJsaWNQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciBwdWJsaWNDb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQoY29udGV4dCk7XG5cbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHRyYW5zYWN0aW9uLmdldFVwZGF0ZVF1ZXVlKCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBwdWJsaWMgY2xhc3NcbiAgICB2YXIgZG9Db25zdHJ1Y3QgPSBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KTtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICB2YXIgcmVuZGVyZWRFbGVtZW50O1xuXG4gICAgLy8gU3VwcG9ydCBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgICBpZiAoIWRvQ29uc3RydWN0ICYmIChpbnN0ID09IG51bGwgfHwgaW5zdC5yZW5kZXIgPT0gbnVsbCkpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IGluc3Q7XG4gICAgICB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIHJlbmRlcmVkRWxlbWVudCk7XG4gICAgICAhKGluc3QgPT09IG51bGwgfHwgaW5zdCA9PT0gZmFsc2UgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGluc3QpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDUnLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgaW5zdCA9IG5ldyBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KTtcbiAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNQdXJlQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLlB1cmVDbGFzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5JbXB1cmVDbGFzcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGxhdGVyIGluIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQsIGJ1dCBhZGQgYW4gZWFybHlcbiAgICAgIC8vIHdhcm5pbmcgbm93IHRvIGhlbHAgZGVidWdnaW5nXG4gICAgICBpZiAoaW5zdC5yZW5kZXIgPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wc011dGF0ZWQgPSBpbnN0LnByb3BzICE9PSBwdWJsaWNQcm9wcztcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0LnByb3BzID09PSB1bmRlZmluZWQgfHwgIXByb3BzTXV0YXRlZCwgJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyAndXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudFxcJ3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBUaGVzZSBzaG91bGQgYmUgc2V0IHVwIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgLy8gc2ltcGxlciBjbGFzcyBhYnN0cmFjdGlvbnMsIHdlIHNldCB0aGVtIHVwIGFmdGVyIHRoZSBmYWN0LlxuICAgIGluc3QucHJvcHMgPSBwdWJsaWNQcm9wcztcbiAgICBpbnN0LmNvbnRleHQgPSBwdWJsaWNDb250ZXh0O1xuICAgIGluc3QucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgIGluc3QudXBkYXRlciA9IHVwZGF0ZVF1ZXVlO1xuXG4gICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0O1xuXG4gICAgLy8gU3RvcmUgYSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgYmFjayB0byB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICBSZWFjdEluc3RhbmNlTWFwLnNldChpbnN0LCB0aGlzKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBTaW5jZSBwbGFpbiBKUyBjbGFzc2VzIGFyZSBkZWZpbmVkIHdpdGhvdXQgYW55IHNwZWNpYWwgaW5pdGlhbGl6YXRpb25cbiAgICAgIC8vIGxvZ2ljLCB3ZSBjYW4gbm90IGNhdGNoIGNvbW1vbiBlcnJvcnMgZWFybHkuIFRoZXJlZm9yZSwgd2UgaGF2ZSB0b1xuICAgICAgLy8gY2F0Y2ggdGhlbSBoZXJlLCBhdCBpbml0aWFsaXphdGlvbiB0aW1lLCBpbnN0ZWFkLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3QuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3QuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5wcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgJyArICdzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnREaWRVbm1vdW50ICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdC5zdGF0ZSA9IGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA2JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIG1hcmt1cDtcbiAgICBpZiAoaW5zdC51bnN0YWJsZV9oYW5kbGVFcnJvcikge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmcocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChpbnN0LmNvbXBvbmVudERpZE1vdW50KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGludm9rZUNvbXBvbmVudERpZE1vdW50V2l0aFRpbWVyLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRNb3VudCwgaW5zdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICBfY29uc3RydWN0Q29tcG9uZW50OiBmdW5jdGlvbiAoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXIoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcihkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICB9XG4gIH0sXG5cbiAgX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcjogZnVuY3Rpb24gKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgaW5zdGFuY2VPckVsZW1lbnQ7XG4gICAgaWYgKGRvQ29uc3RydWN0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2N0b3InKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zdGFuY2VPckVsZW1lbnQgPSBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBjYW4gc3RpbGwgYmUgYW4gaW5zdGFuY2UgaW4gY2FzZSBvZiBmYWN0b3J5IGNvbXBvbmVudHNcbiAgICAgIC8vIGJ1dCB3ZSdsbCBjb3VudCB0aGlzIGFzIHRpbWUgc3BlbnQgcmVuZGVyaW5nIGFzIHRoZSBtb3JlIGNvbW1vbiBjYXNlLlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdyZW5kZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zdGFuY2VPckVsZW1lbnQgPSBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZU9yRWxlbWVudDtcbiAgfSxcblxuICBwZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmc6IGZ1bmN0aW9uIChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBtYXJrdXA7XG4gICAgdmFyIGNoZWNrcG9pbnQgPSB0cmFuc2FjdGlvbi5jaGVja3BvaW50KCk7XG4gICAgdHJ5IHtcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSb2xsIGJhY2sgdG8gY2hlY2twb2ludCwgaGFuZGxlIGVycm9yICh3aGljaCBtYXkgYWRkIGl0ZW1zIHRvIHRoZSB0cmFuc2FjdGlvbiksIGFuZCB0YWtlIGEgbmV3IGNoZWNrcG9pbnRcbiAgICAgIHRyYW5zYWN0aW9uLnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xuICAgICAgdGhpcy5faW5zdGFuY2UudW5zdGFibGVfaGFuZGxlRXJyb3IoZSk7XG4gICAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUpIHtcbiAgICAgICAgdGhpcy5faW5zdGFuY2Uuc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKHRoaXMuX2luc3RhbmNlLnByb3BzLCB0aGlzLl9pbnN0YW5jZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGNoZWNrcG9pbnQgPSB0cmFuc2FjdGlvbi5jaGVja3BvaW50KCk7XG5cbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LnVubW91bnRDb21wb25lbnQodHJ1ZSk7XG4gICAgICB0cmFuc2FjdGlvbi5yb2xsYmFjayhjaGVja3BvaW50KTtcblxuICAgICAgLy8gVHJ5IGFnYWluIC0gd2UndmUgaW5mb3JtZWQgdGhlIGNvbXBvbmVudCBhYm91dCB0aGUgZXJyb3IsIHNvIHRoZXkgY2FuIHJlbmRlciBhbiBlcnJvciBtZXNzYWdlIHRoaXMgdGltZS5cbiAgICAgIC8vIElmIHRoaXMgdGhyb3dzIGFnYWluLCB0aGUgZXJyb3Igd2lsbCBidWJibGUgdXAgKGFuZCBjYW4gYmUgY2F1Z2h0IGJ5IGEgaGlnaGVyIGVycm9yIGJvdW5kYXJ5KS5cbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgcGVyZm9ybUluaXRpYWxNb3VudDogZnVuY3Rpb24gKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsTW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2hlbiBtb3VudGluZywgY2FsbHMgdG8gYHNldFN0YXRlYCBieSBgY29tcG9uZW50V2lsbE1vdW50YCB3aWxsIHNldFxuICAgICAgLy8gYHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlYCB3aXRob3V0IHRyaWdnZXJpbmcgYSByZS1yZW5kZXIuXG4gICAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUpIHtcbiAgICAgICAgaW5zdC5zdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUoaW5zdC5wcm9wcywgaW5zdC5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBub3QgYSBzdGF0ZWxlc3MgY29tcG9uZW50LCB3ZSBub3cgcmVuZGVyXG4gICAgaWYgKHJlbmRlcmVkRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZVR5cGUgPSBSZWFjdE5vZGVUeXBlcy5nZXRUeXBlKHJlbmRlcmVkRWxlbWVudCk7XG4gICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG5vZGVUeXBlO1xuICAgIHZhciBjaGlsZCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQocmVuZGVyZWRFbGVtZW50LCBub2RlVHlwZSAhPT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkgLyogc2hvdWxkSGF2ZURlYnVnSUQgKi9cbiAgICApO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gY2hpbGQ7XG5cbiAgICB2YXIgc2VsZkRlYnVnSUQgPSAwO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzZWxmRGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgfVxuICAgIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSwgc2VsZkRlYnVnSUQpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIGNoaWxkLl9kZWJ1Z0lEICE9PSAwID8gW2NoaWxkLl9kZWJ1Z0lEXSA6IFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZSh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICBpZiAoIXRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCAmJiAhaW5zdC5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQpIHtcbiAgICAgIGluc3QuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50ID0gdHJ1ZTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNhZmVseSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0TmFtZSgpICsgJy5jb21wb25lbnRXaWxsVW5tb3VudCgpJztcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50LmJpbmQoaW5zdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHNhZmVseSk7XG4gICAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbnVsbDtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBwZW5kaW5nIGZpZWxkc1xuICAgIC8vIEV2ZW4gaWYgdGhpcyBjb21wb25lbnQgaXMgc2NoZWR1bGVkIGZvciBhbm90aGVyIHVwZGF0ZSBpbiBSZWFjdFVwZGF0ZXMsXG4gICAgLy8gaXQgd291bGQgc3RpbGwgYmUgaWdub3JlZCBiZWNhdXNlIHRoZXNlIGZpZWxkcyBhcmUgcmVzZXQuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICAvLyBUaGVzZSBmaWVsZHMgZG8gbm90IHJlYWxseSBuZWVkIHRvIGJlIHJlc2V0IHNpbmNlIHRoaXMgb2JqZWN0IGlzIG5vXG4gICAgLy8gbG9uZ2VyIGFjY2Vzc2libGUuXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIERlbGV0ZSB0aGUgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIHRvIHRoaXMgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICAvLyB3aGljaCBhbGxvdyB0aGUgaW50ZXJuYWxzIHRvIGJlIHByb3Blcmx5IGNsZWFuZWQgdXAgZXZlbiBpZiB0aGUgdXNlclxuICAgIC8vIGxlYWtzIGEgcmVmZXJlbmNlIHRvIHRoZSBwdWJsaWMgaW5zdGFuY2UuXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5yZW1vdmUoaW5zdCk7XG5cbiAgICAvLyBTb21lIGV4aXN0aW5nIGNvbXBvbmVudHMgcmVseSBvbiBpbnN0LnByb3BzIGV2ZW4gYWZ0ZXIgdGhleSd2ZSBiZWVuXG4gICAgLy8gZGVzdHJveWVkIChpbiBldmVudCBoYW5kbGVycykuXG4gICAgLy8gVE9ETzogaW5zdC5wcm9wcyA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5zdGF0ZSA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5jb250ZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFza0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jb250ZXh0VHlwZXM7XG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgICB9XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB7fTtcbiAgICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIG1hc2tlZENvbnRleHRbY29udGV4dE5hbWVdID0gY29udGV4dFtjb250ZXh0TmFtZV07XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2AsIGFuZCBhc3NlcnRzIHRoYXQgdGhleSBhcmUgdmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB0aGlzLl9tYXNrQ29udGV4dChjb250ZXh0KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICBpZiAoQ29tcG9uZW50LmNvbnRleHRUeXBlcykge1xuICAgICAgICB0aGlzLl9jaGVja0NvbnRleHRUeXBlcyhDb21wb25lbnQuY29udGV4dFR5cGVzLCBtYXNrZWRDb250ZXh0LCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRDb250ZXh0XG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoY3VycmVudENvbnRleHQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQoKTtcbiAgICB9XG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0ICYmIGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQoKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkQ29udGV4dCkge1xuICAgICAgISh0eXBlb2YgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byB1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA3JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aGlzLl9jaGVja0NvbnRleHRUeXBlcyhDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jaGlsZENvbnRleHQpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgICAgIShuYW1lIGluIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnMTA4JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2Fzc2lnbih7fSwgY3VycmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50Q29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgdGhlIGNvbnRleHQgdHlwZXMgYXJlIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIGNvbnRleHQgZmllbGQgdG8gYSBSZWFjdFByb3BUeXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tDb250ZXh0VHlwZXM6IGZ1bmN0aW9uICh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24pIHtcbiAgICBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCB0aGlzLmdldE5hbWUoKSwgbnVsbCwgdGhpcy5fZGVidWdJRCk7XG4gIH0sXG5cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgbmV4dENvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgcHJldkNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgcHJldkNvbnRleHQsIG5leHRDb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgYW55IG9mIGBfcGVuZGluZ0VsZW1lbnRgLCBgX3BlbmRpbmdTdGF0ZVF1ZXVlYCwgb3IgYF9wZW5kaW5nRm9yY2VVcGRhdGVgXG4gICAqIGlzIHNldCwgdXBkYXRlIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudCh0aGlzLCB0aGlzLl9wZW5kaW5nRWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX2NvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgIT09IG51bGwgfHwgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlQmF0Y2hOdW1iZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybSBhbiB1cGRhdGUgdG8gYSBtb3VudGVkIGNvbXBvbmVudC4gVGhlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgYW5kXG4gICAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSBtZXRob2RzIGFyZSBjYWxsZWQsIHRoZW4gKGFzc3VtaW5nIHRoZSB1cGRhdGUgaXNuJ3RcbiAgICogc2tpcHBlZCkgdGhlIHJlbWFpbmluZyB1cGRhdGUgbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGNhbGxlZCBhbmQgdGhlIERPTVxuICAgKiByZXByZXNlbnRhdGlvbiBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZQYXJlbnRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0UGFyZW50RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldlBhcmVudEVsZW1lbnQsIG5leHRQYXJlbnRFbGVtZW50LCBwcmV2VW5tYXNrZWRDb250ZXh0LCBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQXR0ZW1wdGVkIHRvIHVwZGF0ZSBjb21wb25lbnQgYCVzYCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gdW5tb3VudGVkIChvciBmYWlsZWQgdG8gbW91bnQpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEzNicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgdmFyIHdpbGxSZWNlaXZlID0gZmFsc2U7XG4gICAgdmFyIG5leHRDb250ZXh0O1xuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBjb250ZXh0IGhhcyBjaGFuZ2VkIG9yIG5vdFxuICAgIGlmICh0aGlzLl9jb250ZXh0ID09PSBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgICBuZXh0Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dENvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICAgIHdpbGxSZWNlaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJldlByb3BzID0gcHJldlBhcmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IG5leHRQYXJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gTm90IGEgc2ltcGxlIHN0YXRlIHVwZGF0ZSBidXQgYSBwcm9wcyB1cGRhdGVcbiAgICBpZiAocHJldlBhcmVudEVsZW1lbnQgIT09IG5leHRQYXJlbnRFbGVtZW50KSB7XG4gICAgICB3aWxsUmVjZWl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQW4gdXBkYXRlIGhlcmUgd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgYnV0IGltbWVkaWF0ZWx5IHNldFxuICAgIC8vIF9wZW5kaW5nU3RhdGVRdWV1ZSB3aGljaCB3aWxsIGVuc3VyZSB0aGF0IGFueSBzdGF0ZSB1cGRhdGVzIGdldHNcbiAgICAvLyBpbW1lZGlhdGVseSByZWNvbmNpbGVkIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIG5leHQgYmF0Y2guXG4gICAgaWYgKHdpbGxSZWNlaXZlICYmIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcbiAgICAgIGlmIChpbnN0LnNob3VsZENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdzaG91bGRDb21wb25lbnRVcGRhdGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2hvdWxkVXBkYXRlID0gaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvc2l0ZVR5cGUgPT09IENvbXBvc2l0ZVR5cGVzLlB1cmVDbGFzcykge1xuICAgICAgICAgIHNob3VsZFVwZGF0ZSA9ICFzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwoaW5zdC5zdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgIC8vIFdpbGwgc2V0IGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YC5cbiAgICAgIHRoaXMuX3BlcmZvcm1Db21wb25lbnRVcGRhdGUobmV4dFBhcmVudEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGRldGVybWluZWQgdGhhdCBhIGNvbXBvbmVudCBzaG91bGQgbm90IHVwZGF0ZSwgd2Ugc3RpbGwgd2FudFxuICAgICAgLy8gdG8gc2V0IHByb3BzIGFuZCBzdGF0ZSBidXQgd2Ugc2hvcnRjdXQgdGhlIHJlc3Qgb2YgdGhlIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFBhcmVudEVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gbmV4dFVubWFza2VkQ29udGV4dDtcbiAgICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgfVxuICB9LFxuXG4gIF9wcm9jZXNzUGVuZGluZ1N0YXRlOiBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlO1xuICAgIHZhciByZXBsYWNlID0gdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZTtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuXG4gICAgaWYgKCFxdWV1ZSkge1xuICAgICAgcmV0dXJuIGluc3Quc3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2UgJiYgcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcXVldWVbMF07XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IF9hc3NpZ24oe30sIHJlcGxhY2UgPyBxdWV1ZVswXSA6IGluc3Quc3RhdGUpO1xuICAgIGZvciAodmFyIGkgPSByZXBsYWNlID8gMSA6IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcnRpYWwgPSBxdWV1ZVtpXTtcbiAgICAgIF9hc3NpZ24obmV4dFN0YXRlLCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIHByb3BzLCBjb250ZXh0KSA6IHBhcnRpYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lcmdlcyBuZXcgcHJvcHMgYW5kIHN0YXRlLCBub3RpZmllcyBkZWxlZ2F0ZSBtZXRob2RzIG9mIHVwZGF0ZSBhbmRcbiAgICogcGVyZm9ybXMgdXBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgTmV4dCBlbGVtZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHMgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZSBOZXh0IG9iamVjdCB0byBzZXQgYXMgc3RhdGUuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHQgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdW5tYXNrZWRDb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIGhhc0NvbXBvbmVudERpZFVwZGF0ZSA9IEJvb2xlYW4oaW5zdC5jb21wb25lbnREaWRVcGRhdGUpO1xuICAgIHZhciBwcmV2UHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZTtcbiAgICB2YXIgcHJldkNvbnRleHQ7XG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgcHJldlByb3BzID0gaW5zdC5wcm9wcztcbiAgICAgIHByZXZTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgICBwcmV2Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMuX2NvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gICAgdGhpcy5fdXBkYXRlUmVuZGVyZWRDb21wb25lbnQodHJhbnNhY3Rpb24sIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGludm9rZUNvbXBvbmVudERpZFVwZGF0ZVdpdGhUaW1lci5iaW5kKHRoaXMsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIGluc3QpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgY29tcG9uZW50J3MgYHJlbmRlcmAgbWV0aG9kIGFuZCB1cGRhdGUgdGhlIERPTSBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF91cGRhdGVSZW5kZXJlZENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZDb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIHZhciBwcmV2UmVuZGVyZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgbmV4dFJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2UmVuZGVyZWRFbGVtZW50LCBuZXh0UmVuZGVyZWRFbGVtZW50KSkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBuZXh0UmVuZGVyZWRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbGRIb3N0Tm9kZSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBmYWxzZSk7XG5cbiAgICAgIHZhciBub2RlVHlwZSA9IFJlYWN0Tm9kZVR5cGVzLmdldFR5cGUobmV4dFJlbmRlcmVkRWxlbWVudCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbm9kZVR5cGU7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRSZW5kZXJlZEVsZW1lbnQsIG5vZGVUeXBlICE9PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSAvKiBzaG91bGRIYXZlRGVidWdJRCAqL1xuICAgICAgKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gY2hpbGQ7XG5cbiAgICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZWxmRGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dE1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIHRoaXMuX2hvc3RQYXJlbnQsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpLCBzZWxmRGVidWdJRCk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgY2hpbGQuX2RlYnVnSUQgIT09IDAgPyBbY2hpbGQuX2RlYnVnSURdIDogW10pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRIb3N0Tm9kZSwgbmV4dE1hcmt1cCwgcHJldkNvbXBvbmVudEluc3RhbmNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRkZW4gaW4gc2hhbGxvdyByZW5kZXJpbmcuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9yZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGZ1bmN0aW9uIChvbGRIb3N0Tm9kZSwgbmV4dE1hcmt1cCwgcHJldkluc3RhbmNlKSB7XG4gICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVuZGVyZWRDb21wb25lbnQgPSBpbnN0LnJlbmRlcigpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAncmVuZGVyJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgaWYgKHJlbmRlcmVkQ29tcG9uZW50ID09PSB1bmRlZmluZWQgJiYgaW5zdC5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgIHJlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyZWRDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlbmRlcmVkQ29tcG9uZW50O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nIHx8IHRoaXMuX2NvbXBvc2l0ZVR5cGUgIT09IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWwpIHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlZENvbXBvbmVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCgpO1xuICAgIH1cbiAgICAhKFxuICAgIC8vIFRPRE86IEFuIGBpc1ZhbGlkTm9kZWAgZnVuY3Rpb24gd291bGQgcHJvYmFibHkgYmUgbW9yZSBhcHByb3ByaWF0ZVxuICAgIHJlbmRlcmVkQ29tcG9uZW50ID09PSBudWxsIHx8IHJlbmRlcmVkQ29tcG9uZW50ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocmVuZGVyZWRDb21wb25lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5yZW5kZXIoKTogQSB2YWxpZCBSZWFjdCBlbGVtZW50IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwOScsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgcmV0dXJuIHJlbmRlcmVkQ29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMYXppbHkgYWxsb2NhdGVzIHRoZSByZWZzIG9iamVjdCBhbmQgc3RvcmVzIGBjb21wb25lbnRgIGFzIGByZWZgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIFJlZmVyZW5jZSBuYW1lLlxuICAgKiBAcGFyYW0ge2NvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBzdG9yZSBhcyBgcmVmYC5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhdHRhY2hSZWY6IGZ1bmN0aW9uIChyZWYsIGNvbXBvbmVudCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICEoaW5zdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogX3Byb2RJbnZhcmlhbnQoJzExMCcpIDogdm9pZCAwO1xuICAgIHZhciBwdWJsaWNDb21wb25lbnRJbnN0YW5jZSA9IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudCAmJiBjb21wb25lbnQuZ2V0TmFtZSA/IGNvbXBvbmVudC5nZXROYW1lKCkgOiAnYSBjb21wb25lbnQnO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHVibGljQ29tcG9uZW50SW5zdGFuY2UgIT0gbnVsbCwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzICcgKyAnKFNlZSByZWYgXCIlc1wiIGluICVzIGNyZWF0ZWQgYnkgJXMpLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJywgcmVmLCBjb21wb25lbnROYW1lLCB0aGlzLmdldE5hbWUoKSkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciByZWZzID0gaW5zdC5yZWZzID09PSBlbXB0eU9iamVjdCA/IGluc3QucmVmcyA9IHt9IDogaW5zdC5yZWZzO1xuICAgIHJlZnNbcmVmXSA9IHB1YmxpY0NvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRhY2hlcyBhIHJlZmVyZW5jZSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgdG8gZGVyZWZlcmVuY2UuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGV0YWNoUmVmOiBmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIHJlZnMgPSB0aGlzLmdldFB1YmxpY0luc3RhbmNlKCkucmVmcztcbiAgICBkZWxldGUgcmVmc1tyZWZdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSB0ZXh0IGRlc2NyaXB0aW9uIG9mIHRoZSBjb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSBpdFxuICAgKiBpbiBlcnJvciBtZXNzYWdlcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmFtZSBvciBudWxsLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldE5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5faW5zdGFuY2UgJiYgdGhpcy5faW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLm5hbWUgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBwdWJsaWNseSBhY2Nlc3NpYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50IC0gaS5lLiB3aGF0XG4gICAqIGlzIGV4cG9zZWQgYnkgcmVmcyBhbmQgcmV0dXJuZWQgYnkgcmVuZGVyLiBDYW4gYmUgbnVsbCBmb3Igc3RhdGVsZXNzXG4gICAqIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSB0aGUgcHVibGljIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgaWYgKHRoaXMuX2NvbXBvc2l0ZVR5cGUgPT09IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdDtcbiAgfSxcblxuICAvLyBTdHViXG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBudWxsXG5cbn07XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHtcblxuICBNaXhpbjogUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpblxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3ROb2RlVHlwZXNcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Tm9kZVR5cGVzID0ge1xuICBIT1NUOiAwLFxuICBDT01QT1NJVEU6IDEsXG4gIEVNUFRZOiAyLFxuXG4gIGdldFR5cGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5FTVBUWTtcbiAgICB9IGVsc2UgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgaWYgKHR5cGVvZiBub2RlLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkNPTVBPU0lURTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5IT1NUO1xuICAgICAgfVxuICAgIH1cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBub2RlOiAlcycsIG5vZGUpIDogX3Byb2RJbnZhcmlhbnQoJzI2Jywgbm9kZSkgOiB2b2lkIDA7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3ROb2RlVHlwZXM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE5vZGVUeXBlcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICogXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKHggPT09IHkpIHtcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGEgYHByZXZFbGVtZW50YCBhbmQgYG5leHRFbGVtZW50YCwgZGV0ZXJtaW5lcyBpZiB0aGUgZXhpc3RpbmdcbiAqIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkIGFzIG9wcG9zZWQgdG8gYmVpbmcgZGVzdHJveWVkIG9yIHJlcGxhY2VkIGJ5IGEgbmV3XG4gKiBpbnN0YW5jZS4gQm90aCBhcmd1bWVudHMgYXJlIGVsZW1lbnRzLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGlzIGxvZ2ljIGNhblxuICogb3BlcmF0ZSBvbiBzdGF0ZWxlc3MgdHJlZXMgd2l0aG91dCBhbnkgYmFja2luZyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IHByZXZFbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG5leHRFbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBleGlzdGluZyBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZC5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgdmFyIHByZXZFbXB0eSA9IHByZXZFbGVtZW50ID09PSBudWxsIHx8IHByZXZFbGVtZW50ID09PSBmYWxzZTtcbiAgdmFyIG5leHRFbXB0eSA9IG5leHRFbGVtZW50ID09PSBudWxsIHx8IG5leHRFbGVtZW50ID09PSBmYWxzZTtcbiAgaWYgKHByZXZFbXB0eSB8fCBuZXh0RW1wdHkpIHtcbiAgICByZXR1cm4gcHJldkVtcHR5ID09PSBuZXh0RW1wdHk7XG4gIH1cblxuICB2YXIgcHJldlR5cGUgPSB0eXBlb2YgcHJldkVsZW1lbnQ7XG4gIHZhciBuZXh0VHlwZSA9IHR5cGVvZiBuZXh0RWxlbWVudDtcbiAgaWYgKHByZXZUeXBlID09PSAnc3RyaW5nJyB8fCBwcmV2VHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdzdHJpbmcnIHx8IG5leHRUeXBlID09PSAnbnVtYmVyJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIHByZXZFbGVtZW50LnR5cGUgPT09IG5leHRFbGVtZW50LnR5cGUgJiYgcHJldkVsZW1lbnQua2V5ID09PSBuZXh0RWxlbWVudC5rZXk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RW1wdHlDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUNvbXBvbmVudEZhY3Rvcnk7XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RFbXB0eUNvbXBvbmVudEZhY3Rvcnk6IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgZW1wdHlDb21wb25lbnRGYWN0b3J5ID0gZmFjdG9yeTtcbiAgfVxufTtcblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XG4gICAgcmV0dXJuIGVtcHR5Q29tcG9uZW50RmFjdG9yeShpbnN0YW50aWF0ZSk7XG4gIH1cbn07XG5cblJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uID0gUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVtcHR5Q29tcG9uZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEhvc3RDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgZ2VuZXJpY0NvbXBvbmVudENsYXNzID0gbnVsbDtcbi8vIFRoaXMgcmVnaXN0cnkga2VlcHMgdHJhY2sgb2Ygd3JhcHBlciBjbGFzc2VzIGFyb3VuZCBob3N0IHRhZ3MuXG52YXIgdGFnVG9Db21wb25lbnRDbGFzcyA9IHt9O1xudmFyIHRleHRDb21wb25lbnRDbGFzcyA9IG51bGw7XG5cbnZhciBSZWFjdEhvc3RDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIC8vIFRoaXMgYWNjZXB0cyBhIGNsYXNzIHRoYXQgcmVjZWl2ZXMgdGhlIHRhZyBzdHJpbmcuIFRoaXMgaXMgYSBjYXRjaCBhbGxcbiAgLy8gdGhhdCBjYW4gcmVuZGVyIGFueSBraW5kIG9mIHRhZy5cbiAgaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEgdGV4dCBjb21wb25lbnQgY2xhc3MgdGhhdCB0YWtlcyB0aGUgdGV4dCBzdHJpbmcgdG8gYmVcbiAgLy8gcmVuZGVyZWQgYXMgcHJvcHMuXG4gIGluamVjdFRleHRDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgdGV4dENvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XG4gIH0sXG4gIC8vIFRoaXMgYWNjZXB0cyBhIGtleWVkIG9iamVjdCB3aXRoIGNsYXNzZXMgYXMgdmFsdWVzLiBFYWNoIGtleSByZXByZXNlbnRzIGFcbiAgLy8gdGFnLiBUaGF0IHBhcnRpY3VsYXIgdGFnIHdpbGwgdXNlIHRoaXMgY2xhc3MgaW5zdGVhZCBvZiB0aGUgZ2VuZXJpYyBvbmUuXG4gIGluamVjdENvbXBvbmVudENsYXNzZXM6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzc2VzKSB7XG4gICAgX2Fzc2lnbih0YWdUb0NvbXBvbmVudENsYXNzLCBjb21wb25lbnRDbGFzc2VzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSBob3N0IGludGVybmFsIGNvbXBvbmVudCBjbGFzcyBmb3IgYSBzcGVjaWZpYyB0YWcuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gY3JlYXRlLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBpbnRlcm5hbCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCkge1xuICAhZ2VuZXJpY0NvbXBvbmVudENsYXNzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIGlzIG5vIHJlZ2lzdGVyZWQgY29tcG9uZW50IGZvciB0aGUgdGFnICVzJywgZWxlbWVudC50eXBlKSA6IF9wcm9kSW52YXJpYW50KCcxMTEnLCBlbGVtZW50LnR5cGUpIDogdm9pZCAwO1xuICByZXR1cm4gbmV3IGdlbmVyaWNDb21wb25lbnRDbGFzcyhlbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0VGV4dH0gdGV4dFxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlRm9yVGV4dCh0ZXh0KSB7XG4gIHJldHVybiBuZXcgdGV4dENvbXBvbmVudENsYXNzKHRleHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gY29tcG9uZW50IGluc3RhbmNlb2YgdGV4dENvbXBvbmVudENsYXNzO1xufVxuXG52YXIgUmVhY3RIb3N0Q29tcG9uZW50ID0ge1xuICBjcmVhdGVJbnRlcm5hbENvbXBvbmVudDogY3JlYXRlSW50ZXJuYWxDb21wb25lbnQsXG4gIGNyZWF0ZUluc3RhbmNlRm9yVGV4dDogY3JlYXRlSW5zdGFuY2VGb3JUZXh0LFxuICBpc1RleHRDb21wb25lbnQ6IGlzVGV4dENvbXBvbmVudCxcbiAgaW5qZWN0aW9uOiBSZWFjdEhvc3RDb21wb25lbnRJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RIb3N0Q29tcG9uZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RIb3N0Q29tcG9uZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZsYXR0ZW5DaGlsZHJlblxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgcGFzc2VkIHRocm91Z2ggdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/UmVhY3RDb21wb25lbnR9IGNoaWxkIFJlYWN0IGNoaWxkIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBTdHJpbmcgbmFtZSBvZiBrZXkgcGF0aCB0byBjaGlsZC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gc2VsZkRlYnVnSUQgT3B0aW9uYWwgZGVidWdJRCBvZiB0aGUgY3VycmVudCBpbnRlcm5hbCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIGlmICh0cmF2ZXJzZUNvbnRleHQgJiYgdHlwZW9mIHRyYXZlcnNlQ29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhdmVyc2VDb250ZXh0O1xuICAgIHZhciBrZXlVbmlxdWUgPSByZXN1bHRbbmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XG4gICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICAgIH1cbiAgICAgIGlmICgha2V5VW5pcXVlKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJXMnLCBLZXlFc2NhcGVVdGlscy51bmVzY2FwZShuYW1lKSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChzZWxmRGVidWdJRCkpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5VW5pcXVlICYmIGNoaWxkICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdFtuYW1lXSA9IGNoaWxkO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEZsYXR0ZW5zIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC4gQW55IG51bGxcbiAqIGNoaWxkcmVuIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LlxuICogQHJldHVybiB7IW9iamVjdH0gZmxhdHRlbmVkIGNoaWxkcmVuIGtleWVkIGJ5IG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbiwgc2VsZkRlYnVnSUQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgICAgIHJldHVybiBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCk7XG4gICAgfSwgcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgcmVzdWx0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW5DaGlsZHJlbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2ZsYXR0ZW5DaGlsZHJlbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0U2VydmVyVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyVXBkYXRlUXVldWUnKTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW107XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRSQU5TQUNUSU9OX1dSQVBQRVJTLnB1c2goe1xuICAgIGluaXRpYWxpemU6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2gsXG4gICAgY2xvc2U6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoXG4gIH0pO1xufVxuXG52YXIgbm9vcENhbGxiYWNrUXVldWUgPSB7XG4gIGVucXVldWU6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG4vKipcbiAqIEBjbGFzcyBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlclRvU3RhdGljTWFya3VwXG4gKi9cbmZ1bmN0aW9uIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ocmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9IGZhbHNlO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbmV3IFJlYWN0U2VydmVyVXBkYXRlUXVldWUodGhpcyk7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheX0gRW1wdHkgbGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbm9vcENhbGxiYWNrUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgUmVhY3QgYXN5bmMgZXZlbnRzLlxuICAgKi9cbiAgZ2V0VXBkYXRlUXVldWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge30sXG5cbiAgY2hlY2twb2ludDogZnVuY3Rpb24gKCkge30sXG5cbiAgcm9sbGJhY2s6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG5fYXNzaWduKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZVxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvdXRzaWRlIGNvbXBvbmVudFdpbGxNb3VudCgpIG9uIHRoZSBzZXJ2ZXIuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB1cGRhdGUgcXVldWUgdXNlZCBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAqIEl0IGRlbGVnYXRlcyB0byBSZWFjdFVwZGF0ZVF1ZXVlIHdoaWxlIHNlcnZlciByZW5kZXJpbmcgaXMgaW4gcHJvZ3Jlc3MgYW5kXG4gKiBzd2l0Y2hlcyB0byBSZWFjdE5vb3BVcGRhdGVRdWV1ZSBhZnRlciB0aGUgdHJhbnNhY3Rpb24gaGFzIGNvbXBsZXRlZC5cbiAqIEBjbGFzcyBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICovXG5cbnZhciBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAvKiA6OiB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb247ICovXG5cbiAgZnVuY3Rpb24gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSh0cmFuc2FjdGlvbikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlKTtcblxuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuaXNNb3VudGVkID0gZnVuY3Rpb24gaXNNb3VudGVkKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZUNhbGxiYWNrID0gZnVuY3Rpb24gZW5xdWV1ZUNhbGxiYWNrKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFjayhwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZUZvcmNlVXBkYXRlID0gZnVuY3Rpb24gZW5xdWV1ZUZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlUmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gZW5xdWV1ZVJlcGxhY2VTdGF0ZShwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVSZXBsYWNlU3RhdGUocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlU2V0U3RhdGUgPSBmdW5jdGlvbiBlbnF1ZXVlU2V0U3RhdGUocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVTZXRTdGF0ZShwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFVwZGF0ZVF1ZXVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpIHtcbiAgUmVhY3RVcGRhdGVzLmVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChhcmcpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnO1xuICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICB2YXIgZGlzcGxheU5hbWUgPSBhcmcuY29uc3RydWN0b3IgJiYgYXJnLmNvbnN0cnVjdG9yLm5hbWUgfHwgdHlwZTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICBpZiAoa2V5cy5sZW5ndGggPiAwICYmIGtleXMubGVuZ3RoIDwgMjApIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWUgKyAnIChrZXlzOiAnICsga2V5cy5qb2luKCcsICcpICsgJyknO1xuICB9XG4gIHJldHVybiBkaXNwbGF5TmFtZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICAgIC8vIE9ubHkgd2FybiB3aGVuIHdlIGhhdmUgYSBjYWxsZXJOYW1lLiBPdGhlcndpc2Ugd2Ugc2hvdWxkIGJlIHNpbGVudC5cbiAgICAgIC8vIFdlJ3JlIHByb2JhYmx5IGNhbGxpbmcgZnJvbSBlbnF1ZXVlQ2FsbGJhY2suIFdlIGRvbid0IHdhbnQgdG8gd2FyblxuICAgICAgLy8gdGhlcmUgYmVjYXVzZSB3ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgbGlmZWN5Y2xlIG1ldGhvZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjYWxsZXJOYW1lLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGN0b3IgJiYgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnJXMoLi4uKTogQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyAnICsgJ3dpdGhpbiBgcmVuZGVyYCBvciBhbm90aGVyIGNvbXBvbmVudFxcJ3MgY29uc3RydWN0b3IpLiBSZW5kZXIgbWV0aG9kcyAnICsgJ3Nob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyBjb25zdHJ1Y3RvciAnICsgJ3NpZGUtZWZmZWN0cyBhcmUgYW4gYW50aS1wYXR0ZXJuLCBidXQgY2FuIGJlIG1vdmVkIHRvICcgKyAnYGNvbXBvbmVudFdpbGxNb3VudGAuJywgY2FsbGVyTmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBSZWFjdFVwZGF0ZVF1ZXVlIGFsbG93cyBmb3Igc3RhdGUgdXBkYXRlcyB0byBiZSBzY2hlZHVsZWQgaW50byBhIGxhdGVyXG4gKiByZWNvbmNpbGlhdGlvbiBzdGVwLlxuICovXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICAvLyBEdXJpbmcgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXIgdGhpcyB3aWxsIHN0aWxsIGJlIG51bGwgYnV0IGFmdGVyXG4gICAgICAvLyB0aGF0IHdpbGwgYWx3YXlzIHJlbmRlciB0byBzb21ldGhpbmcuIEF0IGxlYXN0IGZvciBub3cuIFNvIHdlIGNhbiB1c2VcbiAgICAgIC8vIHRoaXMgaGFjay5cbiAgICAgIHJldHVybiAhIWludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhbGxlck5hbWUgTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLnZhbGlkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGNhbGxlck5hbWUpO1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcblxuICAgIC8vIFByZXZpb3VzbHkgd2Ugd291bGQgdGhyb3cgYW4gZXJyb3IgaWYgd2UgZGlkbid0IGhhdmUgYW4gaW50ZXJuYWxcbiAgICAvLyBpbnN0YW5jZS4gU2luY2Ugd2Ugd2FudCB0byBtYWtlIGl0IGEgbm8tb3AgaW5zdGVhZCwgd2UgbWlycm9yIHRoZSBzYW1lXG4gICAgLy8gYmVoYXZpb3Igd2UgaGF2ZSBpbiBvdGhlciBlbnF1ZXVlKiBtZXRob2RzLlxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBpZ25vcmUgY2FsbGJhY2tzIGluIGNvbXBvbmVudFdpbGxNb3VudC4gU2VlXG4gICAgLy8gZW5xdWV1ZVVwZGF0ZXMuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICAgIC8vIFRPRE86IFRoZSBjYWxsYmFjayBoZXJlIGlzIGlnbm9yZWQgd2hlbiBzZXRTdGF0ZSBpcyBjYWxsZWQgZnJvbVxuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudC4gRWl0aGVyIGZpeCBpdCBvciBkaXNhbGxvdyBkb2luZyBzbyBjb21wbGV0ZWx5IGluXG4gICAgLy8gZmF2b3Igb2YgZ2V0SW5pdGlhbFN0YXRlLiBBbHRlcm5hdGl2ZWx5LCB3ZSBjYW4gZGlzYWxsb3dcbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgZHVyaW5nIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIGVucXVldWVDYWxsYmFja0ludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtjb21wbGV0ZVN0YXRlXTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gdHJ1ZTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldFN0YXRlKCk7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwYXJ0aWFsU3RhdGUgIT0gbnVsbCwgJ3NldFN0YXRlKC4uLik6IFlvdSBwYXNzZWQgYW4gdW5kZWZpbmVkIG9yIG51bGwgc3RhdGUgb2JqZWN0OyAnICsgJ2luc3RlYWQsIHVzZSBmb3JjZVVwZGF0ZSgpLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBxdWV1ZSA9IGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlIHx8IChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtdKTtcbiAgICBxdWV1ZS5wdXNoKHBhcnRpYWxTdGF0ZSk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIGVucXVldWVFbGVtZW50SW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXh0RWxlbWVudCwgbmV4dENvbnRleHQpIHtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIC8vIFRPRE86IGludHJvZHVjZSBfcGVuZGluZ0NvbnRleHQgaW5zdGVhZCBvZiBzZXR0aW5nIGl0IGRpcmVjdGx5LlxuICAgIGludGVybmFsSW5zdGFuY2UuX2NvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIHZhbGlkYXRlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgICEoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQoY2FsbGJhY2spKSA6IF9wcm9kSW52YXJpYW50KCcxMjInLCBjYWxsZXJOYW1lLCBmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQoY2FsbGJhY2spKSA6IHZvaWQgMDtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlUXVldWU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFVwZGF0ZVF1ZXVlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHZhbGlkYXRlRE9NTmVzdGluZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBUaGlzIHZhbGlkYXRpb24gY29kZSB3YXMgd3JpdHRlbiBiYXNlZCBvbiB0aGUgSFRNTDUgcGFyc2luZyBzcGVjOlxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICAvL1xuICAvLyBOb3RlOiB0aGlzIGRvZXMgbm90IGNhdGNoIGFsbCBpbnZhbGlkIG5lc3RpbmcsIG5vciBkb2VzIGl0IHRyeSB0byAoYXMgaXQnc1xuICAvLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxuICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlIHBhcnNlciB3aWxsIGdpdmUgYSBwYXJzZSB0cmVlIGRpZmZlcmluZyBmcm9tIHdoYXQgUmVhY3RcbiAgLy8gaW50ZW5kZWQuIEZvciBleGFtcGxlLCA8Yj48ZGl2PjwvZGl2PjwvYj4gaXMgaW52YWxpZCBidXQgd2UgZG9uJ3Qgd2FyblxuICAvLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXG4gIC8vIDxwPiB0YWdzIHdoZXJlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY29uZCBlbGVtZW50IGltcGxpY2l0bHkgY2xvc2VzIHRoZVxuICAvLyBmaXJzdCwgY2F1c2luZyBhIGNvbmZ1c2luZyBtZXNzLlxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG5cbiAgdmFyIGVtcHR5QW5jZXN0b3JJbmZvID0ge1xuICAgIGN1cnJlbnQ6IG51bGwsXG5cbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG5cbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdmFyIHVwZGF0ZWRBbmNlc3RvckluZm8gPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnLCBpbnN0YW5jZSkge1xuICAgIHZhciBhbmNlc3RvckluZm8gPSBfYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaHRtbCc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG5cbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICBjYXNlICdsaXN0aW5nJzpcblxuICAgICAgY2FzZSAndGFibGUnOlxuXG4gICAgICBjYXNlICdocic6XG5cbiAgICAgIGNhc2UgJ3htcCc6XG5cbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IGluc3RhbmNlLCByZXR1cm4gYSBsaXN0IG9mIGl0cyByZWN1cnNpdmVcbiAgICogb3duZXJzLCBzdGFydGluZyBhdCB0aGUgcm9vdCBhbmQgZW5kaW5nIHdpdGggdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHZhciBmaW5kT3duZXJTdGFjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICBkbyB7XG4gICAgICBzdGFjay5wdXNoKGluc3RhbmNlKTtcbiAgICB9IHdoaWxlIChpbnN0YW5jZSA9IGluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgIHN0YWNrLnJldmVyc2UoKTtcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkSW5zdGFuY2UsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIHByb2JsZW1hdGljID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG5cbiAgICBpZiAocHJvYmxlbWF0aWMpIHtcbiAgICAgIHZhciBhbmNlc3RvclRhZyA9IHByb2JsZW1hdGljLnRhZztcbiAgICAgIHZhciBhbmNlc3Rvckluc3RhbmNlID0gcHJvYmxlbWF0aWMuaW5zdGFuY2U7XG5cbiAgICAgIHZhciBjaGlsZE93bmVyID0gY2hpbGRJbnN0YW5jZSAmJiBjaGlsZEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lciA9IGFuY2VzdG9ySW5zdGFuY2UgJiYgYW5jZXN0b3JJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICB2YXIgY2hpbGRPd25lcnMgPSBmaW5kT3duZXJTdGFjayhjaGlsZE93bmVyKTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVycyA9IGZpbmRPd25lclN0YWNrKGFuY2VzdG9yT3duZXIpO1xuXG4gICAgICB2YXIgbWluU3RhY2tMZW4gPSBNYXRoLm1pbihjaGlsZE93bmVycy5sZW5ndGgsIGFuY2VzdG9yT3duZXJzLmxlbmd0aCk7XG4gICAgICB2YXIgaTtcblxuICAgICAgdmFyIGRlZXBlc3RDb21tb24gPSAtMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5TdGFja0xlbjsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZE93bmVyc1tpXSA9PT0gYW5jZXN0b3JPd25lcnNbaV0pIHtcbiAgICAgICAgICBkZWVwZXN0Q29tbW9uID0gaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgVU5LTk9XTiA9ICcodW5rbm93biknO1xuICAgICAgdmFyIGNoaWxkT3duZXJOYW1lcyA9IGNoaWxkT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyTmFtZXMgPSBhbmNlc3Rvck93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3duZXJJbmZvID0gW10uY29uY2F0KFxuICAgICAgLy8gSWYgdGhlIHBhcmVudCBhbmQgY2hpbGQgaW5zdGFuY2VzIGhhdmUgYSBjb21tb24gb3duZXIgYW5jZXN0b3IsIHN0YXJ0XG4gICAgICAvLyB3aXRoIHRoYXQgLS0gb3RoZXJ3aXNlIHdlIGp1c3Qgc3RhcnQgd2l0aCB0aGUgcGFyZW50J3Mgb3duZXJzLlxuICAgICAgZGVlcGVzdENvbW1vbiAhPT0gLTEgPyBjaGlsZE93bmVyc1tkZWVwZXN0Q29tbW9uXS5nZXROYW1lKCkgfHwgVU5LTk9XTiA6IFtdLCBhbmNlc3Rvck93bmVyTmFtZXMsIGFuY2VzdG9yVGFnLFxuICAgICAgLy8gSWYgd2UncmUgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIChub24tcGFyZW50KSBhbmNlc3RyeSwgYWRkICcuLi4nXG4gICAgICBpbnZhbGlkQW5jZXN0b3IgPyBbJy4uLiddIDogW10sIGNoaWxkT3duZXJOYW1lcywgY2hpbGRUYWcpLmpvaW4oJyA+ICcpO1xuXG4gICAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBvd25lckluZm87XG4gICAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XG4gICAgICBpZiAoY2hpbGRUYWcgIT09ICcjdGV4dCcpIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnPCcgKyBjaGlsZFRhZyArICc+JztcbiAgICAgIH1cblxuICAgICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiAnICsgJ1NlZSAlcy4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgb3duZXJJbmZvLCBpbmZvKSA6IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4gU2VlICVzLicsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgb3duZXJJbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvO1xuXG4gIC8vIEZvciB0ZXN0aW5nXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGVET01OZXN0aW5nO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NRW1wdHlDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIFJlYWN0RE9NRW1wdHlDb21wb25lbnQgPSBmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgLy8gUmVhY3RDb21wb3NpdGVDb21wb25lbnQgdXNlcyB0aGlzOlxuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gIC8vIFJlYWN0RE9NQ29tcG9uZW50VHJlZSB1c2VzIHRoZXNlOlxuICB0aGlzLl9ob3N0Tm9kZSA9IG51bGw7XG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IG51bGw7XG4gIHRoaXMuX2RvbUlEID0gMDtcbn07XG5fYXNzaWduKFJlYWN0RE9NRW1wdHlDb21wb25lbnQucHJvdG90eXBlLCB7XG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdmFyIGRvbUlEID0gaG9zdENvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xuICAgIHRoaXMuX2RvbUlEID0gZG9tSUQ7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcblxuICAgIHZhciBub2RlVmFsdWUgPSAnIHJlYWN0LWVtcHR5OiAnICsgdGhpcy5fZG9tSUQgKyAnICc7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gaG9zdENvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgbm9kZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChub2RlVmFsdWUpO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBub2RlKTtcbiAgICAgIHJldHVybiBET01MYXp5VHJlZShub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5IHdlJ2QgaW5zZXJ0IGEgY29tbWVudCBub2RlLCBidXQgc2luY2UgdGhpcyBpcyBhIHNpdHVhdGlvblxuICAgICAgICAvLyB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXIgKHN0YXRpYyBwYWdlcyksIHdlIGNhbiBzaW1wbHkgcmV0dXJuXG4gICAgICAgIC8vIG5vdGhpbmcuXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnPCEtLScgKyBub2RlVmFsdWUgKyAnLS0+JztcbiAgICB9XG4gIH0sXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHt9LFxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01FbXB0eUNvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01UcmVlVHJhdmVyc2FsXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuXG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSB0ZW1wQS5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQSsrO1xuICB9XG4gIHZhciBkZXB0aEIgPSAwO1xuICBmb3IgKHZhciB0ZW1wQiA9IGluc3RCOyB0ZW1wQjsgdGVtcEIgPSB0ZW1wQi5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gaW5zdEEuX2hvc3RQYXJlbnQ7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcbiAgICBkZXB0aEItLTtcbiAgfVxuXG4gIC8vIFdhbGsgaW4gbG9ja3N0ZXAgdW50aWwgd2UgZmluZCBhIG1hdGNoLlxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG4gIHdoaWxlIChkZXB0aC0tKSB7XG4gICAgaWYgKGluc3RBID09PSBpbnN0Qikge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGluc3RBLl9ob3N0UGFyZW50O1xuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIGlmIEEgaXMgYW4gYW5jZXN0b3Igb2YgQi5cbiAqL1xuZnVuY3Rpb24gaXNBbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaXNBbmNlc3RvcjogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNScpIDogdm9pZCAwO1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RCKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0FuY2VzdG9yOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM1JykgOiB2b2lkIDA7XG5cbiAgd2hpbGUgKGluc3RCKSB7XG4gICAgaWYgKGluc3RCID09PSBpbnN0QSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXRQYXJlbnRJbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNicpIDogdm9pZCAwO1xuXG4gIHJldHVybiBpbnN0Ll9ob3N0UGFyZW50O1xufVxuXG4vKipcbiAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHdoaWxlIChpbnN0KSB7XG4gICAgcGF0aC5wdXNoKGluc3QpO1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCBmYWxzZSwgYXJnKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhbaV0sIHRydWUsIGFyZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIElEIGhpZXJhcmNoeSBhbmQgaW52b2tlcyB0aGUgc3VwcGxpZWQgYGNiYCBvbiBhbnkgSURzIHRoYXRcbiAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cbiAqXG4gKiBEb2VzIG5vdCBpbnZva2UgdGhlIGNhbGxiYWNrIG9uIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBiZWNhdXNlIG5vdGhpbmdcbiAqIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgdmFyIGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xuICB2YXIgcGF0aEZyb20gPSBbXTtcbiAgd2hpbGUgKGZyb20gJiYgZnJvbSAhPT0gY29tbW9uKSB7XG4gICAgcGF0aEZyb20ucHVzaChmcm9tKTtcbiAgICBmcm9tID0gZnJvbS5faG9zdFBhcmVudDtcbiAgfVxuICB2YXIgcGF0aFRvID0gW107XG4gIHdoaWxlICh0byAmJiB0byAhPT0gY29tbW9uKSB7XG4gICAgcGF0aFRvLnB1c2godG8pO1xuICAgIHRvID0gdG8uX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoRnJvbS5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhGcm9tW2ldLCB0cnVlLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKGkgPSBwYXRoVG8ubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tpXSwgZmFsc2UsIGFyZ1RvKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBbmNlc3RvcjogaXNBbmNlc3RvcixcbiAgZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3I6IGdldExvd2VzdENvbW1vbkFuY2VzdG9yLFxuICBnZXRQYXJlbnRJbnN0YW5jZTogZ2V0UGFyZW50SW5zdGFuY2UsXG4gIHRyYXZlcnNlVHdvUGhhc2U6IHRyYXZlcnNlVHdvUGhhc2UsXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogdHJhdmVyc2VFbnRlckxlYXZlXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01UcmVlVHJhdmVyc2FsLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG4vKipcbiAqIFRleHQgbm9kZXMgdmlvbGF0ZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFJlYWN0IG1ha2VzIGFib3V0IGNvbXBvbmVudHM6XG4gKlxuICogIC0gV2hlbiBtb3VudGluZyB0ZXh0IGludG8gdGhlIERPTSwgYWRqYWNlbnQgdGV4dCBub2RlcyBhcmUgbWVyZ2VkLlxuICogIC0gVGV4dCBub2RlcyBjYW5ub3QgYmUgYXNzaWduZWQgYSBSZWFjdCByb290IElELlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gd3JhcCBzdHJpbmdzIGJldHdlZW4gY29tbWVudCBub2RlcyBzbyB0aGF0IHRoZXlcbiAqIGNhbiB1bmRlcmdvIHRoZSBzYW1lIHJlY29uY2lsaWF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byBlbGVtZW50cy5cbiAqXG4gKiBUT0RPOiBJbnZlc3RpZ2F0ZSByZXByZXNlbnRpbmcgUmVhY3QgY29tcG9uZW50cyBpbiB0aGUgRE9NIHdpdGggdGV4dCBub2Rlcy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdENvbXBvbmVudFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAvLyBUT0RPOiBUaGlzIGlzIHJlYWxseSBhIFJlYWN0VGV4dCAoUmVhY3ROb2RlKSwgbm90IGEgUmVhY3RFbGVtZW50XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gdGV4dDtcbiAgdGhpcy5fc3RyaW5nVGV4dCA9ICcnICsgdGV4dDtcbiAgLy8gUmVhY3RET01Db21wb25lbnRUcmVlIHVzZXMgdGhlc2U6XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG5cbiAgLy8gUHJvcGVydGllc1xuICB0aGlzLl9kb21JRCA9IDA7XG4gIHRoaXMuX21vdW50SW5kZXggPSAwO1xuICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IG51bGw7XG4gIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XG59O1xuXG5fYXNzaWduKFJlYWN0RE9NVGV4dENvbXBvbmVudC5wcm90b3R5cGUsIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgbWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS4gVGhpcyBub2RlIGlzIG5vdCBpbnRlbmRlZCB0byBoYXZlXG4gICAqIGFueSBmZWF0dXJlcyBiZXNpZGVzIGNvbnRhaW5pbmcgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnRJbmZvO1xuICAgICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdFBhcmVudC5fYW5jZXN0b3JJbmZvO1xuICAgICAgfSBlbHNlIGlmIChob3N0Q29udGFpbmVySW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0Q29udGFpbmVySW5mby5fYW5jZXN0b3JJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudEluZm8pIHtcbiAgICAgICAgLy8gcGFyZW50SW5mbyBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgZXhjZXB0IGZvciB0aGUgdG9wLWxldmVsXG4gICAgICAgIC8vIGNvbXBvbmVudCB3aGVuIHNlcnZlciByZW5kZXJpbmdcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKCcjdGV4dCcsIHRoaXMsIHBhcmVudEluZm8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcbiAgICB2YXIgb3BlbmluZ1ZhbHVlID0gJyByZWFjdC10ZXh0OiAnICsgZG9tSUQgKyAnICc7XG4gICAgdmFyIGNsb3NpbmdWYWx1ZSA9ICcgL3JlYWN0LXRleHQgJztcbiAgICB0aGlzLl9kb21JRCA9IGRvbUlEO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICAgICAgdmFyIG9wZW5pbmdDb21tZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KG9wZW5pbmdWYWx1ZSk7XG4gICAgICB2YXIgY2xvc2luZ0NvbW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY2xvc2luZ1ZhbHVlKTtcbiAgICAgIHZhciBsYXp5VHJlZSA9IERPTUxhenlUcmVlKG93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpKTtcbiAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIERPTUxhenlUcmVlKG9wZW5pbmdDb21tZW50KSk7XG4gICAgICBpZiAodGhpcy5fc3RyaW5nVGV4dCkge1xuICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShvd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuX3N0cmluZ1RleHQpKSk7XG4gICAgICB9XG4gICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShjbG9zaW5nQ29tbWVudCkpO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBvcGVuaW5nQ29tbWVudCk7XG4gICAgICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IGNsb3NpbmdDb21tZW50O1xuICAgICAgcmV0dXJuIGxhenlUcmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXNjYXBlZFRleHQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGhpcy5fc3RyaW5nVGV4dCk7XG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIHdyYXAgdGhpcyBiZXR3ZWVuIGNvbW1lbnQgbm9kZXMgZm9yIHRoZSByZWFzb25zIHN0YXRlZFxuICAgICAgICAvLyBhYm92ZSwgYnV0IHNpbmNlIHRoaXMgaXMgYSBzaXR1YXRpb24gd2hlcmUgUmVhY3Qgd29uJ3QgdGFrZSBvdmVyXG4gICAgICAgIC8vIChzdGF0aWMgcGFnZXMpLCB3ZSBjYW4gc2ltcGx5IHJldHVybiB0aGUgdGV4dCBhcyBpdCBpcy5cbiAgICAgICAgcmV0dXJuIGVzY2FwZWRUZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzwhLS0nICsgb3BlbmluZ1ZhbHVlICsgJy0tPicgKyBlc2NhcGVkVGV4dCArICc8IS0tJyArIGNsb3NpbmdWYWx1ZSArICctLT4nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGNvbXBvbmVudCBieSB1cGRhdGluZyB0aGUgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0VGV4dH0gbmV4dFRleHQgVGhlIG5leHQgdGV4dCBjb250ZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dFRleHQsIHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKG5leHRUZXh0ICE9PSB0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0VGV4dDtcbiAgICAgIHZhciBuZXh0U3RyaW5nVGV4dCA9ICcnICsgbmV4dFRleHQ7XG4gICAgICBpZiAobmV4dFN0cmluZ1RleHQgIT09IHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgLy8gVE9ETzogU2F2ZSB0aGlzIGFzIHBlbmRpbmcgcHJvcHMgYW5kIHVzZSBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnlcbiAgICAgICAgLy8gYW5kL29yIHVwZGF0ZUNvbXBvbmVudCB0byBkbyB0aGUgYWN0dWFsIHVwZGF0ZSBmb3IgY29uc2lzdGVuY3kgd2l0aFxuICAgICAgICAvLyBvdGhlciBjb21wb25lbnQgdHlwZXM/XG4gICAgICAgIHRoaXMuX3N0cmluZ1RleHQgPSBuZXh0U3RyaW5nVGV4dDtcbiAgICAgICAgdmFyIGNvbW1lbnROb2RlcyA9IHRoaXMuZ2V0SG9zdE5vZGUoKTtcbiAgICAgICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnJlcGxhY2VEZWxpbWl0ZWRUZXh0KGNvbW1lbnROb2Rlc1swXSwgY29tbWVudE5vZGVzWzFdLCBuZXh0U3RyaW5nVGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvc3ROb2RlID0gdGhpcy5fY29tbWVudE5vZGVzO1xuICAgIGlmIChob3N0Tm9kZSkge1xuICAgICAgcmV0dXJuIGhvc3ROb2RlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Nsb3NpbmdDb21tZW50KSB7XG4gICAgICB2YXIgb3BlbmluZ0NvbW1lbnQgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgICAgIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQubmV4dFNpYmxpbmc7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAhKG5vZGUgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBjbG9zaW5nIGNvbW1lbnQgZm9yIHRleHQgY29tcG9uZW50ICVzJywgdGhpcy5fZG9tSUQpIDogX3Byb2RJbnZhcmlhbnQoJzY3JywgdGhpcy5fZG9tSUQpIDogdm9pZCAwO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyAvcmVhY3QtdGV4dCAnKSB7XG4gICAgICAgICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBub2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBob3N0Tm9kZSA9IFt0aGlzLl9ob3N0Tm9kZSwgdGhpcy5fY2xvc2luZ0NvbW1lbnRdO1xuICAgIHRoaXMuX2NvbW1lbnROb2RlcyA9IGhvc3ROb2RlO1xuICAgIHJldHVybiBob3N0Tm9kZTtcbiAgfSxcblxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dENvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xuXG52YXIgUkVTRVRfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgfVxufTtcblxudmFyIEZMVVNIX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IFJlYWN0VXBkYXRlcy5mbHVzaEJhdGNoZWRVcGRhdGVzLmJpbmQoUmVhY3RVcGRhdGVzKVxufTtcblxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW0ZMVVNIX0JBVENIRURfVVBEQVRFUywgUkVTRVRfQkFUQ0hFRF9VUERBVEVTXTtcblxuZnVuY3Rpb24gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG59XG5cbl9hc3NpZ24oUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfVxufSk7XG5cbnZhciB0cmFuc2FjdGlvbiA9IG5ldyBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKTtcblxudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSB7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzOiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaW4gYSBjb250ZXh0IHdpdGhpbiB3aGljaCBjYWxscyB0byBgc2V0U3RhdGVgXG4gICAqIGFuZCBmcmllbmRzIGFyZSBiYXRjaGVkIHN1Y2ggdGhhdCBjb21wb25lbnRzIGFyZW4ndCB1cGRhdGVkIHVubmVjZXNzYXJpbHkuXG4gICAqL1xuICBiYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XG4gICAgdmFyIGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzO1xuXG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG5cbiAgICAvLyBUaGUgY29kZSBpcyB3cml0dGVuIHRoaXMgd2F5IHRvIGF2b2lkIGV4dHJhIGFsbG9jYXRpb25zXG4gICAgaWYgKGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgIGNhbGxiYWNrKGEsIGIsIGMsIGQsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKGNhbGxiYWNrLCBudWxsLCBhLCBiLCBjLCBkLCBlKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFdmVudExpc3RlbmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xudmFyIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24nKTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IFJlYWN0IGNvbXBvbmVudCBjb21wbGV0ZWx5IGNvbnRhaW5pbmcgdGhlIHJvb3Qgb2YgdGhlXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBmaW5kUGFyZW50KGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3QuX2hvc3RQYXJlbnQpIHtcbiAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcbiAgfVxuICB2YXIgcm9vdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgdmFyIGNvbnRhaW5lciA9IHJvb3ROb2RlLnBhcmVudE5vZGU7XG4gIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUoY29udGFpbmVyKTtcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXG5mdW5jdGlvbiBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICB0aGlzLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICB0aGlzLmFuY2VzdG9ycyA9IFtdO1xufVxuX2Fzc2lnbihUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucHJvdG90eXBlLCB7XG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRvcExldmVsVHlwZSA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmVFdmVudCA9IG51bGw7XG4gICAgdGhpcy5hbmNlc3RvcnMubGVuZ3RoID0gMDtcbiAgfVxufSk7XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLCBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsSW1wbChib29rS2VlcGluZykge1xuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAvLyBMb29wIHRocm91Z2ggdGhlIGhpZXJhcmNoeSwgaW4gY2FzZSB0aGVyZSdzIGFueSBuZXN0ZWQgY29tcG9uZW50cy5cbiAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBidWlsZCB0aGUgYXJyYXkgb2YgYW5jZXN0b3JzIGJlZm9yZSBjYWxsaW5nIGFueVxuICAvLyBldmVudCBoYW5kbGVycywgYmVjYXVzZSBldmVudCBoYW5kbGVycyBjYW4gbW9kaWZ5IHRoZSBET00sIGxlYWRpbmcgdG9cbiAgLy8gaW5jb25zaXN0ZW5jaWVzIHdpdGggUmVhY3RNb3VudCdzIG5vZGUgY2FjaGUuIFNlZSAjMTEwNS5cbiAgdmFyIGFuY2VzdG9yID0gdGFyZ2V0SW5zdDtcbiAgZG8ge1xuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGFuY2VzdG9yICYmIGZpbmRQYXJlbnQoYW5jZXN0b3IpO1xuICB9IHdoaWxlIChhbmNlc3Rvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY3JvbGxWYWx1ZU1vbml0b3IoY2IpIHtcbiAgdmFyIHNjcm9sbFBvc2l0aW9uID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24od2luZG93KTtcbiAgY2Ioc2Nyb2xsUG9zaXRpb24pO1xufVxuXG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0ge1xuICBfZW5hYmxlZDogdHJ1ZSxcbiAgX2hhbmRsZVRvcExldmVsOiBudWxsLFxuXG4gIFdJTkRPV19IQU5ETEU6IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHdpbmRvdyA6IG51bGwsXG5cbiAgc2V0SGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uIChoYW5kbGVUb3BMZXZlbCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwgPSBoYW5kbGVUb3BMZXZlbDtcbiAgfSxcblxuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCA9ICEhZW5hYmxlZDtcbiAgfSxcblxuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyB0b3AtbGV2ZWwgZXZlbnRzIGJ5IHVzaW5nIGV2ZW50IGJ1YmJsaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gaGFuZGxlIEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhcHMgYSB0b3AtbGV2ZWwgZXZlbnQgYnkgdXNpbmcgZXZlbnQgY2FwdHVyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gaGFuZGxlIEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHZhciBlbGVtZW50ID0gaGFuZGxlO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIG1vbml0b3JTY3JvbGxWYWx1ZTogZnVuY3Rpb24gKHJlZnJlc2gpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBzY3JvbGxWYWx1ZU1vbml0b3IuYmluZChudWxsLCByZWZyZXNoKTtcbiAgICBFdmVudExpc3RlbmVyLmxpc3Rlbih3aW5kb3csICdzY3JvbGwnLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIVJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBib29rS2VlcGluZyA9IFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5nZXRQb29sZWQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWxJbXBsLCBib29rS2VlcGluZyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5yZWxlYXNlKGJvb2tLZWVwaW5nKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudExpc3RlbmVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBVcHN0cmVhbSB2ZXJzaW9uIG9mIGV2ZW50IGxpc3RlbmVyLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBzcGVjaWZpY1xuICogbmF0dXJlIG9mIHBsYXRmb3JtLlxuICovXG52YXIgRXZlbnRMaXN0ZW5lciA9IHtcbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBjYXB0dXJlOiBmdW5jdGlvbiBjYXB0dXJlKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQXR0ZW1wdGVkIHRvIGxpc3RlbiB0byBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlIG9uIGEgJyArICdicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY2FwdHVyZSBwaGFzZS4gWW91ciBhcHBsaWNhdGlvbiAnICsgJ3dpbGwgbm90IHJlY2VpdmUgc29tZSBldmVudHMuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGVtcHR5RnVuY3Rpb25cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHJlZ2lzdGVyRGVmYXVsdDogZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0KCkge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHN1cHBsaWVkIGVsZW1lbnQgb3Igd2luZG93LlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWVzIGFyZSB1bmJvdW5kZWQsIHVubGlrZSBgZ2V0U2Nyb2xsUG9zaXRpb25gLiBUaGlzIG1lYW5zIHRoZXlcbiAqIG1heSBiZSBuZWdhdGl2ZSBvciBleGNlZWQgdGhlIGVsZW1lbnQgYm91bmRhcmllcyAod2hpY2ggaXMgcG9zc2libGUgdXNpbmdcbiAqIGluZXJ0aWFsIHNjcm9sbGluZykuXG4gKlxuICogQHBhcmFtIHtET01XaW5kb3d8RE9NRWxlbWVudH0gc2Nyb2xsYWJsZVxuICogQHJldHVybiB7b2JqZWN0fSBNYXAgd2l0aCBgeGAgYW5kIGB5YCBrZXlzLlxuICovXG5cbmZ1bmN0aW9uIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uKHNjcm9sbGFibGUpIHtcbiAgaWYgKHNjcm9sbGFibGUgPT09IHdpbmRvdykge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBzY3JvbGxhYmxlLnNjcm9sbExlZnQsXG4gICAgeTogc2Nyb2xsYWJsZS5zY3JvbGxUb3BcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbmplY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKCcuL1JlYWN0Q2xhc3MnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0SG9zdENvbXBvbmVudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBSZWFjdEluamVjdGlvbiA9IHtcbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LmluamVjdGlvbixcbiAgQ2xhc3M6IFJlYWN0Q2xhc3MuaW5qZWN0aW9uLFxuICBET01Qcm9wZXJ0eTogRE9NUHJvcGVydHkuaW5qZWN0aW9uLFxuICBFbXB0eUNvbXBvbmVudDogUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24sXG4gIEV2ZW50UGx1Z2luVXRpbHM6IEV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLFxuICBFdmVudEVtaXR0ZXI6IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pbmplY3Rpb24sXG4gIEhvc3RDb21wb25lbnQ6IFJlYWN0SG9zdENvbXBvbmVudC5pbmplY3Rpb24sXG4gIFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5pbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbmplY3Rpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEluamVjdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG5cbi8qKlxuICogRW5zdXJlcyB0aGF0LCB3aGVuIHBvc3NpYmxlLCB0aGUgc2VsZWN0aW9uIHJhbmdlIChjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dFxuICogaW5wdXQpIGlzIG5vdCBkaXN0dXJiZWQgYnkgcGVyZm9ybWluZyB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBTRUxFQ1RJT05fUkVTVE9SQVRJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFNlbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24sXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlbGVjdGlvbn0gc2VsIFNlbGVjdGlvbiBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIGBpbml0aWFsaXplYC5cbiAgICovXG4gIGNsb3NlOiBSZWFjdElucHV0U2VsZWN0aW9uLnJlc3RvcmVTZWxlY3Rpb25cbn07XG5cbi8qKlxuICogU3VwcHJlc3NlcyBldmVudHMgKGJsdXIvZm9jdXMpIHRoYXQgY291bGQgYmUgaW5hZHZlcnRlbnRseSBkaXNwYXRjaGVkIGR1ZSB0b1xuICogaGlnaCBsZXZlbCBET00gbWFuaXB1bGF0aW9ucyAobGlrZSB0ZW1wb3JhcmlseSByZW1vdmluZyBhIHRleHQgaW5wdXQgZnJvbSB0aGVcbiAqIERPTSkuXG4gKi9cbnZhciBFVkVOVF9TVVBQUkVTU0lPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBlbmFibGVkIHN0YXR1cyBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmVcbiAgICogdGhlIHJlY29uY2lsaWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50bHlFbmFibGVkID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmlzRW5hYmxlZCgpO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKGZhbHNlKTtcbiAgICByZXR1cm4gY3VycmVudGx5RW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBwcmV2aW91c2x5RW5hYmxlZCBFbmFibGVkIHN0YXR1cyBvZlxuICAgKiAgIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZSB0aGUgcmVjb25jaWxpYXRpb24gb2NjdXJyZWQuIGBjbG9zZWBcbiAgICogICByZXN0b3JlcyB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKHByZXZpb3VzbHlFbmFibGVkKSB7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQocHJldmlvdXNseUVuYWJsZWQpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgcXVldWUgZm9yIGNvbGxlY3RpbmcgYGNvbXBvbmVudERpZE1vdW50YCBhbmRcbiAqIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBkdXJpbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgT05fRE9NX1JFQURZX1FVRVVFSU5HID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGBvbkRPTVJlYWR5YCBxdWV1ZS5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yZXNldCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZnRlciBET00gaXMgZmx1c2hlZCwgaW52b2tlIGFsbCByZWdpc3RlcmVkIGBvbkRPTVJlYWR5YCBjYWxsYmFja3MuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5Lm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbU0VMRUNUSU9OX1JFU1RPUkFUSU9OLCBFVkVOVF9TVVBQUkVTU0lPTiwgT05fRE9NX1JFQURZX1FVRVVFSU5HXTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVFJBTlNBQ1RJT05fV1JBUFBFUlMucHVzaCh7XG4gICAgaW5pdGlhbGl6ZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCxcbiAgICBjbG9zZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2hcbiAgfSk7XG59XG5cbi8qKlxuICogQ3VycmVudGx5OlxuICogLSBUaGUgb3JkZXIgdGhhdCB0aGVzZSBhcmUgbGlzdGVkIGluIHRoZSB0cmFuc2FjdGlvbiBpcyBjcml0aWNhbDpcbiAqIC0gU3VwcHJlc3NlcyBldmVudHMuXG4gKiAtIFJlc3RvcmVzIHNlbGVjdGlvbiByYW5nZS5cbiAqXG4gKiBGdXR1cmU6XG4gKiAtIFJlc3RvcmUgZG9jdW1lbnQvb3ZlcmZsb3cgc2Nyb2xsIHBvc2l0aW9ucyB0aGF0IHdlcmUgdW5pbnRlbnRpb25hbGx5XG4gKiAgIG1vZGlmaWVkIHZpYSBET00gaW5zZXJ0aW9ucyBhYm92ZSB0aGUgdG9wIHZpZXdwb3J0IGJvdW5kYXJ5LlxuICogLSBJbXBsZW1lbnQvaW50ZWdyYXRlIHdpdGggY3VzdG9taXplZCBjb25zdHJhaW50IGJhc2VkIGxheW91dCBzeXN0ZW0gYW5kIGtlZXBcbiAqICAgdHJhY2sgb2Ygd2hpY2ggZGltZW5zaW9ucyBtdXN0IGJlIHJlbWVhc3VyZWQuXG4gKlxuICogQGNsYXNzIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbih1c2VDcmVhdGVFbGVtZW50KSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgLy8gT25seSBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgcmVhbGx5IG5lZWRzIHRoaXMgb3B0aW9uIChzZWVcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nYCksIGJ1dCBzZXJ2ZXItc2lkZSB1c2VzXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uYCBpbnN0ZWFkLiBUaGlzIG9wdGlvbiBpcyBoZXJlIHNvIHRoYXQgaXQnc1xuICAvLyBhY2Nlc3NpYmxlIGFuZCBkZWZhdWx0cyB0byBmYWxzZSB3aGVuIGBSZWFjdERPTUNvbXBvbmVudGAgYW5kXG4gIC8vIGBSZWFjdERPTVRleHRDb21wb25lbnRgIGNoZWNrcyBpdCBpbiBgbW91bnRDb21wb25lbnRgLmBcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGZhbHNlO1xuICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKG51bGwpO1xuICB0aGlzLnVzZUNyZWF0ZUVsZW1lbnQgPSB1c2VDcmVhdGVFbGVtZW50O1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXk8b2JqZWN0Pn0gTGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKiAgIFRPRE86IGNvbnZlcnQgdG8gYXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgUmVhY3QgYXN5bmMgZXZlbnRzLlxuICAgKi9cbiAgZ2V0VXBkYXRlUXVldWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RVcGRhdGVRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogU2F2ZSBjdXJyZW50IHRyYW5zYWN0aW9uIHN0YXRlIC0tIGlmIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGlzIG1ldGhvZCBpc1xuICAgKiBwYXNzZWQgdG8gYHJvbGxiYWNrYCwgdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcmVzZXQgdG8gdGhhdCBzdGF0ZS5cbiAgICovXG4gIGNoZWNrcG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZWFjdE1vdW50UmVhZHkgaXMgdGhlIG91ciBvbmx5IHN0YXRlZnVsIHdyYXBwZXJcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHkuY2hlY2twb2ludCgpO1xuICB9LFxuXG4gIHJvbGxiYWNrOiBmdW5jdGlvbiAoY2hlY2twb2ludCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMucmVhY3RNb3VudFJlYWR5KTtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XG4gIH1cbn07XG5cbl9hc3NpZ24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdElucHV0U2VsZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0aW9uJyk7XG5cbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHtcblxuICBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xuICB9LFxuXG4gIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgICBzZWxlY3Rpb25SYW5nZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID8gUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICAgKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAgICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gICAqL1xuICByZXN0b3JlU2VsZWN0aW9uOiBmdW5jdGlvbiAocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICAgIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gICAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIGlmIChSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLnNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICAgKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAgICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAgICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gICAqL1xuICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzZWxlY3Rpb247XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAvLyBJRTggaW5wdXQuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzZWxlY3Rpb24gcGVyIGRvY3VtZW50IGluIElFLCBzbyBpdCBtdXN0XG4gICAgICAvLyBiZSBpbiBvdXIgZWxlbWVudC5cbiAgICAgIGlmIChyYW5nZS5wYXJlbnRFbGVtZW50KCkgPT09IGlucHV0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgZW5kOiAtcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbi5nZXRPZmZzZXRzKGlucHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAgICogdGhlIGlucHV0LlxuICAgKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gICAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAgICovXG4gIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0LCBvZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RET01TZWxlY3Rpb24uc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5wdXRTZWxlY3Rpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdElucHV0U2VsZWN0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NU2VsZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCA9IHJlcXVpcmUoJy4vZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCcpO1xudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKCcuL2dldFRleHRDb250ZW50QWNjZXNzb3InKTtcblxuLyoqXG4gKiBXaGlsZSBgaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBvbiB0aGUgU2VsZWN0aW9uIG9iamVjdCBhbmQgYGNvbGxhcHNlZGBcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgUmFuZ2Ugb2JqZWN0LCBJRTExIHNvbWV0aW1lcyBnZXRzIHRoZW0gd3JvbmcuXG4gKiBJZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFuZCBvZmZzZXRzIGFyZSB0aGUgc2FtZSwgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZC5cbiAqL1xuZnVuY3Rpb24gaXNDb2xsYXBzZWQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gIHJldHVybiBhbmNob3JOb2RlID09PSBmb2N1c05vZGUgJiYgYW5jaG9yT2Zmc2V0ID09PSBmb2N1c09mZnNldDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFwcHJvcHJpYXRlIGFuY2hvciBhbmQgZm9jdXMgbm9kZS9vZmZzZXQgcGFpcnMgZm9yIElFLlxuICpcbiAqIFRoZSBjYXRjaCBoZXJlIGlzIHRoYXQgSUUncyBzZWxlY3Rpb24gQVBJIGRvZXNuJ3QgcHJvdmlkZSBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGZvcndhcmQgb3IgYmFja3dhcmQsIHNvIHdlIGhhdmUgdG9cbiAqIGJlaGF2ZSBhcyB0aG91Z2ggaXQncyBhbHdheXMgZm9yd2FyZC5cbiAqXG4gKiBJRSB0ZXh0IGRpZmZlcnMgZnJvbSBtb2Rlcm4gc2VsZWN0aW9uIGluIHRoYXQgaXQgYmVoYXZlcyBhcyB0aG91Z2hcbiAqIGJsb2NrIGVsZW1lbnRzIGVuZCB3aXRoIGEgbmV3IGxpbmUuIFRoaXMgbWVhbnMgY2hhcmFjdGVyIG9mZnNldHMgd2lsbFxuICogZGlmZmVyIGJldHdlZW4gdGhlIHR3byBBUElzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRJRU9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gZG9jdW1lbnQuc2VsZWN0aW9uO1xuICB2YXIgc2VsZWN0ZWRSYW5nZSA9IHNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICB2YXIgc2VsZWN0ZWRMZW5ndGggPSBzZWxlY3RlZFJhbmdlLnRleHQubGVuZ3RoO1xuXG4gIC8vIER1cGxpY2F0ZSBzZWxlY3Rpb24gc28gd2UgY2FuIG1vdmUgcmFuZ2Ugd2l0aG91dCBicmVha2luZyB1c2VyIHNlbGVjdGlvbi5cbiAgdmFyIGZyb21TdGFydCA9IHNlbGVjdGVkUmFuZ2UuZHVwbGljYXRlKCk7XG4gIGZyb21TdGFydC5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgZnJvbVN0YXJ0LnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0Jywgc2VsZWN0ZWRSYW5nZSk7XG5cbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gZnJvbVN0YXJ0LnRleHQubGVuZ3RoO1xuICB2YXIgZW5kT2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyBzZWxlY3RlZExlbmd0aDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydE9mZnNldCxcbiAgICBlbmQ6IGVuZE9mZnNldFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgdmFyIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7XG4gIHZhciBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlO1xuICB2YXIgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgdmFyIGN1cnJlbnRSYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuXG4gIC8vIEluIEZpcmVmb3gsIHJhbmdlLnN0YXJ0Q29udGFpbmVyIGFuZCByYW5nZS5lbmRDb250YWluZXIgY2FuIGJlIFwiYW5vbnltb3VzXG4gIC8vIGRpdnNcIiwgZS5nLiB0aGUgdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXNcbiAgLy8gZGl2cyBkbyBub3Qgc2VlbSB0byBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcbiAgLy8gZXJyb3JcIiBpZiBhbnkgb2YgaXRzIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGVcbiAgLy8gd2F5IHRvIGF2b2lkIGVycm9yaW5nIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvclxuICAvLyBub24tYW5vbnltb3VzIGRpdnMgYW5kIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVR5cGU7XG4gICAgY3VycmVudFJhbmdlLmVuZENvbnRhaW5lci5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBJZiB0aGUgbm9kZSBhbmQgb2Zmc2V0IHZhbHVlcyBhcmUgdGhlIHNhbWUsIHRoZSBzZWxlY3Rpb24gaXMgY29sbGFwc2VkLlxuICAvLyBgU2VsZWN0aW9uLmlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgbmF0aXZlbHksIGJ1dCBJRSBzb21ldGltZXMgZ2V0c1xuICAvLyB0aGlzIHZhbHVlIHdyb25nLlxuICB2YXIgaXNTZWxlY3Rpb25Db2xsYXBzZWQgPSBpc0NvbGxhcHNlZChzZWxlY3Rpb24uYW5jaG9yTm9kZSwgc2VsZWN0aW9uLmFuY2hvck9mZnNldCwgc2VsZWN0aW9uLmZvY3VzTm9kZSwgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0KTtcblxuICB2YXIgcmFuZ2VMZW5ndGggPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCA/IDAgOiBjdXJyZW50UmFuZ2UudG9TdHJpbmcoKS5sZW5ndGg7XG5cbiAgdmFyIHRlbXBSYW5nZSA9IGN1cnJlbnRSYW5nZS5jbG9uZVJhbmdlKCk7XG4gIHRlbXBSYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XG4gIHRlbXBSYW5nZS5zZXRFbmQoY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLCBjdXJyZW50UmFuZ2Uuc3RhcnRPZmZzZXQpO1xuXG4gIHZhciBpc1RlbXBSYW5nZUNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHRlbXBSYW5nZS5zdGFydENvbnRhaW5lciwgdGVtcFJhbmdlLnN0YXJ0T2Zmc2V0LCB0ZW1wUmFuZ2UuZW5kQ29udGFpbmVyLCB0ZW1wUmFuZ2UuZW5kT2Zmc2V0KTtcblxuICB2YXIgc3RhcnQgPSBpc1RlbXBSYW5nZUNvbGxhcHNlZCA/IDAgOiB0ZW1wUmFuZ2UudG9TdHJpbmcoKS5sZW5ndGg7XG4gIHZhciBlbmQgPSBzdGFydCArIHJhbmdlTGVuZ3RoO1xuXG4gIC8vIERldGVjdCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgYmFja3dhcmQuXG4gIHZhciBkZXRlY3Rpb25SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGRldGVjdGlvblJhbmdlLnNldFN0YXJ0KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gIGRldGVjdGlvblJhbmdlLnNldEVuZChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KTtcbiAgdmFyIGlzQmFja3dhcmQgPSBkZXRlY3Rpb25SYW5nZS5jb2xsYXBzZWQ7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogaXNCYWNrd2FyZCA/IGVuZCA6IHN0YXJ0LFxuICAgIGVuZDogaXNCYWNrd2FyZCA/IHN0YXJ0IDogZW5kXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRJRU9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS5kdXBsaWNhdGUoKTtcbiAgdmFyIHN0YXJ0LCBlbmQ7XG5cbiAgaWYgKG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH0gZWxzZSBpZiAob2Zmc2V0cy5zdGFydCA+IG9mZnNldHMuZW5kKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLmVuZDtcbiAgICBlbmQgPSBvZmZzZXRzLnN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBvZmZzZXRzLmVuZDtcbiAgfVxuXG4gIHJhbmdlLm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgcmFuZ2Uuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCByYW5nZSk7XG4gIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgcmFuZ2Uuc2VsZWN0KCk7XG59XG5cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRNb2Rlcm5PZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIGxlbmd0aCA9IG5vZGVbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXS5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHVzZUlFT2Zmc2V0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnc2VsZWN0aW9uJyBpbiBkb2N1bWVudCAmJiAhKCdnZXRTZWxlY3Rpb24nIGluIHdpbmRvdyk7XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgZ2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gZ2V0SUVPZmZzZXRzIDogZ2V0TW9kZXJuT2Zmc2V0cyxcblxuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gICAqL1xuICBzZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBzZXRJRU9mZnNldHMgOiBzZXRNb2Rlcm5PZmZzZXRzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3Rpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9jb250YWluc05vZGUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2lzVGV4dE5vZGUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvaXNOb2RlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvdHlwZW9mLXVuZGVmaW5lZCAqL1xuXG4vKipcbiAqIFNhbWUgYXMgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBidXQgd3JhcHMgaW4gYSB0cnktY2F0Y2ggYmxvY2suIEluIElFIGl0IGlzXG4gKiBub3Qgc2FmZSB0byBjYWxsIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaWYgdGhlcmUgaXMgbm90aGluZyBmb2N1c2VkLlxuICpcbiAqIFRoZSBhY3RpdmVFbGVtZW50IHdpbGwgYmUgbnVsbCBvbmx5IGlmIHRoZSBkb2N1bWVudCBvciBkb2N1bWVudCBib2R5IGlzIG5vdFxuICogeWV0IGRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoKSAvKj9ET01FbGVtZW50Ki97XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBY3RpdmVFbGVtZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNWR0RPTVByb3BlcnR5Q29uZmlnXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTlMgPSB7XG4gIHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gIHhtbDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSdcbn07XG5cbi8vIFdlIHVzZSBhdHRyaWJ1dGVzIGZvciBldmVyeXRoaW5nIFNWRyBzbyBsZXQncyBhdm9pZCBzb21lIGR1cGxpY2F0aW9uIGFuZCBydW5cbi8vIGNvZGUgaW5zdGVhZC5cbi8vIFRoZSBmb2xsb3dpbmcgYXJlIGFsbCBzcGVjaWZpZWQgaW4gdGhlIEhUTUwgY29uZmlnIGFscmVhZHkgc28gd2UgZXhjbHVkZSBoZXJlLlxuLy8gLSBjbGFzcyAoYXMgY2xhc3NOYW1lKVxuLy8gLSBjb2xvclxuLy8gLSBoZWlnaHRcbi8vIC0gaWRcbi8vIC0gbGFuZ1xuLy8gLSBtYXhcbi8vIC0gbWVkaWFcbi8vIC0gbWV0aG9kXG4vLyAtIG1pblxuLy8gLSBuYW1lXG4vLyAtIHN0eWxlXG4vLyAtIHRhcmdldFxuLy8gLSB0eXBlXG4vLyAtIHdpZHRoXG52YXIgQVRUUlMgPSB7XG4gIGFjY2VudEhlaWdodDogJ2FjY2VudC1oZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAwLFxuICBhZGRpdGl2ZTogMCxcbiAgYWxpZ25tZW50QmFzZWxpbmU6ICdhbGlnbm1lbnQtYmFzZWxpbmUnLFxuICBhbGxvd1Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAwLFxuICBhbXBsaXR1ZGU6IDAsXG4gIGFyYWJpY0Zvcm06ICdhcmFiaWMtZm9ybScsXG4gIGFzY2VudDogMCxcbiAgYXR0cmlidXRlTmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGVUeXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9SZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAwLFxuICBiYXNlRnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VQcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYXNlbGluZVNoaWZ0OiAnYmFzZWxpbmUtc2hpZnQnLFxuICBiYm94OiAwLFxuICBiZWdpbjogMCxcbiAgYmlhczogMCxcbiAgYnk6IDAsXG4gIGNhbGNNb2RlOiAnY2FsY01vZGUnLFxuICBjYXBIZWlnaHQ6ICdjYXAtaGVpZ2h0JyxcbiAgY2xpcDogMCxcbiAgY2xpcFBhdGg6ICdjbGlwLXBhdGgnLFxuICBjbGlwUnVsZTogJ2NsaXAtcnVsZScsXG4gIGNsaXBQYXRoVW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY29sb3JJbnRlcnBvbGF0aW9uOiAnY29sb3ItaW50ZXJwb2xhdGlvbicsXG4gIGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnM6ICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLFxuICBjb2xvclByb2ZpbGU6ICdjb2xvci1wcm9maWxlJyxcbiAgY29sb3JSZW5kZXJpbmc6ICdjb2xvci1yZW5kZXJpbmcnLFxuICBjb250ZW50U2NyaXB0VHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudFN0eWxlVHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6IDAsXG4gIGN4OiAwLFxuICBjeTogMCxcbiAgZDogMCxcbiAgZGVjZWxlcmF0ZTogMCxcbiAgZGVzY2VudDogMCxcbiAgZGlmZnVzZUNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAwLFxuICBkaXNwbGF5OiAwLFxuICBkaXZpc29yOiAwLFxuICBkb21pbmFudEJhc2VsaW5lOiAnZG9taW5hbnQtYmFzZWxpbmUnLFxuICBkdXI6IDAsXG4gIGR4OiAwLFxuICBkeTogMCxcbiAgZWRnZU1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogMCxcbiAgZW5hYmxlQmFja2dyb3VuZDogJ2VuYWJsZS1iYWNrZ3JvdW5kJyxcbiAgZW5kOiAwLFxuICBleHBvbmVudDogMCxcbiAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAwLFxuICBmaWxsT3BhY2l0eTogJ2ZpbGwtb3BhY2l0eScsXG4gIGZpbGxSdWxlOiAnZmlsbC1ydWxlJyxcbiAgZmlsdGVyOiAwLFxuICBmaWx0ZXJSZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJVbml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RDb2xvcjogJ2Zsb29kLWNvbG9yJyxcbiAgZmxvb2RPcGFjaXR5OiAnZmxvb2Qtb3BhY2l0eScsXG4gIGZvY3VzYWJsZTogMCxcbiAgZm9udEZhbWlseTogJ2ZvbnQtZmFtaWx5JyxcbiAgZm9udFNpemU6ICdmb250LXNpemUnLFxuICBmb250U2l6ZUFkanVzdDogJ2ZvbnQtc2l6ZS1hZGp1c3QnLFxuICBmb250U3RyZXRjaDogJ2ZvbnQtc3RyZXRjaCcsXG4gIGZvbnRTdHlsZTogJ2ZvbnQtc3R5bGUnLFxuICBmb250VmFyaWFudDogJ2ZvbnQtdmFyaWFudCcsXG4gIGZvbnRXZWlnaHQ6ICdmb250LXdlaWdodCcsXG4gIGZvcm1hdDogMCxcbiAgZnJvbTogMCxcbiAgZng6IDAsXG4gIGZ5OiAwLFxuICBnMTogMCxcbiAgZzI6IDAsXG4gIGdseXBoTmFtZTogJ2dseXBoLW5hbWUnLFxuICBnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbDogJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLFxuICBnbHlwaE9yaWVudGF0aW9uVmVydGljYWw6ICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsXG4gIGdseXBoUmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudFRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnRVbml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAwLFxuICBob3JpekFkdlg6ICdob3Jpei1hZHYteCcsXG4gIGhvcml6T3JpZ2luWDogJ2hvcml6LW9yaWdpbi14JyxcbiAgaWRlb2dyYXBoaWM6IDAsXG4gIGltYWdlUmVuZGVyaW5nOiAnaW1hZ2UtcmVuZGVyaW5nJyxcbiAgJ2luJzogMCxcbiAgaW4yOiAwLFxuICBpbnRlcmNlcHQ6IDAsXG4gIGs6IDAsXG4gIGsxOiAwLFxuICBrMjogMCxcbiAgazM6IDAsXG4gIGs0OiAwLFxuICBrZXJuZWxNYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWxVbml0TGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6IDAsXG4gIGtleVBvaW50czogJ2tleVBvaW50cycsXG4gIGtleVNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5VGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aEFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlclNwYWNpbmc6ICdsZXR0ZXItc3BhY2luZycsXG4gIGxpZ2h0aW5nQ29sb3I6ICdsaWdodGluZy1jb2xvcicsXG4gIGxpbWl0aW5nQ29uZUFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogMCxcbiAgbWFya2VyRW5kOiAnbWFya2VyLWVuZCcsXG4gIG1hcmtlck1pZDogJ21hcmtlci1taWQnLFxuICBtYXJrZXJTdGFydDogJ21hcmtlci1zdGFydCcsXG4gIG1hcmtlckhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlclVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJXaWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogMCxcbiAgbWFza0NvbnRlbnRVbml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrVW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6IDAsXG4gIG1vZGU6IDAsXG4gIG51bU9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAwLFxuICBvcGFjaXR5OiAwLFxuICBvcGVyYXRvcjogMCxcbiAgb3JkZXI6IDAsXG4gIG9yaWVudDogMCxcbiAgb3JpZW50YXRpb246IDAsXG4gIG9yaWdpbjogMCxcbiAgb3ZlcmZsb3c6IDAsXG4gIG92ZXJsaW5lUG9zaXRpb246ICdvdmVybGluZS1wb3NpdGlvbicsXG4gIG92ZXJsaW5lVGhpY2tuZXNzOiAnb3ZlcmxpbmUtdGhpY2tuZXNzJyxcbiAgcGFpbnRPcmRlcjogJ3BhaW50LW9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZS0xJyxcbiAgcGF0aExlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuQ29udGVudFVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm5UcmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVyblVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlckV2ZW50czogJ3BvaW50ZXItZXZlbnRzJyxcbiAgcG9pbnRzOiAwLFxuICBwb2ludHNBdFg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNBdFk6ICdwb2ludHNBdFknLFxuICBwb2ludHNBdFo6ICdwb2ludHNBdFonLFxuICBwcmVzZXJ2ZUFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlQXNwZWN0UmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZlVW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHI6IDAsXG4gIHJhZGl1czogMCxcbiAgcmVmWDogJ3JlZlgnLFxuICByZWZZOiAncmVmWScsXG4gIHJlbmRlcmluZ0ludGVudDogJ3JlbmRlcmluZy1pbnRlbnQnLFxuICByZXBlYXRDb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0RHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRFeHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRGZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXN0YXJ0OiAwLFxuICByZXN1bHQ6IDAsXG4gIHJvdGF0ZTogMCxcbiAgcng6IDAsXG4gIHJ5OiAwLFxuICBzY2FsZTogMCxcbiAgc2VlZDogMCxcbiAgc2hhcGVSZW5kZXJpbmc6ICdzaGFwZS1yZW5kZXJpbmcnLFxuICBzbG9wZTogMCxcbiAgc3BhY2luZzogMCxcbiAgc3BlY3VsYXJDb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhckV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAwLFxuICBzcHJlYWRNZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydE9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkRGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6IDAsXG4gIHN0ZW12OiAwLFxuICBzdGl0Y2hUaWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcENvbG9yOiAnc3RvcC1jb2xvcicsXG4gIHN0b3BPcGFjaXR5OiAnc3RvcC1vcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaFBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2hUaGlja25lc3M6ICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsXG4gIHN0cmluZzogMCxcbiAgc3Ryb2tlOiAwLFxuICBzdHJva2VEYXNoYXJyYXk6ICdzdHJva2UtZGFzaGFycmF5JyxcbiAgc3Ryb2tlRGFzaG9mZnNldDogJ3N0cm9rZS1kYXNob2Zmc2V0JyxcbiAgc3Ryb2tlTGluZWNhcDogJ3N0cm9rZS1saW5lY2FwJyxcbiAgc3Ryb2tlTGluZWpvaW46ICdzdHJva2UtbGluZWpvaW4nLFxuICBzdHJva2VNaXRlcmxpbWl0OiAnc3Ryb2tlLW1pdGVybGltaXQnLFxuICBzdHJva2VPcGFjaXR5OiAnc3Ryb2tlLW9wYWNpdHknLFxuICBzdHJva2VXaWR0aDogJ3N0cm9rZS13aWR0aCcsXG4gIHN1cmZhY2VTY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbUxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZVZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0WDogJ3RhcmdldFgnLFxuICB0YXJnZXRZOiAndGFyZ2V0WScsXG4gIHRleHRBbmNob3I6ICd0ZXh0LWFuY2hvcicsXG4gIHRleHREZWNvcmF0aW9uOiAndGV4dC1kZWNvcmF0aW9uJyxcbiAgdGV4dFJlbmRlcmluZzogJ3RleHQtcmVuZGVyaW5nJyxcbiAgdGV4dExlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0bzogMCxcbiAgdHJhbnNmb3JtOiAwLFxuICB1MTogMCxcbiAgdTI6IDAsXG4gIHVuZGVybGluZVBvc2l0aW9uOiAndW5kZXJsaW5lLXBvc2l0aW9uJyxcbiAgdW5kZXJsaW5lVGhpY2tuZXNzOiAndW5kZXJsaW5lLXRoaWNrbmVzcycsXG4gIHVuaWNvZGU6IDAsXG4gIHVuaWNvZGVCaWRpOiAndW5pY29kZS1iaWRpJyxcbiAgdW5pY29kZVJhbmdlOiAndW5pY29kZS1yYW5nZScsXG4gIHVuaXRzUGVyRW06ICd1bml0cy1wZXItZW0nLFxuICB2QWxwaGFiZXRpYzogJ3YtYWxwaGFiZXRpYycsXG4gIHZIYW5naW5nOiAndi1oYW5naW5nJyxcbiAgdklkZW9ncmFwaGljOiAndi1pZGVvZ3JhcGhpYycsXG4gIHZNYXRoZW1hdGljYWw6ICd2LW1hdGhlbWF0aWNhbCcsXG4gIHZhbHVlczogMCxcbiAgdmVjdG9yRWZmZWN0OiAndmVjdG9yLWVmZmVjdCcsXG4gIHZlcnNpb246IDAsXG4gIHZlcnRBZHZZOiAndmVydC1hZHYteScsXG4gIHZlcnRPcmlnaW5YOiAndmVydC1vcmlnaW4teCcsXG4gIHZlcnRPcmlnaW5ZOiAndmVydC1vcmlnaW4teScsXG4gIHZpZXdCb3g6ICd2aWV3Qm94JyxcbiAgdmlld1RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAwLFxuICB3aWR0aHM6IDAsXG4gIHdvcmRTcGFjaW5nOiAnd29yZC1zcGFjaW5nJyxcbiAgd3JpdGluZ01vZGU6ICd3cml0aW5nLW1vZGUnLFxuICB4OiAwLFxuICB4SGVpZ2h0OiAneC1oZWlnaHQnLFxuICB4MTogMCxcbiAgeDI6IDAsXG4gIHhDaGFubmVsU2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGxpbmtBY3R1YXRlOiAneGxpbms6YWN0dWF0ZScsXG4gIHhsaW5rQXJjcm9sZTogJ3hsaW5rOmFyY3JvbGUnLFxuICB4bGlua0hyZWY6ICd4bGluazpocmVmJyxcbiAgeGxpbmtSb2xlOiAneGxpbms6cm9sZScsXG4gIHhsaW5rU2hvdzogJ3hsaW5rOnNob3cnLFxuICB4bGlua1RpdGxlOiAneGxpbms6dGl0bGUnLFxuICB4bGlua1R5cGU6ICd4bGluazp0eXBlJyxcbiAgeG1sQmFzZTogJ3htbDpiYXNlJyxcbiAgeG1sbnM6IDAsXG4gIHhtbG5zWGxpbms6ICd4bWxuczp4bGluaycsXG4gIHhtbExhbmc6ICd4bWw6bGFuZycsXG4gIHhtbFNwYWNlOiAneG1sOnNwYWNlJyxcbiAgeTogMCxcbiAgeTE6IDAsXG4gIHkyOiAwLFxuICB5Q2hhbm5lbFNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6IDAsXG4gIHpvb21BbmRQYW46ICd6b29tQW5kUGFuJ1xufTtcblxudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0ge1xuICBQcm9wZXJ0aWVzOiB7fSxcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXG4gICAgeGxpbmtBcmNyb2xlOiBOUy54bGluayxcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtTaG93OiBOUy54bGluayxcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxuICAgIHhtbEJhc2U6IE5TLnhtbCxcbiAgICB4bWxMYW5nOiBOUy54bWwsXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge31cbn07XG5cbk9iamVjdC5rZXlzKEFUVFJTKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuUHJvcGVydGllc1trZXldID0gMDtcbiAgaWYgKEFUVFJTW2tleV0pIHtcbiAgICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc1trZXldID0gQVRUUlNba2V5XTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZHRE9NUHJvcGVydHlDb25maWc7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTZWxlY3RFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgc2VsZWN0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWxlY3Q6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlbGVjdENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudSwgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwLCB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZV1cbiAgfVxufTtcblxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLy8gVHJhY2sgd2hldGhlciBhIGxpc3RlbmVyIGV4aXN0cyBmb3IgdGhpcyBwbHVnaW4uIElmIG5vbmUgZXhpc3QsIHdlIGRvXG4vLyBub3QgZXh0cmFjdCBldmVudHMuIFNlZSAjMzYzOS5cbnZhciBoYXNMaXN0ZW5lciA9IGZhbHNlO1xudmFyIE9OX1NFTEVDVF9LRVkgPSBrZXlPZih7IG9uU2VsZWN0OiBudWxsIH0pO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMobm9kZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IG5vZGUuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IG5vZGUuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgfTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFyZW50RWxlbWVudDogcmFuZ2UucGFyZW50RWxlbWVudCgpLFxuICAgICAgdGV4dDogcmFuZ2UudGV4dCxcbiAgICAgIHRvcDogcmFuZ2UuYm91bmRpbmdUb3AsXG4gICAgICBsZWZ0OiByYW5nZS5ib3VuZGluZ0xlZnRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50ID09IG51bGwgfHwgYWN0aXZlRWxlbWVudCAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50O1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGlmICghaGFzTGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIC8vIFRyYWNrIHRoZSBpbnB1dCBub2RlIHRoYXQgaGFzIGZvY3VzLlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzOlxuICAgICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09IE9OX1NFTEVDVF9LRVkpIHtcbiAgICAgIGhhc0xpc3RlbmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0RXZlbnRQbHVnaW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TZWxlY3RFdmVudFBsdWdpbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTaW1wbGVFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgU3ludGhldGljQW5pbWF0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50Jyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG52YXIgU3ludGhldGljRm9jdXNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRm9jdXNFdmVudCcpO1xudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG52YXIgU3ludGhldGljRHJhZ0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNEcmFnRXZlbnQnKTtcbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNUb3VjaEV2ZW50Jyk7XG52YXIgU3ludGhldGljVHJhbnNpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljV2hlZWxFdmVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBhYm9ydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQWJvcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkFib3J0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgYW5pbWF0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25BbmltYXRpb25FbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkFuaW1hdGlvbkVuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGFuaW1hdGlvbkl0ZXJhdGlvbjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQW5pbWF0aW9uSXRlcmF0aW9uOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25BbmltYXRpb25JdGVyYXRpb25DYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBhbmltYXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQW5pbWF0aW9uU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkFuaW1hdGlvblN0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgYmx1cjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQmx1cjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQmx1ckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNhblBsYXk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNhblBsYXk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNhblBsYXlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjYW5QbGF5VGhyb3VnaDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2FuUGxheVRocm91Z2g6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNhblBsYXlUaHJvdWdoQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2xpY2s6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNsaWNrOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DbGlja0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNvbnRleHRNZW51OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db250ZXh0TWVudTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29udGV4dE1lbnVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjb3B5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db3B5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db3B5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkN1dENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRvdWJsZUNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Eb3VibGVDbGljazogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0VuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0VuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbnRlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VudGVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRW50ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRXhpdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0V4aXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFeGl0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0xlYXZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnTGVhdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdMZWF2ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnT3ZlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ092ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ1N0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJvcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJvcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJvcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGR1cmF0aW9uQ2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EdXJhdGlvbkNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHVyYXRpb25DaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlbXB0aWVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbXB0aWVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FbXB0aWVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZW5jcnlwdGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbmNyeXB0ZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVuY3J5cHRlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVuZGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbmRlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRW5kZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlcnJvcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRXJyb3I6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVycm9yQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZm9jdXM6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkZvY3VzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Gb2N1c0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25JbnB1dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uSW5wdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBpbnZhbGlkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25JbnZhbGlkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25JbnZhbGlkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5RG93bjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uS2V5RG93bjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uS2V5RG93bkNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleVByZXNzOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlQcmVzczogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uS2V5UHJlc3NDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlVcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uS2V5VXA6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleVVwQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWRlZERhdGE6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWRlZERhdGE6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRlZERhdGFDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkZWRNZXRhZGF0YToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZGVkTWV0YWRhdGE6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRlZE1ldGFkYXRhQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZFN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIC8vIE5vdGU6IFdlIGRvIG5vdCBhbGxvdyBsaXN0ZW5pbmcgdG8gbW91c2VPdmVyIGV2ZW50cy4gSW5zdGVhZCwgdXNlIHRoZVxuICAvLyBvbk1vdXNlRW50ZXIvb25Nb3VzZUxlYXZlIGNyZWF0ZWQgYnkgYEVudGVyTGVhdmVFdmVudFBsdWdpbmAuXG4gIG1vdXNlRG93bjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VEb3duOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZURvd25DYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU1vdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlTW92ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VNb3ZlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VPdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlT3V0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZU91dENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlT3Zlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VPdmVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZU92ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZVVwOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZVVwOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZVVwQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGFzdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBhc3RlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QYXN0ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBhdXNlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QYXVzZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGF1c2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwbGF5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QbGF5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QbGF5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGxheWluZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGxheWluZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGxheWluZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHByb2dyZXNzOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Qcm9ncmVzczogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUHJvZ3Jlc3NDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICByYXRlQ2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25SYXRlQ2hhbmdlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25SYXRlQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcmVzZXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblJlc2V0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25SZXNldENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNjcm9sbDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2Nyb2xsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TY3JvbGxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzZWVrZWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNlZWtlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2Vla2VkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Vla2luZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2Vla2luZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2Vla2luZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN0YWxsZWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblN0YWxsZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblN0YWxsZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdWJtaXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblN1Ym1pdDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU3VibWl0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc3VzcGVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3VzcGVuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU3VzcGVuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRpbWVVcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRpbWVVcGRhdGU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRpbWVVcGRhdGVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaENhbmNlbDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hDYW5jZWw6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoQ2FuY2VsQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hFbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoRW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaEVuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoTW92ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hNb3ZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaE1vdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaFN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaFN0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaFN0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdHJhbnNpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVHJhbnNpdGlvbkVuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVHJhbnNpdGlvbkVuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHZvbHVtZUNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVm9sdW1lQ2hhbmdlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Wb2x1bWVDaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB3YWl0aW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25XYWl0aW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25XYWl0aW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgd2hlZWw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbldoZWVsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25XaGVlbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7XG4gIHRvcEFib3J0OiBldmVudFR5cGVzLmFib3J0LFxuICB0b3BBbmltYXRpb25FbmQ6IGV2ZW50VHlwZXMuYW5pbWF0aW9uRW5kLFxuICB0b3BBbmltYXRpb25JdGVyYXRpb246IGV2ZW50VHlwZXMuYW5pbWF0aW9uSXRlcmF0aW9uLFxuICB0b3BBbmltYXRpb25TdGFydDogZXZlbnRUeXBlcy5hbmltYXRpb25TdGFydCxcbiAgdG9wQmx1cjogZXZlbnRUeXBlcy5ibHVyLFxuICB0b3BDYW5QbGF5OiBldmVudFR5cGVzLmNhblBsYXksXG4gIHRvcENhblBsYXlUaHJvdWdoOiBldmVudFR5cGVzLmNhblBsYXlUaHJvdWdoLFxuICB0b3BDbGljazogZXZlbnRUeXBlcy5jbGljayxcbiAgdG9wQ29udGV4dE1lbnU6IGV2ZW50VHlwZXMuY29udGV4dE1lbnUsXG4gIHRvcENvcHk6IGV2ZW50VHlwZXMuY29weSxcbiAgdG9wQ3V0OiBldmVudFR5cGVzLmN1dCxcbiAgdG9wRG91YmxlQ2xpY2s6IGV2ZW50VHlwZXMuZG91YmxlQ2xpY2ssXG4gIHRvcERyYWc6IGV2ZW50VHlwZXMuZHJhZyxcbiAgdG9wRHJhZ0VuZDogZXZlbnRUeXBlcy5kcmFnRW5kLFxuICB0b3BEcmFnRW50ZXI6IGV2ZW50VHlwZXMuZHJhZ0VudGVyLFxuICB0b3BEcmFnRXhpdDogZXZlbnRUeXBlcy5kcmFnRXhpdCxcbiAgdG9wRHJhZ0xlYXZlOiBldmVudFR5cGVzLmRyYWdMZWF2ZSxcbiAgdG9wRHJhZ092ZXI6IGV2ZW50VHlwZXMuZHJhZ092ZXIsXG4gIHRvcERyYWdTdGFydDogZXZlbnRUeXBlcy5kcmFnU3RhcnQsXG4gIHRvcERyb3A6IGV2ZW50VHlwZXMuZHJvcCxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6IGV2ZW50VHlwZXMuZHVyYXRpb25DaGFuZ2UsXG4gIHRvcEVtcHRpZWQ6IGV2ZW50VHlwZXMuZW1wdGllZCxcbiAgdG9wRW5jcnlwdGVkOiBldmVudFR5cGVzLmVuY3J5cHRlZCxcbiAgdG9wRW5kZWQ6IGV2ZW50VHlwZXMuZW5kZWQsXG4gIHRvcEVycm9yOiBldmVudFR5cGVzLmVycm9yLFxuICB0b3BGb2N1czogZXZlbnRUeXBlcy5mb2N1cyxcbiAgdG9wSW5wdXQ6IGV2ZW50VHlwZXMuaW5wdXQsXG4gIHRvcEludmFsaWQ6IGV2ZW50VHlwZXMuaW52YWxpZCxcbiAgdG9wS2V5RG93bjogZXZlbnRUeXBlcy5rZXlEb3duLFxuICB0b3BLZXlQcmVzczogZXZlbnRUeXBlcy5rZXlQcmVzcyxcbiAgdG9wS2V5VXA6IGV2ZW50VHlwZXMua2V5VXAsXG4gIHRvcExvYWQ6IGV2ZW50VHlwZXMubG9hZCxcbiAgdG9wTG9hZGVkRGF0YTogZXZlbnRUeXBlcy5sb2FkZWREYXRhLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogZXZlbnRUeXBlcy5sb2FkZWRNZXRhZGF0YSxcbiAgdG9wTG9hZFN0YXJ0OiBldmVudFR5cGVzLmxvYWRTdGFydCxcbiAgdG9wTW91c2VEb3duOiBldmVudFR5cGVzLm1vdXNlRG93bixcbiAgdG9wTW91c2VNb3ZlOiBldmVudFR5cGVzLm1vdXNlTW92ZSxcbiAgdG9wTW91c2VPdXQ6IGV2ZW50VHlwZXMubW91c2VPdXQsXG4gIHRvcE1vdXNlT3ZlcjogZXZlbnRUeXBlcy5tb3VzZU92ZXIsXG4gIHRvcE1vdXNlVXA6IGV2ZW50VHlwZXMubW91c2VVcCxcbiAgdG9wUGFzdGU6IGV2ZW50VHlwZXMucGFzdGUsXG4gIHRvcFBhdXNlOiBldmVudFR5cGVzLnBhdXNlLFxuICB0b3BQbGF5OiBldmVudFR5cGVzLnBsYXksXG4gIHRvcFBsYXlpbmc6IGV2ZW50VHlwZXMucGxheWluZyxcbiAgdG9wUHJvZ3Jlc3M6IGV2ZW50VHlwZXMucHJvZ3Jlc3MsXG4gIHRvcFJhdGVDaGFuZ2U6IGV2ZW50VHlwZXMucmF0ZUNoYW5nZSxcbiAgdG9wUmVzZXQ6IGV2ZW50VHlwZXMucmVzZXQsXG4gIHRvcFNjcm9sbDogZXZlbnRUeXBlcy5zY3JvbGwsXG4gIHRvcFNlZWtlZDogZXZlbnRUeXBlcy5zZWVrZWQsXG4gIHRvcFNlZWtpbmc6IGV2ZW50VHlwZXMuc2Vla2luZyxcbiAgdG9wU3RhbGxlZDogZXZlbnRUeXBlcy5zdGFsbGVkLFxuICB0b3BTdWJtaXQ6IGV2ZW50VHlwZXMuc3VibWl0LFxuICB0b3BTdXNwZW5kOiBldmVudFR5cGVzLnN1c3BlbmQsXG4gIHRvcFRpbWVVcGRhdGU6IGV2ZW50VHlwZXMudGltZVVwZGF0ZSxcbiAgdG9wVG91Y2hDYW5jZWw6IGV2ZW50VHlwZXMudG91Y2hDYW5jZWwsXG4gIHRvcFRvdWNoRW5kOiBldmVudFR5cGVzLnRvdWNoRW5kLFxuICB0b3BUb3VjaE1vdmU6IGV2ZW50VHlwZXMudG91Y2hNb3ZlLFxuICB0b3BUb3VjaFN0YXJ0OiBldmVudFR5cGVzLnRvdWNoU3RhcnQsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGV2ZW50VHlwZXMudHJhbnNpdGlvbkVuZCxcbiAgdG9wVm9sdW1lQ2hhbmdlOiBldmVudFR5cGVzLnZvbHVtZUNoYW5nZSxcbiAgdG9wV2FpdGluZzogZXZlbnRUeXBlcy53YWl0aW5nLFxuICB0b3BXaGVlbDogZXZlbnRUeXBlcy53aGVlbFxufTtcblxuZm9yICh2YXIgdHlwZSBpbiB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcpIHtcbiAgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3R5cGVdLmRlcGVuZGVuY2llcyA9IFt0eXBlXTtcbn1cblxudmFyIE9OX0NMSUNLX0tFWSA9IGtleU9mKHsgb25DbGljazogbnVsbCB9KTtcbnZhciBvbkNsaWNrTGlzdGVuZXJzID0ge307XG5cbmZ1bmN0aW9uIGdldERpY3Rpb25hcnlLZXkoaW5zdCkge1xuICAvLyBQcmV2ZW50cyBWOCBwZXJmb3JtYW5jZSBpc3N1ZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxuICByZXR1cm4gJy4nICsgaW5zdC5fcm9vdE5vZGVJRDtcbn1cblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQWJvcnQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2FuUGxheTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDYW5QbGF5VGhyb3VnaDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEdXJhdGlvbkNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbXB0aWVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEVuY3J5cHRlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbmRlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFcnJvcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BJbnB1dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BJbnZhbGlkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZGVkRGF0YTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkZWRNZXRhZGF0YTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkU3RhcnQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGF1c2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGxheTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQbGF5aW5nOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFByb2dyZXNzOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFJhdGVDaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUmVzZXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2Vla2VkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNlZWtpbmc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU3RhbGxlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdWJtaXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU3VzcGVuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUaW1lVXBkYXRlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFZvbHVtZUNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BXYWl0aW5nOlxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cbiAgICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BGb2N1czpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENsaWNrOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEb3VibGVDbGljazpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VNb3ZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3ZlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFbnRlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRXhpdDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnTGVhdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ092ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ1N0YXJ0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyb3A6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoQ2FuY2VsOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoRW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoTW92ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaFN0YXJ0OlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQW5pbWF0aW9uRW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEFuaW1hdGlvbkl0ZXJhdGlvbjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BBbmltYXRpb25TdGFydDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUcmFuc2l0aW9uRW5kOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BXaGVlbDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvcHk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ3V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAhRXZlbnRDb25zdHJ1Y3RvciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuJywgdG9wTGV2ZWxUeXBlKSA6IF9wcm9kSW52YXJpYW50KCc4NicsIHRvcExldmVsVHlwZSkgOiB2b2lkIDA7XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIC8vIE1vYmlsZSBTYWZhcmkgZG9lcyBub3QgZmlyZSBwcm9wZXJseSBidWJibGUgY2xpY2sgZXZlbnRzIG9uXG4gICAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAgIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgICAvLyBsaXN0ZW5lciBvbiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09IE9OX0NMSUNLX0tFWSkge1xuICAgICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgICAgaWYgKCFvbkNsaWNrTGlzdGVuZXJzW2tleV0pIHtcbiAgICAgICAgb25DbGlja0xpc3RlbmVyc1trZXldID0gRXZlbnRMaXN0ZW5lci5saXN0ZW4obm9kZSwgJ2NsaWNrJywgZW1wdHlGdW5jdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHdpbGxEZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fQ0xJQ0tfS0VZKSB7XG4gICAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XS5yZW1vdmUoKTtcbiAgICAgIGRlbGV0ZSBvbkNsaWNrTGlzdGVuZXJzW2tleV07XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlRXZlbnRQbHVnaW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TaW1wbGVFdmVudFBsdWdpbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNBbmltYXRpb25FdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNBbmltYXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNBbmltYXRpb25FdmVudCwgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljQW5pbWF0aW9uRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQ2xpcGJvYXJkRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNGb2N1c0V2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNGb2N1c0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljRm9jdXNFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNLZXlib2FyZEV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xudmFyIGdldEV2ZW50S2V5ID0gcmVxdWlyZSgnLi9nZXRFdmVudEtleScpO1xudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGxvY2F0aW9uOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICByZXBlYXQ6IG51bGwsXG4gIGxvY2FsZTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljS2V5Ym9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljS2V5Ym9hcmRFdmVudCwgS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRDaGFyQ29kZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudENoYXJDb2RlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0RXZlbnRDaGFyQ29kZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudEtleVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICAnRXNjJzogJ0VzY2FwZScsXG4gICdTcGFjZWJhcic6ICcgJyxcbiAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcbiAgJ1VwJzogJ0Fycm93VXAnLFxuICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXG4gICdEb3duJzogJ0Fycm93RG93bicsXG4gICdEZWwnOiAnRGVsZXRlJyxcbiAgJ1dpbic6ICdPUycsXG4gICdNZW51JzogJ0NvbnRleHRNZW51JyxcbiAgJ0FwcHMnOiAnQ29udGV4dE1lbnUnLFxuICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxuICAnTW96UHJpbnRhYmxlS2V5JzogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gIDg6ICdCYWNrc3BhY2UnLFxuICA5OiAnVGFiJyxcbiAgMTI6ICdDbGVhcicsXG4gIDEzOiAnRW50ZXInLFxuICAxNjogJ1NoaWZ0JyxcbiAgMTc6ICdDb250cm9sJyxcbiAgMTg6ICdBbHQnLFxuICAxOTogJ1BhdXNlJyxcbiAgMjA6ICdDYXBzTG9jaycsXG4gIDI3OiAnRXNjYXBlJyxcbiAgMzI6ICcgJyxcbiAgMzM6ICdQYWdlVXAnLFxuICAzNDogJ1BhZ2VEb3duJyxcbiAgMzU6ICdFbmQnLFxuICAzNjogJ0hvbWUnLFxuICAzNzogJ0Fycm93TGVmdCcsXG4gIDM4OiAnQXJyb3dVcCcsXG4gIDM5OiAnQXJyb3dSaWdodCcsXG4gIDQwOiAnQXJyb3dEb3duJyxcbiAgNDU6ICdJbnNlcnQnLFxuICA0NjogJ0RlbGV0ZScsXG4gIDExMjogJ0YxJywgMTEzOiAnRjInLCAxMTQ6ICdGMycsIDExNTogJ0Y0JywgMTE2OiAnRjUnLCAxMTc6ICdGNicsXG4gIDExODogJ0Y3JywgMTE5OiAnRjgnLCAxMjA6ICdGOScsIDEyMTogJ0YxMCcsIDEyMjogJ0YxMScsIDEyMzogJ0YxMicsXG4gIDE0NDogJ051bUxvY2snLFxuICAxNDU6ICdTY3JvbGxMb2NrJyxcbiAgMjI0OiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudEtleTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2dldEV2ZW50S2V5LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0RyYWdFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRHJhZ0V2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1RvdWNoRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBUb3VjaEV2ZW50SW50ZXJmYWNlID0ge1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUb3VjaEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUb3VjaEV2ZW50LCBUb3VjaEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljVG91Y2hFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xudmFyIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgcHJvcGVydHlOYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQsIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1doZWVsRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljV2hlZWxFdmVudCwgV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljV2hlZWxFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNb3VudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTUNvbnRhaW5lckluZm8gPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29udGFpbmVySW5mbycpO1xudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZlYXR1cmVGbGFncycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RGZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSByZXF1aXJlKCcuL1JlYWN0TWFya3VwQ2hlY2tzdW0nKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBBVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRTtcbnZhciBST09UX0FUVFJfTkFNRSA9IERPTVByb3BlcnR5LlJPT1RfQVRUUklCVVRFX05BTUU7XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XG5cbnZhciBpbnN0YW5jZXNCeVJlYWN0Um9vdElEID0ge307XG5cbi8qKlxuICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAqIHRoYXQncyBub3QgY29tbW9uIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgd2hlcmUgdGhlIHN0cmluZ3MgZGl2ZXJnZVxuICovXG5mdW5jdGlvbiBmaXJzdERpZmZlcmVuY2VJbmRleChzdHJpbmcxLCBzdHJpbmcyKSB7XG4gIHZhciBtaW5MZW4gPSBNYXRoLm1pbihzdHJpbmcxLmxlbmd0aCwgc3RyaW5nMi5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkxlbjsgaSsrKSB7XG4gICAgaWYgKHN0cmluZzEuY2hhckF0KGkpICE9PSBzdHJpbmcyLmNoYXJBdChpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJpbmcxLmxlbmd0aCA9PT0gc3RyaW5nMi5sZW5ndGggPyAtMSA6IG1pbkxlbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NRG9jdW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IG1heSBjb250YWluXG4gKiBhIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7Pyp9IERPTSBlbGVtZW50IHRoYXQgbWF5IGhhdmUgdGhlIHJlYWN0Um9vdCBJRCwgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcm5hbEdldElEKG5vZGUpIHtcbiAgLy8gSWYgbm9kZSBpcyBzb21ldGhpbmcgbGlrZSBhIHdpbmRvdywgZG9jdW1lbnQsIG9yIHRleHQgbm9kZSwgbm9uZSBvZlxuICAvLyB3aGljaCBzdXBwb3J0IGF0dHJpYnV0ZXMgb3IgYSAuZ2V0QXR0cmlidXRlIG1ldGhvZCwgZ3JhY2VmdWxseSByZXR1cm5cbiAgLy8gdGhlIGVtcHR5IHN0cmluZywgYXMgaWYgdGhlIGF0dHJpYnV0ZSB3ZXJlIG1pc3NpbmcuXG4gIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShBVFRSX05BTUUpIHx8ICcnO1xufVxuXG4vKipcbiAqIE1vdW50cyB0aGlzIGNvbXBvbmVudCBhbmQgaW5zZXJ0cyBpdCBpbnRvIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gbW91bnRDb21wb25lbnRJbnRvTm9kZSh3cmFwcGVySW5zdGFuY2UsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gIHZhciBtYXJrZXJOYW1lO1xuICBpZiAoUmVhY3RGZWF0dXJlRmxhZ3MubG9nVG9wTGV2ZWxSZW5kZXJzKSB7XG4gICAgdmFyIHdyYXBwZWRFbGVtZW50ID0gd3JhcHBlckluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgdHlwZSA9IHdyYXBwZWRFbGVtZW50LnR5cGU7XG4gICAgbWFya2VyTmFtZSA9ICdSZWFjdCBtb3VudDogJyArICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUpO1xuICAgIGNvbnNvbGUudGltZShtYXJrZXJOYW1lKTtcbiAgfVxuXG4gIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQod3JhcHBlckluc3RhbmNlLCB0cmFuc2FjdGlvbiwgbnVsbCwgUmVhY3RET01Db250YWluZXJJbmZvKHdyYXBwZXJJbnN0YW5jZSwgY29udGFpbmVyKSwgY29udGV4dCwgMCAvKiBwYXJlbnREZWJ1Z0lEICovXG4gICk7XG5cbiAgaWYgKG1hcmtlck5hbWUpIHtcbiAgICBjb25zb2xlLnRpbWVFbmQobWFya2VyTmFtZSk7XG4gIH1cblxuICB3cmFwcGVySW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50Ll90b3BMZXZlbFdyYXBwZXIgPSB3cmFwcGVySW5zdGFuY2U7XG4gIFJlYWN0TW91bnQuX21vdW50SW1hZ2VJbnRvTm9kZShtYXJrdXAsIGNvbnRhaW5lciwgd3JhcHBlckluc3RhbmNlLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIEJhdGNoZWQgbW91bnQuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUoY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKFxuICAvKiB1c2VDcmVhdGVFbGVtZW50ICovXG4gICFzaG91bGRSZXVzZU1hcmt1cCAmJiBSZWFjdERPTUZlYXR1cmVGbGFncy51c2VDcmVhdGVFbGVtZW50KTtcbiAgdHJhbnNhY3Rpb24ucGVyZm9ybShtb3VudENvbXBvbmVudEludG9Ob2RlLCBudWxsLCBjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpO1xuICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBVbm1vdW50cyBhIGNvbXBvbmVudCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW5zdGFuY2UgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gdW5tb3VudCBmcm9tLlxuICogQGZpbmFsXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge1JlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEZyb21Ob2RlKGluc3RhbmNlLCBjb250YWluZXIsIHNhZmVseSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2goKTtcbiAgfVxuICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChpbnN0YW5jZSwgc2FmZWx5KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRGbHVzaCgpO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9lbXB0eWluZy1hLW5vZGVcbiAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBoYXMgYSBkaXJlY3QgUmVhY3QtcmVuZGVyZWQgY2hpbGQgdGhhdCBpc1xuICogbm90IGEgUmVhY3Qgcm9vdCBlbGVtZW50LiBVc2VmdWwgZm9yIHdhcm5pbmcgaW4gYHJlbmRlcmAsXG4gKiBgdW5tb3VudENvbXBvbmVudEF0Tm9kZWAsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gZWxlbWVudCBjb250YWlucyBhIGRpcmVjdCBjaGlsZCB0aGF0IHdhc1xuICogcmVuZGVyZWQgYnkgUmVhY3QgYnV0IGlzIG5vdCBhIHJvb3QgZWxlbWVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICBpZiAocm9vdEVsKSB7XG4gICAgdmFyIGluc3QgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xuICAgIHJldHVybiAhIShpbnN0ICYmIGluc3QuX2hvc3RQYXJlbnQpO1xuICB9XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSBSZWFjdCBET00gZWxlbWVudCBhbmRcbiAqIGl0IGhhcyBiZWVuIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaGFzIGJlZW4gcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0XG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gbm9kZUlzUmVuZGVyZWRCeU90aGVySW5zdGFuY2UoY29udGFpbmVyKSB7XG4gIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuICEhKHJvb3RFbCAmJiBpc1JlYWN0Tm9kZShyb290RWwpICYmICFSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpKTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpIHtcbiAgcmV0dXJuICEhKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSk7XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSB2YWxpZCBSZWFjdCBub2RlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGlzIGEgdmFsaWQgUmVhY3QgRE9NIG5vZGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNSZWFjdE5vZGUobm9kZSkge1xuICByZXR1cm4gaXNWYWxpZENvbnRhaW5lcihub2RlKSAmJiAobm9kZS5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSX05BTUUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKEFUVFJfTkFNRSkpO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0Um9vdEluc3RhbmNlSW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgdmFyIHByZXZIb3N0SW5zdGFuY2UgPSByb290RWwgJiYgUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKTtcbiAgcmV0dXJuIHByZXZIb3N0SW5zdGFuY2UgJiYgIXByZXZIb3N0SW5zdGFuY2UuX2hvc3RQYXJlbnQgPyBwcmV2SG9zdEluc3RhbmNlIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIHZhciByb290ID0gZ2V0SG9zdFJvb3RJbnN0YW5jZUluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiByb290ID8gcm9vdC5faG9zdENvbnRhaW5lckluZm8uX3RvcExldmVsV3JhcHBlciA6IG51bGw7XG59XG5cbi8qKlxuICogVGVtcG9yYXJ5ICg/KSBoYWNrIHNvIHRoYXQgd2UgY2FuIHN0b3JlIGFsbCB0b3AtbGV2ZWwgcGVuZGluZyB1cGRhdGVzIG9uXG4gKiBjb21wb3NpdGVzIGluc3RlYWQgb2YgaGF2aW5nIHRvIHdvcnJ5IGFib3V0IGRpZmZlcmVudCB0eXBlcyBvZiBjb21wb25lbnRzXG4gKiBoZXJlLlxuICovXG52YXIgdG9wTGV2ZWxSb290Q291bnRlciA9IDE7XG52YXIgVG9wTGV2ZWxXcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJvb3RJRCA9IHRvcExldmVsUm9vdENvdW50ZXIrKztcbn07XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRvcExldmVsV3JhcHBlci5kaXNwbGF5TmFtZSA9ICdUb3BMZXZlbFdyYXBwZXInO1xufVxuVG9wTGV2ZWxXcmFwcGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHRoaXMucHJvcHMgaXMgYWN0dWFsbHkgYSBSZWFjdEVsZW1lbnRcbiAgcmV0dXJuIHRoaXMucHJvcHM7XG59O1xuXG4vKipcbiAqIE1vdW50aW5nIGlzIHRoZSBwcm9jZXNzIG9mIGluaXRpYWxpemluZyBhIFJlYWN0IGNvbXBvbmVudCBieSBjcmVhdGluZyBpdHNcbiAqIHJlcHJlc2VudGF0aXZlIERPTSBlbGVtZW50cyBhbmQgaW5zZXJ0aW5nIHRoZW0gaW50byBhIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICogQW55IHByaW9yIGNvbnRlbnQgaW5zaWRlIGBjb250YWluZXJgIGlzIGRlc3Ryb3llZCBpbiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiAgIFJlYWN0TW91bnQucmVuZGVyKFxuICogICAgIGNvbXBvbmVudCxcbiAqICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJylcbiAqICAgKTtcbiAqXG4gKiAgIDxkaXYgaWQ9XCJjb250YWluZXJcIj4gICAgICAgICAgICAgICAgICAgPC0tIFN1cHBsaWVkIGBjb250YWluZXJgLlxuICogICAgIDxkaXYgZGF0YS1yZWFjdGlkPVwiLjNcIj4gICAgICAgICAgICAgIDwtLSBSZW5kZXJlZCByZWFjdFJvb3Qgb2YgUmVhY3RcbiAqICAgICAgIC8vIC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKlxuICogSW5zaWRlIG9mIGBjb250YWluZXJgLCB0aGUgZmlyc3QgZWxlbWVudCByZW5kZXJlZCBpcyB0aGUgXCJyZWFjdFJvb3RcIi5cbiAqL1xudmFyIFJlYWN0TW91bnQgPSB7XG5cbiAgVG9wTGV2ZWxXcmFwcGVyOiBUb3BMZXZlbFdyYXBwZXIsXG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgZGV2dG9vbHMuIFRoZSBrZXlzIGFyZSBub3QgaW1wb3J0YW50LlxuICAgKi9cbiAgX2luc3RhbmNlc0J5UmVhY3RSb290SUQ6IGluc3RhbmNlc0J5UmVhY3RSb290SUQsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBob29rIHByb3ZpZGVkIHRvIHN1cHBvcnQgcmVuZGVyaW5nIFJlYWN0IGNvbXBvbmVudHMgd2hpbGVcbiAgICogZW5zdXJpbmcgdGhhdCB0aGUgYXBwYXJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIGl0cyBgY29udGFpbmVyYCBkb2VzIG5vdFxuICAgKiBjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIFRoZSBgY29udGFpbmVyYCBiZWluZyByZW5kZXJlZCBpbnRvLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZW5kZXJDYWxsYmFjayBUaGlzIG11c3QgYmUgY2FsbGVkIG9uY2UgdG8gZG8gdGhlIHJlbmRlci5cbiAgICovXG4gIHNjcm9sbE1vbml0b3I6IGZ1bmN0aW9uIChjb250YWluZXIsIHJlbmRlckNhbGxiYWNrKSB7XG4gICAgcmVuZGVyQ2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogVGFrZSBhIGNvbXBvbmVudCB0aGF0J3MgYWxyZWFkeSBtb3VudGVkIGludG8gdGhlIERPTSBhbmQgcmVwbGFjZSBpdHMgcHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcHJldkNvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgYWxyZWFkeSBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICovXG4gIF91cGRhdGVSb290Q29tcG9uZW50OiBmdW5jdGlvbiAocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQsIG5leHRDb250ZXh0LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RNb3VudC5zY3JvbGxNb25pdG9yKGNvbnRhaW5lciwgZnVuY3Rpb24gKCkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlRWxlbWVudEludGVybmFsKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCk7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJldkNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIGEgbmV3IGNvbXBvbmVudCBpbnRvIHRoZSBET00uIEhvb2tlZCBieSBob29rcyFcbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGVsZW1lbnQgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIGlmIHdlIHNob3VsZCBza2lwIHRoZSBtYXJrdXAgaW5zZXJ0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50XG4gICAqL1xuICBfcmVuZGVyTmV3Um9vdENvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ19yZW5kZXJOZXdSb290Q29tcG9uZW50KCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gJyArICdyZW5kZXIgaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnX3JlZ2lzdGVyQ29tcG9uZW50KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzcnKSA6IHZvaWQgMDtcblxuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5lbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3JpbmcoKTtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCBmYWxzZSk7XG5cbiAgICAvLyBUaGUgaW5pdGlhbCByZW5kZXIgaXMgc3luY2hyb25vdXMgYnV0IGFueSB1cGRhdGVzIHRoYXQgaGFwcGVuIGR1cmluZ1xuICAgIC8vIHJlbmRlcmluZywgaW4gY29tcG9uZW50V2lsbE1vdW50IG9yIGNvbXBvbmVudERpZE1vdW50LCB3aWxsIGJlIGJhdGNoZWRcbiAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgYmF0Y2hpbmcgc3RyYXRlZ3kuXG5cbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcblxuICAgIHZhciB3cmFwcGVySUQgPSBjb21wb25lbnRJbnN0YW5jZS5faW5zdGFuY2Uucm9vdElEO1xuICAgIGluc3RhbmNlc0J5UmVhY3RSb290SURbd3JhcHBlcklEXSA9IGNvbXBvbmVudEluc3RhbmNlO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwYXJlbnRDb21wb25lbnQgVGhlIGNvbmNlcHR1YWwgcGFyZW50IG9mIHRoaXMgcmVuZGVyIHRyZWUuXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgUmVhY3RJbnN0YW5jZU1hcC5oYXMocGFyZW50Q29tcG9uZW50KSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCczOCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS52YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCAnUmVhY3RET00ucmVuZGVyJyk7XG4gICAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChuZXh0RWxlbWVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00ucmVuZGVyKCk6IEludmFsaWQgY29tcG9uZW50IGVsZW1lbnQuJXMnLCB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdzdHJpbmcnID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYSBzdHJpbmcgbGlrZSBcXCdkaXZcXCcsIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KFxcJ2RpdlxcJykgb3IgPGRpdiAvPi4nIDogdHlwZW9mIG5leHRFbGVtZW50ID09PSAnZnVuY3Rpb24nID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYSBjbGFzcyBsaWtlIEZvbywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9vKSBvciA8Rm9vIC8+LicgOlxuICAgIC8vIENoZWNrIGlmIGl0IHF1YWNrcyBsaWtlIGFuIGVsZW1lbnRcbiAgICBuZXh0RWxlbWVudCAhPSBudWxsICYmIG5leHRFbGVtZW50LnByb3BzICE9PSB1bmRlZmluZWQgPyAnIFRoaXMgbWF5IGJlIGNhdXNlZCBieSB1bmludGVudGlvbmFsbHkgbG9hZGluZyB0d28gaW5kZXBlbmRlbnQgJyArICdjb3BpZXMgb2YgUmVhY3QuJyA6ICcnKSA6IF9wcm9kSW52YXJpYW50KCczOScsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIHN0cmluZyBsaWtlIFxcJ2RpdlxcJywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoXFwnZGl2XFwnKSBvciA8ZGl2IC8+LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNsYXNzIGxpa2UgRm9vLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChGb28pIG9yIDxGb28gLz4uJyA6IG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogdm9pZCAwO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKSA6IHZvaWQgMDtcblxuICAgIHZhciBuZXh0V3JhcHBlZEVsZW1lbnQgPSBSZWFjdEVsZW1lbnQoVG9wTGV2ZWxXcmFwcGVyLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBuZXh0RWxlbWVudCk7XG5cbiAgICB2YXIgbmV4dENvbnRleHQ7XG4gICAgaWYgKHBhcmVudENvbXBvbmVudCkge1xuICAgICAgdmFyIHBhcmVudEluc3QgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwYXJlbnRDb21wb25lbnQpO1xuICAgICAgbmV4dENvbnRleHQgPSBwYXJlbnRJbnN0Ll9wcm9jZXNzQ2hpbGRDb250ZXh0KHBhcmVudEluc3QuX2NvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0Q29udGV4dCA9IGVtcHR5T2JqZWN0O1xuICAgIH1cblxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIoY29udGFpbmVyKTtcblxuICAgIGlmIChwcmV2Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcHJldldyYXBwZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2V3JhcHBlZEVsZW1lbnQucHJvcHM7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICB2YXIgcHVibGljSW5zdCA9IHByZXZDb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgICAgIHZhciB1cGRhdGVkQ2FsbGJhY2sgPSBjYWxsYmFjayAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChwdWJsaWNJbnN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RNb3VudC5fdXBkYXRlUm9vdENvbXBvbmVudChwcmV2Q29tcG9uZW50LCBuZXh0V3JhcHBlZEVsZW1lbnQsIG5leHRDb250ZXh0LCBjb250YWluZXIsIHVwZGF0ZWRDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBwdWJsaWNJbnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlYWN0Um9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgY29udGFpbmVySGFzUmVhY3RNYXJrdXAgPSByZWFjdFJvb3RFbGVtZW50ICYmICEhaW50ZXJuYWxHZXRJRChyZWFjdFJvb3RFbGVtZW50KTtcbiAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcgKyAnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcgKyAneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnICsgJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJykgOiB2b2lkIDA7XG5cbiAgICAgIGlmICghY29udGFpbmVySGFzUmVhY3RNYXJrdXAgfHwgcmVhY3RSb290RWxlbWVudC5uZXh0U2libGluZykge1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnRTaWJsaW5nID0gcmVhY3RSb290RWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHJvb3RFbGVtZW50U2libGluZykge1xuICAgICAgICAgIGlmIChpbnRlcm5hbEdldElEKHJvb3RFbGVtZW50U2libGluZykpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3RFbGVtZW50U2libGluZyA9IHJvb3RFbGVtZW50U2libGluZy5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaG91bGRSZXVzZU1hcmt1cCA9IGNvbnRhaW5lckhhc1JlYWN0TWFya3VwICYmICFwcmV2Q29tcG9uZW50ICYmICFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZDtcbiAgICB2YXIgY29tcG9uZW50ID0gUmVhY3RNb3VudC5fcmVuZGVyTmV3Um9vdENvbXBvbmVudChuZXh0V3JhcHBlZEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIG5leHRDb250ZXh0KS5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBpbnRvIHRoZSBET00gaW4gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20ucmVuZGVyXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgQ29tcG9uZW50IGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFuZCBkZXN0cm95cyB0aGUgUmVhY3QgY29tcG9uZW50IHJlbmRlcmVkIGluIHRoZSBgY29udGFpbmVyYC5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0ZG9tLnVubW91bnRjb21wb25lbnRhdG5vZGVcbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgY29udGFpbmluZyBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGNvbXBvbmVudCB3YXMgZm91bmQgaW4gYW5kIHVubW91bnRlZCBmcm9tXG4gICAqICAgICAgICAgICAgICAgICAgIGBjb250YWluZXJgXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoU3RyaWN0bHkgc3BlYWtpbmcsIHVubW91bnRpbmcgd29uJ3QgY2F1c2UgYVxuICAgIC8vIHJlbmRlciBidXQgd2Ugc3RpbGwgZG9uJ3QgZXhwZWN0IHRvIGJlIGluIGEgcmVuZGVyIGNhbGwgaGVyZS4pXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciAnICsgJ2lzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCc0MCcpIDogdm9pZCAwO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFub2RlSXNSZW5kZXJlZEJ5T3RoZXJJbnN0YW5jZShjb250YWluZXIpLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgJyArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICBpZiAoIXByZXZDb21wb25lbnQpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBub2RlIGJlaW5nIHVubW91bnRlZCB3YXMgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCBpc24ndCBhXG4gICAgICAvLyByb290IG5vZGUuXG4gICAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgIHZhciBpc0NvbnRhaW5lclJlYWN0Um9vdCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMSAmJiBjb250YWluZXIuaGFzQXR0cmlidXRlKFJPT1RfQVRUUl9OQU1FKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgJyArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3ByZXZDb21wb25lbnQuX2luc3RhbmNlLnJvb3RJRF07XG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKHVubW91bnRDb21wb25lbnRGcm9tTm9kZSwgcHJldkNvbXBvbmVudCwgY29udGFpbmVyLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgX21vdW50SW1hZ2VJbnRvTm9kZTogZnVuY3Rpb24gKG1hcmt1cCwgY29udGFpbmVyLCBpbnN0YW5jZSwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKSB7XG4gICAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtb3VudENvbXBvbmVudEludG9Ob2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IHZhbGlkLicpIDogX3Byb2RJbnZhcmlhbnQoJzQxJykgOiB2b2lkIDA7XG5cbiAgICBpZiAoc2hvdWxkUmV1c2VNYXJrdXApIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgaWYgKFJlYWN0TWFya3VwQ2hlY2tzdW0uY2FuUmV1c2VNYXJrdXAobWFya3VwLCByb290RWxlbWVudCkpIHtcbiAgICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZShpbnN0YW5jZSwgcm9vdEVsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hlY2tzdW0gPSByb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuICAgICAgICByb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuXG4gICAgICAgIHZhciByb290TWFya3VwID0gcm9vdEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICByb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUsIGNoZWNrc3VtKTtcblxuICAgICAgICB2YXIgbm9ybWFsaXplZE1hcmt1cCA9IG1hcmt1cDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAvLyBiZWNhdXNlIHJvb3RNYXJrdXAgaXMgcmV0cmlldmVkIGZyb20gdGhlIERPTSwgdmFyaW91cyBub3JtYWxpemF0aW9uc1xuICAgICAgICAgIC8vIHdpbGwgaGF2ZSBvY2N1cnJlZCB3aGljaCB3aWxsIG5vdCBiZSBwcmVzZW50IGluIGBtYXJrdXBgLiBIZXJlLFxuICAgICAgICAgIC8vIGluc2VydCBtYXJrdXAgaW50byBhIDxkaXY+IG9yIDxpZnJhbWU+IGRlcGVuZGluZyBvbiB0aGUgY29udGFpbmVyXG4gICAgICAgICAgLy8gdHlwZSB0byBwZXJmb3JtIHRoZSBzYW1lIG5vcm1hbGl6YXRpb25zIGJlZm9yZSBjb21wYXJpbmcuXG4gICAgICAgICAgdmFyIG5vcm1hbGl6ZXI7XG4gICAgICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIuaW5uZXJIVE1MID0gbWFya3VwO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuaW5uZXJIVE1MO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5jb250ZW50RG9jdW1lbnQud3JpdGUobWFya3VwKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXJrdXAgPSBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChub3JtYWxpemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlmZkluZGV4ID0gZmlyc3REaWZmZXJlbmNlSW5kZXgobm9ybWFsaXplZE1hcmt1cCwgcm9vdE1hcmt1cCk7XG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gJyAoY2xpZW50KSAnICsgbm9ybWFsaXplZE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKSArICdcXG4gKHNlcnZlcikgJyArIHJvb3RNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCk7XG5cbiAgICAgICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IHVzaW5nIHNlcnZlciByZW5kZXJpbmcgYnV0IHRoZSBjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSByZW5kZXJlZCBhIGRpZmZlcmVudCBjb21wb25lbnQgdHlwZSBvciBwcm9wcyBvbiB0aGUgY2xpZW50IGZyb20gdGhlIG9uZSBvbiB0aGUgc2VydmVyLCBvciB5b3VyIHJlbmRlcigpIG1ldGhvZHMgYXJlIGltcHVyZS4gUmVhY3QgY2Fubm90IGhhbmRsZSB0aGlzIGNhc2UgZHVlIHRvIGNyb3NzLWJyb3dzZXIgcXVpcmtzIGJ5IHJlbmRlcmluZyBhdCB0aGUgZG9jdW1lbnQgcm9vdC4gWW91IHNob3VsZCBsb29rIGZvciBlbnZpcm9ubWVudCBkZXBlbmRlbnQgY29kZSBpbiB5b3VyIGNvbXBvbmVudHMgYW5kIGVuc3VyZSB0aGUgcHJvcHMgYXJlIHRoZSBzYW1lIGNsaWVudCBhbmQgc2VydmVyIHNpZGU6XFxuJXMnLCBkaWZmZXJlbmNlKSA6IF9wcm9kSW52YXJpYW50KCc0MicsIGRpZmZlcmVuY2UpIDogdm9pZCAwO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdCBhdHRlbXB0ZWQgdG8gcmV1c2UgbWFya3VwIGluIGEgY29udGFpbmVyIGJ1dCB0aGUgJyArICdjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyBnZW5lcmFsbHkgbWVhbnMgdGhhdCB5b3UgYXJlICcgKyAndXNpbmcgc2VydmVyIHJlbmRlcmluZyBhbmQgdGhlIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlICcgKyAnc2VydmVyIHdhcyBub3Qgd2hhdCB0aGUgY2xpZW50IHdhcyBleHBlY3RpbmcuIFJlYWN0IGluamVjdGVkICcgKyAnbmV3IG1hcmt1cCB0byBjb21wZW5zYXRlIHdoaWNoIHdvcmtzIGJ1dCB5b3UgaGF2ZSBsb3N0IG1hbnkgJyArICdvZiB0aGUgYmVuZWZpdHMgb2Ygc2VydmVyIHJlbmRlcmluZy4gSW5zdGVhZCwgZmlndXJlIG91dCAnICsgJ3doeSB0aGUgbWFya3VwIGJlaW5nIGdlbmVyYXRlZCBpcyBkaWZmZXJlbnQgb24gdGhlIGNsaWVudCAnICsgJ29yIHNlcnZlcjpcXG4lcycsIGRpZmZlcmVuY2UpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IGJ1dCB5b3UgZGlkblxcJ3QgdXNlIHNlcnZlciByZW5kZXJpbmcuIFdlIGNhblxcJ3QgZG8gdGhpcyB3aXRob3V0IHVzaW5nIHNlcnZlciByZW5kZXJpbmcgZHVlIHRvIGNyb3NzLWJyb3dzZXIgcXVpcmtzLiBTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IF9wcm9kSW52YXJpYW50KCc0MycpIDogdm9pZCAwO1xuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIERPTUxhenlUcmVlLmluc2VydFRyZWVCZWZvcmUoY29udGFpbmVyLCBtYXJrdXAsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJbm5lckhUTUwoY29udGFpbmVyLCBtYXJrdXApO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZShpbnN0YW5jZSwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaG9zdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICBpZiAoaG9zdE5vZGUuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihob3N0Tm9kZS5fZGVidWdJRCwgJ21vdW50JywgbWFya3VwLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNb3VudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbnRhaW5lckluZm9cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG5cbmZ1bmN0aW9uIFJlYWN0RE9NQ29udGFpbmVySW5mbyh0b3BMZXZlbFdyYXBwZXIsIG5vZGUpIHtcbiAgdmFyIGluZm8gPSB7XG4gICAgX3RvcExldmVsV3JhcHBlcjogdG9wTGV2ZWxXcmFwcGVyLFxuICAgIF9pZENvdW50ZXI6IDEsXG4gICAgX293bmVyRG9jdW1lbnQ6IG5vZGUgPyBub2RlLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFID8gbm9kZSA6IG5vZGUub3duZXJEb2N1bWVudCA6IG51bGwsXG4gICAgX25vZGU6IG5vZGUsXG4gICAgX3RhZzogbm9kZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGwsXG4gICAgX25hbWVzcGFjZVVSSTogbm9kZSA/IG5vZGUubmFtZXNwYWNlVVJJIDogbnVsbFxuICB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluZm8uX2FuY2VzdG9ySW5mbyA9IG5vZGUgPyB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCBpbmZvLl90YWcsIG51bGwpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbnRhaW5lckluZm87XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbnRhaW5lckluZm8uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01GZWF0dXJlRmxhZ3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHtcbiAgdXNlQ3JlYXRlRWxlbWVudDogdHJ1ZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZlYXR1cmVGbGFncztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NRmVhdHVyZUZsYWdzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TWFya3VwQ2hlY2tzdW1cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG5cbnZhciBUQUdfRU5EID0gL1xcLz8+LztcbnZhciBDT01NRU5UX1NUQVJUID0gL148XFwhXFwtXFwtLztcblxudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSB7XG4gIENIRUNLU1VNX0FUVFJfTkFNRTogJ2RhdGEtcmVhY3QtY2hlY2tzdW0nLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCBzdHJpbmdcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nIHdpdGggY2hlY2tzdW0gYXR0cmlidXRlIGF0dGFjaGVkXG4gICAqL1xuICBhZGRDaGVja3N1bVRvTWFya3VwOiBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIGNoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuXG4gICAgLy8gQWRkIGNoZWNrc3VtIChoYW5kbGUgYm90aCBwYXJlbnQgdGFncywgY29tbWVudHMgYW5kIHNlbGYtY2xvc2luZyB0YWdzKVxuICAgIGlmIChDT01NRU5UX1NUQVJULnRlc3QobWFya3VwKSkge1xuICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1hcmt1cC5yZXBsYWNlKFRBR19FTkQsICcgJyArIFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FICsgJz1cIicgKyBjaGVja3N1bSArICdcIiQmJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIHRvIHVzZVxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgcm9vdCBSZWFjdCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgbWFya3VwIGlzIHRoZSBzYW1lXG4gICAqL1xuICBjYW5SZXVzZU1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCwgZWxlbWVudCkge1xuICAgIHZhciBleGlzdGluZ0NoZWNrc3VtID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuICAgIGV4aXN0aW5nQ2hlY2tzdW0gPSBleGlzdGluZ0NoZWNrc3VtICYmIHBhcnNlSW50KGV4aXN0aW5nQ2hlY2tzdW0sIDEwKTtcbiAgICB2YXIgbWFya3VwQ2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG4gICAgcmV0dXJuIG1hcmt1cENoZWNrc3VtID09PSBleGlzdGluZ0NoZWNrc3VtO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TWFya3VwQ2hlY2tzdW07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE1hcmt1cENoZWNrc3VtLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGFkbGVyMzJcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE1PRCA9IDY1NTIxO1xuXG4vLyBhZGxlcjMyIGlzIG5vdCBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcsIGFuZCBpcyBvbmx5IHVzZWQgdG8gc2FuaXR5IGNoZWNrIHRoYXRcbi8vIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlIHNlcnZlciBtYXRjaGVzIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBjbGllbnQuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIChhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIFNoZWV0SlMgdmVyc2lvbikgaGFzIGJlZW4gb3B0aW1pemVkXG4vLyBmb3Igb3VyIHVzZSBjYXNlLCBhdCB0aGUgZXhwZW5zZSBvZiBjb25mb3JtaW5nIHRvIHRoZSBhZGxlcjMyIHNwZWNpZmljYXRpb25cbi8vIGZvciBub24tYXNjaWkgaW5wdXRzLlxuZnVuY3Rpb24gYWRsZXIzMihkYXRhKSB7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0gZGF0YS5sZW5ndGg7XG4gIHZhciBtID0gbCAmIH4weDM7XG4gIHdoaWxlIChpIDwgbSkge1xuICAgIHZhciBuID0gTWF0aC5taW4oaSArIDQwOTYsIG0pO1xuICAgIGZvciAoOyBpIDwgbjsgaSArPSA0KSB7XG4gICAgICBiICs9IChhICs9IGRhdGEuY2hhckNvZGVBdChpKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDEpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMikpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAzKSk7XG4gICAgfVxuICAgIGEgJT0gTU9EO1xuICAgIGIgJT0gTU9EO1xuICB9XG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgYiArPSBhICs9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgfVxuICBhICU9IE1PRDtcbiAgYiAlPSBNT0Q7XG4gIHJldHVybiBhIHwgYiA8PCAxNjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvYWRsZXIzMi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmaW5kRE9NTm9kZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xuXG52YXIgZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUgPSByZXF1aXJlKCcuL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBET00gbm9kZSByZW5kZXJlZCBieSB0aGlzIGVsZW1lbnQuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0ZG9tLmZpbmRkb21ub2RlXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudHxET01FbGVtZW50fSBjb21wb25lbnRPckVsZW1lbnRcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fSBUaGUgcm9vdCBub2RlIG9mIHRoaXMgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gIH1cblxuICB2YXIgaW5zdCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGNvbXBvbmVudE9yRWxlbWVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgaW5zdCA9IGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlKGluc3QpO1xuICAgIHJldHVybiBpbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkgOiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2ZpbmRET01Ob2RlIHdhcyBjYWxsZWQgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCc0NCcpIDogdm9pZCAwO1xuICB9IGVsc2Uge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IGFwcGVhcnMgdG8gYmUgbmVpdGhlciBSZWFjdENvbXBvbmVudCBub3IgRE9NTm9kZSAoa2V5czogJXMpJywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSkgOiBfcHJvZEludmFyaWFudCgnNDUnLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRET01Ob2RlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZmluZERPTU5vZGUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE5vZGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3ROb2RlVHlwZXMnKTtcblxuZnVuY3Rpb24gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCkge1xuICB2YXIgdHlwZTtcblxuICB3aGlsZSAoKHR5cGUgPSBpbnN0Ll9yZW5kZXJlZE5vZGVUeXBlKSA9PT0gUmVhY3ROb2RlVHlwZXMuQ09NUE9TSVRFKSB7XG4gICAgaW5zdCA9IGluc3QuX3JlbmRlcmVkQ29tcG9uZW50O1xuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJlYWN0Tm9kZVR5cGVzLkhPU1QpIHtcbiAgICByZXR1cm4gaW5zdC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4qIEBwcm92aWRlc01vZHVsZSByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQucmVuZGVyU3VidHJlZUludG9Db250YWluZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2tcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHJlYWN0UHJvcHMgPSB7XG4gICAgY2hpbGRyZW46IHRydWUsXG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHRydWUsXG4gICAga2V5OiB0cnVlLFxuICAgIHJlZjogdHJ1ZSxcblxuICAgIGF1dG9Gb2N1czogdHJ1ZSxcbiAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgdmFsdWVMaW5rOiB0cnVlLFxuICAgIGRlZmF1bHRDaGVja2VkOiB0cnVlLFxuICAgIGNoZWNrZWRMaW5rOiB0cnVlLFxuICAgIGlubmVySFRNTDogdHJ1ZSxcbiAgICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gICAgb25Gb2N1c0luOiB0cnVlLFxuICAgIG9uRm9jdXNPdXQ6IHRydWVcbiAgfTtcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBuYW1lLCBkZWJ1Z0lEKSB7XG4gICAgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVhY3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiByZWFjdFByb3BzW25hbWVdIHx8IHdhcm5lZFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gZGF0YS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICB2YXIgc3RhbmRhcmROYW1lID0gRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICBpZiAoc3RhbmRhcmROYW1lICE9IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBET00gcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ3Vlc3Mgd2hpY2ggcHJvcCB0aGUgdXNlciBpbnRlbmRlZC5cbiAgICAgIC8vIEl0IGlzIGxpa2VseSB0aGF0IHRoZSB1c2VyIHdhcyBqdXN0IGJsaW5kbHkgc3ByZWFkaW5nL2ZvcndhcmRpbmcgcHJvcHNcbiAgICAgIC8vIENvbXBvbmVudHMgc2hvdWxkIGJlIGNhcmVmdWwgdG8gb25seSByZW5kZXIgdmFsaWQgcHJvcHMvYXR0cmlidXRlcy5cbiAgICAgIC8vIFdhcm5pbmcgd2lsbCBiZSBpbnZva2VkIGluIHdhcm5Vbmtub3duUHJvcGVydGllcyB0byBhbGxvdyBncm91cGluZy5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBlbGVtZW50LnByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KGVsZW1lbnQudHlwZSwga2V5LCBkZWJ1Z0lEKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gdW5rbm93blByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIHByb3AgJXMgb24gPCVzPiB0YWcuIFJlbW92ZSB0aGlzIHByb3AgZnJvbSB0aGUgZWxlbWVudC4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtdW5rbm93bi1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gUmVtb3ZlIHRoZXNlIHByb3BzIGZyb20gdGhlIGVsZW1lbnQuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXVua25vd24tcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50LnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LnR5cGUuaW5kZXhPZignLScpID49IDAgfHwgZWxlbWVudC5wcm9wcy5pcykge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuVW5rbm93blByb3BlcnRpZXMoZGVidWdJRCwgZWxlbWVudCk7XG59XG5cbnZhciBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2sgPSB7XG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2s7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2suanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQudHlwZSAhPT0gJ2lucHV0JyAmJiBlbGVtZW50LnR5cGUgIT09ICd0ZXh0YXJlYScgJiYgZWxlbWVudC50eXBlICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5wcm9wcyAhPSBudWxsICYmIGVsZW1lbnQucHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyB0aGUgZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuXG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayA9IHtcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vaztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vay5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY29ubmVjdCA9IGV4cG9ydHMuUHJvdmlkZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfUHJvdmlkZXIgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvUHJvdmlkZXInKTtcblxudmFyIF9Qcm92aWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qcm92aWRlcik7XG5cbnZhciBfY29ubmVjdCA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9jb25uZWN0Jyk7XG5cbnZhciBfY29ubmVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25uZWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmV4cG9ydHMuUHJvdmlkZXIgPSBfUHJvdmlkZXIyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuY29ubmVjdCA9IF9jb25uZWN0MltcImRlZmF1bHRcIl07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdW5kZWZpbmVkO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9zdG9yZVNoYXBlID0gcmVxdWlyZSgnLi4vdXRpbHMvc3RvcmVTaGFwZScpO1xuXG52YXIgX3N0b3JlU2hhcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RvcmVTaGFwZSk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4uL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUgPSBmYWxzZTtcbmZ1bmN0aW9uIHdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKCkge1xuICBpZiAoZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUgPSB0cnVlO1xuXG4gICgwLCBfd2FybmluZzJbXCJkZWZhdWx0XCJdKSgnPFByb3ZpZGVyPiBkb2VzIG5vdCBzdXBwb3J0IGNoYW5naW5nIGBzdG9yZWAgb24gdGhlIGZseS4gJyArICdJdCBpcyBtb3N0IGxpa2VseSB0aGF0IHlvdSBzZWUgdGhpcyBlcnJvciBiZWNhdXNlIHlvdSB1cGRhdGVkIHRvICcgKyAnUmVkdXggMi54IGFuZCBSZWFjdCBSZWR1eCAyLnggd2hpY2ggbm8gbG9uZ2VyIGhvdCByZWxvYWQgcmVkdWNlcnMgJyArICdhdXRvbWF0aWNhbGx5LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtcmVkdXgvcmVsZWFzZXMvJyArICd0YWcvdjIuMC4wIGZvciB0aGUgbWlncmF0aW9uIGluc3RydWN0aW9ucy4nKTtcbn1cblxudmFyIFByb3ZpZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFByb3ZpZGVyLCBfQ29tcG9uZW50KTtcblxuICBQcm92aWRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7IHN0b3JlOiB0aGlzLnN0b3JlIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gUHJvdmlkZXIocHJvcHMsIGNvbnRleHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvdmlkZXIpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSk7XG5cbiAgICBfdGhpcy5zdG9yZSA9IHByb3BzLnN0b3JlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFByb3ZpZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcblxuICAgIHJldHVybiBfcmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gIH07XG5cbiAgcmV0dXJuIFByb3ZpZGVyO1xufShfcmVhY3QuQ29tcG9uZW50KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQcm92aWRlcjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUHJvdmlkZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICB2YXIgbmV4dFN0b3JlID0gbmV4dFByb3BzLnN0b3JlO1xuXG4gICAgaWYgKHN0b3JlICE9PSBuZXh0U3RvcmUpIHtcbiAgICAgIHdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKCk7XG4gICAgfVxuICB9O1xufVxuXG5Qcm92aWRlci5wcm9wVHlwZXMgPSB7XG4gIHN0b3JlOiBfc3RvcmVTaGFwZTJbXCJkZWZhdWx0XCJdLmlzUmVxdWlyZWQsXG4gIGNoaWxkcmVuOiBfcmVhY3QuUHJvcFR5cGVzLmVsZW1lbnQuaXNSZXF1aXJlZFxufTtcblByb3ZpZGVyLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICBzdG9yZTogX3N0b3JlU2hhcGUyW1wiZGVmYXVsdFwiXS5pc1JlcXVpcmVkXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yZWR1eC9saWIvY29tcG9uZW50cy9Qcm92aWRlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX3JlYWN0LlByb3BUeXBlcy5zaGFwZSh7XG4gIHN1YnNjcmliZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGRpc3BhdGNoOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZ2V0U3RhdGU6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59KTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QtcmVkdXgvbGliL3V0aWxzL3N0b3JlU2hhcGUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHdhcm5pbmc7XG4vKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QtcmVkdXgvbGliL3V0aWxzL3dhcm5pbmcuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbm5lY3Q7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3N0b3JlU2hhcGUgPSByZXF1aXJlKCcuLi91dGlscy9zdG9yZVNoYXBlJyk7XG5cbnZhciBfc3RvcmVTaGFwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdG9yZVNoYXBlKTtcblxudmFyIF9zaGFsbG93RXF1YWwgPSByZXF1aXJlKCcuLi91dGlscy9zaGFsbG93RXF1YWwnKTtcblxudmFyIF9zaGFsbG93RXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhbGxvd0VxdWFsKTtcblxudmFyIF93cmFwQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuLi91dGlscy93cmFwQWN0aW9uQ3JlYXRvcnMnKTtcblxudmFyIF93cmFwQWN0aW9uQ3JlYXRvcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd3JhcEFjdGlvbkNyZWF0b3JzKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMvd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF9ob2lzdE5vblJlYWN0U3RhdGljcyA9IHJlcXVpcmUoJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJyk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaG9pc3ROb25SZWFjdFN0YXRpY3MpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgZGVmYXVsdE1hcFN0YXRlVG9Qcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHMoc3RhdGUpIHtcbiAgcmV0dXJuIHt9O1xufTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xudmFyIGRlZmF1bHRNYXBEaXNwYXRjaFRvUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoKSB7XG4gIHJldHVybiB7IGRpc3BhdGNoOiBkaXNwYXRjaCB9O1xufTtcbnZhciBkZWZhdWx0TWVyZ2VQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRNZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIHBhcmVudFByb3BzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgcGFyZW50UHJvcHMsIHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMpO1xufTtcblxuZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoV3JhcHBlZENvbXBvbmVudCkge1xuICByZXR1cm4gV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XG59XG5cbnZhciBlcnJvck9iamVjdCA9IHsgdmFsdWU6IG51bGwgfTtcbmZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBjdHgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY3R4KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yT2JqZWN0LnZhbHVlID0gZTtcbiAgICByZXR1cm4gZXJyb3JPYmplY3Q7XG4gIH1cbn1cblxuLy8gSGVscHMgdHJhY2sgaG90IHJlbG9hZGluZy5cbnZhciBuZXh0VmVyc2lvbiA9IDA7XG5cbmZ1bmN0aW9uIGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1szXTtcblxuICB2YXIgc2hvdWxkU3Vic2NyaWJlID0gQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpO1xuICB2YXIgbWFwU3RhdGUgPSBtYXBTdGF0ZVRvUHJvcHMgfHwgZGVmYXVsdE1hcFN0YXRlVG9Qcm9wcztcblxuICB2YXIgbWFwRGlzcGF0Y2ggPSB1bmRlZmluZWQ7XG4gIGlmICh0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWFwRGlzcGF0Y2ggPSBtYXBEaXNwYXRjaFRvUHJvcHM7XG4gIH0gZWxzZSBpZiAoIW1hcERpc3BhdGNoVG9Qcm9wcykge1xuICAgIG1hcERpc3BhdGNoID0gZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wcztcbiAgfSBlbHNlIHtcbiAgICBtYXBEaXNwYXRjaCA9ICgwLCBfd3JhcEFjdGlvbkNyZWF0b3JzMltcImRlZmF1bHRcIl0pKG1hcERpc3BhdGNoVG9Qcm9wcyk7XG4gIH1cblxuICB2YXIgZmluYWxNZXJnZVByb3BzID0gbWVyZ2VQcm9wcyB8fCBkZWZhdWx0TWVyZ2VQcm9wcztcbiAgdmFyIF9vcHRpb25zJHB1cmUgPSBvcHRpb25zLnB1cmU7XG4gIHZhciBwdXJlID0gX29wdGlvbnMkcHVyZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9vcHRpb25zJHB1cmU7XG4gIHZhciBfb3B0aW9ucyR3aXRoUmVmID0gb3B0aW9ucy53aXRoUmVmO1xuICB2YXIgd2l0aFJlZiA9IF9vcHRpb25zJHdpdGhSZWYgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkd2l0aFJlZjtcblxuICB2YXIgY2hlY2tNZXJnZWRFcXVhbHMgPSBwdXJlICYmIGZpbmFsTWVyZ2VQcm9wcyAhPT0gZGVmYXVsdE1lcmdlUHJvcHM7XG5cbiAgLy8gSGVscHMgdHJhY2sgaG90IHJlbG9hZGluZy5cbiAgdmFyIHZlcnNpb24gPSBuZXh0VmVyc2lvbisrO1xuXG4gIHJldHVybiBmdW5jdGlvbiB3cmFwV2l0aENvbm5lY3QoV3JhcHBlZENvbXBvbmVudCkge1xuICAgIHZhciBjb25uZWN0RGlzcGxheU5hbWUgPSAnQ29ubmVjdCgnICsgZ2V0RGlzcGxheU5hbWUoV3JhcHBlZENvbXBvbmVudCkgKyAnKSc7XG5cbiAgICBmdW5jdGlvbiBjaGVja1N0YXRlU2hhcGUocHJvcHMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIGlmICghKDAsIF9pc1BsYWluT2JqZWN0MltcImRlZmF1bHRcIl0pKHByb3BzKSkge1xuICAgICAgICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkobWV0aG9kTmFtZSArICcoKSBpbiAnICsgY29ubmVjdERpc3BsYXlOYW1lICsgJyBtdXN0IHJldHVybiBhIHBsYWluIG9iamVjdC4gJyArICgnSW5zdGVhZCByZWNlaXZlZCAnICsgcHJvcHMgKyAnLicpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTWVyZ2VkUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgcGFyZW50UHJvcHMpIHtcbiAgICAgIHZhciBtZXJnZWRQcm9wcyA9IGZpbmFsTWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBwYXJlbnRQcm9wcyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja1N0YXRlU2hhcGUobWVyZ2VkUHJvcHMsICdtZXJnZVByb3BzJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gICAgfVxuXG4gICAgdmFyIENvbm5lY3QgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgICAgX2luaGVyaXRzKENvbm5lY3QsIF9Db21wb25lbnQpO1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiAhcHVyZSB8fCB0aGlzLmhhdmVPd25Qcm9wc0NoYW5nZWQgfHwgdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZDtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIENvbm5lY3QocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbm5lY3QpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xuXG4gICAgICAgIF90aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICBfdGhpcy5zdG9yZSA9IHByb3BzLnN0b3JlIHx8IGNvbnRleHQuc3RvcmU7XG5cbiAgICAgICAgKDAsIF9pbnZhcmlhbnQyW1wiZGVmYXVsdFwiXSkoX3RoaXMuc3RvcmUsICdDb3VsZCBub3QgZmluZCBcInN0b3JlXCIgaW4gZWl0aGVyIHRoZSBjb250ZXh0IG9yICcgKyAoJ3Byb3BzIG9mIFwiJyArIGNvbm5lY3REaXNwbGF5TmFtZSArICdcIi4gJykgKyAnRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgJyArICgnb3IgZXhwbGljaXRseSBwYXNzIFwic3RvcmVcIiBhcyBhIHByb3AgdG8gXCInICsgY29ubmVjdERpc3BsYXlOYW1lICsgJ1wiLicpKTtcblxuICAgICAgICB2YXIgc3RvcmVTdGF0ZSA9IF90aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIF90aGlzLnN0YXRlID0geyBzdG9yZVN0YXRlOiBzdG9yZVN0YXRlIH07XG4gICAgICAgIF90aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wdXRlU3RhdGVQcm9wcyA9IGZ1bmN0aW9uIGNvbXB1dGVTdGF0ZVByb3BzKHN0b3JlLCBwcm9wcykge1xuICAgICAgICBpZiAoIXRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmVGaW5hbE1hcFN0YXRlKHN0b3JlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICB2YXIgc3RhdGVQcm9wcyA9IHRoaXMuZG9TdGF0ZVByb3BzRGVwZW5kT25Pd25Qcm9wcyA/IHRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIHByb3BzKSA6IHRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMoc3RhdGUpO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKHN0YXRlUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGVQcm9wcztcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbmZpZ3VyZUZpbmFsTWFwU3RhdGUgPSBmdW5jdGlvbiBjb25maWd1cmVGaW5hbE1hcFN0YXRlKHN0b3JlLCBwcm9wcykge1xuICAgICAgICB2YXIgbWFwcGVkU3RhdGUgPSBtYXBTdGF0ZShzdG9yZS5nZXRTdGF0ZSgpLCBwcm9wcyk7XG4gICAgICAgIHZhciBpc0ZhY3RvcnkgPSB0eXBlb2YgbWFwcGVkU3RhdGUgPT09ICdmdW5jdGlvbic7XG5cbiAgICAgICAgdGhpcy5maW5hbE1hcFN0YXRlVG9Qcm9wcyA9IGlzRmFjdG9yeSA/IG1hcHBlZFN0YXRlIDogbWFwU3RhdGU7XG4gICAgICAgIHRoaXMuZG9TdGF0ZVByb3BzRGVwZW5kT25Pd25Qcm9wcyA9IHRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMubGVuZ3RoICE9PSAxO1xuXG4gICAgICAgIGlmIChpc0ZhY3RvcnkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlU3RhdGVQcm9wcyhzdG9yZSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja1N0YXRlU2hhcGUobWFwcGVkU3RhdGUsICdtYXBTdGF0ZVRvUHJvcHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwcGVkU3RhdGU7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wdXRlRGlzcGF0Y2hQcm9wcyA9IGZ1bmN0aW9uIGNvbXB1dGVEaXNwYXRjaFByb3BzKHN0b3JlLCBwcm9wcykge1xuICAgICAgICBpZiAoIXRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmVGaW5hbE1hcERpc3BhdGNoKHN0b3JlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlzcGF0Y2ggPSBzdG9yZS5kaXNwYXRjaDtcblxuICAgICAgICB2YXIgZGlzcGF0Y2hQcm9wcyA9IHRoaXMuZG9EaXNwYXRjaFByb3BzRGVwZW5kT25Pd25Qcm9wcyA/IHRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIHByb3BzKSA6IHRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gpO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKGRpc3BhdGNoUHJvcHMsICdtYXBEaXNwYXRjaFRvUHJvcHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzcGF0Y2hQcm9wcztcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbmZpZ3VyZUZpbmFsTWFwRGlzcGF0Y2ggPSBmdW5jdGlvbiBjb25maWd1cmVGaW5hbE1hcERpc3BhdGNoKHN0b3JlLCBwcm9wcykge1xuICAgICAgICB2YXIgbWFwcGVkRGlzcGF0Y2ggPSBtYXBEaXNwYXRjaChzdG9yZS5kaXNwYXRjaCwgcHJvcHMpO1xuICAgICAgICB2YXIgaXNGYWN0b3J5ID0gdHlwZW9mIG1hcHBlZERpc3BhdGNoID09PSAnZnVuY3Rpb24nO1xuXG4gICAgICAgIHRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMgPSBpc0ZhY3RvcnkgPyBtYXBwZWREaXNwYXRjaCA6IG1hcERpc3BhdGNoO1xuICAgICAgICB0aGlzLmRvRGlzcGF0Y2hQcm9wc0RlcGVuZE9uT3duUHJvcHMgPSB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzLmxlbmd0aCAhPT0gMTtcblxuICAgICAgICBpZiAoaXNGYWN0b3J5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZURpc3BhdGNoUHJvcHMoc3RvcmUsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKG1hcHBlZERpc3BhdGNoLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcHBlZERpc3BhdGNoO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUudXBkYXRlU3RhdGVQcm9wc0lmTmVlZGVkID0gZnVuY3Rpb24gdXBkYXRlU3RhdGVQcm9wc0lmTmVlZGVkKCkge1xuICAgICAgICB2YXIgbmV4dFN0YXRlUHJvcHMgPSB0aGlzLmNvbXB1dGVTdGF0ZVByb3BzKHRoaXMuc3RvcmUsIHRoaXMucHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZVByb3BzICYmICgwLCBfc2hhbGxvd0VxdWFsMltcImRlZmF1bHRcIl0pKG5leHRTdGF0ZVByb3BzLCB0aGlzLnN0YXRlUHJvcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHM7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUudXBkYXRlRGlzcGF0Y2hQcm9wc0lmTmVlZGVkID0gZnVuY3Rpb24gdXBkYXRlRGlzcGF0Y2hQcm9wc0lmTmVlZGVkKCkge1xuICAgICAgICB2YXIgbmV4dERpc3BhdGNoUHJvcHMgPSB0aGlzLmNvbXB1dGVEaXNwYXRjaFByb3BzKHRoaXMuc3RvcmUsIHRoaXMucHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5kaXNwYXRjaFByb3BzICYmICgwLCBfc2hhbGxvd0VxdWFsMltcImRlZmF1bHRcIl0pKG5leHREaXNwYXRjaFByb3BzLCB0aGlzLmRpc3BhdGNoUHJvcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaFByb3BzID0gbmV4dERpc3BhdGNoUHJvcHM7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUudXBkYXRlTWVyZ2VkUHJvcHNJZk5lZWRlZCA9IGZ1bmN0aW9uIHVwZGF0ZU1lcmdlZFByb3BzSWZOZWVkZWQoKSB7XG4gICAgICAgIHZhciBuZXh0TWVyZ2VkUHJvcHMgPSBjb21wdXRlTWVyZ2VkUHJvcHModGhpcy5zdGF0ZVByb3BzLCB0aGlzLmRpc3BhdGNoUHJvcHMsIHRoaXMucHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5tZXJnZWRQcm9wcyAmJiBjaGVja01lcmdlZEVxdWFscyAmJiAoMCwgX3NoYWxsb3dFcXVhbDJbXCJkZWZhdWx0XCJdKShuZXh0TWVyZ2VkUHJvcHMsIHRoaXMubWVyZ2VkUHJvcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5pc1N1YnNjcmliZWQgPSBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy51bnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnRyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIHRyeVN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHNob3VsZFN1YnNjcmliZSAmJiAhdGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSB0aGlzLnN0b3JlLnN1YnNjcmliZSh0aGlzLmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS50cnlVbnN1YnNjcmliZSA9IGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAodGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy50cnlTdWJzY3JpYmUoKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAoIXB1cmUgfHwgISgwLCBfc2hhbGxvd0VxdWFsMltcImRlZmF1bHRcIl0pKG5leHRQcm9wcywgdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICB0aGlzLmhhdmVPd25Qcm9wc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hQcm9wcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGVQcm9wcyA9IG51bGw7XG4gICAgICAgIHRoaXMubWVyZ2VkUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLmhhdmVPd25Qcm9wc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhhc1N0b3JlU3RhdGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXZlU3RhdGVQcm9wc0JlZW5QcmVjYWxjdWxhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0b3JlU3RhdGUgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIHZhciBwcmV2U3RvcmVTdGF0ZSA9IHRoaXMuc3RhdGUuc3RvcmVTdGF0ZTtcbiAgICAgICAgaWYgKHB1cmUgJiYgcHJldlN0b3JlU3RhdGUgPT09IHN0b3JlU3RhdGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHVyZSAmJiAhdGhpcy5kb1N0YXRlUHJvcHNEZXBlbmRPbk93blByb3BzKSB7XG4gICAgICAgICAgdmFyIGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9IHRyeUNhdGNoKHRoaXMudXBkYXRlU3RhdGVQcm9wc0lmTmVlZGVkLCB0aGlzKTtcbiAgICAgICAgICBpZiAoIWhhdmVTdGF0ZVByb3BzQ2hhbmdlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkID09PSBlcnJvck9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvciA9IGVycm9yT2JqZWN0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzdG9yZVN0YXRlOiBzdG9yZVN0YXRlIH0pO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuZ2V0V3JhcHBlZEluc3RhbmNlID0gZnVuY3Rpb24gZ2V0V3JhcHBlZEluc3RhbmNlKCkge1xuICAgICAgICAoMCwgX2ludmFyaWFudDJbXCJkZWZhdWx0XCJdKSh3aXRoUmVmLCAnVG8gYWNjZXNzIHRoZSB3cmFwcGVkIGluc3RhbmNlLCB5b3UgbmVlZCB0byBzcGVjaWZ5ICcgKyAneyB3aXRoUmVmOiB0cnVlIH0gYXMgdGhlIGZvdXJ0aCBhcmd1bWVudCBvZiB0aGUgY29ubmVjdCgpIGNhbGwuJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcy53cmFwcGVkSW5zdGFuY2U7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBoYXZlT3duUHJvcHNDaGFuZ2VkID0gdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkO1xuICAgICAgICB2YXIgaGFzU3RvcmVTdGF0ZUNoYW5nZWQgPSB0aGlzLmhhc1N0b3JlU3RhdGVDaGFuZ2VkO1xuICAgICAgICB2YXIgaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZCA9IHRoaXMuaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZDtcbiAgICAgICAgdmFyIHN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yID0gdGhpcy5zdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgdmFyIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMucmVuZGVyZWRFbGVtZW50O1xuXG4gICAgICAgIHRoaXMuaGF2ZU93blByb3BzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1N0b3JlU3RhdGVDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yID0gbnVsbDtcblxuICAgICAgICBpZiAoc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBzdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG91bGRVcGRhdGVTdGF0ZVByb3BzID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNob3VsZFVwZGF0ZURpc3BhdGNoUHJvcHMgPSB0cnVlO1xuICAgICAgICBpZiAocHVyZSAmJiByZW5kZXJlZEVsZW1lbnQpIHtcbiAgICAgICAgICBzaG91bGRVcGRhdGVTdGF0ZVByb3BzID0gaGFzU3RvcmVTdGF0ZUNoYW5nZWQgfHwgaGF2ZU93blByb3BzQ2hhbmdlZCAmJiB0aGlzLmRvU3RhdGVQcm9wc0RlcGVuZE9uT3duUHJvcHM7XG4gICAgICAgICAgc2hvdWxkVXBkYXRlRGlzcGF0Y2hQcm9wcyA9IGhhdmVPd25Qcm9wc0NoYW5nZWQgJiYgdGhpcy5kb0Rpc3BhdGNoUHJvcHNEZXBlbmRPbk93blByb3BzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgaGF2ZURpc3BhdGNoUHJvcHNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChoYXZlU3RhdGVQcm9wc0JlZW5QcmVjYWxjdWxhdGVkKSB7XG4gICAgICAgICAgaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzaG91bGRVcGRhdGVTdGF0ZVByb3BzKSB7XG4gICAgICAgICAgaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkID0gdGhpcy51cGRhdGVTdGF0ZVByb3BzSWZOZWVkZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlRGlzcGF0Y2hQcm9wcykge1xuICAgICAgICAgIGhhdmVEaXNwYXRjaFByb3BzQ2hhbmdlZCA9IHRoaXMudXBkYXRlRGlzcGF0Y2hQcm9wc0lmTmVlZGVkKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGF2ZU1lcmdlZFByb3BzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIGlmIChoYXZlU3RhdGVQcm9wc0NoYW5nZWQgfHwgaGF2ZURpc3BhdGNoUHJvcHNDaGFuZ2VkIHx8IGhhdmVPd25Qcm9wc0NoYW5nZWQpIHtcbiAgICAgICAgICBoYXZlTWVyZ2VkUHJvcHNDaGFuZ2VkID0gdGhpcy51cGRhdGVNZXJnZWRQcm9wc0lmTmVlZGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGF2ZU1lcmdlZFByb3BzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXZlTWVyZ2VkUHJvcHNDaGFuZ2VkICYmIHJlbmRlcmVkRWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJlZEVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2l0aFJlZikge1xuICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50ID0gKDAsIF9yZWFjdC5jcmVhdGVFbGVtZW50KShXcmFwcGVkQ29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgdGhpcy5tZXJnZWRQcm9wcywge1xuICAgICAgICAgICAgcmVmOiAnd3JhcHBlZEluc3RhbmNlJ1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudCA9ICgwLCBfcmVhY3QuY3JlYXRlRWxlbWVudCkoV3JhcHBlZENvbXBvbmVudCwgdGhpcy5tZXJnZWRQcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlZEVsZW1lbnQ7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29ubmVjdDtcbiAgICB9KF9yZWFjdC5Db21wb25lbnQpO1xuXG4gICAgQ29ubmVjdC5kaXNwbGF5TmFtZSA9IGNvbm5lY3REaXNwbGF5TmFtZTtcbiAgICBDb25uZWN0LldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgIENvbm5lY3QuY29udGV4dFR5cGVzID0ge1xuICAgICAgc3RvcmU6IF9zdG9yZVNoYXBlMltcImRlZmF1bHRcIl1cbiAgICB9O1xuICAgIENvbm5lY3QucHJvcFR5cGVzID0ge1xuICAgICAgc3RvcmU6IF9zdG9yZVNoYXBlMltcImRlZmF1bHRcIl1cbiAgICB9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy52ZXJzaW9uID09PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgYXJlIGhvdCByZWxvYWRpbmchXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMudHJ5U3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9ob2lzdE5vblJlYWN0U3RhdGljczJbXCJkZWZhdWx0XCJdKShDb25uZWN0LCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgfTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QtcmVkdXgvbGliL2NvbXBvbmVudHMvY29ubmVjdC5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBzaGFsbG93RXF1YWw7XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqQSA9PT0gb2JqQikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd24uY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgb2JqQVtrZXlzQVtpXV0gIT09IG9iakJba2V5c0FbaV1dKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy9zaGFsbG93RXF1YWwuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHdyYXBBY3Rpb25DcmVhdG9ycztcblxudmFyIF9yZWR1eCA9IHJlcXVpcmUoJ3JlZHV4Jyk7XG5cbmZ1bmN0aW9uIHdyYXBBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycykge1xuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoKSB7XG4gICAgcmV0dXJuICgwLCBfcmVkdXguYmluZEFjdGlvbkNyZWF0b3JzKShhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9O1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvd3JhcEFjdGlvbkNyZWF0b3JzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jb21wb3NlID0gZXhwb3J0cy5hcHBseU1pZGRsZXdhcmUgPSBleHBvcnRzLmJpbmRBY3Rpb25DcmVhdG9ycyA9IGV4cG9ydHMuY29tYmluZVJlZHVjZXJzID0gZXhwb3J0cy5jcmVhdGVTdG9yZSA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVTdG9yZSA9IHJlcXVpcmUoJy4vY3JlYXRlU3RvcmUnKTtcblxudmFyIF9jcmVhdGVTdG9yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVTdG9yZSk7XG5cbnZhciBfY29tYmluZVJlZHVjZXJzID0gcmVxdWlyZSgnLi9jb21iaW5lUmVkdWNlcnMnKTtcblxudmFyIF9jb21iaW5lUmVkdWNlcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tYmluZVJlZHVjZXJzKTtcblxudmFyIF9iaW5kQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuL2JpbmRBY3Rpb25DcmVhdG9ycycpO1xuXG52YXIgX2JpbmRBY3Rpb25DcmVhdG9yczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iaW5kQWN0aW9uQ3JlYXRvcnMpO1xuXG52YXIgX2FwcGx5TWlkZGxld2FyZSA9IHJlcXVpcmUoJy4vYXBwbHlNaWRkbGV3YXJlJyk7XG5cbnZhciBfYXBwbHlNaWRkbGV3YXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FwcGx5TWlkZGxld2FyZSk7XG5cbnZhciBfY29tcG9zZSA9IHJlcXVpcmUoJy4vY29tcG9zZScpO1xuXG52YXIgX2NvbXBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9zZSk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4vdXRpbHMvd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLypcbiogVGhpcyBpcyBhIGR1bW15IGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBmdW5jdGlvbiBuYW1lIGhhcyBiZWVuIGFsdGVyZWQgYnkgbWluaWZpY2F0aW9uLlxuKiBJZiB0aGUgZnVuY3Rpb24gaGFzIGJlZW4gbWluaWZpZWQgYW5kIE5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsIHdhcm4gdGhlIHVzZXIuXG4qL1xuZnVuY3Rpb24gaXNDcnVzaGVkKCkge31cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGlzQ3J1c2hlZC5uYW1lID09PSAnc3RyaW5nJyAmJiBpc0NydXNoZWQubmFtZSAhPT0gJ2lzQ3J1c2hlZCcpIHtcbiAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKSgnWW91IGFyZSBjdXJyZW50bHkgdXNpbmcgbWluaWZpZWQgY29kZSBvdXRzaWRlIG9mIE5PREVfRU5WID09PSBcXCdwcm9kdWN0aW9uXFwnLiAnICsgJ1RoaXMgbWVhbnMgdGhhdCB5b3UgYXJlIHJ1bm5pbmcgYSBzbG93ZXIgZGV2ZWxvcG1lbnQgYnVpbGQgb2YgUmVkdXguICcgKyAnWW91IGNhbiB1c2UgbG9vc2UtZW52aWZ5IChodHRwczovL2dpdGh1Yi5jb20vemVydG9zaC9sb29zZS1lbnZpZnkpIGZvciBicm93c2VyaWZ5ICcgKyAnb3IgRGVmaW5lUGx1Z2luIGZvciB3ZWJwYWNrIChodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMwMDMwMDMxKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbmV4cG9ydHMuY3JlYXRlU3RvcmUgPSBfY3JlYXRlU3RvcmUyWydkZWZhdWx0J107XG5leHBvcnRzLmNvbWJpbmVSZWR1Y2VycyA9IF9jb21iaW5lUmVkdWNlcnMyWydkZWZhdWx0J107XG5leHBvcnRzLmJpbmRBY3Rpb25DcmVhdG9ycyA9IF9iaW5kQWN0aW9uQ3JlYXRvcnMyWydkZWZhdWx0J107XG5leHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IF9hcHBseU1pZGRsZXdhcmUyWydkZWZhdWx0J107XG5leHBvcnRzLmNvbXBvc2UgPSBfY29tcG9zZTJbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVkdXgvbGliL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHVuZGVmaW5lZDtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZVN0b3JlO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfc3ltYm9sT2JzZXJ2YWJsZSA9IHJlcXVpcmUoJ3N5bWJvbC1vYnNlcnZhYmxlJyk7XG5cbnZhciBfc3ltYm9sT2JzZXJ2YWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2xPYnNlcnZhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xudmFyIEFjdGlvblR5cGVzID0gZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogJ0BAcmVkdXgvSU5JVCdcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gKiBUaGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZSBkYXRhIGluIHRoZSBzdG9yZSBpcyB0byBjYWxsIGBkaXNwYXRjaCgpYCBvbiBpdC5cbiAqXG4gKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gKiBwYXJ0cyBvZiB0aGUgc3RhdGUgdHJlZSByZXNwb25kIHRvIGFjdGlvbnMsIHlvdSBtYXkgY29tYmluZSBzZXZlcmFsIHJlZHVjZXJzXG4gKiBpbnRvIGEgc2luZ2xlIHJlZHVjZXIgZnVuY3Rpb24gYnkgdXNpbmcgYGNvbWJpbmVSZWR1Y2Vyc2AuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVkdWNlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlblxuICogdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGFjdGlvbiB0byBoYW5kbGUuXG4gKlxuICogQHBhcmFtIHthbnl9IFtwcmVsb2FkZWRTdGF0ZV0gVGhlIGluaXRpYWwgc3RhdGUuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBoeWRyYXRlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYVxuICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAqIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2Vyc2AgdG8gcHJvZHVjZSB0aGUgcm9vdCByZWR1Y2VyIGZ1bmN0aW9uLCB0aGlzIG11c3QgYmVcbiAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGBjb21iaW5lUmVkdWNlcnNgIGtleXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5oYW5jZXIgVGhlIHN0b3JlIGVuaGFuY2VyLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gZW5oYW5jZSB0aGUgc3RvcmUgd2l0aCB0aGlyZC1wYXJ0eSBjYXBhYmlsaXRpZXMgc3VjaCBhcyBtaWRkbGV3YXJlLFxuICogdGltZSB0cmF2ZWwsIHBlcnNpc3RlbmNlLCBldGMuIFRoZSBvbmx5IHN0b3JlIGVuaGFuY2VyIHRoYXQgc2hpcHMgd2l0aCBSZWR1eFxuICogaXMgYGFwcGx5TWlkZGxld2FyZSgpYC5cbiAqXG4gKiBAcmV0dXJucyB7U3RvcmV9IEEgUmVkdXggc3RvcmUgdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBzdGF0ZSwgZGlzcGF0Y2ggYWN0aW9uc1xuICogYW5kIHN1YnNjcmliZSB0byBjaGFuZ2VzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuaGFuY2VyID0gcHJlbG9hZGVkU3RhdGU7XG4gICAgcHJlbG9hZGVkU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgY3VycmVudFN0YXRlID0gcHJlbG9hZGVkU3RhdGU7XG4gIHZhciBjdXJyZW50TGlzdGVuZXJzID0gW107XG4gIHZhciBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycztcbiAgdmFyIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xuICAgIGlmIChuZXh0TGlzdGVuZXJzID09PSBjdXJyZW50TGlzdGVuZXJzKSB7XG4gICAgICBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycy5zbGljZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgc3RhdGUgdHJlZSBtYW5hZ2VkIGJ5IHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2hhbmdlIGxpc3RlbmVyLiBJdCB3aWxsIGJlIGNhbGxlZCBhbnkgdGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCxcbiAgICogYW5kIHNvbWUgcGFydCBvZiB0aGUgc3RhdGUgdHJlZSBtYXkgcG90ZW50aWFsbHkgaGF2ZSBjaGFuZ2VkLiBZb3UgbWF5IHRoZW5cbiAgICogY2FsbCBgZ2V0U3RhdGUoKWAgdG8gcmVhZCB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGluc2lkZSB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqIFlvdSBtYXkgY2FsbCBgZGlzcGF0Y2goKWAgZnJvbSBhIGNoYW5nZSBsaXN0ZW5lciwgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIGNhdmVhdHM6XG4gICAqXG4gICAqIDEuIFRoZSBzdWJzY3JpcHRpb25zIGFyZSBzbmFwc2hvdHRlZCBqdXN0IGJlZm9yZSBldmVyeSBgZGlzcGF0Y2goKWAgY2FsbC5cbiAgICogSWYgeW91IHN1YnNjcmliZSBvciB1bnN1YnNjcmliZSB3aGlsZSB0aGUgbGlzdGVuZXJzIGFyZSBiZWluZyBpbnZva2VkLCB0aGlzXG4gICAqIHdpbGwgbm90IGhhdmUgYW55IGVmZmVjdCBvbiB0aGUgYGRpc3BhdGNoKClgIHRoYXQgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLlxuICAgKiBIb3dldmVyLCB0aGUgbmV4dCBgZGlzcGF0Y2goKWAgY2FsbCwgd2hldGhlciBuZXN0ZWQgb3Igbm90LCB3aWxsIHVzZSBhIG1vcmVcbiAgICogcmVjZW50IHNuYXBzaG90IG9mIHRoZSBzdWJzY3JpcHRpb24gbGlzdC5cbiAgICpcbiAgICogMi4gVGhlIGxpc3RlbmVyIHNob3VsZCBub3QgZXhwZWN0IHRvIHNlZSBhbGwgc3RhdGUgY2hhbmdlcywgYXMgdGhlIHN0YXRlXG4gICAqIG1pZ2h0IGhhdmUgYmVlbiB1cGRhdGVkIG11bHRpcGxlIHRpbWVzIGR1cmluZyBhIG5lc3RlZCBgZGlzcGF0Y2goKWAgYmVmb3JlXG4gICAqIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQuIEl0IGlzLCBob3dldmVyLCBndWFyYW50ZWVkIHRoYXQgYWxsIHN1YnNjcmliZXJzXG4gICAqIHJlZ2lzdGVyZWQgYmVmb3JlIHRoZSBgZGlzcGF0Y2goKWAgc3RhcnRlZCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBsYXRlc3RcbiAgICogc3RhdGUgYnkgdGhlIHRpbWUgaXQgZXhpdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiBldmVyeSBkaXNwYXRjaC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGlzIGNoYW5nZSBsaXN0ZW5lci5cbiAgICovXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcblxuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICBuZXh0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcblxuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgdmFyIGluZGV4ID0gbmV4dExpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gYWN0aW9uLiBJdCBpcyB0aGUgb25seSB3YXkgdG8gdHJpZ2dlciBhIHN0YXRlIGNoYW5nZS5cbiAgICpcbiAgICogVGhlIGByZWR1Y2VyYCBmdW5jdGlvbiwgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JlLCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBnaXZlbiBgYWN0aW9uYC4gSXRzIHJldHVybiB2YWx1ZSB3aWxsXG4gICAqIGJlIGNvbnNpZGVyZWQgdGhlICoqbmV4dCoqIHN0YXRlIG9mIHRoZSB0cmVlLCBhbmQgdGhlIGNoYW5nZSBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSBub3RpZmllZC5cbiAgICpcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBwbGFpbiBvYmplY3QgYWN0aW9ucy4gSWYgeW91IHdhbnQgdG9cbiAgICogZGlzcGF0Y2ggYSBQcm9taXNlLCBhbiBPYnNlcnZhYmxlLCBhIHRodW5rLCBvciBzb21ldGhpbmcgZWxzZSwgeW91IG5lZWQgdG9cbiAgICogd3JhcCB5b3VyIHN0b3JlIGNyZWF0aW5nIGZ1bmN0aW9uIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbWlkZGxld2FyZS4gRm9yXG4gICAqIGV4YW1wbGUsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGByZWR1eC10aHVua2AgcGFja2FnZS4gRXZlbiB0aGVcbiAgICogbWlkZGxld2FyZSB3aWxsIGV2ZW50dWFsbHkgZGlzcGF0Y2ggcGxhaW4gb2JqZWN0IGFjdGlvbnMgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gQSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIOKAnHdoYXQgY2hhbmdlZOKAnS4gSXQgaXNcbiAgICogYSBnb29kIGlkZWEgdG8ga2VlcCBhY3Rpb25zIHNlcmlhbGl6YWJsZSBzbyB5b3UgY2FuIHJlY29yZCBhbmQgcmVwbGF5IHVzZXJcbiAgICogc2Vzc2lvbnMsIG9yIHVzZSB0aGUgdGltZSB0cmF2ZWxsaW5nIGByZWR1eC1kZXZ0b29sc2AuIEFuIGFjdGlvbiBtdXN0IGhhdmVcbiAgICogYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggbWF5IG5vdCBiZSBgdW5kZWZpbmVkYC4gSXQgaXMgYSBnb29kIGlkZWEgdG8gdXNlXG4gICAqIHN0cmluZyBjb25zdGFudHMgZm9yIGFjdGlvbiB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gRm9yIGNvbnZlbmllbmNlLCB0aGUgc2FtZSBhY3Rpb24gb2JqZWN0IHlvdSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQsIGlmIHlvdSB1c2UgYSBjdXN0b20gbWlkZGxld2FyZSwgaXQgbWF5IHdyYXAgYGRpc3BhdGNoKClgIHRvXG4gICAqIHJldHVybiBzb21ldGhpbmcgZWxzZSAoZm9yIGV4YW1wbGUsIGEgUHJvbWlzZSB5b3UgY2FuIGF3YWl0KS5cbiAgICovXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghKDAsIF9pc1BsYWluT2JqZWN0MlsnZGVmYXVsdCddKShhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiAnICsgJ1VzZSBjdXN0b20gbWlkZGxld2FyZSBmb3IgYXN5bmMgYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuICcgKyAnSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXJzIG1heSBub3QgZGlzcGF0Y2ggYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXSgpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBuZXh0UmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyb3BlcmFiaWxpdHkgcG9pbnQgZm9yIG9ic2VydmFibGUvcmVhY3RpdmUgbGlicmFyaWVzLlxuICAgKiBAcmV0dXJucyB7b2JzZXJ2YWJsZX0gQSBtaW5pbWFsIG9ic2VydmFibGUgb2Ygc3RhdGUgY2hhbmdlcy5cbiAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgb2JzZXJ2YWJsZSBwcm9wb3NhbDpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBvdXRlclN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICByZXR1cm4gX3JlZiA9IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG1pbmltYWwgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gbWV0aG9kLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVyIEFueSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBvYnNlcnZlci5cbiAgICAgICAqIFRoZSBvYnNlcnZlciBvYmplY3Qgc2hvdWxkIGhhdmUgYSBgbmV4dGAgbWV0aG9kLlxuICAgICAgICogQHJldHVybnMge3N1YnNjcmlwdGlvbn0gQW4gb2JqZWN0IHdpdGggYW4gYHVuc3Vic2NyaWJlYCBtZXRob2QgdGhhdCBjYW5cbiAgICAgICAqIGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmFibGUgZnJvbSB0aGUgc3RvcmUsIGFuZCBwcmV2ZW50IGZ1cnRoZXJcbiAgICAgICAqIGVtaXNzaW9uIG9mIHZhbHVlcyBmcm9tIHRoZSBvYnNlcnZhYmxlLlxuICAgICAgICovXG4gICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlU3RhdGUoKSB7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JzZXJ2ZVN0YXRlKCk7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZSA9IG91dGVyU3Vic2NyaWJlKG9ic2VydmVTdGF0ZSk7XG4gICAgICAgIHJldHVybiB7IHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSB9O1xuICAgICAgfVxuICAgIH0sIF9yZWZbX3N5bWJvbE9ic2VydmFibGUyWydkZWZhdWx0J11dID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgX3JlZjtcbiAgfVxuXG4gIC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG5cbiAgcmV0dXJuIF9yZWYyID0ge1xuICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXG4gICAgcmVwbGFjZVJlZHVjZXI6IHJlcGxhY2VSZWR1Y2VyXG4gIH0sIF9yZWYyW19zeW1ib2xPYnNlcnZhYmxlMlsnZGVmYXVsdCddXSA9IG9ic2VydmFibGUsIF9yZWYyO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWR1eC9saWIvY3JlYXRlU3RvcmUuanNcbiAqKi8iLCJ2YXIgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNIb3N0T2JqZWN0ID0gcmVxdWlyZSgnLi9faXNIb3N0T2JqZWN0JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHxcbiAgICAgIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpICE9IG9iamVjdFRhZyB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vbG9kYXNoL2lzUGxhaW5PYmplY3QuanNcbiAqKi8iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzXG4gKiovIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9sb2Rhc2gvX292ZXJBcmcuanNcbiAqKi8iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSG9zdE9iamVjdDtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9sb2Rhc2gvX2lzSG9zdE9iamVjdC5qc1xuICoqLyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9pbmRleCcpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BvbnlmaWxsID0gcmVxdWlyZSgnLi9wb255ZmlsbCcpO1xuXG52YXIgX3BvbnlmaWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BvbnlmaWxsKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgcm9vdCA9IHVuZGVmaW5lZDsgLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG5pZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0cm9vdCA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0cm9vdCA9IHdpbmRvdztcbn1cblxudmFyIHJlc3VsdCA9ICgwLCBfcG9ueWZpbGwyWydkZWZhdWx0J10pKHJvb3QpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gcmVzdWx0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGw7XG5mdW5jdGlvbiBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwocm9vdCkge1xuXHR2YXIgcmVzdWx0O1xuXHR2YXIgX1N5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgX1N5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGlmIChfU3ltYm9sLm9ic2VydmFibGUpIHtcblx0XHRcdHJlc3VsdCA9IF9TeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gX1N5bWJvbCgnb2JzZXJ2YWJsZScpO1xuXHRcdFx0X1N5bWJvbC5vYnNlcnZhYmxlID0gcmVzdWx0O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXN1bHQgPSAnQEBvYnNlcnZhYmxlJztcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzWydkZWZhdWx0J10gPSBjb21iaW5lUmVkdWNlcnM7XG5cbnZhciBfY3JlYXRlU3RvcmUgPSByZXF1aXJlKCcuL2NyZWF0ZVN0b3JlJyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbikge1xuICB2YXIgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgdmFyIGFjdGlvbk5hbWUgPSBhY3Rpb25UeXBlICYmICdcIicgKyBhY3Rpb25UeXBlLnRvU3RyaW5nKCkgKyAnXCInIHx8ICdhbiBhY3Rpb24nO1xuXG4gIHJldHVybiAnR2l2ZW4gYWN0aW9uICcgKyBhY3Rpb25OYW1lICsgJywgcmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkLiAnICsgJ1RvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4nO1xufVxuXG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSkge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBhcmd1bWVudE5hbWUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUID8gJ3ByZWxvYWRlZFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyWydkZWZhdWx0J10pKGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuICdUaGUgJyArIGFyZ3VtZW50TmFtZSArICcgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcIicgKyB7fS50b1N0cmluZy5jYWxsKGlucHV0U3RhdGUpLm1hdGNoKC9cXHMoW2EtenxBLVpdKykvKVsxXSArICdcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyAnICsgKCdrZXlzOiBcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIicpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldO1xuICB9KTtcblxuICB1bmV4cGVjdGVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSA9IHRydWU7XG4gIH0pO1xuXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICdVbmV4cGVjdGVkICcgKyAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/ICdrZXlzJyA6ICdrZXknKSArICcgJyArICgnXCInICsgdW5leHBlY3RlZEtleXMuam9pbignXCIsIFwiJykgKyAnXCIgZm91bmQgaW4gJyArIGFyZ3VtZW50TmFtZSArICcuICcpICsgJ0V4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogJyArICgnXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNhbml0eShyZWR1Y2Vycykge1xuICBPYmplY3Qua2V5cyhyZWR1Y2VycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHJlZHVjZXIgPSByZWR1Y2Vyc1trZXldO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLiAnICsgJ0lmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCAnICsgJ2V4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgJyArICdub3QgYmUgdW5kZWZpbmVkLicpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gJ0BAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05fJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xuICAgIGlmICh0eXBlb2YgcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogdHlwZSB9KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gJyArICgnRG9uXFwndCB0cnkgdG8gaGFuZGxlICcgKyBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCArICcgb3Igb3RoZXIgYWN0aW9ucyBpbiBcInJlZHV4LypcIiAnKSArICduYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSAnICsgJ2N1cnJlbnQgc3RhdGUgZm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsICcgKyAnaW4gd2hpY2ggY2FzZSB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUsIHJlZ2FyZGxlc3Mgb2YgdGhlICcgKyAnYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLicpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgZGlmZmVyZW50IHJlZHVjZXIgZnVuY3Rpb25zLCBpbnRvIGEgc2luZ2xlXG4gKiByZWR1Y2VyIGZ1bmN0aW9uLiBJdCB3aWxsIGNhbGwgZXZlcnkgY2hpbGQgcmVkdWNlciwgYW5kIGdhdGhlciB0aGVpciByZXN1bHRzXG4gKiBpbnRvIGEgc2luZ2xlIHN0YXRlIG9iamVjdCwgd2hvc2Uga2V5cyBjb3JyZXNwb25kIHRvIHRoZSBrZXlzIG9mIHRoZSBwYXNzZWRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWR1Y2VycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGNvcnJlc3BvbmQgdG8gZGlmZmVyZW50XG4gKiByZWR1Y2VyIGZ1bmN0aW9ucyB0aGF0IG5lZWQgdG8gYmUgY29tYmluZWQgaW50byBvbmUuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluXG4gKiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhcyByZWR1Y2Vyc2Agc3ludGF4LiBUaGUgcmVkdWNlcnMgbWF5IG5ldmVyIHJldHVyblxuICogdW5kZWZpbmVkIGZvciBhbnkgYWN0aW9uLiBJbnN0ZWFkLCB0aGV5IHNob3VsZCByZXR1cm4gdGhlaXIgaW5pdGlhbCBzdGF0ZVxuICogaWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGVtIHdhcyB1bmRlZmluZWQsIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBmb3IgYW55XG4gKiB1bnJlY29nbml6ZWQgYWN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSByZWR1Y2VyIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBldmVyeSByZWR1Y2VyIGluc2lkZSB0aGVcbiAqIHBhc3NlZCBvYmplY3QsIGFuZCBidWlsZHMgYSBzdGF0ZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZS5cbiAqL1xuZnVuY3Rpb24gY29tYmluZVJlZHVjZXJzKHJlZHVjZXJzKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGZpbmFsUmVkdWNlcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSByZWR1Y2VyS2V5c1tpXTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICgwLCBfd2FybmluZzJbJ2RlZmF1bHQnXSkoJ05vIHJlZHVjZXIgcHJvdmlkZWQgZm9yIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG4gIHZhciBmaW5hbFJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMoZmluYWxSZWR1Y2Vycyk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgdW5leHBlY3RlZEtleUNhY2hlID0ge307XG4gIH1cblxuICB2YXIgc2FuaXR5RXJyb3I7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNhbml0eShmaW5hbFJlZHVjZXJzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNhbml0eUVycm9yID0gZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzWzFdO1xuXG4gICAgaWYgKHNhbml0eUVycm9yKSB7XG4gICAgICB0aHJvdyBzYW5pdHlFcnJvcjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHdhcm5pbmdNZXNzYWdlID0gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShzdGF0ZSwgZmluYWxSZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpO1xuICAgICAgaWYgKHdhcm5pbmdNZXNzYWdlKSB7XG4gICAgICAgICgwLCBfd2FybmluZzJbJ2RlZmF1bHQnXSkod2FybmluZ01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGZpbmFsUmVkdWNlcktleXNbaV07XG4gICAgICB2YXIgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNba2V5XTtcbiAgICAgIHZhciBwcmV2aW91c1N0YXRlRm9yS2V5ID0gc3RhdGVba2V5XTtcbiAgICAgIHZhciBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG4gICAgICBpZiAodHlwZW9mIG5leHRTdGF0ZUZvcktleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGVba2V5XSA9IG5leHRTdGF0ZUZvcktleTtcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0NoYW5nZWQgPyBuZXh0U3RhdGUgOiBzdGF0ZTtcbiAgfTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVkdXgvbGliL2NvbWJpbmVSZWR1Y2Vycy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHdhcm5pbmc7XG4vKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGJpbmRBY3Rpb25DcmVhdG9ycztcbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZnVuY3Rpb24gaW4gcmV0dXJuLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBhY3Rpb25DcmVhdG9ycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb25cbiAqIGNyZWF0b3IgZnVuY3Rpb25zLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpbiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhc2BcbiAqIHN5bnRheC4gWW91IG1heSBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggVGhlIGBkaXNwYXRjaGAgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIHlvdXIgUmVkdXhcbiAqIHN0b3JlLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBvYmplY3QgbWltaWNraW5nIHRoZSBvcmlnaW5hbCBvYmplY3QsIGJ1dCB3aXRoXG4gKiBldmVyeSBhY3Rpb24gY3JlYXRvciB3cmFwcGVkIGludG8gdGhlIGBkaXNwYXRjaGAgY2FsbC4gSWYgeW91IHBhc3NlZCBhXG4gKiBmdW5jdGlvbiBhcyBgYWN0aW9uQ3JlYXRvcnNgLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYWxzbyBiZSBhIHNpbmdsZVxuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCAnICsgKGFjdGlvbkNyZWF0b3JzID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGFjdGlvbkNyZWF0b3JzKSArICcuICcgKyAnRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj8nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWN0aW9uQ3JlYXRvcnMpO1xuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWR1eC9saWIvYmluZEFjdGlvbkNyZWF0b3JzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBhcHBseU1pZGRsZXdhcmU7XG5cbnZhciBfY29tcG9zZSA9IHJlcXVpcmUoJy4vY29tcG9zZScpO1xuXG52YXIgX2NvbXBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9zZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RvcmUgZW5oYW5jZXIgdGhhdCBhcHBsaWVzIG1pZGRsZXdhcmUgdG8gdGhlIGRpc3BhdGNoIG1ldGhvZFxuICogb2YgdGhlIFJlZHV4IHN0b3JlLiBUaGlzIGlzIGhhbmR5IGZvciBhIHZhcmlldHkgb2YgdGFza3MsIHN1Y2ggYXMgZXhwcmVzc2luZ1xuICogYXN5bmNocm9ub3VzIGFjdGlvbnMgaW4gYSBjb25jaXNlIG1hbm5lciwgb3IgbG9nZ2luZyBldmVyeSBhY3Rpb24gcGF5bG9hZC5cbiAqXG4gKiBTZWUgYHJlZHV4LXRodW5rYCBwYWNrYWdlIGFzIGFuIGV4YW1wbGUgb2YgdGhlIFJlZHV4IG1pZGRsZXdhcmUuXG4gKlxuICogQmVjYXVzZSBtaWRkbGV3YXJlIGlzIHBvdGVudGlhbGx5IGFzeW5jaHJvbm91cywgdGhpcyBzaG91bGQgYmUgdGhlIGZpcnN0XG4gKiBzdG9yZSBlbmhhbmNlciBpbiB0aGUgY29tcG9zaXRpb24gY2hhaW4uXG4gKlxuICogTm90ZSB0aGF0IGVhY2ggbWlkZGxld2FyZSB3aWxsIGJlIGdpdmVuIHRoZSBgZGlzcGF0Y2hgIGFuZCBgZ2V0U3RhdGVgIGZ1bmN0aW9uc1xuICogYXMgbmFtZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1pZGRsZXdhcmVzIFRoZSBtaWRkbGV3YXJlIGNoYWluIHRvIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgc3RvcmUgZW5oYW5jZXIgYXBwbHlpbmcgdGhlIG1pZGRsZXdhcmUuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1pZGRsZXdhcmVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNyZWF0ZVN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcik7XG4gICAgICB2YXIgX2Rpc3BhdGNoID0gc3RvcmUuZGlzcGF0Y2g7XG4gICAgICB2YXIgY2hhaW4gPSBbXTtcblxuICAgICAgdmFyIG1pZGRsZXdhcmVBUEkgPSB7XG4gICAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBfZGlzcGF0Y2goYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNoYWluID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgICAgIHJldHVybiBtaWRkbGV3YXJlKG1pZGRsZXdhcmVBUEkpO1xuICAgICAgfSk7XG4gICAgICBfZGlzcGF0Y2ggPSBfY29tcG9zZTJbJ2RlZmF1bHQnXS5hcHBseSh1bmRlZmluZWQsIGNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RvcmUsIHtcbiAgICAgICAgZGlzcGF0Y2g6IF9kaXNwYXRjaFxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVkdXgvbGliL2FwcGx5TWlkZGxld2FyZS5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjb21wb3NlO1xuLyoqXG4gKiBDb21wb3NlcyBzaW5nbGUtYXJndW1lbnQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC4gVGhlIHJpZ2h0bW9zdFxuICogZnVuY3Rpb24gY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzIGFzIGl0IHByb3ZpZGVzIHRoZSBzaWduYXR1cmUgZm9yXG4gKiB0aGUgcmVzdWx0aW5nIGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jcyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gb2J0YWluZWQgYnkgY29tcG9zaW5nIHRoZSBhcmd1bWVudCBmdW5jdGlvbnNcbiAqIGZyb20gcmlnaHQgdG8gbGVmdC4gRm9yIGV4YW1wbGUsIGNvbXBvc2UoZiwgZywgaCkgaXMgaWRlbnRpY2FsIHRvIGRvaW5nXG4gKiAoLi4uYXJncykgPT4gZihnKGgoLi4uYXJncykpKS5cbiAqL1xuXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9O1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmdW5jc1swXTtcbiAgfVxuXG4gIHZhciBsYXN0ID0gZnVuY3NbZnVuY3MubGVuZ3RoIC0gMV07XG4gIHZhciByZXN0ID0gZnVuY3Muc2xpY2UoMCwgLTEpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXN0LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChjb21wb3NlZCwgZikge1xuICAgICAgcmV0dXJuIGYoY29tcG9zZWQpO1xuICAgIH0sIGxhc3QuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVkdXgvbGliL2NvbXBvc2UuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gICAgbmFtZTogdHJ1ZSxcbiAgICBsZW5ndGg6IHRydWUsXG4gICAgcHJvdG90eXBlOiB0cnVlLFxuICAgIGNhbGxlcjogdHJ1ZSxcbiAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgYXJpdHk6IHRydWVcbn07XG5cbnZhciBpc0dldE93blByb3BlcnR5U3ltYm9sc0F2YWlsYWJsZSA9IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBjdXN0b21TdGF0aWNzKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5c1tpXV0gJiYgIUtOT1dOX1NUQVRJQ1Nba2V5c1tpXV0gJiYgKCFjdXN0b21TdGF0aWNzIHx8ICFjdXN0b21TdGF0aWNzW2tleXNbaV1dKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENvbXBvbmVudFtrZXlzW2ldXSA9IHNvdXJjZUNvbXBvbmVudFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ludmFyaWFudC9icm93c2VyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZnVuY3Rpb24gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKGV4dHJhQXJndW1lbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGRpc3BhdGNoID0gX3JlZi5kaXNwYXRjaDtcbiAgICB2YXIgZ2V0U3RhdGUgPSBfcmVmLmdldFN0YXRlO1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aW9uKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmFBcmd1bWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufVxuXG52YXIgdGh1bmsgPSBjcmVhdGVUaHVua01pZGRsZXdhcmUoKTtcbnRodW5rLndpdGhFeHRyYUFyZ3VtZW50ID0gY3JlYXRlVGh1bmtNaWRkbGV3YXJlO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB0aHVuaztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVkdXgtdGh1bmsvbGliL2luZGV4LmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5cbmltcG9ydCBTb25nTGlzdCBmcm9tICcuL1NvbmdMaXN0JztcbmltcG9ydCB2YWx1ZXMgZnJvbSAnb2JqZWN0LnZhbHVlcyc7XG5cbmltcG9ydCB7XG4gIGNvbm5lY3RTb2NrZXQsXG4gIGRpc2Nvbm5lY3RTb2NrZXQsXG4gIHNlbmRNZXNzYWdlLFxuICB1cHZvdGVTb25nXG59IGZyb20gJy4vLi4vYWN0aW9ucyc7XG5cbmltcG9ydCAnLi8uLi9hcHAuY3NzJztcblxuY2xhc3MgQXBwIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIGxldCB7XG4gICAgICBkaXNwbGF5LFxuICAgICAgZGlzcGF0Y2gsXG4gICAgICBzb25nc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgbGV0IHVwdm90ZSA9IGJpbmRBY3Rpb25DcmVhdG9ycyh1cHZvdGVTb25nLCBkaXNwYXRjaCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdj5cbiAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBkaXNwYXRjaChjb25uZWN0U29ja2V0KCkpIH0+Q29ubmVjdDwvYnV0dG9uPlxuICAgICAgICA8YnIvPlxuICAgICAgICA8YnIvPlxuICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IGRpc3BhdGNoKGRpc2Nvbm5lY3RTb2NrZXQoKSkgfT5EaXNDb25uZWN0PC9idXR0b24+XG4gICAgICAgIDxici8+XG4gICAgICAgIDxici8+XG4gICAgICAgIDxpbnB1dCByZWY9XCJtZXNzYWdlXCI+PC9pbnB1dD5cbiAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBkaXNwYXRjaChzZW5kTWVzc2FnZSh0aGlzLnJlZnMubWVzc2FnZS52YWx1ZSkpIH0+U2VuZCBNZXNzYWdlPC9idXR0b24+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPFNvbmdMaXN0XG4gICAgICAgICAgICB1cHZvdGVTb25nPXt1cHZvdGV9XG4gICAgICAgICAgICBzb25ncz17c29uZ3N9Lz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChzdGF0ZSA9PiB7XG4gIHJldHVybiB7XG4gICAgc29uZ3M6IHZhbHVlcyhzdGF0ZS5zb25ncylcbiAgfVxufSkoQXBwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vY29tcG9uZW50cy9BcHAuanNcbiAqKi8iLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc29ydEJ5TGlrZXMgfSBmcm9tICcuLy4uL3NvcnQudXRpbC5qcyc7XG5cbmNsYXNzIFNvbmdMaXN0IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIGxldCBzb25ncyA9IHRoaXMucHJvcHMuc29uZ3Muc29ydChzb3J0QnlMaWtlcykubWFwKChzb25nLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMucHJvcHMudXB2b3RlU29uZy5iaW5kKHRoaXMsIHNvbmcuaWQpfVxuICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgY2xhc3NOYW1lPVwic29uZ1wiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic29uZy1uYW1lXCI+e3NvbmcubmFtZX08L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNvbmctbGlrZXNcIj57c29uZy5saWtlc308L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApXG4gICAgfSlcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJsaXN0XCI+XG4gICAgICAgIHtzb25nc31cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTb25nTGlzdDtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vY29tcG9uZW50cy9Tb25nTGlzdC5qc1xuICoqLyIsImV4cG9ydCBmdW5jdGlvbiBzb3J0QnlMaWtlcyhhLCBiKSB7XG4gIGlmKGEubGlrZXMgPiBiLmxpa2VzKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZihhLmxpa2VzIDwgYi5saWtlcykge1xuICAgIHJldHVybiAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NvcnQudXRpbC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBzaGltID0gcmVxdWlyZSgnLi9zaGltJyk7XG5cbmRlZmluZShpbXBsZW1lbnRhdGlvbiwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gaW1wbGVtZW50YXRpb247XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vb2JqZWN0LnZhbHVlcy9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cycpO1xudmFyIGZvcmVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgpID09PSAnc3ltYm9sJztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcblx0cmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0ci5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBhcmVQcm9wZXJ0eURlc2NyaXB0b3JzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgb2JqID0ge307XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ3gnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogb2JqIH0pO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cbiAgICAgICAgZm9yICh2YXIgXyBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG5cdFx0cmV0dXJuIG9iai54ID09PSBvYmo7XG5cdH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBJRSA4LiAqL1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIGFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQoKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgdmFsdWUsIHByZWRpY2F0ZSkge1xuXHRpZiAobmFtZSBpbiBvYmplY3QgJiYgKCFpc0Z1bmN0aW9uKHByZWRpY2F0ZSkgfHwgIXByZWRpY2F0ZSgpKSkge1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRvYmplY3RbbmFtZV0gPSB2YWx1ZTtcblx0fVxufTtcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXApIHtcblx0dmFyIHByZWRpY2F0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXHR2YXIgcHJvcHMgPSBrZXlzKG1hcCk7XG5cdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0cHJvcHMgPSBwcm9wcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtYXApKTtcblx0fVxuXHRmb3JlYWNoKHByb3BzLCBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgbWFwW25hbWVdLCBwcmVkaWNhdGVzW25hbWVdKTtcblx0fSk7XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzLnN1cHBvcnRzRGVzY3JpcHRvcnMgPSAhIXN1cHBvcnRzRGVzY3JpcHRvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydGllcztcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9kZWZpbmUtcHJvcGVydGllcy9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLy8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpc0FyZ3MgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyk7XG52YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBoYXNEb250RW51bUJ1ZyA9ICFpc0VudW1lcmFibGUuY2FsbCh7IHRvU3RyaW5nOiBudWxsIH0sICd0b1N0cmluZycpO1xudmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG52YXIgZG9udEVudW1zID0gW1xuXHQndG9TdHJpbmcnLFxuXHQndG9Mb2NhbGVTdHJpbmcnLFxuXHQndmFsdWVPZicsXG5cdCdoYXNPd25Qcm9wZXJ0eScsXG5cdCdpc1Byb3RvdHlwZU9mJyxcblx0J3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcblx0J2NvbnN0cnVjdG9yJ1xuXTtcbnZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG5cdHZhciBjdG9yID0gby5jb25zdHJ1Y3Rvcjtcblx0cmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG59O1xudmFyIGV4Y2x1ZGVkS2V5cyA9IHtcblx0JGNvbnNvbGU6IHRydWUsXG5cdCRleHRlcm5hbDogdHJ1ZSxcblx0JGZyYW1lOiB0cnVlLFxuXHQkZnJhbWVFbGVtZW50OiB0cnVlLFxuXHQkZnJhbWVzOiB0cnVlLFxuXHQkaW5uZXJIZWlnaHQ6IHRydWUsXG5cdCRpbm5lcldpZHRoOiB0cnVlLFxuXHQkb3V0ZXJIZWlnaHQ6IHRydWUsXG5cdCRvdXRlcldpZHRoOiB0cnVlLFxuXHQkcGFnZVhPZmZzZXQ6IHRydWUsXG5cdCRwYWdlWU9mZnNldDogdHJ1ZSxcblx0JHBhcmVudDogdHJ1ZSxcblx0JHNjcm9sbExlZnQ6IHRydWUsXG5cdCRzY3JvbGxUb3A6IHRydWUsXG5cdCRzY3JvbGxYOiB0cnVlLFxuXHQkc2Nyb2xsWTogdHJ1ZSxcblx0JHNlbGY6IHRydWUsXG5cdCR3ZWJraXRJbmRleGVkREI6IHRydWUsXG5cdCR3ZWJraXRTdG9yYWdlSW5mbzogdHJ1ZSxcblx0JHdpbmRvdzogdHJ1ZVxufTtcbnZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuXHQvKiBnbG9iYWwgd2luZG93ICovXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Zm9yICh2YXIgayBpbiB3aW5kb3cpIHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFleGNsdWRlZEtleXNbJyQnICsga10gJiYgaGFzLmNhbGwod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufSgpKTtcbnZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAobykge1xuXHQvKiBnbG9iYWwgd2luZG93ICovXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnKSB7XG5cdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG52YXIga2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHR2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG5cdHZhciBpc0Z1bmN0aW9uID0gdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0dmFyIGlzU3RyaW5nID0gaXNPYmplY3QgJiYgdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBTdHJpbmddJztcblx0dmFyIHRoZUtleXMgPSBbXTtcblxuXHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcblx0fVxuXG5cdHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcblx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0Lmxlbmd0aDsgKytqKSB7XG5cdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGopKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcblx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG5cblx0XHRmb3IgKHZhciBrID0gMDsgayA8IGRvbnRFbnVtcy5sZW5ndGg7ICsraykge1xuXHRcdFx0aWYgKCEoc2tpcENvbnN0cnVjdG9yICYmIGRvbnRFbnVtc1trXSA9PT0gJ2NvbnN0cnVjdG9yJykgJiYgaGFzLmNhbGwob2JqZWN0LCBkb250RW51bXNba10pKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChkb250RW51bXNba10pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGhlS2V5cztcbn07XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHJldHVybiAoT2JqZWN0LmtleXMoYXJndW1lbnRzKSB8fCAnJykubGVuZ3RoID09PSAyO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0dmFyIG9yaWdpbmFsS2V5cyA9IE9iamVjdC5rZXlzO1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRPYmplY3Qua2V5cyA9IGtleXNTaGltO1xuXHR9XG5cdHJldHVybiBPYmplY3Qua2V5cyB8fCBrZXlzU2hpbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vb2JqZWN0LWtleXMvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHR2YXIgaXNBcmdzID0gc3RyID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcblx0aWYgKCFpc0FyZ3MpIHtcblx0XHRpc0FyZ3MgPSBzdHIgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHRcdHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0fVxuXHRyZXR1cm4gaXNBcmdzO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qc1xuICoqLyIsIlxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKG9iaiwgZm4sIGN0eCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsID09PSArbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZm9yZWFjaC9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEVTID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvZXM3Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBpc0VudW1lcmFibGUgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsdWVzKE8pIHtcblx0dmFyIG9iaiA9IEVTLlJlcXVpcmVPYmplY3RDb2VyY2libGUoTyk7XG5cdHZhciB2YWxzID0gW107XG5cdGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0XHRpZiAoaGFzKG9iaiwga2V5KSAmJiBpc0VudW1lcmFibGUob2JqLCBrZXkpKSB7XG5cdFx0XHR2YWxzLnB1c2gob2JqW2tleV0pO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFscztcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vb2JqZWN0LnZhbHVlcy9pbXBsZW1lbnRhdGlvbi5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEVTNiA9IHJlcXVpcmUoJy4vZXM2Jyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Fzc2lnbicpO1xuXG52YXIgRVM3ID0gYXNzaWduKEVTNiwge1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9lY21hMjYyL3B1bGwvNjBcblx0U2FtZVZhbHVlTm9uTnVtYmVyOiBmdW5jdGlvbiBTYW1lVmFsdWVOb25OdW1iZXIoeCwgeSkge1xuXHRcdGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHggIT09IHR5cGVvZiB5KSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdTYW1lVmFsdWVOb25OdW1iZXIgcmVxdWlyZXMgdHdvIG5vbi1udW1iZXIgdmFsdWVzIG9mIHRoZSBzYW1lIHR5cGUuJyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLlNhbWVWYWx1ZSh4LCB5KTtcblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRVM3O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VzLWFic3RyYWN0L2VzNy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJztcbnZhciBzeW1ib2xUb1N0ciA9IGhhc1N5bWJvbHMgPyBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nIDogdG9TdHI7XG5cbnZhciAkaXNOYU4gPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNOYU4nKTtcbnZhciAkaXNGaW5pdGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNGaW5pdGUnKTtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgTWF0aC5wb3coMiwgNTMpIC0gMTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vaGVscGVycy9hc3NpZ24nKTtcbnZhciBzaWduID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NpZ24nKTtcbnZhciBtb2QgPSByZXF1aXJlKCcuL2hlbHBlcnMvbW9kJyk7XG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNQcmltaXRpdmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2VzLXRvLXByaW1pdGl2ZS9lczYnKTtcbnZhciBwYXJzZUludGVnZXIgPSBwYXJzZUludDtcbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xudmFyIGlzQmluYXJ5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUudGVzdCwgL14wYlswMV0rJC9pKTtcbnZhciBpc09jdGFsID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUudGVzdCwgL14wb1swLTddKyQvaSk7XG52YXIgbm9uV1MgPSBbJ1xcdTAwODUnLCAnXFx1MjAwYicsICdcXHVmZmZlJ10uam9pbignJyk7XG52YXIgbm9uV1NyZWdleCA9IG5ldyBSZWdFeHAoJ1snICsgbm9uV1MgKyAnXScsICdnJyk7XG52YXIgaGFzTm9uV1MgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgUmVnRXhwLnByb3RvdHlwZS50ZXN0LCBub25XU3JlZ2V4KTtcbnZhciBpbnZhbGlkSGV4TGl0ZXJhbCA9IC9eW1xcLVxcK10weFswLTlhLWZdKyQvaTtcbnZhciBpc0ludmFsaWRIZXhMaXRlcmFsID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUudGVzdCwgaW52YWxpZEhleExpdGVyYWwpO1xuXG4vLyB3aGl0ZXNwYWNlIGZyb206IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuNS40LjIwXG4vLyBpbXBsZW1lbnRhdGlvbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9ibG9iL3YzLjQuMC9lczUtc2hpbS5qcyNMMTMwNC1MMTMyNFxudmFyIHdzID0gW1xuXHQnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnLFxuXHQnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjgnLFxuXHQnXFx1MjAyOVxcdUZFRkYnXG5dLmpvaW4oJycpO1xudmFyIHRyaW1SZWdleCA9IG5ldyBSZWdFeHAoJyheWycgKyB3cyArICddKyl8KFsnICsgd3MgKyAnXSskKScsICdnJyk7XG52YXIgcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyIHRyaW0gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIHJlcGxhY2UodmFsdWUsIHRyaW1SZWdleCwgJycpO1xufTtcblxudmFyIEVTNSA9IHJlcXVpcmUoJy4vZXM1Jyk7XG5cbnZhciBoYXNSZWdFeHBNYXRjaGVyID0gcmVxdWlyZSgnaXMtcmVnZXgnKTtcblxuLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWFic3RyYWN0LW9wZXJhdGlvbnNcbnZhciBFUzYgPSBhc3NpZ24oYXNzaWduKHt9LCBFUzUpLCB7XG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWNhbGwtZi12LWFyZ3Ncblx0Q2FsbDogZnVuY3Rpb24gQ2FsbChGLCBWKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IFtdO1xuXHRcdGlmICghdGhpcy5Jc0NhbGxhYmxlKEYpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKEYgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cdFx0fVxuXHRcdHJldHVybiBGLmFwcGx5KFYsIGFyZ3MpO1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b3ByaW1pdGl2ZVxuXHRUb1ByaW1pdGl2ZTogdG9QcmltaXRpdmUsXG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvYm9vbGVhblxuXHQvLyBUb0Jvb2xlYW46IEVTNS5Ub0Jvb2xlYW4sXG5cblx0Ly8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbnVtYmVyXG5cdFRvTnVtYmVyOiBmdW5jdGlvbiBUb051bWJlcihhcmd1bWVudCkge1xuXHRcdHZhciB2YWx1ZSA9IGlzUHJpbWl0aXZlKGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogdG9QcmltaXRpdmUoYXJndW1lbnQsICdudW1iZXInKTtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBudW1iZXInKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGlmIChpc0JpbmFyeSh2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuVG9OdW1iZXIocGFyc2VJbnRlZ2VyKHN0clNsaWNlKHZhbHVlLCAyKSwgMikpO1xuXHRcdFx0fSBlbHNlIGlmIChpc09jdGFsKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5Ub051bWJlcihwYXJzZUludGVnZXIoc3RyU2xpY2UodmFsdWUsIDIpLCA4KSk7XG5cdFx0XHR9IGVsc2UgaWYgKGhhc05vbldTKHZhbHVlKSB8fCBpc0ludmFsaWRIZXhMaXRlcmFsKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gTmFOO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHRyaW1tZWQgPSB0cmltKHZhbHVlKTtcblx0XHRcdFx0aWYgKHRyaW1tZWQgIT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuVG9OdW1iZXIodHJpbW1lZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIE51bWJlcih2YWx1ZSk7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvaW50ZWdlclxuXHQvLyBUb0ludGVnZXI6IEVTNS5Ub051bWJlcixcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9pbnQzMlxuXHQvLyBUb0ludDMyOiBFUzUuVG9JbnQzMixcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG91aW50MzJcblx0Ly8gVG9VaW50MzI6IEVTNS5Ub1VpbnQzMixcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9pbnQxNlxuXHRUb0ludDE2OiBmdW5jdGlvbiBUb0ludDE2KGFyZ3VtZW50KSB7XG5cdFx0dmFyIGludDE2Yml0ID0gdGhpcy5Ub1VpbnQxNihhcmd1bWVudCk7XG5cdFx0cmV0dXJuIGludDE2Yml0ID49IDB4ODAwMCA/IGludDE2Yml0IC0gMHgxMDAwMCA6IGludDE2Yml0O1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b3VpbnQxNlxuXHQvLyBUb1VpbnQxNjogRVM1LlRvVWludDE2LFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2ludDhcblx0VG9JbnQ4OiBmdW5jdGlvbiBUb0ludDgoYXJndW1lbnQpIHtcblx0XHR2YXIgaW50OGJpdCA9IHRoaXMuVG9VaW50OChhcmd1bWVudCk7XG5cdFx0cmV0dXJuIGludDhiaXQgPj0gMHg4MCA/IGludDhiaXQgLSAweDEwMCA6IGludDhiaXQ7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvdWludDhcblx0VG9VaW50ODogZnVuY3Rpb24gVG9VaW50OChhcmd1bWVudCkge1xuXHRcdHZhciBudW1iZXIgPSB0aGlzLlRvTnVtYmVyKGFyZ3VtZW50KTtcblx0XHRpZiAoJGlzTmFOKG51bWJlcikgfHwgbnVtYmVyID09PSAwIHx8ICEkaXNGaW5pdGUobnVtYmVyKSkgeyByZXR1cm4gMDsgfVxuXHRcdHZhciBwb3NJbnQgPSBzaWduKG51bWJlcikgKiBNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikpO1xuXHRcdHJldHVybiBtb2QocG9zSW50LCAweDEwMCk7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvdWludDhjbGFtcFxuXHRUb1VpbnQ4Q2xhbXA6IGZ1bmN0aW9uIFRvVWludDhDbGFtcChhcmd1bWVudCkge1xuXHRcdHZhciBudW1iZXIgPSB0aGlzLlRvTnVtYmVyKGFyZ3VtZW50KTtcblx0XHRpZiAoJGlzTmFOKG51bWJlcikgfHwgbnVtYmVyIDw9IDApIHsgcmV0dXJuIDA7IH1cblx0XHRpZiAobnVtYmVyID49IDB4RkYpIHsgcmV0dXJuIDB4RkY7IH1cblx0XHR2YXIgZiA9IE1hdGguZmxvb3IoYXJndW1lbnQpO1xuXHRcdGlmIChmICsgMC41IDwgbnVtYmVyKSB7IHJldHVybiBmICsgMTsgfVxuXHRcdGlmIChudW1iZXIgPCBmICsgMC41KSB7IHJldHVybiBmOyB9XG5cdFx0aWYgKGYgJSAyICE9PSAwKSB7IHJldHVybiBmICsgMTsgfVxuXHRcdHJldHVybiBmO1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b3N0cmluZ1xuXHRUb1N0cmluZzogZnVuY3Rpb24gVG9TdHJpbmcoYXJndW1lbnQpIHtcblx0XHRpZiAodHlwZW9mIGFyZ3VtZW50ID09PSAnc3ltYm9sJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcblx0XHR9XG5cdFx0cmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvb2JqZWN0XG5cdFRvT2JqZWN0OiBmdW5jdGlvbiBUb09iamVjdCh2YWx1ZSkge1xuXHRcdHRoaXMuUmVxdWlyZU9iamVjdENvZXJjaWJsZSh2YWx1ZSk7XG5cdFx0cmV0dXJuIE9iamVjdCh2YWx1ZSk7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvcHJvcGVydHlrZXlcblx0VG9Qcm9wZXJ0eUtleTogZnVuY3Rpb24gVG9Qcm9wZXJ0eUtleShhcmd1bWVudCkge1xuXHRcdHZhciBrZXkgPSB0aGlzLlRvUHJpbWl0aXZlKGFyZ3VtZW50LCBTdHJpbmcpO1xuXHRcdHJldHVybiB0eXBlb2Yga2V5ID09PSAnc3ltYm9sJyA/IHN5bWJvbFRvU3RyLmNhbGwoa2V5KSA6IHRoaXMuVG9TdHJpbmcoa2V5KTtcblx0fSxcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcblx0VG9MZW5ndGg6IGZ1bmN0aW9uIFRvTGVuZ3RoKGFyZ3VtZW50KSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMuVG9JbnRlZ2VyKGFyZ3VtZW50KTtcblx0XHRpZiAobGVuIDw9IDApIHsgcmV0dXJuIDA7IH0gLy8gaW5jbHVkZXMgY29udmVydGluZyAtMCB0byArMFxuXHRcdGlmIChsZW4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7IHJldHVybiBNQVhfU0FGRV9JTlRFR0VSOyB9XG5cdFx0cmV0dXJuIGxlbjtcblx0fSxcblxuXHQvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtY2Fub25pY2FsbnVtZXJpY2luZGV4c3RyaW5nXG5cdENhbm9uaWNhbE51bWVyaWNJbmRleFN0cmluZzogZnVuY3Rpb24gQ2Fub25pY2FsTnVtZXJpY0luZGV4U3RyaW5nKGFyZ3VtZW50KSB7XG5cdFx0aWYgKHRvU3RyLmNhbGwoYXJndW1lbnQpICE9PSAnW29iamVjdCBTdHJpbmddJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBiZSBhIHN0cmluZycpO1xuXHRcdH1cblx0XHRpZiAoYXJndW1lbnQgPT09ICctMCcpIHsgcmV0dXJuIC0wOyB9XG5cdFx0dmFyIG4gPSB0aGlzLlRvTnVtYmVyKGFyZ3VtZW50KTtcblx0XHRpZiAodGhpcy5TYW1lVmFsdWUodGhpcy5Ub1N0cmluZyhuKSwgYXJndW1lbnQpKSB7IHJldHVybiBuOyB9XG5cdFx0cmV0dXJuIHZvaWQgMDtcblx0fSxcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxuXHRSZXF1aXJlT2JqZWN0Q29lcmNpYmxlOiBFUzUuQ2hlY2tPYmplY3RDb2VyY2libGUsXG5cblx0Ly8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWlzYXJyYXlcblx0SXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBJc0FycmF5KGFyZ3VtZW50KSB7XG5cdFx0cmV0dXJuIHRvU3RyLmNhbGwoYXJndW1lbnQpID09PSAnW29iamVjdCBBcnJheV0nO1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1pc2NhbGxhYmxlXG5cdC8vIElzQ2FsbGFibGU6IEVTNS5Jc0NhbGxhYmxlLFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1pc2NvbnN0cnVjdG9yXG5cdElzQ29uc3RydWN0b3I6IGZ1bmN0aW9uIElzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09PSAnZnVuY3Rpb24nICYmICEhYXJndW1lbnQucHJvdG90eXBlOyAvLyB1bmZvcnR1bmF0ZWx5IHRoZXJlJ3Mgbm8gd2F5IHRvIHRydWx5IGNoZWNrIHRoaXMgd2l0aG91dCB0cnkvY2F0Y2ggYG5ldyBhcmd1bWVudGBcblx0fSxcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtaXNleHRlbnNpYmxlLW9cblx0SXNFeHRlbnNpYmxlOiBmdW5jdGlvbiBJc0V4dGVuc2libGUob2JqKSB7XG5cdFx0aWYgKCFPYmplY3QucHJldmVudEV4dGVuc2lvbnMpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoaXNQcmltaXRpdmUob2JqKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gT2JqZWN0LmlzRXh0ZW5zaWJsZShvYmopO1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1pc2ludGVnZXJcblx0SXNJbnRlZ2VyOiBmdW5jdGlvbiBJc0ludGVnZXIoYXJndW1lbnQpIHtcblx0XHRpZiAodHlwZW9mIGFyZ3VtZW50ICE9PSAnbnVtYmVyJyB8fCAkaXNOYU4oYXJndW1lbnQpIHx8ICEkaXNGaW5pdGUoYXJndW1lbnQpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHZhciBhYnMgPSBNYXRoLmFicyhhcmd1bWVudCk7XG5cdFx0cmV0dXJuIE1hdGguZmxvb3IoYWJzKSA9PT0gYWJzO1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1pc3Byb3BlcnR5a2V5XG5cdElzUHJvcGVydHlLZXk6IGZ1bmN0aW9uIElzUHJvcGVydHlLZXkoYXJndW1lbnQpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXJndW1lbnQgPT09ICdzeW1ib2wnO1xuXHR9LFxuXG5cdC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1pc3JlZ2V4cFxuXHRJc1JlZ0V4cDogZnVuY3Rpb24gSXNSZWdFeHAoYXJndW1lbnQpIHtcblx0XHRpZiAoIWFyZ3VtZW50IHx8IHR5cGVvZiBhcmd1bWVudCAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRcdHZhciBpc1JlZ0V4cCA9IGFyZ3VtZW50W1N5bWJvbC5tYXRjaF07XG5cdFx0XHRpZiAodHlwZW9mIGlzUmVnRXhwICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRyZXR1cm4gRVM1LlRvQm9vbGVhbihpc1JlZ0V4cCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBoYXNSZWdFeHBNYXRjaGVyKGFyZ3VtZW50KTtcblx0fSxcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlXG5cdC8vIFNhbWVWYWx1ZTogRVM1LlNhbWVWYWx1ZSxcblxuXHQvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVyb1xuXHRTYW1lVmFsdWVaZXJvOiBmdW5jdGlvbiBTYW1lVmFsdWVaZXJvKHgsIHkpIHtcblx0XHRyZXR1cm4gKHggPT09IHkpIHx8ICgkaXNOYU4oeCkgJiYgJGlzTmFOKHkpKTtcblx0fSxcblxuXHRUeXBlOiBmdW5jdGlvbiBUeXBlKHgpIHtcblx0XHRpZiAodHlwZW9mIHggPT09ICdzeW1ib2wnKSB7XG5cdFx0XHRyZXR1cm4gJ1N5bWJvbCc7XG5cdFx0fVxuXHRcdHJldHVybiBFUzUuVHlwZSh4KTtcblx0fSxcblxuXHQvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc3BlY2llc2NvbnN0cnVjdG9yXG5cdFNwZWNpZXNDb25zdHJ1Y3RvcjogZnVuY3Rpb24gU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3Rvcikge1xuXHRcdGlmICh0aGlzLlR5cGUoTykgIT09ICdPYmplY3QnKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiBUeXBlKE8pIGlzIG5vdCBPYmplY3QnKTtcblx0XHR9XG5cdFx0dmFyIEMgPSBPLmNvbnN0cnVjdG9yO1xuXHRcdGlmICh0eXBlb2YgQyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBkZWZhdWx0Q29uc3RydWN0b3I7XG5cdFx0fVxuXHRcdGlmICh0aGlzLlR5cGUoQykgIT09ICdPYmplY3QnKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPLmNvbnN0cnVjdG9yIGlzIG5vdCBhbiBPYmplY3QnKTtcblx0XHR9XG5cdFx0dmFyIFMgPSBoYXNTeW1ib2xzICYmIFN5bWJvbC5zcGVjaWVzID8gQ1tTeW1ib2wuc3BlY2llc10gOiB1bmRlZmluZWQ7XG5cdFx0aWYgKFMgPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGRlZmF1bHRDb25zdHJ1Y3Rvcjtcblx0XHR9XG5cdFx0aWYgKHRoaXMuSXNDb25zdHJ1Y3RvcihTKSkge1xuXHRcdFx0cmV0dXJuIFM7XG5cdFx0fVxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIGNvbnN0cnVjdG9yIGZvdW5kJyk7XG5cdH1cbn0pO1xuXG5kZWxldGUgRVM2LkNoZWNrT2JqZWN0Q29lcmNpYmxlOyAvLyByZW5hbWVkIGluIEVTNiB0byBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlXG5cbm1vZHVsZS5leHBvcnRzID0gRVM2O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VzLWFic3RyYWN0L2VzNi5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIGlzTmFOKGEpIHtcblx0cmV0dXJuIGEgIT09IGE7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VzLWFic3RyYWN0L2hlbHBlcnMvaXNOYU4uanNcbiAqKi8iLCJ2YXIgJGlzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhICE9PSBhOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmICEkaXNOYU4oeCkgJiYgeCAhPT0gSW5maW5pdHkgJiYgeCAhPT0gLUluZmluaXR5OyB9O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VzLWFic3RyYWN0L2hlbHBlcnMvaXNGaW5pdGUuanNcbiAqKi8iLCJ2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHtcblx0Zm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuXHRcdGlmIChoYXMuY2FsbChzb3VyY2UsIGtleSkpIHtcblx0XHRcdHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VzLWFic3RyYWN0L2hlbHBlcnMvYXNzaWduLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaWduKG51bWJlcikge1xuXHRyZXR1cm4gbnVtYmVyID49IDAgPyAxIDogLTE7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VzLWFic3RyYWN0L2hlbHBlcnMvc2lnbi5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbW9kKG51bWJlciwgbW9kdWxvKSB7XG5cdHZhciByZW1haW4gPSBudW1iZXIgJSBtb2R1bG87XG5cdHJldHVybiBNYXRoLmZsb29yKHJlbWFpbiA+PSAwID8gcmVtYWluIDogcmVtYWluICsgbW9kdWxvKTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZXMtYWJzdHJhY3QvaGVscGVycy9tb2QuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9lcy1hYnN0cmFjdC9oZWxwZXJzL2lzUHJpbWl0aXZlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCc7XG5cbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc1ByaW1pdGl2ZScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCdpcy1jYWxsYWJsZScpO1xudmFyIGlzRGF0ZSA9IHJlcXVpcmUoJ2lzLWRhdGUtb2JqZWN0Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCdpcy1zeW1ib2wnKTtcblxudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBmdW5jdGlvbiBPcmRpbmFyeVRvUHJpbWl0aXZlKE8sIGhpbnQpIHtcblx0aWYgKHR5cGVvZiBPID09PSAndW5kZWZpbmVkJyB8fCBPID09PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgbWV0aG9kIG9uICcgKyBPKTtcblx0fVxuXHRpZiAodHlwZW9mIGhpbnQgIT09ICdzdHJpbmcnIHx8IChoaW50ICE9PSAnbnVtYmVyJyAmJiBoaW50ICE9PSAnc3RyaW5nJykpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdoaW50IG11c3QgYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiJyk7XG5cdH1cblx0dmFyIG1ldGhvZE5hbWVzID0gaGludCA9PT0gJ3N0cmluZycgPyBbJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnXSA6IFsndmFsdWVPZicsICd0b1N0cmluZyddO1xuXHR2YXIgbWV0aG9kLCByZXN1bHQsIGk7XG5cdGZvciAoaSA9IDA7IGkgPCBtZXRob2ROYW1lcy5sZW5ndGg7ICsraSkge1xuXHRcdG1ldGhvZCA9IE9bbWV0aG9kTmFtZXNbaV1dO1xuXHRcdGlmIChpc0NhbGxhYmxlKG1ldGhvZCkpIHtcblx0XHRcdHJlc3VsdCA9IG1ldGhvZC5jYWxsKE8pO1xuXHRcdFx0aWYgKGlzUHJpbWl0aXZlKHJlc3VsdCkpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0dGhyb3cgbmV3IFR5cGVFcnJvcignTm8gZGVmYXVsdCB2YWx1ZScpO1xufTtcblxudmFyIEdldE1ldGhvZCA9IGZ1bmN0aW9uIEdldE1ldGhvZChPLCBQKSB7XG5cdHZhciBmdW5jID0gT1tQXTtcblx0aWYgKGZ1bmMgIT09IG51bGwgJiYgdHlwZW9mIGZ1bmMgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0aWYgKCFpc0NhbGxhYmxlKGZ1bmMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGZ1bmMgKyAnIHJldHVybmVkIGZvciBwcm9wZXJ0eSAnICsgUCArICcgb2Ygb2JqZWN0ICcgKyBPICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHRcdH1cblx0XHRyZXR1cm4gZnVuYztcblx0fVxufTtcblxuLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0LCBQcmVmZXJyZWRUeXBlKSB7XG5cdGlmIChpc1ByaW1pdGl2ZShpbnB1dCkpIHtcblx0XHRyZXR1cm4gaW5wdXQ7XG5cdH1cblx0dmFyIGhpbnQgPSAnZGVmYXVsdCc7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdGlmIChQcmVmZXJyZWRUeXBlID09PSBTdHJpbmcpIHtcblx0XHRcdGhpbnQgPSAnc3RyaW5nJztcblx0XHR9IGVsc2UgaWYgKFByZWZlcnJlZFR5cGUgPT09IE51bWJlcikge1xuXHRcdFx0aGludCA9ICdudW1iZXInO1xuXHRcdH1cblx0fVxuXG5cdHZhciBleG90aWNUb1ByaW07XG5cdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0aWYgKFN5bWJvbC50b1ByaW1pdGl2ZSkge1xuXHRcdFx0ZXhvdGljVG9QcmltID0gR2V0TWV0aG9kKGlucHV0LCBTeW1ib2wudG9QcmltaXRpdmUpO1xuXHRcdH0gZWxzZSBpZiAoaXNTeW1ib2woaW5wdXQpKSB7XG5cdFx0XHRleG90aWNUb1ByaW0gPSBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2Y7XG5cdFx0fVxuXHR9XG5cdGlmICh0eXBlb2YgZXhvdGljVG9QcmltICE9PSAndW5kZWZpbmVkJykge1xuXHRcdHZhciByZXN1bHQgPSBleG90aWNUb1ByaW0uY2FsbChpbnB1dCwgaGludCk7XG5cdFx0aWYgKGlzUHJpbWl0aXZlKHJlc3VsdCkpIHtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuYWJsZSB0byBjb252ZXJ0IGV4b3RpYyBvYmplY3QgdG8gcHJpbWl0aXZlJyk7XG5cdH1cblx0aWYgKGhpbnQgPT09ICdkZWZhdWx0JyAmJiAoaXNEYXRlKGlucHV0KSB8fCBpc1N5bWJvbChpbnB1dCkpKSB7XG5cdFx0aGludCA9ICdzdHJpbmcnO1xuXHR9XG5cdHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBoaW50ID09PSAnZGVmYXVsdCcgPyAnbnVtYmVyJyA6IGhpbnQpO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9lcy10by1wcmltaXRpdmUvZXM2LmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZXMtdG8tcHJpbWl0aXZlL2hlbHBlcnMvaXNQcmltaXRpdmUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzIC87XG52YXIgaXNFUzZDbGFzc0ZuID0gZnVuY3Rpb24gaXNFUzZDbGFzc0ZuKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0dmFyIGZuU3RyID0gZm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHR2YXIgc2luZ2xlU3RyaXBwZWQgPSBmblN0ci5yZXBsYWNlKC9cXC9cXC8uKlxcbi9nLCAnJyk7XG5cdFx0dmFyIG11bHRpU3RyaXBwZWQgPSBzaW5nbGVTdHJpcHBlZC5yZXBsYWNlKC9cXC9cXCpbLlxcc1xcU10qXFwqXFwvL2csICcnKTtcblx0XHR2YXIgc3BhY2VTdHJpcHBlZCA9IG11bHRpU3RyaXBwZWQucmVwbGFjZSgvXFxuL21nLCAnICcpLnJlcGxhY2UoLyB7Mn0vZywgJyAnKTtcblx0XHRyZXR1cm4gY29uc3RydWN0b3JSZWdleC50ZXN0KHNwYWNlU3RyaXBwZWQpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHR9XG59O1xuXG52YXIgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSkge1xuXHR0cnkge1xuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZuQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xudmFyIGdlbkNsYXNzID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpOyB9XG5cdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHR2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0cmV0dXJuIHN0ckNsYXNzID09PSBmbkNsYXNzIHx8IHN0ckNsYXNzID09PSBnZW5DbGFzcztcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaXMtY2FsbGFibGUvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXREYXkgPSBEYXRlLnByb3RvdHlwZS5nZXREYXk7XG52YXIgdHJ5RGF0ZU9iamVjdCA9IGZ1bmN0aW9uIHRyeURhdGVPYmplY3QodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRnZXREYXkuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZGF0ZUNsYXNzID0gJ1tvYmplY3QgRGF0ZV0nO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0RhdGVPYmplY3QodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiBoYXNUb1N0cmluZ1RhZyA/IHRyeURhdGVPYmplY3QodmFsdWUpIDogdG9TdHIuY2FsbCh2YWx1ZSkgPT09IGRhdGVDbGFzcztcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaXMtZGF0ZS1vYmplY3QvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgpID09PSAnc3ltYm9sJztcblxuaWYgKGhhc1N5bWJvbHMpIHtcblx0dmFyIHN5bVRvU3RyID0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIHN5bVN0cmluZ1JlZ2V4ID0gL15TeW1ib2xcXCguKlxcKSQvO1xuXHR2YXIgaXNTeW1ib2xPYmplY3QgPSBmdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUudmFsdWVPZigpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRyZXR1cm4gc3ltU3RyaW5nUmVnZXgudGVzdChzeW1Ub1N0ci5jYWxsKHZhbHVlKSk7XG5cdH07XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmICh0b1N0ci5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBpc1N5bWJvbE9iamVjdCh2YWx1ZSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcblx0XHQvLyB0aGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU3ltYm9scy5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaXMtc3ltYm9sL2luZGV4LmpzXG4gKiovIiwidmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2Z1bmN0aW9uLWJpbmQvaW5kZXguanNcbiAqKi8iLCJ2YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGlzTmFOID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzTmFOJyk7XG52YXIgJGlzRmluaXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzRmluaXRlJyk7XG5cbnZhciBzaWduID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NpZ24nKTtcbnZhciBtb2QgPSByZXF1aXJlKCcuL2hlbHBlcnMvbW9kJyk7XG5cbnZhciBJc0NhbGxhYmxlID0gcmVxdWlyZSgnaXMtY2FsbGFibGUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2VzLXRvLXByaW1pdGl2ZS9lczUnKTtcblxuLy8gaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OVxudmFyIEVTNSA9IHtcblx0VG9QcmltaXRpdmU6IHRvUHJpbWl0aXZlLFxuXG5cdFRvQm9vbGVhbjogZnVuY3Rpb24gVG9Cb29sZWFuKHZhbHVlKSB7XG5cdFx0cmV0dXJuIEJvb2xlYW4odmFsdWUpO1xuXHR9LFxuXHRUb051bWJlcjogZnVuY3Rpb24gVG9OdW1iZXIodmFsdWUpIHtcblx0XHRyZXR1cm4gTnVtYmVyKHZhbHVlKTtcblx0fSxcblx0VG9JbnRlZ2VyOiBmdW5jdGlvbiBUb0ludGVnZXIodmFsdWUpIHtcblx0XHR2YXIgbnVtYmVyID0gdGhpcy5Ub051bWJlcih2YWx1ZSk7XG5cdFx0aWYgKCRpc05hTihudW1iZXIpKSB7IHJldHVybiAwOyB9XG5cdFx0aWYgKG51bWJlciA9PT0gMCB8fCAhJGlzRmluaXRlKG51bWJlcikpIHsgcmV0dXJuIG51bWJlcjsgfVxuXHRcdHJldHVybiBzaWduKG51bWJlcikgKiBNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikpO1xuXHR9LFxuXHRUb0ludDMyOiBmdW5jdGlvbiBUb0ludDMyKHgpIHtcblx0XHRyZXR1cm4gdGhpcy5Ub051bWJlcih4KSA+PiAwO1xuXHR9LFxuXHRUb1VpbnQzMjogZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuXHRcdHJldHVybiB0aGlzLlRvTnVtYmVyKHgpID4+PiAwO1xuXHR9LFxuXHRUb1VpbnQxNjogZnVuY3Rpb24gVG9VaW50MTYodmFsdWUpIHtcblx0XHR2YXIgbnVtYmVyID0gdGhpcy5Ub051bWJlcih2YWx1ZSk7XG5cdFx0aWYgKCRpc05hTihudW1iZXIpIHx8IG51bWJlciA9PT0gMCB8fCAhJGlzRmluaXRlKG51bWJlcikpIHsgcmV0dXJuIDA7IH1cblx0XHR2YXIgcG9zSW50ID0gc2lnbihudW1iZXIpICogTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpKTtcblx0XHRyZXR1cm4gbW9kKHBvc0ludCwgMHgxMDAwMCk7XG5cdH0sXG5cdFRvU3RyaW5nOiBmdW5jdGlvbiBUb1N0cmluZyh2YWx1ZSkge1xuXHRcdHJldHVybiBTdHJpbmcodmFsdWUpO1xuXHR9LFxuXHRUb09iamVjdDogZnVuY3Rpb24gVG9PYmplY3QodmFsdWUpIHtcblx0XHR0aGlzLkNoZWNrT2JqZWN0Q29lcmNpYmxlKHZhbHVlKTtcblx0XHRyZXR1cm4gT2JqZWN0KHZhbHVlKTtcblx0fSxcblx0Q2hlY2tPYmplY3RDb2VyY2libGU6IGZ1bmN0aW9uIENoZWNrT2JqZWN0Q29lcmNpYmxlKHZhbHVlLCBvcHRNZXNzYWdlKSB7XG5cdFx0LyoganNoaW50IGVxbnVsbDp0cnVlICovXG5cdFx0aWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3Iob3B0TWVzc2FnZSB8fCAnQ2Fubm90IGNhbGwgbWV0aG9kIG9uICcgKyB2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0SXNDYWxsYWJsZTogSXNDYWxsYWJsZSxcblx0U2FtZVZhbHVlOiBmdW5jdGlvbiBTYW1lVmFsdWUoeCwgeSkge1xuXHRcdGlmICh4ID09PSB5KSB7IC8vIDAgPT09IC0wLCBidXQgdGhleSBhcmUgbm90IGlkZW50aWNhbC5cblx0XHRcdGlmICh4ID09PSAwKSB7IHJldHVybiAxIC8geCA9PT0gMSAvIHk7IH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gJGlzTmFOKHgpICYmICRpc05hTih5KTtcblx0fSxcblxuXHQvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOFxuXHRUeXBlOiBmdW5jdGlvbiBUeXBlKHgpIHtcblx0XHRpZiAoeCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuICdOdWxsJztcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuICdVbmRlZmluZWQnO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHggPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gJ09iamVjdCc7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcblx0XHRcdHJldHVybiAnTnVtYmVyJztcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB4ID09PSAnYm9vbGVhbicpIHtcblx0XHRcdHJldHVybiAnQm9vbGVhbic7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiAnU3RyaW5nJztcblx0XHR9XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRVM1O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VzLWFic3RyYWN0L2VzNS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzUHJpbWl0aXZlJyk7XG5cbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnaXMtY2FsbGFibGUnKTtcblxuLy8gaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OC4xMlxudmFyIEVTNWludGVybmFsU2xvdHMgPSB7XG5cdCdbW0RlZmF1bHRWYWx1ZV1dJzogZnVuY3Rpb24gKE8sIGhpbnQpIHtcblx0XHR2YXIgYWN0dWFsSGludCA9IGhpbnQgfHwgKHRvU3RyLmNhbGwoTykgPT09ICdbb2JqZWN0IERhdGVdJyA/IFN0cmluZyA6IE51bWJlcik7XG5cblx0XHRpZiAoYWN0dWFsSGludCA9PT0gU3RyaW5nIHx8IGFjdHVhbEhpbnQgPT09IE51bWJlcikge1xuXHRcdFx0dmFyIG1ldGhvZHMgPSBhY3R1YWxIaW50ID09PSBTdHJpbmcgPyBbJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnXSA6IFsndmFsdWVPZicsICd0b1N0cmluZyddO1xuXHRcdFx0dmFyIHZhbHVlLCBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0aWYgKGlzQ2FsbGFibGUoT1ttZXRob2RzW2ldXSkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IE9bbWV0aG9kc1tpXV0oKTtcblx0XHRcdFx0XHRpZiAoaXNQcmltaXRpdmUodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBkZWZhdWx0IHZhbHVlJyk7XG5cdFx0fVxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgW1tEZWZhdWx0VmFsdWVdXSBoaW50IHN1cHBsaWVkJyk7XG5cdH1cbn07XG5cbi8vIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVG9QcmltaXRpdmUoaW5wdXQsIFByZWZlcnJlZFR5cGUpIHtcblx0aWYgKGlzUHJpbWl0aXZlKGlucHV0KSkge1xuXHRcdHJldHVybiBpbnB1dDtcblx0fVxuXHRyZXR1cm4gRVM1aW50ZXJuYWxTbG90c1snW1tEZWZhdWx0VmFsdWVdXSddKGlucHV0LCBQcmVmZXJyZWRUeXBlKTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZXMtdG8tcHJpbWl0aXZlL2VzNS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZ2V4RXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbnZhciB0cnlSZWdleEV4ZWMgPSBmdW5jdGlvbiB0cnlSZWdleEV4ZWModmFsdWUpIHtcblx0dHJ5IHtcblx0XHRyZWdleEV4ZWMuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHJlZ2V4Q2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNSZWdleCh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0cmV0dXJuIGhhc1RvU3RyaW5nVGFnID8gdHJ5UmVnZXhFeGVjKHZhbHVlKSA6IHRvU3RyLmNhbGwodmFsdWUpID09PSByZWdleENsYXNzO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9pcy1yZWdleC9pbmRleC5qc1xuICoqLyIsInZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oYXMvc3JjL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJldHVybiB0eXBlb2YgT2JqZWN0LnZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC52YWx1ZXMgOiBpbXBsZW1lbnRhdGlvbjtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vb2JqZWN0LnZhbHVlcy9wb2x5ZmlsbC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbVZhbHVlcygpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE9iamVjdCwgeyB2YWx1ZXM6IHBvbHlmaWxsIH0sIHsgdmFsdWVzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3QudmFsdWVzICE9PSBwb2x5ZmlsbDsgfSB9KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9vYmplY3QudmFsdWVzL3NoaW0uanNcbiAqKi8iLCJpbXBvcnQgaW8gZnJvbSAnc29ja2V0LmlvLWNsaWVudCc7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG5pbXBvcnQge1xuICBDT05ORUNULFxuICBESVNDT05ORUNULFxuICBJTklUSUFMX1JFU1VMVCxcbiAgUkVDRUlWRV9NRVNTQUdFLFxuICBQT1NUX01FU1NBR0UsXG4gIFVQREFURVxufSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25uZWN0U29ja2V0KCkge1xuICByZXR1cm4gZGlzcGF0Y2ggPT4ge1xuICAgIGxldCBzb2NrZXQgPSBpbygpO1xuICAgIHNvY2tldC5vbignaW5pdGlhbFJlc3VsdCcsIGRhdGEgPT4ge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBJTklUSUFMX1JFU1VMVCxcbiAgICAgICAgcmVzdWx0OiBkYXRhLnJlc3VsdFxuICAgICAgfSlcbiAgICB9KVxuICAgIHNvY2tldC5vbigndXBkYXRlJywgZGF0YSA9PiB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgc29uZzogZGF0YS5yZXN1bHQubmV3X3ZhbFxuICAgICAgfSlcbiAgICB9KVxuICAgIGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IENPTk5FQ1QsXG4gICAgICBzb2NrZXRcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNjb25uZWN0U29ja2V0KCkge1xuICByZXR1cm4gKGRpc3BhdGNoLCBzdGF0ZSkgPT4ge1xuICAgIGxldCBzb2NrZXQgPSBzdGF0ZSgpLnNvY2tldDtcbiAgICBPYmplY3Qua2V5cyhzb2NrZXQpLmxlbmd0aCA+IDAgPyBzb2NrZXQuZGlzY29ubmVjdCgpIDogbnVsbDtcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiBESVNDT05ORUNUXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSl7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDRUlWRV9NRVNTQUdFLFxuICAgIG1lc3NhZ2VcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zdE1lc3NhZ2UodGV4dCl7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUE9TVF9NRVNTQUdFLFxuICAgIHRleHRcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICByZXR1cm4gKGRpc3BhdGNoLCBzdGF0ZSkgPT4ge1xuICAgIGxldCBzb2NrZXQgPSBzdGF0ZSgpLnNvY2tldDtcbiAgICBzb2NrZXQuZW1pdCgnbWVzc2FnZScsIHsgbWVzc2FnZSB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXB2b3RlU29uZyhzb25nSWQpIHtcbiAgcmV0dXJuIGRpc3BhdGNoID0+IHtcbiAgICBheGlvcy5nZXQoYC91cHZvdGUvJHtzb25nSWR9YCkudGhlbihyZXMgPT4ge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIHNvbmc6IHJlcy5kYXRhXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYWN0aW9ucy5qc1xuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCcuL3VybCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbG9va3VwO1xuXG4vKipcbiAqIE1hbmFnZXJzIGNhY2hlLlxuICovXG5cbnZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblxuLyoqXG4gKiBMb29rcyB1cCBhbiBleGlzdGluZyBgTWFuYWdlcmAgZm9yIG11bHRpcGxleGluZy5cbiAqIElmIHRoZSB1c2VyIHN1bW1vbnM6XG4gKlxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYScpO2BcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2InKTtgXG4gKlxuICogV2UgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlIGJhc2VkIG9uIHNhbWUgc2NoZW1lL3BvcnQvaG9zdCxcbiAqIGFuZCB3ZSBpbml0aWFsaXplIHNvY2tldHMgZm9yIGVhY2ggbmFtZXNwYWNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9va3VwKHVyaSwgb3B0cykge1xuICBpZiAodHlwZW9mIHVyaSA9PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHBhcnNlZCA9IHVybCh1cmkpO1xuICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcbiAgdmFyIGlkID0gcGFyc2VkLmlkO1xuICB2YXIgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuICB2YXIgbmV3Q29ubmVjdGlvbiA9IG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuXG4gIHZhciBpbztcblxuICBpZiAobmV3Q29ubmVjdGlvbikge1xuICAgIGRlYnVnKCdpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzJywgc291cmNlKTtcbiAgICBpbyA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgZGVidWcoJ25ldyBpbyBpbnN0YW5jZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgICAgY2FjaGVbaWRdID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBpbyA9IGNhY2hlW2lkXTtcbiAgfVxuXG4gIHJldHVybiBpby5zb2NrZXQocGFyc2VkLnBhdGgpO1xufVxuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuXG4vKipcbiAqIGBjb25uZWN0YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY29ubmVjdCA9IGxvb2t1cDtcblxuLyoqXG4gKiBFeHBvc2UgY29uc3RydWN0b3JzIGZvciBzdGFuZGFsb25lIGJ1aWxkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5NYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG5leHBvcnRzLlNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9saWIvaW5kZXguanNcbiAqKi8iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDp1cmwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybDtcblxuLyoqXG4gKiBVUkwgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdXJsKHVyaSwgbG9jKXtcbiAgdmFyIG9iaiA9IHVyaTtcblxuICAvLyBkZWZhdWx0IHRvIHdpbmRvdy5sb2NhdGlvblxuICB2YXIgbG9jID0gbG9jIHx8IGdsb2JhbC5sb2NhdGlvbjtcbiAgaWYgKG51bGwgPT0gdXJpKSB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3Q7XG5cbiAgLy8gcmVsYXRpdmUgcGF0aCBzdXBwb3J0XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdXJpKSB7XG4gICAgaWYgKCcvJyA9PSB1cmkuY2hhckF0KDApKSB7XG4gICAgICBpZiAoJy8nID09IHVyaS5jaGFyQXQoMSkpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gbG9jLmhvc3QgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcbiAgICAgIGRlYnVnKCdwcm90b2NvbC1sZXNzIHVybCAlcycsIHVyaSk7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGxvYykge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gJ2h0dHBzOi8vJyArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwYXJzZVxuICAgIGRlYnVnKCdwYXJzZSAlcycsIHVyaSk7XG4gICAgb2JqID0gcGFyc2V1cmkodXJpKTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB3ZSB0cmVhdCBgbG9jYWxob3N0OjgwYCBhbmQgYGxvY2FsaG9zdGAgZXF1YWxseVxuICBpZiAoIW9iai5wb3J0KSB7XG4gICAgaWYgKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc4MCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnNDQzJztcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHZhciBob3N0ID0gaXB2NiA/ICdbJyArIG9iai5ob3N0ICsgJ10nIDogb2JqLmhvc3Q7XG5cbiAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgLy8gZGVmaW5lIGhyZWZcbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09IG9iai5wb3J0ID8gJycgOiAoJzonICsgb2JqLnBvcnQpKTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvbGliL3VybC5qc1xuICoqLyIsIi8qKlxuICogUGFyc2VzIGFuIFVSSVxuICpcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xuXG52YXIgcGFydHMgPSBbXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xuICAgIHZhciBzcmMgPSBzdHIsXG4gICAgICAgIGIgPSBzdHIuaW5kZXhPZignWycpLFxuICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcblxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcbiAgICAgICAgdXJpID0ge30sXG4gICAgICAgIGkgPSAxNDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG4gICAgfVxuXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xuICAgICAgICB1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5hdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5LnJlcGxhY2UoJ1snLCAnJykucmVwbGFjZSgnXScsICcnKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJpO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9wYXJzZXVyaS9pbmRleC5qc1xuICoqLyIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9kZWJ1Zy9icm93c2VyLmpzXG4gKiovIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91c2x5IGFzc2lnbmVkIGNvbG9yLlxuICovXG5cbnZhciBwcmV2Q29sb3IgPSAwO1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKCkge1xuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKysgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICAvLyBkZWZpbmUgdGhlIGBkaXNhYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcbiAgfVxuICBkaXNhYmxlZC5lbmFibGVkID0gZmFsc2U7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZW5hYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBlbmFibGVkKCkge1xuXG4gICAgdmFyIHNlbGYgPSBlbmFibGVkO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuICAgIGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG4gIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cbiAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cbiAgZm4ubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZGVidWcvZGVidWcuanNcbiAqKi8iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKXtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcbiAgcmV0dXJuIG9wdGlvbnMubG9uZ1xuICAgID8gbG9uZyh2YWwpXG4gICAgOiBzaG9ydCh2YWwpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9ICcnICsgc3RyO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSByZXR1cm47XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgaWYgKG1zID49IGgpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIGlmIChtcyA+PSBtKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICBpZiAobXMgPj0gcykgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXG4gICAgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpXG4gICAgfHwgcGx1cmFsKG1zLCBtLCAnbWludXRlJylcbiAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxuICAgIHx8IG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHJldHVybjtcbiAgaWYgKG1zIDwgbiAqIDEuNSkgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vbXMvaW5kZXguanNcbiAqKi8iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIganNvbiA9IHJlcXVpcmUoJ2pzb24zJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL2JpbmFyeScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdBQ0snLFxuICAnRVJST1InLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0JJTkFSWV9BQ0snXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG4vKipcbiAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG4gIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG5zcCA9IGZhbHNlO1xuXG4gIC8vIGZpcnN0IGlzIHR5cGVcbiAgc3RyICs9IG9iai50eXBlO1xuXG4gIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cztcbiAgICBzdHIgKz0gJy0nO1xuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgaWYgKG9iai5uc3AgJiYgJy8nICE9IG9iai5uc3ApIHtcbiAgICBuc3AgPSB0cnVlO1xuICAgIHN0ciArPSBvYmoubnNwO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIGlmIChuc3ApIHtcbiAgICAgIHN0ciArPSAnLCc7XG4gICAgICBuc3AgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RyICs9IG9iai5pZDtcbiAgfVxuXG4gIC8vIGpzb24gZGF0YVxuICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgIGlmIChuc3ApIHN0ciArPSAnLCc7XG4gICAgc3RyICs9IGpzb24uc3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVjb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBvYmopIHtcbiAgICBwYWNrZXQgPSBkZWNvZGVTdHJpbmcob2JqKTtcbiAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuICB2YXIgcCA9IHt9O1xuICB2YXIgaSA9IDA7XG5cbiAgLy8gbG9vayB1cCB0eXBlXG4gIHAudHlwZSA9IE51bWJlcihzdHIuY2hhckF0KDApKTtcbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSByZXR1cm4gZXJyb3IoKTtcblxuICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHAudHlwZSkge1xuICAgIHZhciBidWYgPSAnJztcbiAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9ICctJykge1xuICAgICAgYnVmICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgaWYgKGJ1ZiAhPSBOdW1iZXIoYnVmKSB8fCBzdHIuY2hhckF0KGkpICE9ICctJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGF0dGFjaG1lbnRzJyk7XG4gICAgfVxuICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gIGlmICgnLycgPT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICBwLm5zcCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmICgnLCcgPT0gYykgYnJlYWs7XG4gICAgICBwLm5zcCArPSBjO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAubnNwID0gJy8nO1xuICB9XG5cbiAgLy8gbG9vayB1cCBpZFxuICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICBwLmlkID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIHAuaWQgPSBOdW1iZXIocC5pZCk7XG4gIH1cblxuICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHAuZGF0YSA9IGpzb24ucGFyc2Uoc3RyLnN1YnN0cihpKSk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBlcnJvcigpO1xuICAgIH1cbiAgfVxuXG4gIGRlYnVnKCdkZWNvZGVkICVzIGFzICVqJywgc3RyLCBwKTtcbiAgcmV0dXJuIHA7XG59XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PSB0aGlzLnJlY29uUGFjay5hdHRhY2htZW50cykgeyAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3RcbiAgICB2YXIgcGFja2V0ID0gYmluYXJ5LnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuICAgIHRoaXMuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS5maW5pc2hlZFJlY29uc3RydWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVjb25QYWNrID0gbnVsbDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59O1xuXG5mdW5jdGlvbiBlcnJvcihkYXRhKXtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBleHBvcnRzLkVSUk9SLFxuICAgIGRhdGE6ICdwYXJzZXIgZXJyb3InXG4gIH07XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc29ja2V0LmlvLXBhcnNlci9pbmRleC5qc1xuICoqLyIsIi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9zb2NrZXQuaW8tcGFyc2VyL34vanNvbjMvbGliL2pzb24zLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMjM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaXNhcnJheS9pbmRleC5qc1xuICoqLyIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHNlbGYub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qc1xuICoqLyIsIi8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuICogQW55dGhpbmcgd2l0aCBibG9icyBvciBmaWxlcyBzaG91bGQgYmUgZmVkIHRocm91Z2ggcmVtb3ZlQmxvYnMgYmVmb3JlIGNvbWluZ1xuICogaGVyZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGRlY29uc3RydWN0ZWQgcGFja2V0IGFuZCBsaXN0IG9mIGJ1ZmZlcnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG5cbiAgZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gICAgaWYgKGlzQnVmKGRhdGEpKSB7XG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSB7IF9wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aCB9O1xuICAgICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgdmFyIG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGVvZiBkYXRhICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgcGFjayA9IHBhY2tldDtcbiAgcGFjay5kYXRhID0gX2RlY29uc3RydWN0UGFja2V0KHBhY2tldERhdGEpO1xuICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICByZXR1cm4ge3BhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVyc307XG59O1xuXG4vKipcbiAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIGV2ZW50IHBhY2tldCB3aXRoIHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjb25zdHJ1Y3RlZCBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgYnVmZmVycykge1xuICB2YXIgY3VyUGxhY2VIb2xkZXIgPSAwO1xuXG4gIGZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhciBidWYgPSBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgJiYgJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEpO1xuICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgcmV0dXJuIHBhY2tldDtcbn07XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVtb3ZlcyBCbG9icyBvciBGaWxlcyBmcm9tIGRhdGEgdmlhXG4gKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgLy8gY29udmVydCBhbnkgYmxvYlxuICAgIGlmICgoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICBwZW5kaW5nQmxvYnMrKztcblxuICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcbiAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuICAgICAgICBpZighIC0tcGVuZGluZ0Jsb2JzKSB7XG4gICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9iaikpIHsgLy8gaGFuZGxlIGFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmogJiYgIWlzQnVmKG9iaikpIHsgLy8gYW5kIG9iamVjdFxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcbiAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG4gIF9yZW1vdmVCbG9icyhibG9ibGVzc0RhdGEpO1xuICBpZiAoIXBlbmRpbmdCbG9icykge1xuICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gIH1cbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanNcbiAqKi8iLCJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3NvY2tldC5pby1wYXJzZXIvaXMtYnVmZmVyLmpzXG4gKiovIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGVpbyA9IHJlcXVpcmUoJ2VuZ2luZS5pby1jbGllbnQnKTtcbnZhciBTb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6bWFuYWdlcicpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgQmFja29mZiA9IHJlcXVpcmUoJ2JhY2tvMicpO1xuXG4vKipcbiAqIElFNisgaGFzT3duUHJvcGVydHlcbiAqL1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTWFuYWdlcjtcblxuLyoqXG4gKiBgTWFuYWdlcmAgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVuZ2luZSBpbnN0YW5jZSBvciBlbmdpbmUgdXJpL29wdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1hbmFnZXIodXJpLCBvcHRzKXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcbiAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuICB0aGlzLm5zcHMgPSB7fTtcbiAgdGhpcy5zdWJzID0gW107XG4gIHRoaXMub3B0cyA9IG9wdHM7XG4gIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG4gIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0cyB8fCBJbmZpbml0eSk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuICB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3Iob3B0cy5yYW5kb21pemF0aW9uRmFjdG9yIHx8IDAuNSk7XG4gIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcbiAgICBtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcbiAgICBtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG4gIH0pO1xuICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLnVyaSA9IHVyaTtcbiAgdGhpcy5jb25uZWN0aW5nID0gW107XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RlciA9IG5ldyBwYXJzZXIuRW5jb2RlcigpO1xuICB0aGlzLmRlY29kZXIgPSBuZXcgcGFyc2VyLkRlY29kZXIoKTtcbiAgdGhpcy5hdXRvQ29ubmVjdCA9IG9wdHMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlO1xuICBpZiAodGhpcy5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogUHJvcGFnYXRlIGdpdmVuIGV2ZW50IHRvIHNvY2tldHMgYW5kIGVtaXQgb24gYHRoaXNgXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZW1pdEFsbCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmVtaXQuYXBwbHkodGhpcy5uc3BzW25zcF0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBgc29ja2V0LmlkYCBvZiBhbGwgc29ja2V0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uKCl7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5pZCA9IHRoaXMuZW5naW5lLmlkO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoTWFuYWdlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldHMgdGhlIGByZWNvbm5lY3Rpb25gIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUvZmFsc2UgaWYgaXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbiA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gIHRoaXMuX3JlY29ubmVjdGlvbiA9ICEhdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cztcbiAgdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheSA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXkgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1pbih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yYW5kb21pemF0aW9uRmFjdG9yID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG4gIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heCA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heDtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1heCh2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbm5lY3Rpb24gdGltZW91dC4gYGZhbHNlYCB0byBkaXNhYmxlXG4gKlxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gIHRoaXMuX3RpbWVvdXQgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RhcnRzIHRyeWluZyB0byByZWNvbm5lY3QgaWYgcmVjb25uZWN0aW9uIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgbm90XG4gKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5tYXliZVJlY29ubmVjdE9uT3BlbiA9IGZ1bmN0aW9uKCkge1xuICAvLyBPbmx5IHRyeSB0byByZWNvbm5lY3QgaWYgaXQncyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBjb25uZWN0aW5nXG4gIGlmICghdGhpcy5yZWNvbm5lY3RpbmcgJiYgdGhpcy5fcmVjb25uZWN0aW9uICYmIHRoaXMuYmFja29mZi5hdHRlbXB0cyA9PT0gMCkge1xuICAgIC8vIGtlZXBzIHJlY29ubmVjdGlvbiBmcm9tIGZpcmluZyB0d2ljZSBmb3IgdGhlIHNhbWUgcmVjb25uZWN0aW9uIGxvb3BcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQgYHNvY2tldGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9uYWwsIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9wZW4gPVxuTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKGZuKXtcbiAgZGVidWcoJ3JlYWR5U3RhdGUgJXMnLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAofnRoaXMucmVhZHlTdGF0ZS5pbmRleE9mKCdvcGVuJykpIHJldHVybiB0aGlzO1xuXG4gIGRlYnVnKCdvcGVuaW5nICVzJywgdGhpcy51cmkpO1xuICB0aGlzLmVuZ2luZSA9IGVpbyh0aGlzLnVyaSwgdGhpcy5vcHRzKTtcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG5cbiAgLy8gZW1pdCBgb3BlbmBcbiAgdmFyIG9wZW5TdWIgPSBvbihzb2NrZXQsICdvcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uKGRhdGEpe1xuICAgIGRlYnVnKCdjb25uZWN0X2Vycm9yJyk7XG4gICAgc2VsZi5jbGVhbnVwKCk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X2Vycm9yJywgZGF0YSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIGVycm9yJyk7XG4gICAgICBlcnIuZGF0YSA9IGRhdGE7XG4gICAgICBmbihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgc2VsZi5tYXliZVJlY29ubmVjdE9uT3BlbigpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF90aW1lb3V0YFxuICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblxuICAgIC8vIHNldCB0aW1lclxuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgdGltZWQgb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG4gICAgICBvcGVuU3ViLmRlc3Ryb3koKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgJ3RpbWVvdXQnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF90aW1lb3V0JywgdGltZW91dCk7XG4gICAgfSwgdGltZW91dCk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG4gIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ29wZW4nKTtcblxuICAvLyBjbGVhciBvbGQgc3Vic1xuICB0aGlzLmNsZWFudXAoKTtcblxuICAvLyBtYXJrIGFzIG9wZW5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcblxuICAvLyBhZGQgbmV3IHN1YnNcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdkYXRhJywgYmluZCh0aGlzLCAnb25kYXRhJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncGluZycsIGJpbmQodGhpcywgJ29ucGluZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BvbmcnLCBiaW5kKHRoaXMsICdvbnBvbmcnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdlcnJvcicsIGJpbmQodGhpcywgJ29uZXJyb3InKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbih0aGlzLmRlY29kZXIsICdkZWNvZGVkJywgYmluZCh0aGlzLCAnb25kZWNvZGVkJykpKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBwaW5nLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucGluZyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMubGFzdFBpbmcgPSBuZXcgRGF0ZTtcbiAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZW1pdEFsbCgncG9uZycsIG5ldyBEYXRlIC0gdGhpcy5sYXN0UGluZyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNvY2tldCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24oZXJyKXtcbiAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbihuc3Ape1xuICB2YXIgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG4gIGlmICghc29ja2V0KSB7XG4gICAgc29ja2V0ID0gbmV3IFNvY2tldCh0aGlzLCBuc3ApO1xuICAgIHRoaXMubnNwc1tuc3BdID0gc29ja2V0O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3RpbmcnLCBvbkNvbm5lY3RpbmcpO1xuICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCl7XG4gICAgICBzb2NrZXQuaWQgPSBzZWxmLmVuZ2luZS5pZDtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmF1dG9Db25uZWN0KSB7XG4gICAgICAvLyBtYW51YWxseSBjYWxsIGhlcmUgc2luY2UgY29ubmVjdGluZyBldm5ldCBpcyBmaXJlZCBiZWZvcmUgbGlzdGVuaW5nXG4gICAgICBvbkNvbm5lY3RpbmcoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbm5lY3RpbmcoKSB7XG4gICAgaWYgKCF+aW5kZXhPZihzZWxmLmNvbm5lY3RpbmcsIHNvY2tldCkpIHtcbiAgICAgIHNlbGYuY29ubmVjdGluZy5wdXNoKHNvY2tldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvY2tldDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG4gKlxuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihzb2NrZXQpe1xuICB2YXIgaW5kZXggPSBpbmRleE9mKHRoaXMuY29ubmVjdGluZywgc29ja2V0KTtcbiAgaWYgKH5pbmRleCkgdGhpcy5jb25uZWN0aW5nLnNwbGljZShpbmRleCwgMSk7XG4gIGlmICh0aGlzLmNvbm5lY3RpbmcubGVuZ3RoKSByZXR1cm47XG5cbiAgdGhpcy5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghc2VsZi5lbmNvZGluZykge1xuICAgIC8vIGVuY29kZSwgdGhlbiB3cml0ZSB0byBlbmdpbmUgd2l0aCByZXN1bHRcbiAgICBzZWxmLmVuY29kaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCwgZnVuY3Rpb24oZW5jb2RlZFBhY2tldHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0sIHBhY2tldC5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7IC8vIGFkZCBwYWNrZXQgdG8gdGhlIHF1ZXVlXG4gICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG4gKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ2NsZWFudXAnKTtcblxuICB2YXIgc3ViO1xuICB3aGlsZSAoc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCkpIHN1Yi5kZXN0cm95KCk7XG5cbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcblxuICB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xufTtcblxuLyoqXG4gKiBDbG9zZSB0aGUgY3VycmVudCBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPVxuTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdkaXNjb25uZWN0Jyk7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gYG9uY2xvc2VgIHdpbGwgbm90IGZpcmUgYmVjYXVzZVxuICAgIC8vIGFuIG9wZW4gZXZlbnQgbmV2ZXIgaGFwcGVuZWRcbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIGlmICh0aGlzLmVuZ2luZSkgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuICBkZWJ1Zygnb25jbG9zZScpO1xuXG4gIHRoaXMuY2xlYW51cCgpO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgIGRlYnVnKCdyZWNvbm5lY3QgZmFpbGVkJyk7XG4gICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcbiAgICBkZWJ1Zygnd2lsbCB3YWl0ICVkbXMgYmVmb3JlIHJlY29ubmVjdCBhdHRlbXB0JywgZGVsYXkpO1xuXG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgZGVidWcoJ2F0dGVtcHRpbmcgcmVjb25uZWN0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9hdHRlbXB0Jywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0aW5nJywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcblxuICAgICAgLy8gY2hlY2sgYWdhaW4gZm9yIHRoZSBjYXNlIHNvY2tldCBjbG9zZWQgaW4gYWJvdmUgZXZlbnRzXG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIHNlbGYub3BlbihmdW5jdGlvbihlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnJlY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy51cGRhdGVTb2NrZXRJZHMoKTtcbiAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3QnLCBhdHRlbXB0KTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qc1xuICoqLyIsIlxubW9kdWxlLmV4cG9ydHMgPSAgcmVxdWlyZSgnLi9saWIvJyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZW5naW5lLmlvLWNsaWVudC9pbmRleC5qc1xuICoqLyIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydHMgcGFyc2VyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi9pbmRleC5qc1xuICoqLyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIHBhcnNlanNvbiA9IHJlcXVpcmUoJ3BhcnNlanNvbicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogTm9vcCBmdW5jdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fVxuXG4vKipcbiAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQodXJpLCBvcHRzKXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKHVyaSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgdXJpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSBudWxsO1xuICB9XG5cbiAgaWYgKHVyaSkge1xuICAgIHVyaSA9IHBhcnNldXJpKHVyaSk7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHVyaS5ob3N0O1xuICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH0gZWxzZSBpZiAob3B0cy5ob3N0KSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNldXJpKG9wdHMuaG9zdCkuaG9zdDtcbiAgfVxuXG4gIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlIDpcbiAgICAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sKTtcblxuICBpZiAob3B0cy5ob3N0bmFtZSAmJiAhb3B0cy5wb3J0KSB7XG4gICAgLy8gaWYgbm8gcG9ydCBpcyBzcGVjaWZpZWQgbWFudWFsbHksIHVzZSB0aGUgcHJvdG9jb2wgZGVmYXVsdFxuICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gJzQ0MycgOiAnODAnO1xuICB9XG5cbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8XG4gICAgKGdsb2JhbC5sb2NhdGlvbiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogJ2xvY2FsaG9zdCcpO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQgfHwgKGdsb2JhbC5sb2NhdGlvbiAmJiBsb2NhdGlvbi5wb3J0ID9cbiAgICAgICBsb2NhdGlvbi5wb3J0IDpcbiAgICAgICAodGhpcy5zZWN1cmUgPyA0NDMgOiA4MCkpO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG4gIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30pIDogZmFsc2U7XG5cbiAgaWYgKHRydWUgPT09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUpIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkID0gMTAyNDtcbiAgfVxuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4IHx8IG51bGw7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydCB8fCBudWxsO1xuICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCkge1xuICAgIGlmIChvcHRzLmV4dHJhSGVhZGVycyAmJiBPYmplY3Qua2V5cyhvcHRzLmV4dHJhSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgICB9XG4gIH1cblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMnKTtcblNvY2tldC5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcbiAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGZvcmNlSlNPTlA6IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogdGhpcy5mb3JjZUJhc2U2NCxcbiAgICBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIsXG4gICAgdGltZXN0YW1wUmVxdWVzdHM6IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogdGhpcy5wb2xpY3lQb3J0LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBwZng6IHRoaXMucGZ4LFxuICAgIGtleTogdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogdGhpcy5wYXNzcGhyYXNlLFxuICAgIGNlcnQ6IHRoaXMuY2VydCxcbiAgICBjYTogdGhpcy5jYSxcbiAgICBjaXBoZXJzOiB0aGlzLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICBleHRyYUhlYWRlcnM6IHRoaXMuZXh0cmFIZWFkZXJzXG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc3BvcnQ7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgb1tpXSA9IG9ialtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFuc3BvcnQ7XG4gIGlmICh0aGlzLnJlbWVtYmVyVXBncmFkZSAmJiBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSAhPSAtMSkge1xuICAgIHRyYW5zcG9ydCA9ICd3ZWJzb2NrZXQnO1xuICB9IGVsc2UgaWYgKDAgPT09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAvLyBFbWl0IGVycm9yIG9uIG5leHQgdGljayBzbyBpdCBjYW4gYmUgbGlzdGVuZWQgdG9cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24odHJhbnNwb3J0KXtcbiAgZGVidWcoJ3NldHRpbmcgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0Lm5hbWUpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgZGVidWcoJ2NsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlcycsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuICB0cmFuc3BvcnRcbiAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkRyYWluKCk7XG4gIH0pXG4gIC5vbigncGFja2V0JywgZnVuY3Rpb24ocGFja2V0KXtcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH0pXG4gIC5vbignZXJyb3InLCBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoZSk7XG4gIH0pXG4gIC5vbignY2xvc2UnLCBmdW5jdGlvbigpe1xuICAgIHNlbGYub25DbG9zZSgndHJhbnNwb3J0IGNsb3NlJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSwgeyBwcm9iZTogMSB9KVxuICAgICwgZmFpbGVkID0gZmFsc2VcbiAgICAsIHNlbGYgPSB0aGlzO1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4oKXtcbiAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcbiAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcbiAgICAgIGZhaWxlZCA9IGZhaWxlZCB8fCB1cGdyYWRlTG9zZXNCaW5hcnk7XG4gICAgfVxuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIG9wZW5lZCcsIG5hbWUpO1xuICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG4gICAgdHJhbnNwb3J0Lm9uY2UoJ3BhY2tldCcsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgIGlmICgncG9uZycgPT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PSBtc2cuZGF0YSkge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG4gICAgICAgIHNlbGYudXBncmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICAgICAgZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJywgc2VsZi50cmFuc3BvcnQubmFtZSk7XG4gICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0KCkge1xuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgIGZhaWxlZCA9IHRydWU7XG5cbiAgICBjbGVhbnVwKCk7XG5cbiAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgLy9IYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UoKXtcbiAgICBvbmVycm9yKFwidHJhbnNwb3J0IGNsb3NlZFwiKTtcbiAgfVxuXG4gIC8vV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKXtcbiAgICBvbmVycm9yKFwic29ja2V0IGNsb3NlZFwiKTtcbiAgfVxuXG4gIC8vV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb251cGdyYWRlKHRvKXtcbiAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT0gdHJhbnNwb3J0Lm5hbWUpIHtcbiAgICAgIGRlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLCB0by5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICB9XG4gIH1cblxuICAvL1JlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcbiAgZnVuY3Rpb24gY2xlYW51cCgpe1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG4gIH1cblxuICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuICB0aGlzLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuICB0cmFuc3BvcnQub3BlbigpO1xuXG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudXBncmFkZSAmJiB0aGlzLnRyYW5zcG9ydC5wYXVzZSkge1xuICAgIGRlYnVnKCdzdGFydGluZyB1cGdyYWRlIHByb2JlcycpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcblxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblxuICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcbiAgICB0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcpO1xuXG4gICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgIHRoaXMub25IYW5kc2hha2UocGFyc2Vqc29uKHBhY2tldC5kYXRhKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwb25nJzpcbiAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG4gICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdzZXJ2ZXIgZXJyb3InKTtcbiAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGFja2V0LmRhdGEpO1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG4gIHRoaXMuaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgdGhpcy5vbk9wZW4oKTtcbiAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICBpZiAgKCdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICB0aGlzLnNldFBpbmcoKTtcblxuICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG4gIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ2Nsb3NlZCcgPT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG59O1xuXG4vKipcbiAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG4gICAgc2VsZi5waW5nKCk7XG4gICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcbiAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4qIFNlbmRzIGEgcGluZyBwYWNrZXQuXG4qXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VuZFBhY2tldCgncGluZycsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5lbWl0KCdwaW5nJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25EcmFpbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcbiAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG4gIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcbiAgICAhdGhpcy51cGdyYWRpbmcgJiYgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICBkZWJ1ZygnZmx1c2hpbmcgJWQgcGFja2V0cyBpbiBzb2NrZXQnLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgbGVuZ3RoIG9mIHdyaXRlQnVmZmVyXG4gICAgLy8gc3BsaWNlIHdyaXRlQnVmZmVyIGFuZCBjYWxsYmFja0J1ZmZlciBvbiBgZHJhaW5gXG4gICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgdGhpcy5lbWl0KCdmbHVzaCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS53cml0ZSA9XG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobXNnLCBvcHRpb25zLCBmbikge1xuICB0aGlzLnNlbmRQYWNrZXQoJ21lc3NhZ2UnLCBtc2csIG9wdGlvbnMsIGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrZXQgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZFBhY2tldCA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBvcHRpb25zLCBmbikge1xuICBpZignZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgIGZuID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGlmICgnY2xvc2luZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2luZyc7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHNlbGYub25DbG9zZSgnZm9yY2VkIGNsb3NlJyk7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zaW5nIC0gdGVsbGluZyB0cmFuc3BvcnQgdG8gY2xvc2UnKTtcbiAgICBzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cEFuZENsb3NlKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlKCkge1xuICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGk8ajsgaSsrKSB7XG4gICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgWEhSID0gcmVxdWlyZSgnLi9wb2xsaW5nLXhocicpO1xudmFyIEpTT05QID0gcmVxdWlyZSgnLi9wb2xsaW5nLWpzb25wJyk7XG52YXIgd2Vic29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnQgdHJhbnNwb3J0cy5cbiAqL1xuXG5leHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuZXhwb3J0cy53ZWJzb2NrZXQgPSB3ZWJzb2NrZXQ7XG5cbi8qKlxuICogUG9sbGluZyB0cmFuc3BvcnQgcG9seW1vcnBoaWMgY29uc3RydWN0b3IuXG4gKiBEZWNpZGVzIG9uIHhociB2cyBqc29ucCBiYXNlZCBvbiBmZWF0dXJlIGRldGVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwb2xsaW5nKG9wdHMpe1xuICB2YXIgeGhyO1xuICB2YXIgeGQgPSBmYWxzZTtcbiAgdmFyIHhzID0gZmFsc2U7XG4gIHZhciBqc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuXG4gIGlmIChnbG9iYWwubG9jYXRpb24pIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPSBvcHRzLnBvcnQ7XG4gICAgeHMgPSBvcHRzLnNlY3VyZSAhPSBpc1NTTDtcbiAgfVxuXG4gIG9wdHMueGRvbWFpbiA9IHhkO1xuICBvcHRzLnhzY2hlbWUgPSB4cztcbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG4gIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcbiAgICByZXR1cm4gbmV3IFhIUihvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG4gICAgcmV0dXJuIG5ldyBKU09OUChvcHRzKTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvaW5kZXguanNcbiAqKi8iLCIvLyBicm93c2VyIHNoaW0gZm9yIHhtbGh0dHByZXF1ZXN0IG1vZHVsZVxudmFyIGhhc0NPUlMgPSByZXF1aXJlKCdoYXMtY29ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgdmFyIHhkb21haW4gPSBvcHRzLnhkb21haW47XG5cbiAgLy8gc2NoZW1lIG11c3QgYmUgc2FtZSB3aGVuIHVzaWduIFhEb21haW5SZXF1ZXN0XG4gIC8vIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAxMC8wNS8xMy94ZG9tYWlucmVxdWVzdC1yZXN0cmljdGlvbnMtbGltaXRhdGlvbnMtYW5kLXdvcmthcm91bmRzLmFzcHhcbiAgdmFyIHhzY2hlbWUgPSBvcHRzLnhzY2hlbWU7XG5cbiAgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmxvdyBvZiBub3Qgc2VuZGluZyBjb29raWUsIHRoZXJlZm9yZSBpdCBzaG91bGQgYmUgZGlzYWJsZWQgYXMgYSBkZWZhdWx0LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9lbmdpbmUuaW8tY2xpZW50L3B1bGwvMjE3XG4gIHZhciBlbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcbiAgLy8gYmVjYXVzZSBsb2FkaW5nIGJhciBrZWVwcyBmbGFzaGluZyB3aGVuIHVzaW5nIGpzb25wLXBvbGxpbmdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1amlvc2FrYS9zb2NrZS5pby1pZTgtbG9hZGluZy1leGFtcGxlXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBYRG9tYWluUmVxdWVzdCAmJiAheHNjaGVtZSAmJiBlbmFibGVzWERSKSB7XG4gICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICBpZiAoIXhkb21haW4pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0gY2F0Y2goZSkgeyB9XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi94bWxodHRwcmVxdWVzdC5qc1xuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hhcy1jb3JzL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZy14aHInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUjtcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEVtcHR5IGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkoKXt9XG5cbi8qKlxuICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSKG9wdHMpe1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHRoaXMueGQgPSBvcHRzLmhvc3RuYW1lICE9IGdsb2JhbC5sb2NhdGlvbi5ob3N0bmFtZSB8fFxuICAgICAgcG9ydCAhPSBvcHRzLnBvcnQ7XG4gICAgdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG4vKipcbiAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcbiAqL1xuXG5YSFIucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihvcHRzKXtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5leHRyYUhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcblxuICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG59O1xuXG4vKipcbiAqIFNlbmRzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24oZGF0YSwgZm4pe1xuICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5zZW5kWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3hociBwb2xsJyk7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKXtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvbGwgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5wb2xsWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChvcHRzKXtcbiAgdGhpcy5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCAnR0VUJztcbiAgdGhpcy51cmkgPSBvcHRzLnVyaTtcbiAgdGhpcy54ZCA9ICEhb3B0cy54ZDtcbiAgdGhpcy54cyA9ICEhb3B0cy54cztcbiAgdGhpcy5hc3luYyA9IGZhbHNlICE9PSBvcHRzLmFzeW5jO1xuICB0aGlzLmRhdGEgPSB1bmRlZmluZWQgIT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG4gIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gb3B0cy5zdXBwb3J0c0JpbmFyeTtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbigpe1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIGRlYnVnKCd4aHIgb3BlbiAlczogJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmkpO1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAodGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgZG9uZSBhZnRlciBvcGVuIGJlY2F1c2UgRmlyZWZveCBpcyBzdHVwaWRcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMyMTY5MDMvZ2V0LWJpbmFyeS1kYXRhLXdpdGgteG1saHR0cHJlcXVlc3QtaW4tYS1maXJlZm94LWV4dGVuc2lvblxuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgfVxuXG4gICAgaWYgKCdQT1NUJyA9PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLy8gaWU2IGNoZWNrXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICg0ICE9IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgIGlmICgyMDAgPT0geGhyLnN0YXR1cyB8fCAxMjIzID09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKGZyb21FcnJvcil7XG4gIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaChlKSB7fVxuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgdGhpcy54aHIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBsb2FkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykuc3BsaXQoJzsnKVswXTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHRoaXMueGhyLnJlc3BvbnNlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB2YXIgdWk4QXJyID0gbmV3IFVpbnQ4QXJyYXkodGhpcy54aHIucmVzcG9uc2UpO1xuICAgICAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSB1aThBcnIubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBkYXRhQXJyYXkucHVzaCh1aThBcnJbaWR4XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0YUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMub25FcnJvcihlKTtcbiAgfVxuICBpZiAobnVsbCAhPSBkYXRhKSB7XG4gICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgaXQgaGFzIFhEb21haW5SZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmhhc1hEUiA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cblxuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICBSZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuICBSZXF1ZXN0LnJlcXVlc3RzID0ge307XG4gIGlmIChnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIoKSB7XG4gIGZvciAodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuICAgIGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qc1xuICoqLyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG4vKipcbiAqIElzIFhIUjIgc3VwcG9ydGVkP1xuICovXG5cbnZhciBoYXNYSFIyID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbiAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xufSkoKTtcblxuLyoqXG4gKiBQb2xsaW5nIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUG9sbGluZyhvcHRzKXtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmICghaGFzWEhSMiB8fCBmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFBvbGxpbmcsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUubmFtZSA9ICdwb2xsaW5nJztcblxuLyoqXG4gKiBPcGVucyB0aGUgc29ja2V0ICh0cmlnZ2VycyBwb2xsaW5nKS4gV2Ugd3JpdGUgYSBQSU5HIG1lc3NhZ2UgdG8gZGV0ZXJtaW5lXG4gKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbigpe1xuICB0aGlzLnBvbGwoKTtcbn07XG5cbi8qKlxuICogUGF1c2VzIHBvbGxpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKG9uUGF1c2Upe1xuICB2YXIgcGVuZGluZyA9IDA7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cbiAgZnVuY3Rpb24gcGF1c2UoKXtcbiAgICBkZWJ1ZygncGF1c2VkJyk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgncG9sbENvbXBsZXRlJywgZnVuY3Rpb24oKXtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSBwb2xsaW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgd3JpdGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKXtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSB3cml0aW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXVzZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdwb2xsaW5nJyk7XG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBkZWJ1ZygncG9sbGluZyBnb3QgZGF0YSAlcycsIGRhdGEpO1xuICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbihwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICBpZiAoJ29wZW5pbmcnID09IHNlbGYucmVhZHlTdGF0ZSkge1xuICAgICAgc2VsZi5vbk9wZW4oKTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgaWYgKCdjbG9zZScgPT0gcGFja2V0LnR5cGUpIHtcbiAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH07XG5cbiAgLy8gZGVjb2RlIHBheWxvYWRcbiAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXG4gIC8vIGlmIGFuIGV2ZW50IGRpZCBub3QgdHJpZ2dlciBjbG9zaW5nXG4gIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cbiAgICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UoKXtcbiAgICBkZWJ1Zygnd3JpdGluZyBjbG9zZSBwYWNrZXQnKTtcbiAgICBzZWxmLndyaXRlKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuICB9XG5cbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nJyk7XG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHZhciBjYWxsYmFja2ZuID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9O1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgcGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24oZGF0YSkge1xuICAgIHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzJyA6ICdodHRwJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBjYWNoZSBidXN0aW5nIGlzIGZvcmNlZFxuICBpZiAoZmFsc2UgIT09IHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ2h0dHBzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0MykgfHxcbiAgICAgKCdodHRwJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanNcbiAqKi8iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcblxuLyoqXG4gKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBUcmFuc3BvcnQgKG9wdHMpIHtcbiAgdGhpcy5wYXRoID0gb3B0cy5wYXRoO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0O1xuICB0aGlzLnNlY3VyZSA9IG9wdHMuc2VjdXJlO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW07XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuc29ja2V0ID0gb3B0cy5zb2NrZXQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoVHJhbnNwb3J0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogRW1pdHMgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7VHJhbnNwb3J0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKG1zZywgZGVzYykge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci50eXBlID0gJ1RyYW5zcG9ydEVycm9yJztcbiAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPcGVucyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgICB0aGlzLmRvT3BlbigpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLmRvQ2xvc2UoKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBtdWx0aXBsZSBwYWNrZXRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgbm90IG9wZW4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBvcGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB2YXIgcGFja2V0ID0gcGFyc2VyLmRlY29kZVBhY2tldChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcbiAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBhIGRlY29kZWQgcGFja2V0LlxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanNcbiAqKi8iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcbnZhciBoYXNCaW5hcnkgPSByZXF1aXJlKCdoYXMtYmluYXJ5Jyk7XG52YXIgc2xpY2VCdWZmZXIgPSByZXF1aXJlKCdhcnJheWJ1ZmZlci5zbGljZScpO1xudmFyIGJhc2U2NGVuY29kZXIgPSByZXF1aXJlKCdiYXNlNjQtYXJyYXlidWZmZXInKTtcbnZhciBhZnRlciA9IHJlcXVpcmUoJ2FmdGVyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJ3V0ZjgnKTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBhbiBhbmRyb2lkIGJyb3dzZXIuIFRoYXQgcmVxdWlyZXMgdXMgdG8gdXNlXG4gKiBBcnJheUJ1ZmZlciB3aXRoIHBvbGxpbmcgdHJhbnNwb3J0cy4uLlxuICpcbiAqIGh0dHA6Ly9naGluZGEubmV0L2pwZWctYmxvYi1hamF4LWFuZHJvaWQvXG4gKi9cblxudmFyIGlzQW5kcm9pZCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gUGhhbnRvbUpTLlxuICogVXBsb2FkaW5nIGEgQmxvYiB3aXRoIFBoYW50b21KUyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSwgYXMgcmVwb3J0ZWQgaGVyZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExMzk1XG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBpc1BoYW50b21KUyA9IC9QaGFudG9tSlMvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIFdoZW4gdHJ1ZSwgYXZvaWRzIHVzaW5nIEJsb2JzIHRvIGVuY29kZSBwYXlsb2Fkcy5cbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGRvbnRTZW5kQmxvYnMgPSBpc0FuZHJvaWQgfHwgaXNQaGFudG9tSlM7XG5cbi8qKlxuICogQ3VycmVudCBwcm90b2NvbCB2ZXJzaW9uLlxuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqL1xuXG52YXIgcGFja2V0cyA9IGV4cG9ydHMucGFja2V0cyA9IHtcbiAgICBvcGVuOiAgICAgMCAgICAvLyBub24td3NcbiAgLCBjbG9zZTogICAgMSAgICAvLyBub24td3NcbiAgLCBwaW5nOiAgICAgMlxuICAsIHBvbmc6ICAgICAzXG4gICwgbWVzc2FnZTogIDRcbiAgLCB1cGdyYWRlOiAgNVxuICAsIG5vb3A6ICAgICA2XG59O1xuXG52YXIgcGFja2V0c2xpc3QgPSBrZXlzKHBhY2tldHMpO1xuXG4vKipcbiAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuICovXG5cbnZhciBlcnIgPSB7IHR5cGU6ICdlcnJvcicsIGRhdGE6ICdwYXJzZXIgZXJyb3InIH07XG5cbi8qKlxuICogQ3JlYXRlIGEgYmxvYiBhcGkgZXZlbiBmb3IgYmxvYiBidWlsZGVyIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2IgPSByZXF1aXJlKCdibG9iJyk7XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldC5cbiAqXG4gKiAgICAgPHBhY2tldCB0eXBlIGlkPiBbIDxkYXRhPiBdXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgNWhlbGxvIHdvcmxkXG4gKiAgICAgM1xuICogICAgIDRcbiAqXG4gKiBCaW5hcnkgaXMgZW5jb2RlZCBpbiBhbiBpZGVudGljYWwgcHJpbmNpcGxlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHN1cHBvcnRzQmluYXJ5KSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHV0ZjhlbmNvZGUpIHtcbiAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgdXRmOGVuY29kZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGE7XG5cbiAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKEJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpKSA6IFN0cmluZyhwYWNrZXQuZGF0YSk7XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2soJycgKyBlbmNvZGVkKTtcblxufTtcblxuZnVuY3Rpb24gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spIHtcbiAgLy8gcGFja2V0IGRhdGEgaXMgYW4gb2JqZWN0IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV0gKyBwYWNrZXQuZGF0YS5kYXRhO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBoZWxwZXJzIGZvciBiaW5hcnkgdHlwZXNcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgcmVzdWx0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSArIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgcmVzdWx0QnVmZmVyWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0QnVmZmVyW2krMV0gPSBjb250ZW50QXJyYXlbaV07XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2socmVzdWx0QnVmZmVyLmJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBwYWNrZXQuZGF0YSA9IGZyLnJlc3VsdDtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBjYWxsYmFjayk7XG4gIH07XG4gIHJldHVybiBmci5yZWFkQXNBcnJheUJ1ZmZlcihwYWNrZXQuZGF0YSk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmIChkb250U2VuZEJsb2JzKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBuZXcgVWludDhBcnJheSgxKTtcbiAgbGVuZ3RoWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIHZhciBibG9iID0gbmV3IEJsb2IoW2xlbmd0aC5idWZmZXIsIHBhY2tldC5kYXRhXSk7XG5cbiAgcmV0dXJuIGNhbGxiYWNrKGJsb2IpO1xufVxuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQgd2l0aCBiaW5hcnkgZGF0YSBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0LCBoYXMgYHR5cGVgIGFuZCBgZGF0YWBcbiAqIEByZXR1cm4ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBjYWxsYmFjaykge1xuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gIGlmIChCbG9iICYmIHBhY2tldC5kYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGI2NCA9IGZyLnJlc3VsdC5zcGxpdCgnLCcpWzFdO1xuICAgICAgY2FsbGJhY2sobWVzc2FnZSArIGI2NCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnIucmVhZEFzRGF0YVVSTChwYWNrZXQuZGF0YSk7XG4gIH1cblxuICB2YXIgYjY0ZGF0YTtcbiAgdHJ5IHtcbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgd2l0aCB0eXBlZCBhcnJheXNcbiAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7XG4gICAgdmFyIGJhc2ljID0gbmV3IEFycmF5KHR5cGVkLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgYmFzaWNbaV0gPSB0eXBlZFtpXTtcbiAgICB9XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYmFzaWMpO1xuICB9XG4gIG1lc3NhZ2UgKz0gZ2xvYmFsLmJ0b2EoYjY0ZGF0YSk7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldC4gQ2hhbmdlcyBmb3JtYXQgdG8gQmxvYiBpZiByZXF1ZXN0ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG4gIC8vIFN0cmluZyBkYXRhXG4gIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJyB8fCBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGF0YS5jaGFyQXQoMCkgPT0gJ2InKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksIGJpbmFyeVR5cGUpO1xuICAgIH1cblxuICAgIGlmICh1dGY4ZGVjb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG5cbiAgICBpZiAoTnVtYmVyKHR5cGUpICE9IHR5cGUgfHwgIXBhY2tldHNsaXN0W3R5cGVdKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnN1YnN0cmluZygxKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBhc0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciB0eXBlID0gYXNBcnJheVswXTtcbiAgdmFyIHJlc3QgPSBzbGljZUJ1ZmZlcihkYXRhLCAxKTtcbiAgaWYgKEJsb2IgJiYgYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgcmVzdCA9IG5ldyBCbG9iKFtyZXN0XSk7XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IHJlc3QgfTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqL1xuXG5leHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuICB2YXIgdHlwZSA9IHBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO1xuICBpZiAoIWdsb2JhbC5BcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBtc2cuc3Vic3RyKDEpIH0gfTtcbiAgfVxuXG4gIHZhciBkYXRhID0gYmFzZTY0ZW5jb2Rlci5kZWNvZGUobXNnLnN1YnN0cigxKSk7XG5cbiAgaWYgKGJpbmFyeVR5cGUgPT09ICdibG9iJyAmJiBCbG9iKSB7XG4gICAgZGF0YSA9IG5ldyBCbG9iKFtkYXRhXSk7XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuICpcbiAqICAgICA8bGVuZ3RoPjpkYXRhXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG4gKlxuICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcbiAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIHRydWUsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdHMuam9pbignJykpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQXN5bmMgYXJyYXkgbWFwIHVzaW5nIGFmdGVyXG4gKi9cblxuZnVuY3Rpb24gbWFwKGFyeSwgZWFjaCwgZG9uZSkge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFyeS5sZW5ndGgpO1xuICB2YXIgbmV4dCA9IGFmdGVyKGFyeS5sZW5ndGgsIGRvbmUpO1xuXG4gIHZhciBlYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24oaSwgZWwsIGNiKSB7XG4gICAgZWFjaChlbCwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuICAgICAgcmVzdWx0W2ldID0gbXNnO1xuICAgICAgY2IoZXJyb3IsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBlYWNoV2l0aEluZGV4KGksIGFyeVtpXSwgbmV4dCk7XG4gIH1cbn1cblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuICogZGVjb2RlZCBmcm9tIHRoZWlyIGJhc2U2NCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiBleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgcGFja2V0O1xuICBpZiAoZGF0YSA9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJ1xuICAgICwgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoJzonICE9IGNocikge1xuICAgICAgbGVuZ3RoICs9IGNocjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCcnID09IGxlbmd0aCB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2cgPSBkYXRhLnN1YnN0cihpICsgMSwgbik7XG5cbiAgICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgICBwYWNrZXQgPSBleHBvcnRzLmRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIHRydWUpO1xuXG4gICAgICAgIGlmIChlcnIudHlwZSA9PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgICAgaWYgKGZhbHNlID09PSByZXQpIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICAgIGkgKz0gbjtcbiAgICAgIGxlbmd0aCA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsZW5ndGggIT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG4gKlxuICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuICogMjU1PjxkYXRhPlxuICpcbiAqIEV4YW1wbGU6XG4gKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBlbmNvZGVkIHBheWxvYWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkb25lQ2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIGVuY29kZWRQYWNrZXRzKSB7XG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgcCkge1xuICAgICAgdmFyIGxlbjtcbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpe1xuICAgICAgICBsZW4gPSBwLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IHAuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2MgKyBsZW4udG9TdHJpbmcoKS5sZW5ndGggKyBsZW4gKyAyOyAvLyBzdHJpbmcvYmluYXJ5IGlkZW50aWZpZXIgKyBzZXBhcmF0b3IgPSAyXG4gICAgfSwgMCk7XG5cbiAgICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cbiAgICB2YXIgYnVmZmVySW5kZXggPSAwO1xuICAgIGVuY29kZWRQYWNrZXRzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuICAgICAgdmFyIGFiID0gcDtcbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IHAuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBhYiA9IHZpZXcuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdHJpbmcpIHsgLy8gbm90IHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMDtcbiAgICAgIH0gZWxzZSB7IC8vIHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlblN0ciA9IGFiLmJ5dGVMZW5ndGgudG9TdHJpbmcoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMjU1O1xuXG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHZpZXdbaV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0QXJyYXkuYnVmZmVyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEVuY29kZSBhcyBCbG9iXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDE7XG4gICAgICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gZW5jb2RlZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZWQgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSAoZW5jb2RlZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICA/IGVuY29kZWQuYnl0ZUxlbmd0aFxuICAgICAgICA6IGVuY29kZWQuc2l6ZTtcblxuICAgICAgdmFyIGxlblN0ciA9IGxlbi50b1N0cmluZygpO1xuICAgICAgdmFyIGxlbmd0aEFyeSA9IG5ldyBVaW50OEFycmF5KGxlblN0ci5sZW5ndGggKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlbmd0aEFyeVtpXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICBsZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF0gPSAyNTU7XG5cbiAgICAgIGlmIChCbG9iKSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2JpbmFyeUlkZW50aWZpZXIuYnVmZmVyLCBsZW5ndGhBcnkuYnVmZmVyLCBlbmNvZGVkXSk7XG4gICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQmxvYihyZXN1bHRzKSk7XG4gIH0pO1xufTtcblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBidWZmZXJUYWlsID0gZGF0YTtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcblxuICB2YXIgbnVtYmVyVG9vTG9uZyA9IGZhbHNlO1xuICB3aGlsZSAoYnVmZmVyVGFpbC5ieXRlTGVuZ3RoID4gMCkge1xuICAgIHZhciB0YWlsQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJUYWlsKTtcbiAgICB2YXIgaXNTdHJpbmcgPSB0YWlsQXJyYXlbMF0gPT09IDA7XG4gICAgdmFyIG1zZ0xlbmd0aCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IDsgaSsrKSB7XG4gICAgICBpZiAodGFpbEFycmF5W2ldID09IDI1NSkgYnJlYWs7XG5cbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIG51bWJlclRvb0xvbmcgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbXNnTGVuZ3RoICs9IHRhaWxBcnJheVtpXTtcbiAgICB9XG5cbiAgICBpZihudW1iZXJUb29Mb25nKSByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VuZ2luZS5pby1wYXJzZXIvbGliL2Jyb3dzZXIuanNcbiAqKi8iLCJcbi8qKlxuICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBpKSkge1xuICAgICAgYXJyLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VuZ2luZS5pby1wYXJzZXIvbGliL2tleXMuanNcbiAqKi8iLCJcbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogUmlnaHQgbm93IG9ubHkgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlciBhcmUgc3VwcG9ydGVkLi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpIHtcblxuICBmdW5jdGlvbiBfaGFzQmluYXJ5KG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgaWYgKG9iai50b0pTT04pIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9lbmdpbmUuaW8tcGFyc2VyL34vaGFzLWJpbmFyeS9pbmRleC5qc1xuICoqLyIsIi8qKlxuICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG4gKiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGVuZCA9IGVuZCB8fCBieXRlcztcblxuICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cbiAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBieXRlczsgfVxuICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA+IGJ5dGVzKSB7IGVuZCA9IGJ5dGVzOyB9XG5cbiAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gIH1cblxuICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG4gICAgcmVzdWx0W2lpXSA9IGFidltpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanNcbiAqKi8iLCIvKlxuICogYmFzZTY0LWFycmF5YnVmZmVyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE5pa2xhcyB2b24gSGVydHplblxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG4oZnVuY3Rpb24oY2hhcnMpe1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLFxuICAgIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gXCJcIjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTMpIHtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyKSB8IChieXRlc1tpICsgMl0gPj4gNildO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG5cbiAgICBpZiAoKGxlbiAlIDMpID09PSAyKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfTtcblxuICBleHBvcnRzLmRlY29kZSA9ICBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG4gICAgbGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsXG4gICAgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG5cbiAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpIHtcbiAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLFxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgZW5jb2RlZDEgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpXSk7XG4gICAgICBlbmNvZGVkMiA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krMV0pO1xuICAgICAgZW5jb2RlZDMgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzJdKTtcbiAgICAgIGVuY29kZWQ0ID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSszXSk7XG5cbiAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5YnVmZmVyO1xuICB9O1xufSkoXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2Jhc2U2NC1hcnJheWJ1ZmZlci9saWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYWZ0ZXIvaW5kZXguanNcbiAqKi8iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4wLjAgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2Bcblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYFxuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsXG5cdC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgXG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW107XG5cdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGKSB7XG5cdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0J0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0dmFyIHN5bWJvbCA9ICcnO1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRjgwMCkgPT0gMCkgeyAvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRkYwMDAwKSA9PSAwKSB7IC8vIDMtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0Y2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpO1xuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRcdHJldHVybiBzeW1ib2w7XG5cdH1cblxuXHRmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZykge1xuXHRcdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXHRcdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgY29kZVBvaW50O1xuXHRcdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIGJ5dGVTdHJpbmc7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpIHtcblx0XHRpZiAoYnl0ZUluZGV4ID49IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdHZhciBjb250aW51YXRpb25CeXRlID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvbnRpbnVhdGlvbkJ5dGUgJiAweDNGO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVjb2RlU3ltYm9sKCkge1xuXHRcdHZhciBieXRlMTtcblx0XHR2YXIgYnl0ZTI7XG5cdFx0dmFyIGJ5dGUzO1xuXHRcdHZhciBieXRlNDtcblx0XHR2YXIgY29kZVBvaW50O1xuXG5cdFx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gUmVhZCBmaXJzdCBieXRlXG5cdFx0Ynl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHg4MCkgPT0gMCkge1xuXHRcdFx0cmV0dXJuIGJ5dGUxO1xuXHRcdH1cblxuXHRcdC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0XHR2YXIgYnl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcblx0fVxuXG5cdHZhciBieXRlQXJyYXk7XG5cdHZhciBieXRlQ291bnQ7XG5cdHZhciBieXRlSW5kZXg7XG5cdGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZykge1xuXHRcdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdFx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0XHRieXRlSW5kZXggPSAwO1xuXHRcdHZhciBjb2RlUG9pbnRzID0gW107XG5cdFx0dmFyIHRtcDtcblx0XHR3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbCgpKSAhPT0gZmFsc2UpIHtcblx0XHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciB1dGY4ID0ge1xuXHRcdCd2ZXJzaW9uJzogJzIuMC4wJyxcblx0XHQnZW5jb2RlJzogdXRmOGVuY29kZSxcblx0XHQnZGVjb2RlJzogdXRmOGRlY29kZVxuXHR9O1xuXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHV0Zjg7XG5cdFx0fSk7XG5cdH1cdGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuXHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSB1dGY4O1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHR2YXIgb2JqZWN0ID0ge307XG5cdFx0XHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdXRmOCkge1xuXHRcdFx0XHRoYXNPd25Qcm9wZXJ0eS5jYWxsKHV0ZjgsIGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSB1dGY4W2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QudXRmOCA9IHV0Zjg7XG5cdH1cblxufSh0aGlzKSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vdXRmOC91dGY4LmpzXG4gKiovIiwiLyoqXG4gKiBDcmVhdGUgYSBibG9iIGJ1aWxkZXIgZXZlbiB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iQnVpbGRlciA9IGdsb2JhbC5CbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuV2ViS2l0QmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLk1TQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLk1vekJsb2JCdWlsZGVyO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3IgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JTdXBwb3J0ZWQgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGEgPSBuZXcgQmxvYihbJ2hpJ10pO1xuICAgIHJldHVybiBhLnNpemUgPT09IDI7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIHN1cHBvcnRzIEFycmF5QnVmZmVyVmlld3NcbiAqIEZhaWxzIGluIFNhZmFyaSA2LCBzbyB3ZSBuZWVkIHRvIG1hcCB0byBBcnJheUJ1ZmZlcnMgdGhlcmUuXG4gKi9cblxudmFyIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA9IGJsb2JTdXBwb3J0ZWQgJiYgKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBiID0gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KFsxLDJdKV0pO1xuICAgIHJldHVybiBiLnNpemUgPT09IDI7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iQnVpbGRlciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYkJ1aWxkZXJTdXBwb3J0ZWQgPSBCbG9iQnVpbGRlclxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5nZXRCbG9iO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IG1hcHMgQXJyYXlCdWZmZXJWaWV3cyB0byBBcnJheUJ1ZmZlcnNcbiAqIFVzZWQgYnkgQmxvYkJ1aWxkZXIgY29uc3RydWN0b3IgYW5kIG9sZCBicm93c2VycyB0aGF0IGRpZG4ndFxuICogc3VwcG9ydCBpdCBpbiB0aGUgQmxvYiBjb25zdHJ1Y3Rvci5cbiAqL1xuXG5mdW5jdGlvbiBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaHVuayA9IGFyeVtpXTtcbiAgICBpZiAoY2h1bmsuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciBidWYgPSBjaHVuay5idWZmZXI7XG5cbiAgICAgIC8vIGlmIHRoaXMgaXMgYSBzdWJhcnJheSwgbWFrZSBhIGNvcHkgc28gd2Ugb25seVxuICAgICAgLy8gaW5jbHVkZSB0aGUgc3ViYXJyYXkgcmVnaW9uIGZyb20gdGhlIHVuZGVybHlpbmcgYnVmZmVyXG4gICAgICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCAhPT0gYnVmLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgVWludDhBcnJheShjaHVuay5ieXRlTGVuZ3RoKTtcbiAgICAgICAgY29weS5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKSk7XG4gICAgICAgIGJ1ZiA9IGNvcHkuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICBhcnlbaV0gPSBidWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIEJsb2JCdWlsZGVyQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBiYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBiYi5hcHBlbmQoYXJ5W2ldKTtcbiAgfVxuXG4gIHJldHVybiAob3B0aW9ucy50eXBlKSA/IGJiLmdldEJsb2Iob3B0aW9ucy50eXBlKSA6IGJiLmdldEJsb2IoKTtcbn07XG5cbmZ1bmN0aW9uIEJsb2JDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcbiAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuICByZXR1cm4gbmV3IEJsb2IoYXJ5LCBvcHRpb25zIHx8IHt9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBpZiAoYmxvYlN1cHBvcnRlZCkge1xuICAgIHJldHVybiBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPyBnbG9iYWwuQmxvYiA6IEJsb2JDb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIGlmIChibG9iQnVpbGRlclN1cHBvcnRlZCkge1xuICAgIHJldHVybiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn0pKCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYmxvYi9pbmRleC5qc1xuICoqLyIsIi8qKlxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xuICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xuICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XG4gIHZhciBxcnkgPSB7fTtcbiAgdmFyIHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgcXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gIH1cbiAgcmV0dXJuIHFyeTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcGFyc2Vxcy9pbmRleC5qc1xuICoqLyIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcbiAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgZm47XG4gIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvbXBvbmVudC1pbmhlcml0L2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotXycuc3BsaXQoJycpXG4gICwgbGVuZ3RoID0gNjRcbiAgLCBtYXAgPSB7fVxuICAsIHNlZWQgPSAwXG4gICwgaSA9IDBcbiAgLCBwcmV2O1xuXG4vKipcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBlbmNvZGUobnVtKSB7XG4gIHZhciBlbmNvZGVkID0gJyc7XG5cbiAgZG8ge1xuICAgIGVuY29kZWQgPSBhbHBoYWJldFtudW0gJSBsZW5ndGhdICsgZW5jb2RlZDtcbiAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIGxlbmd0aCk7XG4gIH0gd2hpbGUgKG51bSA+IDApO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW50ZWdlciB2YWx1ZSBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbnRlZ2VyIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gIHZhciBkZWNvZGVkID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG4gIH1cblxuICByZXR1cm4gZGVjb2RlZDtcbn1cblxuLyoqXG4gKiBZZWFzdDogQSB0aW55IGdyb3dpbmcgaWQgZ2VuZXJhdG9yLlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IEEgdW5pcXVlIGlkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24geWVhc3QoKSB7XG4gIHZhciBub3cgPSBlbmNvZGUoK25ldyBEYXRlKCkpO1xuXG4gIGlmIChub3cgIT09IHByZXYpIHJldHVybiBzZWVkID0gMCwgcHJldiA9IG5vdztcbiAgcmV0dXJuIG5vdyArJy4nKyBlbmNvZGUoc2VlZCsrKTtcbn1cblxuLy9cbi8vIE1hcCBlYWNoIGNoYXJhY3RlciB0byBpdHMgaW5kZXguXG4vL1xuZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgbWFwW2FscGhhYmV0W2ldXSA9IGk7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIGB5ZWFzdGAsIGBlbmNvZGVgIGFuZCBgZGVjb2RlYCBmdW5jdGlvbnMuXG4vL1xueWVhc3QuZW5jb2RlID0gZW5jb2RlO1xueWVhc3QuZGVjb2RlID0gZGVjb2RlO1xubW9kdWxlLmV4cG9ydHMgPSB5ZWFzdDtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi95ZWFzdC9pbmRleC5qc1xuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbi8qKlxuICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKi9cblxudmFyIHJOZXdsaW5lID0gL1xcbi9nO1xudmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG4vKipcbiAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG4gKi9cblxudmFyIGNhbGxiYWNrcztcblxuLyoqXG4gKiBDYWxsYmFja3MgY291bnQuXG4gKi9cblxudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG4vKipcbiAqIEpTT05QIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEpTT05QUG9sbGluZyAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cbiAgLy8gZGVmaW5lIGdsb2JhbCBjYWxsYmFja3MgYXJyYXkgaWYgbm90IHByZXNlbnRcbiAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cbiAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVuZ2luZXMgaW4gdGhlIHNhbWUgcGFnZVxuICAgIGlmICghZ2xvYmFsLl9fX2VpbykgZ2xvYmFsLl9fX2VpbyA9IFtdO1xuICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW87XG4gIH1cblxuICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG4gIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG4gICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgfSk7XG5cbiAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG4gIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcbiAgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXG4vKlxuICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLmZvcm0pIHtcbiAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuICAgIHRoaXMuZm9ybSA9IG51bGw7XG4gICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICB9XG5cbiAgUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcbiAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLGUpO1xuICB9O1xuXG4gIHZhciBpbnNlcnRBdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgaWYgKGluc2VydEF0KSB7XG4gICAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfVxuICB0aGlzLnNjcmlwdCA9IHNjcmlwdDtcblxuICB2YXIgaXNVQWdlY2tvID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBcbiAgaWYgKGlzVUFnZWNrbykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIH0sIDEwMCk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIHdpdGggYSBoaWRkZW4gaWZyYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXRoaXMuZm9ybSkge1xuICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgIHZhciBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG4gICAgdmFyIGlmcmFtZTtcblxuICAgIGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcbiAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBmb3JtLnN0eWxlLnRvcCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgZm9ybS50YXJnZXQgPSBpZDtcbiAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcbiAgICBhcmVhLm5hbWUgPSAnZCc7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXG4gICAgdGhpcy5mb3JtID0gZm9ybTtcbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICB9XG5cbiAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cbiAgZnVuY3Rpb24gY29tcGxldGUgKCkge1xuICAgIGluaXRJZnJhbWUoKTtcbiAgICBmbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdElmcmFtZSAoKSB7XG4gICAgaWYgKHNlbGYuaWZyYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInKyBzZWxmLmlmcmFtZUlkICsnXCI+JztcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBpZnJhbWUubmFtZSA9IHNlbGYuaWZyYW1lSWQ7XG4gICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG4gICAgfVxuXG4gICAgaWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblxuICAgIHNlbGYuZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuICB9XG5cbiAgaW5pdElmcmFtZSgpO1xuXG4gIC8vIGVzY2FwZSBcXG4gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNvbnZlcnRlZCBpbnRvIFxcclxcbiBieSBzb21lIFVBc1xuICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UockVzY2FwZWROZXdsaW5lLCAnXFxcXFxcbicpO1xuICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpO1xuXG4gIHRyeSB7XG4gICAgdGhpcy5mb3JtLnN1Ym1pdCgpO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgaWYgKHRoaXMuaWZyYW1lLmF0dGFjaEV2ZW50KSB7XG4gICAgdGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICAgIGlmIChzZWxmLmlmcmFtZS5yZWFkeVN0YXRlID09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaWZyYW1lLm9ubG9hZCA9IGNvbXBsZXRlO1xuICB9XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qc1xuICoqLyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXQnKTtcbnZhciBCcm93c2VyV2ViU29ja2V0ID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuXG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG4gKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG4gKi9cblxudmFyIFdlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQ7XG5pZiAoIVdlYlNvY2tldCAmJiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICB0cnkge1xuICAgIFdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJyk7XG4gIH0gY2F0Y2ggKGUpIHsgfVxufVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV1M7XG5cbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBXUyhvcHRzKXtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmIChmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZTtcbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChXUywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5uYW1lID0gJ3dlYnNvY2tldCc7XG5cbi8qXG4gKiBXZWJTb2NrZXRzIHN1cHBvcnQgYmluYXJ5XG4gKi9cblxuV1MucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBPcGVucyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGlmICghdGhpcy5jaGVjaygpKSB7XG4gICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuICB2YXIgcHJvdG9jb2xzID0gdm9pZCgwKTtcbiAgdmFyIG9wdHMgPSB7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGVcbiAgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuICB9XG5cbiAgdGhpcy53cyA9IEJyb3dzZXJXZWJTb2NrZXQgPyBuZXcgV2ViU29ja2V0KHVyaSkgOiBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdidWZmZXInO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gIH1cblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG59O1xuXG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzb2NrZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICAgIHNlbGYub25PcGVuKCk7XG4gIH07XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkNsb3NlKCk7XG4gIH07XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpe1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIGUpO1xuICB9O1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBgb25EYXRhYCB0byB1c2UgYSB0aW1lciBvbiBpT1MuXG4gKiBTZWU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21sb3VnaHJhbi8yMDUyMDA2XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBuYXZpZ2F0b3JcbiAgJiYgL2lQYWR8aVBob25lfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gIFdTLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEuY2FsbChzZWxmLCBkYXRhKTtcbiAgICB9LCAwKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBXcml0ZXMgZGF0YSB0byBzb2NrZXQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgcGFja2V0cy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuICAvLyBubyBuZWVkIGZvciBlbmNvZGVQYXlsb2FkXG4gIHZhciB0b3RhbCA9IHBhY2tldHMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHRvdGFsOyBpIDwgbDsgaSsrKSB7XG4gICAgKGZ1bmN0aW9uKHBhY2tldCkge1xuICAgICAgcGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHNlbGYuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKCFCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgLy8gYWx3YXlzIGNyZWF0ZSBhIG5ldyBvYmplY3QgKEdILTQzNylcbiAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgICAgIGlmIChwYWNrZXQub3B0aW9ucykge1xuICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IHBhY2tldC5vcHRpb25zLmNvbXByZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gJ3N0cmluZycgPT0gdHlwZW9mIGRhdGEgPyBnbG9iYWwuQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW4gPCBzZWxmLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9Tb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgIC8vaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAgIC8vdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgZGVidWcoJ3dlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC0tdG90YWwgfHwgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSkocGFja2V0c1tpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkb25lKCl7XG4gICAgc2VsZi5lbWl0KCdmbHVzaCcpO1xuXG4gICAgLy8gZmFrZSBkcmFpblxuICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgICB9LCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oKXtcbiAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIENsb3NlcyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpe1xuICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ3dzcycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA0NDMpXG4gICAgfHwgKCd3cycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG4gIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG4vKipcbiAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhIVdlYlNvY2tldCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanNcbiAqKi8iLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIHdzIChpZ25vcmVkKVxuICoqIG1vZHVsZSBpZCA9IDI2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9pbmRleG9mL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBKU09OIHBhcnNlLlxuICpcbiAqIEBzZWUgQmFzZWQgb24galF1ZXJ5I3BhcnNlSlNPTiAoTUlUKSBhbmQgSlNPTjJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvO1xudmFyIHJ2YWxpZGVzY2FwZSA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2c7XG52YXIgcnZhbGlkdG9rZW5zID0gL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nO1xudmFyIHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcbnZhciBydHJpbUxlZnQgPSAvXlxccysvO1xudmFyIHJ0cmltUmlnaHQgPSAvXFxzKyQvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlanNvbihkYXRhKSB7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSB8fCAhZGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGF0YSA9IGRhdGEucmVwbGFjZShydHJpbUxlZnQsICcnKS5yZXBsYWNlKHJ0cmltUmlnaHQsICcnKTtcblxuICAvLyBBdHRlbXB0IHRvIHBhcnNlIHVzaW5nIHRoZSBuYXRpdmUgSlNPTiBwYXJzZXIgZmlyc3RcbiAgaWYgKGdsb2JhbC5KU09OICYmIEpTT04ucGFyc2UpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgfVxuXG4gIGlmIChydmFsaWRjaGFycy50ZXN0KGRhdGEucmVwbGFjZShydmFsaWRlc2NhcGUsICdAJylcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZHRva2VucywgJ10nKVxuICAgICAgLnJlcGxhY2UocnZhbGlkYnJhY2VzLCAnJykpKSB7XG4gICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgZGF0YSkpKCk7XG4gIH1cbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3BhcnNlanNvbi9pbmRleC5qc1xuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgdG9BcnJheSA9IHJlcXVpcmUoJ3RvLWFycmF5Jyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGhhc0JpbiA9IHJlcXVpcmUoJ2hhcy1iaW5hcnknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZXZlbnRzID0ge1xuICBjb25uZWN0OiAxLFxuICBjb25uZWN0X2Vycm9yOiAxLFxuICBjb25uZWN0X3RpbWVvdXQ6IDEsXG4gIGNvbm5lY3Rpbmc6IDEsXG4gIGRpc2Nvbm5lY3Q6IDEsXG4gIGVycm9yOiAxLFxuICByZWNvbm5lY3Q6IDEsXG4gIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuICByZWNvbm5lY3RfZXJyb3I6IDEsXG4gIHJlY29ubmVjdGluZzogMSxcbiAgcGluZzogMSxcbiAgcG9uZzogMVxufTtcblxuLyoqXG4gKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cbiAqL1xuXG52YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQoaW8sIG5zcCl7XG4gIHRoaXMuaW8gPSBpbztcbiAgdGhpcy5uc3AgPSBuc3A7XG4gIHRoaXMuanNvbiA9IHRoaXM7IC8vIGNvbXBhdFxuICB0aGlzLmlkcyA9IDA7XG4gIHRoaXMuYWNrcyA9IHt9O1xuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gb3BlbiwgY2xvc2UgYW5kIHBhY2tldCBldmVudHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnN1YkV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zdWJzKSByZXR1cm47XG5cbiAgdmFyIGlvID0gdGhpcy5pbztcbiAgdGhpcy5zdWJzID0gW1xuICAgIG9uKGlvLCAnb3BlbicsIGJpbmQodGhpcywgJ29ub3BlbicpKSxcbiAgICBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLFxuICAgIG9uKGlvLCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpXG4gIF07XG59O1xuXG4vKipcbiAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vcGVuID1cblNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5zdWJFdmVudHMoKTtcbiAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG4gIGlmICgnb3BlbicgPT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbigpe1xuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBlbWl0YC5cbiAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXYpe1xuICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2KSkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICB2YXIgcGFyc2VyVHlwZSA9IHBhcnNlci5FVkVOVDsgLy8gZGVmYXVsdFxuICBpZiAoaGFzQmluKGFyZ3MpKSB7IHBhcnNlclR5cGUgPSBwYXJzZXIuQklOQVJZX0VWRU5UOyB9IC8vIGJpbmFyeVxuICB2YXIgcGFja2V0ID0geyB0eXBlOiBwYXJzZXJUeXBlLCBkYXRhOiBhcmdzIH07XG5cbiAgcGFja2V0Lm9wdGlvbnMgPSB7fTtcbiAgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3MgPSAhdGhpcy5mbGFncyB8fCBmYWxzZSAhPT0gdGhpcy5mbGFncy5jb21wcmVzcztcblxuICAvLyBldmVudCBhY2sgY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuICAgIGRlYnVnKCdlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWQnLCB0aGlzLmlkcyk7XG4gICAgdGhpcy5hY2tzW3RoaXMuaWRzXSA9IGFyZ3MucG9wKCk7XG4gICAgcGFja2V0LmlkID0gdGhpcy5pZHMrKztcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIHRoaXMucGFja2V0KHBhY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxuXG4gIGRlbGV0ZSB0aGlzLmZsYWdzO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHBhY2tldC5uc3AgPSB0aGlzLm5zcDtcbiAgdGhpcy5pby5wYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCd0cmFuc3BvcnQgaXMgb3BlbiAtIGNvbm5lY3RpbmcnKTtcblxuICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3NhcnlcbiAgaWYgKCcvJyAhPSB0aGlzLm5zcCkge1xuICAgIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkNPTk5FQ1QgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24ocmVhc29uKXtcbiAgZGVidWcoJ2Nsb3NlICglcyknLCByZWFzb24pO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIGRlbGV0ZSB0aGlzLmlkO1xuICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCByZWFzb24pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBzb2NrZXQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBpZiAocGFja2V0Lm5zcCAhPSB0aGlzLm5zcCkgcmV0dXJuO1xuXG4gIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICBjYXNlIHBhcnNlci5DT05ORUNUOlxuICAgICAgdGhpcy5vbmNvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0VWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkFDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0FDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRElTQ09OTkVDVDpcbiAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVSUk9SOlxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHBhY2tldC5kYXRhKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25ldmVudCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHZhciBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gIGRlYnVnKCdlbWl0dGluZyBldmVudCAlaicsIGFyZ3MpO1xuXG4gIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgIGRlYnVnKCdhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50Jyk7XG4gICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlY2VpdmVCdWZmZXIucHVzaChhcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm9kdWNlcyBhbiBhY2sgY2FsbGJhY2sgdG8gZW1pdCB3aXRoIGFuIGV2ZW50LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuYWNrID0gZnVuY3Rpb24oaWQpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzZW50ID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgIGlmIChzZW50KSByZXR1cm47XG4gICAgc2VudCA9IHRydWU7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgZGVidWcoJ3NlbmRpbmcgYWNrICVqJywgYXJncyk7XG5cbiAgICB2YXIgdHlwZSA9IGhhc0JpbihhcmdzKSA/IHBhcnNlci5CSU5BUllfQUNLIDogcGFyc2VyLkFDSztcbiAgICBzZWxmLnBhY2tldCh7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaWQ6IGlkLFxuICAgICAgZGF0YTogYXJnc1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBhY2tub3dsZWdlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uYWNrID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGFjayA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYWNrKSB7XG4gICAgZGVidWcoJ2NhbGxpbmcgYWNrICVzIHdpdGggJWonLCBwYWNrZXQuaWQsIHBhY2tldC5kYXRhKTtcbiAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgIGRlbGV0ZSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygnYmFkIGFjayAlcycsIHBhY2tldC5pZCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xufTtcblxuLyoqXG4gKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3NlcnZlciBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gIHRoaXMuZGVzdHJveSgpO1xuICB0aGlzLm9uY2xvc2UoJ2lvIHNlcnZlciBkaXNjb25uZWN0Jyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG4gKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuICogdGhhdCByZWNvbm5lY3Rpb25zIGRvbid0IGdldCB0cmlnZ2VyZWQgZm9yIHRoaXMuXG4gKlxuICogQGFwaSBwcml2YXRlLlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLnN1YnMpIHtcbiAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9XG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24oY29tcHJlc3Mpe1xuICB0aGlzLmZsYWdzID0gdGhpcy5mbGFncyB8fCB7fTtcbiAgdGhpcy5mbGFncy5jb21wcmVzcyA9IGNvbXByZXNzO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc29ja2V0LmlvLWNsaWVudC9saWIvc29ja2V0LmpzXG4gKiovIiwiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gdG9BcnJheVxuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIGluZGV4KSB7XG4gICAgdmFyIGFycmF5ID0gW11cblxuICAgIGluZGV4ID0gaW5kZXggfHwgMFxuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2kgLSBpbmRleF0gPSBsaXN0W2ldXG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vdG8tYXJyYXkvaW5kZXguanNcbiAqKi8iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBvbjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIHN1YnNjcmlwdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBvbihvYmosIGV2LCBmbikge1xuICBvYmoub24oZXYsIGZuKTtcbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKGV2LCBmbik7XG4gICAgfVxuICB9O1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzXG4gKiovIiwiLyoqXG4gKiBTbGljZSByZWZlcmVuY2UuXG4gKi9cblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbi8qKlxuICogQmluZCBgb2JqYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBvciBzdHJpbmdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgZm4pe1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZuKSBmbiA9IG9ialtmbl07XG4gIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH1cbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29tcG9uZW50LWJpbmQvaW5kZXguanNcbiAqKi8iLCJcbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogUmlnaHQgbm93IG9ubHkgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlciBhcmUgc3VwcG9ydGVkLi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpIHtcblxuICBmdW5jdGlvbiBfaGFzQmluYXJ5KG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICAgIChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoX2hhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2hhcy1iaW5hcnkvcHVsbC80XG4gICAgICBpZiAob2JqLnRvSlNPTiAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBvYmoudG9KU09OKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBfaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIF9oYXNCaW5hcnkoZGF0YSk7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaGFzLWJpbmFyeS9pbmRleC5qc1xuICoqLyIsIlxuLyoqXG4gKiBFeHBvc2UgYEJhY2tvZmZgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja29mZjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG4gKlxuICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG4gKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cbiAqIC0gYGppdHRlcmAgWzBdXG4gKiAtIGBmYWN0b3JgIFsyXVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcbiAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgdGhpcy5mYWN0b3IgPSBvcHRzLmZhY3RvciB8fCAyO1xuICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGJhY2tvZmYgZHVyYXRpb24uXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgaWYgKHRoaXMuaml0dGVyKSB7XG4gICAgdmFyIHJhbmQgPSAgTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihtcywgdGhpcy5tYXgpIHwgMDtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWluaW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24obWluKXtcbiAgdGhpcy5tcyA9IG1pbjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbihtYXgpe1xuICB0aGlzLm1heCA9IG1heDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBqaXR0ZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uKGppdHRlcil7XG4gIHRoaXMuaml0dGVyID0gaml0dGVyO1xufTtcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2JhY2tvMi9pbmRleC5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYXhpb3MvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZSgpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShkZWZhdWx0Q29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKTtcbn07XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi9heGlvcy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IC0+IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgIWlzQXJyYXkob2JqKSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0W2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbVxufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvdXRpbHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi8uLi9kZWZhdWx0cycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwnKTtcbnZhciBjb21iaW5lVVJMcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGRlZmF1bHRDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IHV0aWxzLm1lcmdlKGRlZmF1bHRzLCBkZWZhdWx0Q29uZmlnKTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSB1dGlscy5tZXJnZSh7XG4gICAgICB1cmw6IGFyZ3VtZW50c1swXVxuICAgIH0sIGFyZ3VtZW50c1sxXSk7XG4gIH1cblxuICBjb25maWcgPSB1dGlscy5tZXJnZShkZWZhdWx0cywgdGhpcy5kZWZhdWx0cywgeyBtZXRob2Q6ICdnZXQnIH0sIGNvbmZpZyk7XG5cbiAgLy8gU3VwcG9ydCBiYXNlVVJMIGNvbmZpZ1xuICBpZiAoY29uZmlnLmJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwoY29uZmlnLnVybCkpIHtcbiAgICBjb25maWcudXJsID0gY29tYmluZVVSTHMoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICB9XG5cbiAgLy8gSG9vayB1cCBpbnRlcmNlcHRvcnMgbWlkZGxld2FyZVxuICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgd2hpbGUgKGNoYWluLmxlbmd0aCkge1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmxcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG5cbnZhciBQUk9URUNUSU9OX1BSRUZJWCA9IC9eXFwpXFxdXFx9Jyw/XFxuLztcbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoUFJPVEVDVElPTl9QUkVGSVgsICcnKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgaGVhZGVyczoge1xuICAgIGNvbW1vbjoge1xuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gICAgfSxcbiAgICBwYXRjaDogdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpLFxuICAgIHBvc3Q6IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKSxcbiAgICBwdXQ6IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKVxuICB9LFxuXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYXhpb3MvbGliL2RlZmF1bHRzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB3aGljaGV2ZXIgYWRhcHRlclxuICogaXMgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlcjtcblxuICBpZiAodHlwZW9mIGNvbmZpZy5hZGFwdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRm9yIGN1c3RvbSBhZGFwdGVyIHN1cHBvcnRcbiAgICBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZylcbiAgICAvLyBXcmFwIHN5bmNocm9ub3VzIGFkYXB0ZXIgZXJyb3JzIGFuZCBwYXNzIGNvbmZpZ3VyYXRpb25cbiAgICAudGhlbihhZGFwdGVyKVxuICAgIC50aGVuKGZ1bmN0aW9uIG9uRnVsZmlsbGVkKHJlc3BvbnNlKSB7XG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sIGZ1bmN0aW9uIG9uUmVqZWN0ZWQoZXJyb3IpIHtcbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAoZXJyb3IgJiYgZXJyb3IucmVzcG9uc2UpIHtcbiAgICAgICAgZXJyb3IucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgZXJyb3IucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICBlcnJvci5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH0pO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG52YXIgYnRvYSA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYnRvYSkgfHwgcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J0b2EnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgbG9hZEV2ZW50ID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG4gICAgdmFyIHhEb21haW4gPSBmYWxzZTtcblxuICAgIC8vIEZvciBJRSA4LzkgQ09SUyBzdXBwb3J0XG4gICAgLy8gT25seSBzdXBwb3J0cyBQT1NUIGFuZCBHRVQgY2FsbHMgYW5kIGRvZXNuJ3QgcmV0dXJucyB0aGUgcmVzcG9uc2UgaGVhZGVycy5cbiAgICAvLyBET04nVCBkbyB0aGlzIGZvciB0ZXN0aW5nIGIvYyBYTUxIdHRwUmVxdWVzdCBpcyBtb2NrZWQsIG5vdCBYRG9tYWluUmVxdWVzdC5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSAmJlxuICAgICAgICAhaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSB7XG4gICAgICByZXF1ZXN0ID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuICAgICAgbG9hZEV2ZW50ID0gJ29ubG9hZCc7XG4gICAgICB4RG9tYWluID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzKCkge307XG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7fTtcbiAgICB9XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkIHx8ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0W2xvYWRFdmVudF0gPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQgJiYgIXhEb21haW4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhY29uZmlnLnJlc3BvbnNlVHlwZSB8fCBjb25maWcucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgLy8gSUUgc2VuZHMgMTIyMyBpbnN0ZWFkIG9mIDIwNCAoaHR0cHM6Ly9naXRodWIuY29tL216YWJyaXNraWUvYXhpb3MvaXNzdWVzLzIwMSlcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1cyA9PT0gMTIyMyA/ICdObyBDb250ZW50JyA6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZykpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJykpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgdmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xuXG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oY29uZmlnLnVybCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG4gICAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLndpdGhDcmVkZW50aWFscykge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAocmVxdWVzdC5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cblxuICAgIGlmIChyZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiBAIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVzcG9uc2UpO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuIEAgQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICByZXR1cm4gZXJyb3I7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9XG5cbiAgICAgIGlmICghdXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgfVxuXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpXG4pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLy8gYnRvYSBwb2x5ZmlsbCBmb3IgSUU8MTAgY291cnRlc3kgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkY2hhbWJlcnMvQmFzZTY0LmpzXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEUoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xufVxuRS5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5FLnByb3RvdHlwZS5jb2RlID0gNTtcbkUucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuZnVuY3Rpb24gYnRvYShpbnB1dCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGlucHV0KTtcbiAgdmFyIG91dHB1dCA9ICcnO1xuICBmb3IgKFxuICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnM7XG4gICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgKSB7XG4gICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMyAvIDQpO1xuICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgIHRocm93IG5ldyBFKCk7XG4gICAgfVxuICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnRvYTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvaGVscGVycy9idG9hLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICB9LFxuXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfSkoKVxuKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJyk7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qc1xuICoqLyIsImV4cG9ydCBjb25zdCBDT05ORUNUID0gJ0NPTk5FQ1QnO1xuZXhwb3J0IGNvbnN0IERJU0NPTk5FQ1QgPSAnRElTQ09OTkVDVCc7XG5leHBvcnQgY29uc3QgSU5JVElBTF9SRVNVTFQgPSAnSU5JVElBTF9SRVNVTFQnO1xuZXhwb3J0IGNvbnN0IFBPU1RfTUVTU0FHRSA9ICdQT1NUX01FU1NBR0UnO1xuZXhwb3J0IGNvbnN0IFJFQ0VJVkVfTUVTU0FHRSA9ICdSRUNFSVZFX01FU1NBR0UnO1xuZXhwb3J0IGNvbnN0IFVQREFURSA9ICdVUERBVEUnO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9jb25zdGFudHMuanNcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2FwcC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYXBwLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2FwcC5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9hcHAuY3NzXG4gKiogbW9kdWxlIGlkID0gMjk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5saXN0IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG4uc29uZyB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBwYWRkaW5nOiAxMHB4IDA7XFxufVxcbi5zb25nOmhvdmVyIHtcXG4gIGJhY2tncm91bmQ6ICNiZmJmYmY7XFxufVxcbi5zb25nLW5hbWUge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgd2lkdGg6IDI1MHB4O1xcbn1cXG4uc29uZy1saWtlcyB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9hcHAuY3NzXG4gKiogbW9kdWxlIGlkID0gMjk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cclxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XHJcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcclxuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xyXG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXHJcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXHJcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXHJcblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXHJcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXHJcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XHJcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcclxuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XHJcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcclxuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xyXG5cdHJldHVybiBsaW5rRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxyXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMzAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tICdyZWR1eCc7XG5cbmZ1bmN0aW9uIHNvY2tldChzdGF0ZSA9IHt9LCBhY3Rpb24pIHtcbiAgc3dpdGNoKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSAnQ09OTkVDVCc6XG4gICAgICByZXR1cm4gYWN0aW9uLnNvY2tldDtcbiAgICBjYXNlICdESVNDT05ORUNUJzpcbiAgICAgIHJldHVybiB7fTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNvbmdzKHN0YXRlID0gW10sIGFjdGlvbikge1xuICBzd2l0Y2goYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdJTklUSUFMX1JFU1VMVCc6XG4gICAgICByZXR1cm4gYWN0aW9uLnJlc3VsdDtcbiAgICBjYXNlICdVUERBVEUnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFthY3Rpb24uc29uZy5pZF0gOiBhY3Rpb24uc29uZyxcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjb21iaW5lUmVkdWNlcnMoe1xuICBzb25ncyxcbiAgc29ja2V0LFxufSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3JlZHVjZXJzLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==